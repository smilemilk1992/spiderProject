2020-02-05 20:12:21 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87866560', 'title': 'spring cloud config将配置存储在数据库中', 'readNum': '18535', 'commentNum': '6', 'publishTime': '2019-02-21 18:49:53', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/87866560<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客版：<a href="https://www.fangzhipeng.com/springcloud/2019/02/21/config-jdbc.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/02/21/config-jdbc.html</a></p>\n<p>Spring Cloud Config Server最常见是将配置文件放在本地或者远程Git仓库，放在本地是将将所有的配置文件统一写在Config Server工程目录下，如果需要修改配置，需要重启config server；放在Git仓库，是将配置统一放在Git仓库，可以利用Git仓库的版本控制。本文将介绍使用另外一种方式存放配置信息，即将配置存放在Mysql中。</p>\n<p>整个流程：Config Sever暴露Http API接口，Config Client 通过调用Config Sever的Http API接口来读取配置Config Server的配置信息，Config Server从数据中读取具体的应用的配置。流程图如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003459904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_13"></a>案例实战</h2>\n<p>在本案例中需要由2个工程，分为config-server和config-client，其中config-server工程需要连接Mysql数据库，读取配置；config-client则在启动的时候从config-server工程读取。本案例Spring Cloud版本为Greenwich.RELEASE，Spring Boot版本为2.1.0.RELEASE。</p>\n\n<table>\n<thead>\n<tr>\n<th>工程</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>config-server</td>\n<td>端口8769，从数据库中读取配置</td>\n</tr>\n<tr>\n<td>config-client</td>\n<td>端口8083，从config-server读取配置</td>\n</tr>\n</tbody>\n</table><h3><a id="configserver_23"></a>搭建config-server工程</h3>\n<p>创建工程config-server，在工程的pom文件引入config-server的起步依赖，mysql的连接器，jdbc的起步依赖，代码如下:</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-config-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n</code></pre>\n<p>在工程的配置文件application.yml下做以下的配置：</p>\n<pre><code class="prism language-text">spring:\n  profiles:\n     active: jdbc\n  application:\n     name: config-jdbc-server\n  datasource:\n     url: jdbc:mysql://127.0.0.1:3306/config-jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;serverTimezone=GMT%2B8\n     username: root\n     password: 123456\n     driver-class-name: com.mysql.jdbc.Driver\n  cloud:\n     config:\n       label: master\n       server:\n         jdbc: true\nserver:\n  port: 8769\nspring.cloud.config.server.jdbc.sql: SELECT key1, value1 from config_properties where APPLICATION=? and PROFILE=? and LABEL=?\n\n</code></pre>\n<p>其中，spring.profiles.active为spring读取的配置文件名，从数据库中读取，必须为jdbc。spring.datasource配置了数据库相关的信息，spring.cloud.config.label读取的配置的分支，这个需要在数据库中数据对应。spring.cloud.config.server.jdbc.sql为查询数据库的sql语句，该语句的字段必须与数据库的表字段一致。</p>\n<p>在程序的启动文件ConfigServerApplication加上@EnableConfigServer注解，开启ConfigServer的功能，代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableConfigServer</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigServerApplication</span> <span class="token punctuation">{</span>\n\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\tSpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ConfigServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n\n</code></pre>\n<h3><a id="_84"></a>初始化数据库</h3>\n<p>由于Config-server需要从数据库中读取，所以读者需要先安装MySQL数据库，安装成功后，创建config-jdbc数据库，数据库编码为utf-8，然后在config-jdbc数据库下，执行以下的数据库脚本：</p>\n<pre><code class="prism language-text">CREATE TABLE `config_properties` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(50) COLLATE utf8_bin NOT NULL,\n  `value1` varchar(500) COLLATE utf8_bin DEFAULT NULL,\n  `application` varchar(50) COLLATE utf8_bin NOT NULL,\n  `profile` varchar(50) COLLATE utf8_bin NOT NULL,\n  `label` varchar(50) COLLATE utf8_bin DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_bin\n\n</code></pre>\n<p>其中key1字段为配置的key,value1字段为配置的值，application字段对应于应用名，profile对应于环境，label对应于读取的分支，一般为master。</p>\n<p>插入数据config-client 的2条数据，包括server.port和foo两个配置，具体数据库脚本如下:</p>\n<pre><code class="prism language-text">\ninsert into `config_properties` (`id`, `key1`, `value1`, `application`, `profile`, `label`) values(\'1\',\'server.port\',\'8083\',\'config-client\',\'dev\',\'master\');\ninsert into `config_properties` (`id`, `key1`, `value1`, `application`, `profile`, `label`) values(\'2\',\'foo\',\'bar-jdbc\',\'config-client\',\'dev\',\'master\');\n</code></pre>\n<h3><a id="configclient_111"></a>搭建config-client</h3>\n<p>在 config-client工程的pom文件，引入web和config的起步依赖，代码如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n</code></pre>\n<p>在程序的启动配置文件 bootstrap.yml做程序的相关配置，一定要是bootstrap.yml，不可以是application.yml，bootstrap.yml的读取优先级更高，配置如下：</p>\n<pre><code class="prism language-text">spring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      uri: http://localhost:8769\n      fail-fast: true\n  profiles:\n    active: dev\n\n</code></pre>\n<p>其中spring.cloud.config.uri配置的config-server的地址，spring.cloud.config.fail-fast配置的是读取配置失败后，执行快速失败。spring.profiles.active配置的是spring读取配置文件的环境。</p>\n<p>在程序的启动文件ConfigClientApplication，写一个RestAPI，读取配置文件的foo配置，返回给浏览器，代码如下：</p>\n<pre><code>@SpringBootApplication\n@RestController\npublic class ConfigClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ConfigClientApplication.class, args);\n\t}\n\n\t@Value("${foo}")\n\tString foo;\n\t@RequestMapping(value = "/foo")\n\tpublic String hi(){\n\t\treturn foo;\n\t}\n}\n\n</code></pre>\n<p>依次启动2个工程，其中config-client的启动端口为8083，这个是在数据库中的，可见config-client从 config-server中读取了配置。在浏览器上访问http://localhost:8083/foo，浏览器显示bar-jdbc,这个是在数据库中的，可见config-client从 config-server中读取了配置。</p>\n<h2><a id="_167"></a>参考资料</h2>\n<p>https://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html#_jdbc_backend</p>\n<h2><a id="_171"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/chapter10-5-jdbc</p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:21'}
2020-02-05 20:12:21 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/90728051', 'title': '文章图片看不了，点击这里', 'readNum': '5471', 'commentNum': '20', 'publishTime': '2019-06-01 12:49:41', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>各位大佬，由于图床坏了，目前已经修复了大部分文章，但是工作量比较大，如果发现本博客有文章看不了，请在下面留言，并贴出不能看的文章的链接，感谢了。</p>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:21'}
2020-02-05 20:12:21 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/88823244', 'title': 'Java面试BAT通关手册', 'readNum': '14190', 'commentNum': '13', 'publishTime': '2019-03-26 16:17:17', 'content': '<div class="htmledit_views" id="content_views">\n                                            <p><strong>转载请标明出处： https://blog.csdn.net/forezp/article/details/88823244 </strong></p>\n\n<p>\xa0</p>\n\n<p>手机端可以关注微信公众号号查看：</p>\n\n<p><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZmFuZ3poaXBlbmcuY29tL2ltZy9jeHltc3EuanBn?x-oss-process=image/format,png"></p>\n\n<p>\xa0</p>\n\n<ul id="posts-list"><li>\n\t<p>2019-07-14<a href="https://www.fangzhipeng.com/javainterview/2019/07/15/mysql-connector-pool.html" rel="nofollow">数据库：数据库连接池原理详解与自定义连接池实现</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-14<a href="https://www.fangzhipeng.com/javainterview/2019/07/14/mysql-index.html" rel="nofollow">数据库：数据库索引的类型</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-14<a href="https://www.fangzhipeng.com/javainterview/2019/07/14/mysql-index-better.html" rel="nofollow">数据库：数据库索引优化</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-13<a href="https://www.fangzhipeng.com/javainterview/2019/07/13/mysql-store-engine.html" rel="nofollow">数据库：MySQL几种常用的存储引擎区别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-12<a href="https://www.fangzhipeng.com/javainterview/2019/07/12/mysql-datatype.html" rel="nofollow">数据库：Mysql数据类型</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-11<a href="https://www.fangzhipeng.com/javainterview/2019/07/11/mysql-practice.html" rel="nofollow">数据库：Mysql综合练习题</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-10<a href="https://www.fangzhipeng.com/javainterview/2019/07/10/mysql-geli-level.html" rel="nofollow">数据库：真正理解Mysql的四种隔离级别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-04<a href="https://www.fangzhipeng.com/javainterview/2019/07/04/tcp-http3.html" rel="nofollow">网络：TCP、IP协议族(三) 数字签名与HTTPS详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-03<a href="https://www.fangzhipeng.com/javainterview/2019/07/03/tcp-http2.html" rel="nofollow">网络：TCP、IP协议族(二) HTTP报文头解析</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-02<a href="https://www.fangzhipeng.com/javainterview/2019/07/02/tcp-http1.html" rel="nofollow">网络：TCP、IP协议族(一) HTTP简介、请求方法与响应状态码</a></p>\n\t</li>\n\t<li>\n\t<p>2019-07-01<a href="https://www.fangzhipeng.com/javainterview/2019/07/01/bigdata-sort.html" rel="nofollow">算法：5亿整数的大文件，怎么排？</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-17<a href="https://www.fangzhipeng.com/javainterview/2019/04/17/jvm-tools.html" rel="nofollow">Java虚拟机：JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-16<a href="https://www.fangzhipeng.com/javainterview/2019/04/16/class-loader2.html" rel="nofollow">Java虚拟机：虚拟机类加载机制</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-15<a href="https://www.fangzhipeng.com/javainterview/2019/04/15/class-loader.html" rel="nofollow">Java虚拟机：JVM类加载机制</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-14<a href="https://www.fangzhipeng.com/javainterview/2019/04/14/gc-root.html" rel="nofollow">Java虚拟机：怎么确定对象已经死了？</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-13<a href="https://www.fangzhipeng.com/javainterview/2019/04/13/gc-memory.html" rel="nofollow">Java虚拟机：垃圾收集器和内存分配策略</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-11<a href="https://www.fangzhipeng.com/javainterview/2019/04/11/gc-algorithm.html" rel="nofollow">Java虚拟机：垃圾收集算法</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-10<a href="https://www.fangzhipeng.com/javainterview/2019/04/10/jmm-volatile.html" rel="nofollow">Java虚拟机：JVM内存模型和volatile详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-09<a href="https://www.fangzhipeng.com/javainterview/2019/04/09/jmm.html" rel="nofollow">Java虚拟机：JVM内存模型</a></p>\n\t</li>\n\t<li>\n\t<p>2019-04-08<a href="https://www.fangzhipeng.com/javainterview/2019/04/08/dobble-check.html" rel="nofollow">Java并发：单例模式的双检查</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-24<a href="https://www.fangzhipeng.com/javainterview/2019/03/24/threadlocal.html" rel="nofollow">Java并发：彻底理解ThreadLocal</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-23<a href="https://www.fangzhipeng.com/javainterview/2019/03/23/synchronized-base.html" rel="nofollow">Java并发：Synchronized原理和优化</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-22<a href="https://www.fangzhipeng.com/javainterview/2019/03/22/threadpool.html" rel="nofollow">Java并发：java线程池详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-21<a href="https://www.fangzhipeng.com/javainterview/2019/03/21/latch-barrier-semaphore.html" rel="nofollow">Java并发：Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-20<a href="https://www.fangzhipeng.com/javainterview/2019/03/20/java-lock.html" rel="nofollow">Java并发：Java中锁的分类</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-19<a href="https://www.fangzhipeng.com/javainterview/2019/03/19/java-cas.html" rel="nofollow">Java并发：Java中CAS详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-19<a href="https://www.fangzhipeng.com/javainterview/2019/03/19/copyonwritearraylist.html" rel="nofollow">Java并发：CopyOnWriteArrayList实现原理及源码分析</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-18<a href="https://www.fangzhipeng.com/javainterview/2019/03/18/concurrenthashmap.html" rel="nofollow">Java并发：ConcurrentHashMap解读</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-17<a href="https://www.fangzhipeng.com/javainterview/2019/03/17/blockingqueue.html" rel="nofollow">Java并发：BlockingQueue解读</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-16<a href="https://www.fangzhipeng.com/javainterview/2019/03/16/atomicinteger-cas.html" rel="nofollow">Java并发：AtomicInteger源码分析——基于CAS的乐观锁实现</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-15<a href="https://www.fangzhipeng.com/javainterview/2019/03/15/collections-hashmap.html" rel="nofollow">Java基础：Java容器之HashMap</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-14<a href="https://www.fangzhipeng.com/javainterview/2019/03/14/collections-arraylist.html" rel="nofollow">Java基础：Java容器之ArrayList</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-13<a href="https://www.fangzhipeng.com/javainterview/2019/03/13/collectins-hashset.html" rel="nofollow">Java基础：java中HashSet详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-12<a href="https://www.fangzhipeng.com/javainterview/2019/03/12/collections-bitset.html" rel="nofollow">Java基础：JAVA中BitSet使用详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-11<a href="https://www.fangzhipeng.com/javainterview/2019/03/11/hashmap-dead-cycle.html" rel="nofollow">Java基础：JAVA Hashmap的死循环及Java8的修复</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-10<a href="https://www.fangzhipeng.com/javainterview/2019/03/10/collections-linkedlist.html" rel="nofollow">Java基础：Java容器之LinkedList</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-07<a href="https://www.fangzhipeng.com/javainterview/2019/03/07/thread-state.html" rel="nofollow">Java基础：java线程状态</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-06<a href="https://www.fangzhipeng.com/javainterview/2019/03/06/thread-basic.html" rel="nofollow">Java基础：Java线程基础</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-05<a href="https://www.fangzhipeng.com/javainterview/2019/03/05/javanio2.html" rel="nofollow">Java基础：攻破JAVA NIO技术壁垒2</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-04<a href="https://www.fangzhipeng.com/javainterview/2019/03/04/javanio1.html" rel="nofollow">Java基础：攻破JAVA NIO技术壁垒1</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-04<a href="https://www.fangzhipeng.com/javainterview/2019/03/04/javaio.html" rel="nofollow">Java基础：Java IO流学习总结</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-03<a href="https://www.fangzhipeng.com/javainterview/2019/03/03/interface-orited.html" rel="nofollow">Java基础：面向接口编程详解</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-02<a href="https://www.fangzhipeng.com/javainterview/2019/03/02/object-init.html" rel="nofollow">Java基础：Java对象初始化过程</a></p>\n\t</li>\n\t<li>\n\t<p>2019-03-01<a href="https://www.fangzhipeng.com/javainterview/2019/03/01/try-catch-finnally.html" rel="nofollow">Java基础：Java finally语句到底是在return之前还是之后执行？</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-27<a href="https://www.fangzhipeng.com/javainterview/2019/02/27/refect.html" rel="nofollow">Java基础：Java基础：Java的反射机制</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-25<a href="https://www.fangzhipeng.com/javainterview/2019/02/25/int-integer.html" rel="nofollow">Java基础：int与Integer区别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-24<a href="https://www.fangzhipeng.com/javainterview/2019/02/24/paradigm.html" rel="nofollow">Java基础：java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-24<a href="https://www.fangzhipeng.com/javainterview/2019/02/24/override.html" rel="nofollow">Java基础：Java中重载与重写的区别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-23<a href="https://www.fangzhipeng.com/javainterview/2019/02/23/inner-static-class.html" rel="nofollow">Java基础：Java 内部类和静态内部类的区别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-23<a href="https://www.fangzhipeng.com/javainterview/2019/02/23/equals-hashcode.html" rel="nofollow">Java基础：Java 中的 ==, equals 与 hashCode 的区别与联系</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-22<a href="https://www.fangzhipeng.com/javainterview/2019/02/22/interfacevsabstract.html" rel="nofollow">Java基础：Java抽象类与接口的区别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-22<a href="https://www.fangzhipeng.com/javainterview/2019/02/22/finalvsly.html" rel="nofollow">Java基础：谈谈final、finally、finalize的区别</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-20<a href="https://www.fangzhipeng.com/javainterview/2019/02/20/objetc-principle.html" rel="nofollow">Java基础：面向对象六大原则</a></p>\n\t</li>\n\t<li>\n\t<p>2019-02-19<a href="https://www.fangzhipeng.com/javainterview/2019/02/19/object-factors.html" rel="nofollow">Java基础：Java面向对象的特征</a></p>\n\t</li>\n</ul>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:21'}
2020-02-05 20:12:21 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87075651', 'title': 'Spring Cloud Sleuth 之Greenwich版本全攻略', 'readNum': '15513', 'commentNum': '11', 'publishTime': '2019-02-12 11:18:47', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/87075651<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版： <a href="https://www.fangzhipeng.com/springcloud/2019/02/05/sc-sleuth-g.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/02/05/sc-sleuth-g.html</a></p>\n<p>微服务架构是一个分布式架构，微服务系统按业务划分服务单元，一个微服务系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性较高，如果出现了错误和异常，很难去定位。主要体现在一个请求可能需要调用很多个服务，而内部服务的调用复杂性决定了问题难以定位。所以在微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题能够快速定位的目的。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003557132.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在微服务系统中，一个来自用户的请求先到达前端A（如前端界面），然后通过远程调用，到达系统的中间件B、C（如负载均衡、网关等），最后到达后端服务D、E，后端经过一系列的业务逻辑计算，最后将数据返回给用户。对于这样一个请求，经历了这么多个服务，怎么样将它的请求过程用数据记录下来呢？这就需要用到服务链路追踪。</p>\n<h2><a id="Spring_Cloud_Sleuth_13"></a>Spring Cloud Sleuth</h2>\n<p>Spring Cloud Sleuth 为服务之间调用提供链路追踪。通过 Sleuth 可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外 Sleuth 可以帮助我们：</p>\n<ul>\n<li>耗时分析: 通过 Sleuth 可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时;</li>\n<li>可视化错误: 对于程序未捕捉的异常，可以通过集成 Zipkin 服务界面上看到;</li>\n<li>链路优化: 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。</li>\n</ul>\n<p>Google开源了Dapper链路追踪组件，并在2010年发表了论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，这篇论文是业内实现链路追踪的标杆和理论基础，具有很高的参考价值。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003613405.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>Spring Cloud Sleuth采用了Google的开源项目Dapper的专业术语。</p>\n<ul>\n<li>Span：基本工作单元，发送一个远程调度任务就会产生一个Span，Span是用一个64位ID唯一标识的，Trace是用另一个64位ID唯一标识的。Span还包含了其他的信息，例如摘要、时间戳事件、Span的ID以及进程ID。</li>\n<li>Trace：由一系列Span组成的，呈树状结构。请求一个微服务系统的API接口，这个API接口需要调用多个微服务单元，调用每个微服务单元都会产生一个新的Span，所有由这个请求产生的Span组成了这个Trace。</li>\n<li>Annotation：用于记录一个事件，一些核心注解用于定义一个请求的开始和结束，这些注解如下。\n<ul>\n<li>cs-Client Sent：客户端发送一个请求，这个注解描述了Span的开始。</li>\n<li>sr-Server Received：服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳，便可得到网络传输的时间。</li>\n<li>ss-Server Sent：服务端发送响应，该注解表明请求处理的完成（当请求返回客户端），用ss的时间戳减去sr时间戳，便可以得到服务器请求的时间。</li>\n<li>cr-Client Received：客户端接收响应，此时Span结束，如果cr的时间戳减去cs时间戳，便可以得到整个请求所消耗的时间。</li>\n</ul>\n</li>\n</ul>\n<p>Spring Cloud Sleuth 也为我们提供了一套完整的链路解决方案,Spring Cloud Sleuth 可以结合 Zipkin，将信息发送到 Zipkin，利用 Zipkin 的存储来存储链路信息，利用 Zipkin UI 来展示数据。</p>\n<h2><a id="Zipkin_36"></a>Zipkin</h2>\n<p>Zipkin是一种分布式链路追踪系统。 它有助于收集解决微服务架构中的延迟问题所需的时序数据。 它管理这些数据的收集和查找。 Zipkin的设计基于Google Dapper论文。</p>\n<p>跟踪器存在于应用程序中，记录请求调用的时间和元数据。跟踪器使用库，它们的使用对用户是无感知的。例如，Web服务器会在收到请求时和发送响应时会记录相应的时间和一些元数据。一次完整链路请求所收集的数据被称为Span。</p>\n<p>我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的 REST API 接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的 API 接口之外，它也提供了方便的 UI 组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。<br>\nZipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。接下来的测试为方便直接采用 In-Memory 方式进行存储，生产推荐 Elasticsearch.</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003637136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>上图展示了 Zipkin 的基础架构，它主要由 4 个核心组件构成：</p>\n<ul>\n<li>Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为 Zipkin 内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。</li>\n<li>Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。</li>\n<li>RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。</li>\n<li>Web UI：UI 组件，基于 API 组件实现的上层应用。通过 UI 组件用户可以方便而有直观地查询和分析跟踪信息。</li>\n</ul>\n<h2><a id="_57"></a>案例实战</h2>\n<p>在本案例一共有三个应用，分别为注册中心，eureka-server、eureka-client、eureka-client-feign，三个应用的基本信息如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>应用名</th>\n<th>端口</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>eureka-server</td>\n<td>8761</td>\n<td>注册中心</td>\n</tr>\n<tr>\n<td>eureka-client</td>\n<td>8763</td>\n<td>服务提供者</td>\n</tr>\n<tr>\n<td>eureka-client-feign</td>\n<td>8765</td>\n<td>服务消费者</td>\n</tr>\n</tbody>\n</table><p>其中eureka-server 应用为注册中心，其他两个应用向它注册。eureka-client为服务提供者，提供了一个RESTAPI,eureka-client-feign为服务消费者，通过Feign Client向服务提供者消费服务。</p>\n<p>在之前的文章已经讲述了如何如何搭建服务注册中心，在这里就省略这一部分内容。服务提供者提供一个REST接口，服务消费者通过FeignClient消费服务。</p>\n<h3><a id="_72"></a>服务提供者</h3>\n<p>eureka-client服务提供者，对外提供一个RESTAPI，并向服务注册中心注册，这部分内容，不再讲述，见源码。需要在工程的pom文件加上sleuth的起步依赖和zipkin的起步依赖，代码如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-sleuth<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-zipkin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>在工程的配置文件application.yml需要做以下的配置：</p>\n<pre><code class="prism language-text">spring:\n  sleuth:\n    web:\n      client:\n        enabled: true\n    sampler:\n      probability: 1.0 # 将采样比例设置为 1.0，也就是全部都需要。默认是 0.1\n  zipkin:\n    base-url: http://localhost:9411/ # 指定了 Zipkin 服务器的地址\n\n</code></pre>\n<p>其中spring.sleuth.web.client.enable为true设置的是web开启sleuth功能;spring.sleuth.sampler.probability可以设置为小数，最大值为1.0，当设置为1.0时就是链路数据100%收集到zipkin-server，当设置为0.1时，即10%概率收集链路数据;spring.zipkin.base-url设置zipkin-server的地址。</p>\n<p>对外提供一个Api，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HiController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>\n    String port<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">home</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"hi "</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",i am from port:"</span> <span class="token operator">+</span>port<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="_123"></a>服务消费者</h3>\n<p>服务消费者通过FeignClient消费服务提供者提供的服务。同服务提供者一样，需要在工程的pom文件加上sleuth的起步依赖和zipkin的起步依赖，另外也需要在配置文件application.yml做相关的配置，具体同服务提供者。</p>\n<p>服务消费者通过feignClient进行服务消费，feignclient代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"eureka-client"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> FeignConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EurekaClientFeign</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    String <span class="token function">sayHiFromClientEureka</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n</code></pre>\n<p>servcie层代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HiService</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    EurekaClientFeign eurekaClientFeign<span class="token punctuation">;</span>\n\n \n    <span class="token keyword">public</span> String <span class="token function">sayHi</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span>  eurekaClientFeign<span class="token punctuation">.</span><span class="token function">sayHiFromClientEureka</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>controller代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HiController</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Autowired</span>\n    HiService hiService<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span> defaultValue <span class="token operator">=</span> <span class="token string">"forezp"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> hiService<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n</code></pre>\n<p>上面的代码对外暴露一个API，通过FeignClient的方式调用eureka-client的服务。</p>\n<h3><a id="zipkinserver_173"></a>zipkin-server</h3>\n<p>在Spring Cloud D版本，zipkin-server通过引入依赖的方式构建工程，自从E版本之后，这一方式改变了，采用官方的jar形式启动，所以需要通过下载官方的jar来启动，也通过以下命令一键启动：</p>\n<pre><code>curl -sSL https://zipkin.io/quickstart.sh | bash -s\njava -jar zipkin.jar\n\n</code></pre>\n<p>上面的第一行命令会从zipkin官网下载官方的jar包。<br>\n如果是window系统，建议使用gitbash执行上面的命令。</p>\n<p>如果用 Docker 的话，使用以下命令：</p>\n<pre><code class="prism language-text">\ndocker run -d -p 9411:9411 openzipkin/zipkin\n\n</code></pre>\n<p>通过java -jar zipkin.jar的方式启动之后，在浏览器上访问lcoalhost:9411，显示的界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003710687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_197"></a>链路数据验证</h3>\n<p>依次启动eureka-server，eureka-client,eureka-client-feign的三个应用，等所有应用启动完成后，在浏览器上访问http://localhost:8765/hi（如果报错，是服务与发现需要一定的时间，耐心等待几十秒），访问成功后，再次在浏览器上访问zipkin-server的页面，显示如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003801417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>从上图可以看出每次请求所消耗的时间，以及一些span的信息。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003833615.png" alt="在这里插入图片描述"></p>\n<p>从上图可以看出具体的服务依赖关系，eureka-feign-client依赖了eureka-client。</p>\n<h3><a id="rabbitmq_210"></a>使用rabbitmq进行链路数据收集</h3>\n<p>在上面的案例中使用的http请求的方式将链路数据发送给zipkin-server，其实还可以使用rabbitmq的方式进行服务的消费。使用rabbitmq需要安装rabbitmq程序，下载地址http://www.rabbitmq.com/。</p>\n<p>下载完成后，需要eureka-client和eureka-client-feign的起步依赖加上rabbitmq的依赖，依赖如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-stream-binder-rabbit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>在配置文件上需要配置rabbitmq的配置，配置信息如下：</p>\n<pre><code class="prism language-text">spring:\n  rabbitmq:\n    host: localhost\n    username: guest\n    password: guest\n    port: 5672\n\n</code></pre>\n<p>另外需要把spring.zipkin.base-url去掉。</p>\n<p>在上面2个工程中，rabbitmq通过发送链路数据，那么zipkin-server是怎么样知道rabbitmq的地址呢，怎么监听收到的链路数据呢？这需要在程序启动的时候，通过环境变量的形式到环境中，然后zikin-server从环境变量中读取。<br>\n可配置的属性如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>环境变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zipkin.collector.rabbitmq.addresses</td>\n<td>RABBIT_ADDRESSES</td>\n<td>用逗号分隔的 RabbitMQ 地址列表，例如localhost:5672,localhost:5673</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.password</td>\n<td>RABBIT_PASSWORD</td>\n<td>连接到 RabbitMQ 时使用的密码，默认为 guest</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.username</td>\n<td>RABBIT_USER</td>\n<td>连接到 RabbitMQ 时使用的用户名，默认为guest</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.virtual-host</td>\n<td>RABBIT_VIRTUAL_HOST</td>\n<td>使用的 RabbitMQ virtual host，默认为 /</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.use-ssl</td>\n<td>RABBIT_USE_SSL</td>\n<td>设置为true则用 SSL 的方式与 RabbitMQ 建立链接</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.concurrency</td>\n<td>RABBIT_CONCURRENCY</td>\n<td>并发消费者数量，默认为1</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.connection-timeout</td>\n<td>RABBIT_CONNECTION_TIMEOUT</td>\n<td>建立连接时的超时时间，默认为 60000毫秒，即 1 分钟</td>\n</tr>\n<tr>\n<td>zipkin.collector.rabbitmq.queue</td>\n<td>RABBIT_QUEUE</td>\n<td>从中获取 span 信息的队列，默认为 zipkin</td>\n</tr>\n</tbody>\n</table><p>比如，通过以下命令启动：</p>\n<pre><code class="prism language-text">RABBIT_ADDRESSES=localhost java -jar zipkin.jar\n\n</code></pre>\n<p>上面的命令等同于一下的命令：</p>\n<pre><code class="prism language-text">java -jar zipkin.jar --zipkin.collector.rabbitmq.addressed=localhost\n\n</code></pre>\n<p>用上面的2条命令中的任何一种方式重新启动zipkin-server程序，并重新启动eureka-client、eureka-server、eureka-client-feign，动完成后在浏览器上访问http://localhost:8765/hi，再访问http://localhost:9411/zipkin/，就可以看到通过Http方式发送链路数据一样的接口。</p>\n<h3><a id="Tag_267"></a>自定义Tag</h3>\n<p>在页面上可以查看每个请求的traceId，每个trace又包含若干的span，每个span又包含了很多的tag，自定义tag可以通过Tracer这个类来自定义。</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@Autowired</span>\nTracer tracer<span class="token punctuation">;</span>\n\n <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">home</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        tracer<span class="token punctuation">.</span><span class="token function">currentSpan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"forezp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token string">"hi "</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",i am from port:"</span> <span class="token operator">+</span>port<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="Mysql_284"></a>将链路数据存储在Mysql数据库中</h3>\n<p>上面的例子是将链路数据存在内存中，只要zipkin-server重启之后，之前的链路数据全部查找不到了，zipkin是支持将链路数据存储在mysql、cassandra、elasticsearch中的。<br>\n现在讲解如何将链路数据存储在Mysql数据库中。<br>\n首先需要初始化zikin存储在Mysql的数据的scheme，可以在这里查看https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql，具体如下：</p>\n<pre><code class="prism language-text">CREATE TABLE IF NOT EXISTS zipkin_spans (\n  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT \'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit\',\n  `trace_id` BIGINT NOT NULL,\n  `id` BIGINT NOT NULL,\n  `name` VARCHAR(255) NOT NULL,\n  `parent_id` BIGINT,\n  `debug` BIT(1),\n  `start_ts` BIGINT COMMENT \'Span.timestamp(): epoch micros used for endTs query and to implement TTL\',\n  `duration` BIGINT COMMENT \'Span.duration(): micros used for minDuration and maxDuration query\'\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT \'ignore insert on duplicate\';\nALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT \'for joining with zipkin_annotations\';\nALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT \'for getTracesByIds\';\nALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT \'for getTraces and getSpanNames\';\nALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT \'for getTraces ordering and range\';\n\nCREATE TABLE IF NOT EXISTS zipkin_annotations (\n  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT \'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit\',\n  `trace_id` BIGINT NOT NULL COMMENT \'coincides with zipkin_spans.trace_id\',\n  `span_id` BIGINT NOT NULL COMMENT \'coincides with zipkin_spans.id\',\n  `a_key` VARCHAR(255) NOT NULL COMMENT \'BinaryAnnotation.key or Annotation.value if type == -1\',\n  `a_value` BLOB COMMENT \'BinaryAnnotation.value(), which must be smaller than 64KB\',\n  `a_type` INT NOT NULL COMMENT \'BinaryAnnotation.type() or -1 if Annotation\',\n  `a_timestamp` BIGINT COMMENT \'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp\',\n  `endpoint_ipv4` INT COMMENT \'Null when Binary/Annotation.endpoint is null\',\n  `endpoint_ipv6` BINARY(16) COMMENT \'Null when Binary/Annotation.endpoint is null, or no IPv6 address\',\n  `endpoint_port` SMALLINT COMMENT \'Null when Binary/Annotation.endpoint is null\',\n  `endpoint_service_name` VARCHAR(255) COMMENT \'Null when Binary/Annotation.endpoint is null\'\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT \'Ignore insert on duplicate\';\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT \'for joining with zipkin_spans\';\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT \'for getTraces/ByIds\';\nALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT \'for getTraces and getServiceNames\';\nALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT \'for getTraces and autocomplete values\';\nALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT \'for getTraces and autocomplete values\';\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT \'for dependencies job\';\n\nCREATE TABLE IF NOT EXISTS zipkin_dependencies (\n  `day` DATE NOT NULL,\n  `parent` VARCHAR(255) NOT NULL,\n  `child` VARCHAR(255) NOT NULL,\n  `call_count` BIGINT,\n  `error_count` BIGINT\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);\n</code></pre>\n<p>在数据库中初始化上面的脚本之后，需要做的就是zipkin-server如何连接数据库。zipkin如何连数据库同连接rabbitmq一样。zipkin连接数据库的属性所对应的环境变量如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>环境变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zipkin.torage.type</td>\n<td>STORAGE_TYPE</td>\n<td>默认的为mem，即为内存，其他可支持的为cassandra、cassandra3、elasticsearch、mysql</td>\n</tr>\n<tr>\n<td>zipkin.torage.mysql.host</td>\n<td>MYSQL_HOST</td>\n<td>数据库的host，默认localhost</td>\n</tr>\n<tr>\n<td>zipkin.torage.mysql.port</td>\n<td>MYSQL_TCP_PORT</td>\n<td>数据库的端口，默认3306</td>\n</tr>\n<tr>\n<td>zipkin.torage.mysql.username</td>\n<td>MYSQL_USER</td>\n<td>连接数据库的用户名，默认为空</td>\n</tr>\n<tr>\n<td>zipkin.torage.mysql.password</td>\n<td>MYSQL_PASS</td>\n<td>连接数据库的密码，默认为空</td>\n</tr>\n<tr>\n<td>zipkin.torage.mysql.db</td>\n<td>MYSQL_DB</td>\n<td>zipkin使用的数据库名，默认是zipkin</td>\n</tr>\n<tr>\n<td>zipkin.torage.mysql.max-active</td>\n<td>MYSQL_MAX_CONNECTIONS</td>\n<td>最大连接数，默认是10</td>\n</tr>\n</tbody>\n</table><pre><code class="prism language-text">STORAGE_TYPE=mysql MYSQL_HOST=localhost MYSQL_TCP_PORT=3306 MYSQL_USER=root MYSQL_PASS=123456 MYSQL_DB=zipkin java -jar zipkin.jar\n</code></pre>\n<p>等同于以下的命令</p>\n<pre><code class="prism language-text">java -jar zipkin.jar --zipkin.torage.type=mysql --zipkin.torage.mysql.host=localhost --zipkin.torage.mysql.port=3306 --zipkin.torage.mysql.username=root --zipkin.torage.mysql.password=123456\n</code></pre>\n<p>使用上面的命令启动zipkin.jar工程，然后再浏览数上访问http://localhost:8765/hi，再访问http://localhost:9411/zipkin/，可以看到链路数据。这时去数据库查看数据，也是可以看到存储在数据库的链路数据，如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003918302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>这时重启应用zipkin.jar，再次在浏览器上访问http://localhost:9411/zipkin/，仍然可以得到之前的结果，证明链路数据存储在数据库中，而不是内存中。</p>\n<h3><a id="Elasticsearch_371"></a>将链路数据存在在Elasticsearch中</h3>\n<p>zipkin-server支持将链路数据存储在ElasticSearch中。读者需要自行安装ElasticSearch和Kibana，下载地址为https://www. elastic.co/products/elasticsearch。安装完成后启动，其中ElasticSearch的默认端口号为9200，Kibana的默认端口号为5601。</p>\n<p>同理，zipkin连接elasticsearch也是从环境变量中读取的，elasticsearch相关的环境变量和对应的属性如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>环境变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zipkin.torage.elasticsearch.hosts</td>\n<td>ES_HOSTS</td>\n<td>ES_HOSTS，默认为空</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.pipeline</td>\n<td>ES_PIPELINE</td>\n<td>ES_PIPELINE，默认为空</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.max-requests</td>\n<td>ES_MAX_REQUESTS</td>\n<td>ES_MAX_REQUESTS，默认为64</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.timeout</td>\n<td>ES_TIMEOUT</td>\n<td>ES_TIMEOUT，默认为10s</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.index</td>\n<td>ES_INDEX</td>\n<td>ES_INDEX，默认是zipkin</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.date-separator</td>\n<td>ES_DATE_SEPARATOR</td>\n<td>ES_DATE_SEPARATOR，默认为“-”</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.index-shards</td>\n<td>ES_INDEX_SHARDS</td>\n<td>ES_INDEX_SHARDS，默认是5</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.index-replicas</td>\n<td>ES_INDEX_REPLICAS</td>\n<td>ES_INDEX_REPLICAS，默认是1</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.username</td>\n<td>ES_USERNAME</td>\n<td>ES的用户名，默认为空</td>\n</tr>\n<tr>\n<td>zipkin.torage.elasticsearch.password</td>\n<td>ES_PASSWORD</td>\n<td>ES的密码，默认是为空</td>\n</tr>\n</tbody>\n</table><p>采用以下命令启动zipkin-server:</p>\n<pre><code class="prism language-text">\nSTORAGE_TYPE=elasticsearch ES_HOSTS=http://localhost:9200 ES_INDEX=zipkin java -jar zipkin.jar\n\n</code></pre>\n<pre><code>java -jar zipkin.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=http://localhost:9200 --ES_INDEX=zipkin \n\n</code></pre>\n<pre><code>java -jar zipkin.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=http://localhost:9200 --ES_INDEX=zipkin \n</code></pre>\n<pre><code>java -jar zipkin.jar --zipkin.torage.type=elasticsearch --zipkin.torage.elasticsearch.hosts=http://localhost:9200 --zipkin.torage.elasticsearch.index=zipkin \n\n</code></pre>\n<p>启动完成后，然后在浏览数上访问http://localhost:8765/hi，再访问http://localhost:9411/zipkin/，可以看到链路数据。这时链路数据存储在ElasticSearch。</p>\n<h3><a id="zipkin_416"></a>在zipkin上展示链路数据</h3>\n<p>链路数据存储在ElasticSearch中，ElasticSearch可以和Kibana结合，将链路数据展示在Kibana上。安装完成Kibana后启动，Kibana默认会向本地端口为9200的ElasticSearch读取数据。Kibana默认的端口为5601，访问Kibana的主页http://localhost:5601，其界面如下图所示。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004020346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在上图的界面中，单击“Management”按钮，然后单击“Add New”，添加一个index。我们将在上节ElasticSearch中写入链路数据的index配置为“zipkin”，那么在界面填写为“zipkin-*”，单击“Create”按钮，界面如下图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004051218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>创建完成index后，单击“Discover”，就可以在界面上展示链路数据了，展示界面如下图所示。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004124462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_434"></a>参考资料</h3>\n<p>https://zipkin.io/</p>\n<p>https://github.com/spring-cloud/spring-cloud-sleuth</p>\n<p>https://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.1.0.RELEASE/single/spring-cloud-sleuth.html</p>\n<p>https://github.com/openzipkin/zipkin/blob/master/zipkin-server/src/main/resources/zipkin-server-shared.yml</p>\n<p>https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql</p>\n<p>https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/</p>\n<p>https://segmentfault.com/a/1190000015697673</p>\n<p>elatstic 版本为2.6.x，下载地址：https://www.elastic.co/downloads/past-releases</p>\n<p>http://www.cnblogs.com/JreeyQi/p/9336692.html</p>\n<h3><a id="_454"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:21'}
2020-02-05 20:12:21 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/86105850', 'title': 'Spring Boot Admin 2.1.0 全攻略', 'readNum': '20809', 'commentNum': '9', 'publishTime': '2019-01-08 23:07:56', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/86105850<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2019/01/04/sc-f-boot-admin.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/01/04/sc-f-boot-admin.html</a></p>\n<h2><a id="Spring_Boot_Admin_7"></a>Spring Boot Admin简介</h2>\n<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。 应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册（通过HTTP）或使用SpringCloud注册中心（例如Eureka，Consul）发现。 UI是的AngularJs应用程序，展示Spring Boot Admin Client的Actuator端点上的一些监控。常见的功能或者监控如下：</p>\n<ul>\n<li>显示健康状况</li>\n<li>显示详细信息，例如\n<ul>\n<li>JVM和内存指标</li>\n<li>micrometer.io指标</li>\n<li>数据源指标</li>\n<li>缓存指标</li>\n</ul>\n</li>\n<li>显示构建信息编号</li>\n<li>关注并下载日志文件</li>\n<li>查看jvm系统和环境属性</li>\n<li>查看Spring Boot配置属性</li>\n<li>支持Spring Cloud的postable / env-和/ refresh-endpoint</li>\n<li>轻松的日志级管理</li>\n<li>与JMX-beans交互</li>\n<li>查看线程转储</li>\n<li>查看http跟踪</li>\n<li>查看auditevents</li>\n<li>查看http-endpoints</li>\n<li>查看计划任务</li>\n<li>查看和删除活动会话（使用spring-session）</li>\n<li>查看Flyway / Liquibase数据库迁移</li>\n<li>下载heapdump</li>\n<li>状态变更通知（通过电子邮件，Slack，Hipchat，…）</li>\n<li>状态更改的事件日志（非持久性）</li>\n</ul>\n<h2><a id="_35"></a>快速开始</h2>\n<h3><a id="Spring_Boot_Admin_Server_37"></a>创建Spring Boot Admin Server</h3>\n<p>本文的所有工程的Spring Boot版本为2.1.0 、Spring Cloud版本为Finchley.SR2。案例采用Maven多module形式，父pom文件引入以下的依赖（完整的依赖见源码）：</p>\n<pre><code class="prism language-xml">\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.1.0.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>\n    \n    \n     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${spring-cloud.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>\n                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>\n\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-cloud.version</span><span class="token punctuation">&gt;</span></span>Finchley.SR2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-cloud.version</span><span class="token punctuation">&gt;</span></span>\n\n\n</code></pre>\n<p>在工程admin-server引入admin-server的起来依赖和web的起步依赖，代码如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>de.codecentric<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-admin-starter-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>然后在工程的启动类AdminServerApplication加上@EnableAdminServer注解，开启AdminServer的功能，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableAdminServer</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServerApplication</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span> AdminServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>在工程的配置文件application.yml中配置程序名和程序的端口，代码如下：</p>\n<pre><code>spring:\n  application:\n    name: admin-server\nserver:\n  port: 8769\n</code></pre>\n<p>这样Admin Server就创建好了。</p>\n<h3><a id="Spring_Boot_Admin_Client_111"></a>创建Spring Boot Admin Client</h3>\n<p>在admin-client工程的pom文件引入admin-client的起步依赖和web的起步依赖，代码如下：</p>\n<pre><code class="prism language-xml">\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>de.codecentric<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-admin-starter-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n       \n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n\n</code></pre>\n<p>在工程的配置文件application.yml中配置应用名和端口信息，以及向admin-server注册的地址为http://localhost:8769，最后暴露自己的actuator的所有端口信息，具体配置如下：</p>\n<pre><code class="prism language-text">spring:\n  application:\n    name: admin-client\n  boot:\n    admin:\n      client:\n        url: http://localhost:8769\nserver:\n  port: 8768\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \'*\'\n  endpoint:\n    health:\n      show-details: ALWAYS\n\n</code></pre>\n<p>在工程的启动文件如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminClientApplication</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span> AdminClientApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</code></pre>\n<p>一次启动两个工程，在浏览器上输入localhost:8769 ，浏览器显示的界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060100443430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>查看wallboard：<br>\n<img src="https://img-blog.csdnimg.cn/20190601004445187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>点击wallboard，可以查看admin-client具体的信息，比如内存状态信息：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004529293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>也可以查看spring bean的情况：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004553878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>更多监控信息，自己体验。</p>\n<h2><a id="Spring_boot_AdminSC_186"></a>Spring boot Admin结合SC注册中心使用</h2>\n<p>同上一个案例一样，本案例也是使用的是Spring Boot版本为2.1.0 、Spring Cloud版本为Finchley.SR2。案例采用Maven多module形式，父pom文件引入以下的依赖（完整的依赖见源码），此处省略。</p>\n<h3><a id="_191"></a>搭建注册中心</h3>\n<p>注册中心使用Eureka、使用Consul也是可以的，在eureka-server工程中的pom文件中引入：</p>\n<pre><code class="prism language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n</code></pre>\n<p>配置eureka-server的端口信息，以及defaultZone和防止自注册。最后系统暴露eureka-server的actuator的所有端口。</p>\n<pre><code class="prism language-text">spring:\n  application:\n    name: eureka-server\nserver:\n  port: 8761\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka\n    register-with-eureka: false\n    fetch-registry: false\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n  endpoint:\n    health:\n      show-details: ALWAYS\n</code></pre>\n<p>在工程的启动文件EurekaServerApplication加上@EnableEurekaServer注解开启Eureka Server.</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableEurekaServer</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServerApplication</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span> EurekaServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>eureka-server搭建完毕。</p>\n<h3><a id="adminserver_244"></a>搭建admin-server</h3>\n<p>在admin-server工程的pom文件引入admin-server的起步依赖、web的起步依赖、eureka-client的起步依赖，如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>de.codecentric<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-admin-starter-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n        \n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>然后配置admin-server，应用名、端口信息。并向注册中心注册，注册地址为http://localhost:8761，最后将actuator的所有端口暴露出来，配置如下：</p>\n<pre><code>\nspring:\n  application:\n    name: admin-server\nserver:\n  port: 8769\neureka:\n  client:\n    registryFetchIntervalSeconds: 5\n    service-url:\n      defaultZone: ${EUREKA_SERVICE_URL:http://localhost:8761}/eureka/\n  instance:\n    leaseRenewalIntervalInSeconds: 10\n    health-check-url-path: /actuator/health\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n  endpoint:\n    health:\n      show-details: ALWAYS\n</code></pre>\n<p>在工程的启动类AdminServerApplication加上@EnableAdminServer注解，开启admin server的功能，加上@EnableDiscoveryClient注解开启eurke client的功能。</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableAdminServer</span>\n<span class="token annotation punctuation">@EnableDiscoveryClient</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServerApplication</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span> AdminServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="adminclient_312"></a>搭建admin-client</h3>\n<p>在admin-client的pom文件引入以下的依赖，由于2.1.0采用webflux，引入webflux的起步依赖，引入eureka-client的起步依赖，并引用actuator的起步依赖如下：</p>\n<pre><code class="prism language-xml">\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-webflux<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>在工程的配置文件配置应用名、端口、向注册中心注册的地址，以及暴露actuator的所有端口。</p>\n<pre><code class="prism language-java">\nspring<span class="token operator">:</span>\n  application<span class="token operator">:</span>\n    name<span class="token operator">:</span> admin<span class="token operator">-</span>client\neureka<span class="token operator">:</span>\n  instance<span class="token operator">:</span>\n    leaseRenewalIntervalInSeconds<span class="token operator">:</span> <span class="token number">10</span>\n    health<span class="token operator">-</span>check<span class="token operator">-</span>url<span class="token operator">-</span>path<span class="token operator">:</span> <span class="token operator">/</span>actuator<span class="token operator">/</span>health\n\n  client<span class="token operator">:</span>\n    registryFetchIntervalSeconds<span class="token operator">:</span> <span class="token number">5</span>\n    service<span class="token operator">-</span>url<span class="token operator">:</span>\n      defaultZone<span class="token operator">:</span> $<span class="token punctuation">{</span>EUREKA_SERVICE_URL<span class="token operator">:</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">8761</span><span class="token punctuation">}</span><span class="token operator">/</span>eureka<span class="token operator">/</span>\nmanagement<span class="token operator">:</span>\n  endpoints<span class="token operator">:</span>\n    web<span class="token operator">:</span>\n      exposure<span class="token operator">:</span>\n        include<span class="token operator">:</span> <span class="token string">"*"</span>\n  endpoint<span class="token operator">:</span>\n    health<span class="token operator">:</span>\n      show<span class="token operator">-</span>details<span class="token operator">:</span> ALWAYS\nserver<span class="token operator">:</span>\n  port<span class="token operator">:</span> <span class="token number">8762</span>\n\n</code></pre>\n<p>在启动类加上@EnableDiscoveryClie注解，开启DiscoveryClient的功能。</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableDiscoveryClient</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminClientApplication</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span> AdminClientApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>一次启动三个工程，在浏览器上访问localhost:8769，浏览器会显示和上一小节一样的界面。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004635406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="spring_security_379"></a>集成spring security</h3>\n<p>在2.1.0版本中去掉了hystrix dashboard，登录界面默认集成到了spring security模块，只要加上spring security就集成了登录模块。</p>\n<p>只需要改变下admin-server工程，需要在admin-server工程的pom文件引入以下的依赖：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>在admin-server工的配置文件application.yml中配置spring security的用户名和密码，这时需要在服务注册时带上metadata-map的信息，如下：</p>\n<pre><code>spring:\n  security:\n    user:\n      name: "admin"\n      password: "admin"\n      \neureka:\n  instance:\n    metadata-map:\n      user.name: ${spring.security.user.name}\n      user.password: ${spring.security.user.password}\n\n</code></pre>\n<p>写一个配置类SecuritySecureConfig继承WebSecurityConfigurerAdapter，配置如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@Configuration</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecuritySecureConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">final</span> String adminContextPath<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token function">SecuritySecureConfig</span><span class="token punctuation">(</span>AdminServerProperties adminServerProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>adminContextPath <span class="token operator">=</span> adminServerProperties<span class="token punctuation">.</span><span class="token function">getContextPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>\n        <span class="token comment">// @formatter:off</span>\n        SavedRequestAwareAuthenticationSuccessHandler successHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SavedRequestAwareAuthenticationSuccessHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        successHandler<span class="token punctuation">.</span><span class="token function">setTargetUrlParameter</span><span class="token punctuation">(</span> <span class="token string">"redirectTo"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        http<span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span> adminContextPath <span class="token operator">+</span> <span class="token string">"/assets/**"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span> adminContextPath <span class="token operator">+</span> <span class="token string">"/login"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loginPage</span><span class="token punctuation">(</span> adminContextPath <span class="token operator">+</span> <span class="token string">"/login"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">successHandler</span><span class="token punctuation">(</span> successHandler <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logoutUrl</span><span class="token punctuation">(</span> adminContextPath <span class="token operator">+</span> <span class="token string">"/logout"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">httpBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// @formatter:on</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>重启启动工程，在浏览器上访问：http://localhost:8769/，会被重定向到登录界面，登录的用户名和密码为配置文件中配置的，分别为admin和admin，界面显示如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004705428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_448"></a>集成邮箱报警功能</h3>\n<p>在spring boot admin中，也可以集成邮箱报警功能，比如服务不健康了、下线了，都可以给指定邮箱发送邮件。集成非常简单，只需要改造下admin-server即可：</p>\n<p>在admin-server工程Pom文件，加上mail的起步依赖，代码如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-mail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\n</code></pre>\n<p>在配置文件application.yml文件中，需要配置邮件相关的配置，如下：</p>\n<pre><code>spring.mail.host: smtp.163.com\nspring.mail.username: miles02\nspring.mail.password:\nspring.boot.admin.notify.mail.to: 124746406@qq.com\n\n</code></pre>\n<p>做完以上配置后，当我们已注册的客户端的状态从 UP 变为 OFFLINE 或其他状态，服务端就会自动将电子邮件发送到上面配置的地址。</p>\n<h2><a id="_475"></a>源码下载</h2>\n<p>快速开始： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-boot-admin</p>\n<p>和spring cloud结合：https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-boot-admin-cloud</p>\n<h2><a id="_481"></a>参考资料</h2>\n<p>http://codecentric.github.io/spring-boot-admin/2.1.0/</p>\n<p>https://github.com/codecentric/spring-boot-admin</p>\n<h3><a id="_489"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:21'}
2020-02-05 20:12:21 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87273153', 'title': 'Spring Cloud Consul 之Greenwich版本全攻略', 'readNum': '21224', 'commentNum': '14', 'publishTime': '2019-02-14 14:45:01', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/87273153<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客版：<a href="https://www.fangzhipeng.com/springcloud/2019/02/14/sc-consul-g.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/02/14/sc-consul-g.html</a></p>\n<h2><a id="Consul_8"></a>什么是Consul</h2>\n<p>Consul是HashiCorp公司推出的开源软件，使用GO语言编写，提供了分布式系统的服务注册和发现、配置等功能，这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格。Consul不仅具有服务治理的功能，而且使用分布式一致协议RAFT算法实现，有多数据中心的高可用方案，并且很容易和Spring Cloud等微服务框架集成，使用起来非常的简单，具有简单、易用、可插排等特点。使用简而言之，Consul提供了一种完整的服务网格解决方案 。</p>\n<h3><a id="Consul_12"></a>Consul具有以下的特点和功能</h3>\n<ul>\n<li>服务发现：Consul的客户端可以向Consul注册服务，例如api服务或者mysql服务，其他客户端可以使用Consul来发现服务的提供者。Consul支持使用DNS或HTTP来注册和发现服务。</li>\n<li>运行时健康检查：Consul客户端可以提供任意数量的运行状况检查机制，这些检查机制可以是给定服务（“是Web服务器返回200 OK”）或本地节点（“内存利用率低于90％”）相关联。这些信息可以用来监控群集的运行状况，服务发现组件可以使用这些监控信息来路由流量，可以使流量远离不健康的服务。</li>\n<li>KV存储：应用程序可以将Consul的键/值存储用于任何需求，包括动态配置，功能标记，协调，领导者选举等。它采用HTTP API使其易于使用。</li>\n<li>安全服务通信：Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。</li>\n<li>多数据中心：Consul支持多个数据中心。这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域。</li>\n</ul>\n<h3><a id="Consul_20"></a>Consul原理</h3>\n<p>每个提供服务的节点都运行了Consul的代理，运行代理不需要服务发现和获取配置的KV键值对，代理只负责监控检查。代理节点可以和一个或者多个Consul server通讯。 Consul服务器是存储和复制数据的地方。服务器本身选出了领导者。虽然Consul可以在一台服务器上运行，但建议使用3到5，以避免导致数据丢失的故障情况。建议为每个数据中心使用一组Consul服务器。<br>\n如果你的组件需要发现服务，可以查询任何Consul Server或任何Consul客户端，Consul客户端会自动将查询转发给Consul Server。<br>\n需要发现其他服务或节点的基础架构组件可以查询任何Consul服务器或任何Consul代理。代理会自动将查询转发给服务器。每个数据中心都运行Consul服务器集群。发生跨数据中心服务发现或配置请求时，本地Consul服务器会将请求转发到远程数据中心并返回结果。</p>\n<p><strong>术语</strong></p>\n<ul>\n<li>Agent agent是一直运行在Consul集群中每个成员上的守护进程。通过运行 consul agent 来启动。agent可以运行在client或者server模式。指定节点作为client或者server是非常简单的，除非有其他agent实例。所有的agent都能运行DNS或者HTTP接口，并负责运行时检查和保持服务同步。</li>\n<li>Client 一个Client是一个转发所有RPC到server的代理。这个client是相对无状态的。client唯一执行的后台活动是加入LAN gossip池。这有一个最低的资源开销并且仅消耗少量的网络带宽。</li>\n<li>Server 一个server是一个有一组扩展功能的代理，这些功能包括参与Raft选举，维护集群状态，响应RPC查询，与其他数据中心交互WAN gossip和转发查询给leader或者远程数据中心。</li>\n<li>DataCenter 虽然数据中心的定义是显而易见的，但是有一些细微的细节必须考虑。例如，在EC2中，多个可用区域被认为组成一个数据中心？我们定义数据中心为一个私有的，低延迟和高带宽的一个网络环境。这不包括访问公共网络，但是对于我们而言，同一个EC2中的多个可用区域可以被认为是一个数据中心的一部分。</li>\n<li>Consensus 在我们的文档中，我们使用Consensus来表明就leader选举和事务的顺序达成一致。由于这些事务都被应用到有限状态机上，Consensus暗示复制状态机的一致性。</li>\n<li>Gossip Consul建立在Serf的基础之上，它提供了一个用于多播目的的完整的gossip协议。Serf提供成员关系，故障检测和事件广播。更多的信息在gossip文档中描述。这足以知道gossip使用基于UDP的随机的点到点通信。</li>\n<li>LAN Gossip 它包含所有位于同一个局域网或者数据中心的所有节点。</li>\n<li>WAN Gossip 它只包含Server。这些server主要分布在不同的数据中心并且通常通过因特网或者广域网通信。</li>\n<li>RPC 远程过程调用。这是一个允许client请求server的请求/响应机制。</li>\n</ul>\n<p><img src="https://img-blog.csdnimg.cn/20190601003058940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>让我们分解这张图并描述每个部分。首先，我们能看到有两个数据中心，标记为“1”和“2”。Consul对多数据中心有一流的支持并且希望这是一个常见的情况。</p>\n<p>在每个数据中心，client和server是混合的。一般建议有3-5台server。这是基于有故障情况下的可用性和性能之间的权衡结果，因为越多的机器加入达成共识越慢。然而，并不限制client的数量，它们可以很容易的扩展到数千或者数万台。</p>\n<p>同一个数据中心的所有节点都必须加入gossip协议。这意味着gossip协议包含一个给定数据中心的所有节点。这服务于几个目的：第一，不需要在client上配置server地址。发现都是自动完成的。第二，检测节点故障的工作不是放在server上，而是分布式的。这是的故障检测相比心跳机制有更高的可扩展性。第三：它用来作为一个消息层来通知事件，比如leader选举发生时。</p>\n<p>每个数据中心的server都是Raft节点集合的一部分。这意味着它们一起工作并选出一个leader，一个有额外工作的server。leader负责处理所有的查询和事务。作为一致性协议的一部分，事务也必须被复制到所有其他的节点。因为这一要求，当一个非leader得server收到一个RPC请求时，它将请求转发给集群leader。</p>\n<p>server节点也作为WAN gossip Pool的一部分。这个Pool不同于LAN Pool，因为它是为了优化互联网更高的延迟，并且它只包含其他Consul server节点。这个Pool的目的是为了允许数据中心能够以low-touch的方式发现彼此。这使得一个新的数据中心可以很容易的加入现存的WAN gossip。因为server都运行在这个pool中，它也支持跨数据中心请求。当一个server收到来自另一个数据中心的请求时，它随即转发给正确数据中想一个server。该server再转发给本地leader。</p>\n<p>这使得数据中心之间只有一个很低的耦合，但是由于故障检测，连接缓存和复用，跨数据中心的请求都是相对快速和可靠的。</p>\n<h3><a id="Consul__54"></a>Consul 服务注册发现流程</h3>\n<p>Consul在业界最广泛的用途就是作为服务注册中心，同Eureka类型，consul作为服务注册中心，它的注册和发现过程如下图：<br>\n<img src="https://img-blog.csdnimg.cn/20190601003139118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在上面的流程图上有三个角色，分别为服务注册中心、服务提供者、服务消费者。</p>\n<ul>\n<li>服务提供者Provider启动的时候，会向Consul发送一个请求，将自己的host、ip、应用名、健康检查等元数据信息发送给Consul</li>\n<li>Consul 接收到 Provider 的注册后，定期向 Provider 发送健康检查的请求，检验Provider是否健康</li>\n<li>服务消费者Consumer会从注册中心Consul中获取服务注册列表，当服务消费者消费服务时，根据应用名从服务注册列表获取到具体服务的实例（1个或者多个），从而完成服务的调用。</li>\n</ul>\n<h3><a id="Consul_VS_Eureka_65"></a>Consul VS Eureka</h3>\n<p>Eureka是一种服务发现工具。 该体系结构主要是客户端/服务器，每个数据中心有一组Eureka服务器，通常每个可用区域一个。 通常，Eureka的客户使用嵌入式SDK来注册和发现服务。 对于非本地集成的客户端，使用Ribbon等边车通过Eureka透明地发现服务。</p>\n<p>Eureka使用尽力而为的复制提供弱一致的服务视图。 当客户端向服务器注册时，该服务器将尝试复制到其他服务器但不提供保证。 服务注册的生存时间很短（TTL），要求客户端对服务器进行心跳检测。 不健康的服务或节点将停止心跳，导致它们超时并从注册表中删除。 发现请求可以路由到任何服务，由于尽力复制，这些服务可以提供过时或丢失的数据。 这种简化的模型允许轻松的集群管理和高可扩展性。</p>\n<p>Consul提供了一系列超级功能，包括更丰富的运行状况检查，键/值存储和多数据中心感知。 Consul需要每个数据中心中的一组服务器，以及每个客户端上的代理，类似于使用像Ribbon这样的边车。 Consul代理允许大多数应用程序不知道Consul，通过配置文件执行服务注册以及通过DNS或负载平衡器sidecars进行发现。</p>\n<p>Consul提供强大的一致性保证，因为服务器使用Raft协议复制状态。 Consul支持丰富的运行状况检查，包括TCP，HTTP，Nagios / Sensu兼容脚本或基于的Eureka的TTL。 客户端节点参与基于gossip的健康检查，该检查分发健康检查的工作，而不像集中式心跳，这成为可扩展性挑战。 发现请求被路由到当选的Consul领导者，这使他们默认情况下非常一致。 允许过时读取的客户端允许任何服务器处理其请求，从而允许像Eureka一样的线性可伸缩性。</p>\n<p>Consul的强烈一致性意味着它可以用作领导者选举和集群协调的锁定服务。 Eureka不提供类似的保证，并且通常需要为需要执行协调或具有更强一致性需求的服务运行ZooKeeper。</p>\n<p>Consul提供了支持面向服务的体系结构所需的功能工具包。 这包括服务发现，还包括丰富的运行状况检查，锁定，键/值，多数据中心联合，事件系统和ACL。 Consul和consul-template和envconsul等工具生态系统都试图最大限度地减少集成所需的应用程序更改，以避免需要通过SDK进行本机集成。 Eureka是更大的Netflix OSS套件的一部分，该套件期望应用程序相对同质且紧密集成。 因此，Eureka只解决了有限的一部分问题，期望其他工具如ZooKeeper可以同时使用。</p>\n<p>Eureka Server端采用的是P2P的复制模式，但是它不保证复制操作一定能成功，因此它提供的是一个最终一致性的服务实例视图；Client端在Server端的注册信息有一个带期限的租约，一旦Server端在指定期间没有收到Client端发送的心跳，则Server端会认定为Client端注册的服务是不健康的，定时任务将会将其从注册表中删除。Consul与Eureka不同，Consul采用Raft算法，可以提供强一致性的保证，Consul的agent相当于Netflix Ribbon + Netflix Eureka Client，而且对应用来说相对透明，同时相对于Eureka这种集中式的心跳检测机制，Consul的agent可以参与到基于goosip协议的健康检查，分散了server端的心跳检测压力。除此之外，Consul为多数据中心提供了开箱即用的原生支持等。</p>\n<h2><a id="Consul_83"></a>Consul下载和安装</h2>\n<p>Consul采用Go语言编写，支持Linux、Mac、Windows等各大操作系统，本文使用windows操作系统，下载地址：https://www.consul.io/downloads.html，下完成后解压到计算机目录下，解压成功后，只有一个可执行的consul.exe可执行文件。打开cmd终端，切换到目录，执行以下命令：</p>\n<pre><code>consul --version\n</code></pre>\n<p>终端显示如下：</p>\n<pre><code>Consul v1.4.2\nProtocol 2 spoken by default, understands 2 to 3 (agent will automatically use p\nrotocol &gt;2 when speaking to compatible agents)\n</code></pre>\n<p>证明consul下载成功了，并可执行。</p>\n<p>consul的一些常见的执行命令如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>agent</td>\n<td>运行一个consul agent</td>\n<td>consul agent -dev</td>\n</tr>\n<tr>\n<td>join</td>\n<td>将agent加入到consul集群</td>\n<td>consul join IP</td>\n</tr>\n<tr>\n<td>members</td>\n<td>列出consul cluster集群中的members</td>\n<td>consul members</td>\n</tr>\n<tr>\n<td>leave</td>\n<td>将节点移除所在集群</td>\n<td>consul leave</td>\n</tr>\n</tbody>\n</table><p>更多命令请查看官方网站：https://www.consul.io/docs/commands/index.html</p>\n<p>开发模式启动：</p>\n<pre><code>consul agent -dev \n</code></pre>\n<p>启动成功，在浏览器上访问：http://localhost:8500，显示的界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003244126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="spring_cloud_consul_121"></a>spring cloud consul</h2>\n<p>该项目通过自动配置并绑定到Spring环境和其他Spring编程模型成语，为Spring Boot应用程序提供Consul集成。通过几个简单的注释，您可以快速启用和配置应用程序中的常见模式，并使用基于Consul的组件构建大型分布式系统。提供的模式包括服务发现，控制总线和配置。智能路由（Zuul）和客户端负载平衡（Ribbon），断路器（Hystrix）通过与Spring Cloud Netflix的集成提供。</p>\n<h2><a id="spring_cloud_consul_125"></a>使用spring cloud consul来服务注册与发现</h2>\n<p>本小节以案例的形式来讲解如何使用Spring Cloud Consul来进行服务注册和发现的，并且使用Feign来消费服务。再讲解之前，已经启动consul的agent，并且在浏览器上http://localhost:8500能够显示正确的页面。本案例一共有2个工程，分别如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>工程名</th>\n<th>端口</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>consul-provider</td>\n<td>8763</td>\n<td>服务提供者</td>\n</tr>\n<tr>\n<td>consul-consumer</td>\n<td>8765</td>\n<td>服务消费者</td>\n</tr>\n</tbody>\n</table><p>其中，服务提供者和服务消费者分别向consul注册，注册完成后，服务消费者通过FeignClient来消费服务提供者的服务。</p>\n<h3><a id="consulprovider_137"></a>服务提供者consul-provider</h3>\n<p>创建一个工程consul-provider，在工程的pom文件引入以下依赖，包括consul-discovery的起步依赖，该依赖是spring cloud consul用来向consul 注册和发现服务的依赖，采用REST API的方式进行通讯。另外加上web的起步依赖，用于对外提供REST API。代码如下：</p>\n<pre><code class="prism language-xml"> \n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n \n</code></pre>\n<p>在工程的配置文件application.yml做下以下配置：</p>\n<pre><code class="prism language-text">server:\n  port: 8763\nspring:\n  application:\n    name: consul-provider\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        serviceName: consul-provider\n</code></pre>\n<p>上面的配置，指定了程序的启动端口为8763，应用名为consul-provider，consul注册中心的地址为localhost:8500</p>\n<p>在程序员的启动类ConsulProviderApplication加上@EnableDiscoveryClient注解，开启服务发现的功能。</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableDiscoveryClient</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsulProviderApplication</span> <span class="token punctuation">{</span>\n\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\tSpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ConsulProviderApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n</code></pre>\n<p>写一个RESTAPI，该API为一个GET请求，返回当前程序的启动端口，代码如下。</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HiController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>\n    String port<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">home</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"hi "</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",i am from port:"</span> <span class="token operator">+</span>port<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>启动工程，在浏览器上访问http://localhost:8500，页面显示如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601003321491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>从上图可知，consul-provider服务已经成功注册到consul上面去了。</p>\n<h3><a id="consulprovider_212"></a>服务消费者consul-provider</h3>\n<p>服务消费者的搭建过程同服务提供者，在pom文件中引入的依赖同服务提供者，在配置文件application.yml配置同服务提供者，不同的点在端口为8765，服务名为consul-consumer。</p>\n<p>写一个FeignClient，该FeignClient调用consul-provider的REST API，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"consul-provider"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EurekaClientFeign</span> <span class="token punctuation">{</span>\n\n \n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    String <span class="token function">sayHiFromClientEureka</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n</code></pre>\n<p>Service层代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HiService</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    EurekaClientFeign eurekaClientFeign<span class="token punctuation">;</span>\n \n   \n    <span class="token keyword">public</span> String <span class="token function">sayHi</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span>  eurekaClientFeign<span class="token punctuation">.</span><span class="token function">sayHiFromClientEureka</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>对外提供一个REST API，该API调用了consul-provider的服务，代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HiController</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Autowired</span>\n    HiService hiService<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span> defaultValue <span class="token operator">=</span> <span class="token string">"forezp"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> hiService<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>在浏览器上访问http://localhost:8765/hi，浏览器响应如下：</p>\n<blockquote>\n<p>hi forezp,i am from port:8763</p>\n</blockquote>\n<p>这说明consul-consumer已经成功调用了consul-provider的服务。这说明consul-provider的服务已经注册到了consul的注册中心上面去了。consul-consumer能够获取注册中心的注册列表来获来消费服务。</p>\n<h2><a id="Spring_Cloud_Consul_Config_270"></a>使用Spring Cloud Consul Config来做服务配置中心</h2>\n<p>Consul不仅能用来服务注册和发现，Consul而且支持Key/Value键值对的存储，可以用来做配置中心。Spring Cloud 提供了Spring Cloud Consul Config依赖去和Consul相集成，用来做配置中心。<br>\n现在以案例的形式来讲解如何使用Consul作为配置中心，本案例在上一个案例的consul-provider基础上进行改造。首先在工程的pom文件加上consul-config的起步依赖，代码如下：</p>\n<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-consul-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>然后在配置文件application.yml加上以下的以下的配置，配置如下：</p>\n<pre><code class="prism language-text">spring:\n  profiles:\n    active: dev \n</code></pre>\n<p>上面的配置指定了SpringBoot启动时的读取的profiles为dev。<br>\n然后再工程的启动配置文件bootstrap.yml文件中配置以下的配置：</p>\n<pre><code class="prism language-text">spring:\n  application:\n    name: consul-provider\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        serviceName: consul-provider\n      config:\n        enabled: true\n        format: yaml           \n        prefix: config     \n        profile-separator: \':\'    \n        data-key: data           \n\n</code></pre>\n<p>关于spring.cloud.consul.config的配置项描述如下：</p>\n<ul>\n<li>enabled 设置config是否启用，默认为true</li>\n<li>format 设置配置的值的格式，可以yaml和properties</li>\n<li>prefix 设置配的基本目录，比如config</li>\n<li>defaultContext 设置默认的配置，被所有的应用读取，本例子没用的</li>\n<li>profileSeparator profiles配置分隔符,默认为‘,’</li>\n<li>date-key为应用配置的key名字，值为整个应用配置的字符串。</li>\n</ul>\n<p>网页上访问consul的KV存储的管理界面，即http://localhost:8500/ui/dc1/kv，创建一条记录，</p>\n<p>key值为：config/consul-provider:dev/data<br>\nvalue值如下:</p>\n<pre><code class="prism language-text">foo:\n  bar: bar1\nserver:\n  port: 8081\n\n</code></pre>\n<p><img src="https://img-blog.csdnimg.cn/2019060100335832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在consul-provider工程新建一个API，该API返回从consul 配置中心读取foo.bar的值，代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooBarController</span> <span class="token punctuation">{</span>\n    \n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${foo.bar}"</span><span class="token punctuation">)</span>\n    String fooBar<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/foo"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">getFooBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> fooBar<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>启动工程，可以看到程序的启动端口为8081，即是consul的配置中心配置的server.port端口。<br>\n工程启动完成后，在浏览器上访问http://localhost:8081/foo，页面显示bar1。由此可知，应用consul-provider已经成功从consul的配置中心读取了配置foo.bar的配置。</p>\n<h3><a id="_354"></a>动态刷新配置</h3>\n<p>当使用spring cloud config作为配置中心的时候，可以使用spring cloud config bus支持动态刷新配置。Spring Cloud Comsul Config默认就支持动态刷新，只需要在需要动态刷新的类上加上@RefreshScope注解即可，修改代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RefreshScope</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooBarController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${foo.bar}"</span><span class="token punctuation">)</span>\n    String fooBar<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/foo"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">getFooBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> fooBar<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>启动consul-provider工程，在浏览器上访问http://localhost:8081/foo，页面显示bar1。然后<br>\n在网页上访问consul的KV存储的管理界面，即http://localhost:8500/ui/dc1/kv，修改config/consul-provider:dev/data的值，修改后的值如下：</p>\n<pre><code class="prism language-text">foo:\n  bar: bar2\nserver: \n  port: 8081\n\n</code></pre>\n<p>此时不重新启动consul-provider，在浏览器上访问http://localhost:8081/foo，页面显示bar2。可见foo.bar的最新配置在应用不重启的情况下已经生效。</p>\n<h3><a id="_386"></a>注意事项</h3>\n<ul>\n<li>consul支持的KV存储的Value值不能超过512KB</li>\n<li>Consul的dev模式，所有数据都存储在内存中，重启Consul的时候会导致所有数据丢失，在正式的环境中，Consul的数据会持久化，数据不会丢失。</li>\n</ul>\n<h2><a id="_391"></a>参考资料</h2>\n<p>https://www.consul.io/intro/index.html</p>\n<p>https://www.consul.io/docs/internals/architecture.html</p>\n<p>https://www.consul.io/intro/vs/eureka.html</p>\n<p>http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html</p>\n<p>https://springcloud.cc/spring-cloud-consul.html</p>\n<p>https://www.cnblogs.com/lsf90/p/6021465.html</p>\n<p>https://blog.csdn.net/longgeqiaojie304/article/details/85227936</p>\n<h3><a id="_407"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:21'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/85210153', 'title': 'spring cloud gateway之服务注册与发现', 'readNum': '44363', 'commentNum': '14', 'publishTime': '2018-12-22 16:08:40', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/85210153<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/12/23/sc-f-gateway5.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/12/23/sc-f-gateway5.html</a></p>\n<p>在之前的文章介绍了Spring Cloud Gateway的Predict（断言）、Filter（过滤器），大家对Spring Cloud Gateway有初步的认识，其中在对服务路由转发的这一块，在之前的文章是采用硬编码的方式进行路由转发。这篇文章以案例的形式来讲解Spring Cloud Gateway如何配合服务注册中心进行路由转发。</p>\n<h2><a id="_10"></a>工程介绍</h2>\n<p>本案例中使用spring boot的版本为2.0.3.RELEASE,spring cloud版本为Finchley.RELEASE。在中涉及到了三个工程， 分别为注册中心eureka-server、服务提供者service-hi、 服务网关service-gateway，如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>工程名</th>\n<th>端口</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>eureka-server</td>\n<td>8761</td>\n<td>注册中心eureka server</td>\n</tr>\n<tr>\n<td>service-hi</td>\n<td>8762</td>\n<td>服务提供者 eurka client</td>\n</tr>\n<tr>\n<td>service-gateway</td>\n<td>8081</td>\n<td>路由网关 eureka client</td>\n</tr>\n</tbody>\n</table><p>这三个工程中，其中service-hi、service-gateway向注册中心eureka-server注册。用户的请求首先经过service-gateway，根据路径由gateway的predict 去断言进到哪一个 router， router经过各种过滤器处理后，最后路由到具体的业务服务，比如 service-hi。如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060101155398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>eureka-server、service-hi这两个工程直接复制于我的另外一篇文章https://blog.csdn.net/forezp/article/details/81040925 ，在这就不在重复，可以查看源码，源码地址见文末链接。 其中，service-hi服务对外暴露了一个RESTFUL接口“/hi”接口。现在重点讲解service-gateway。</p>\n<h2><a id="gateway_29"></a>gateway工程详细介绍</h2>\n<p>在gateway工程中引入项目所需的依赖，包括eureka-client的起步依赖和gateway的起步依赖，代码如下：</p>\n<pre><code class="prism language-text">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>在工程的配置文件application.yml中 ，指定程序的启动端口为8081，注册地址、gateway的配置等信息，配置信息如下：</p>\n<pre><code class="prism language-text">server:\n  port: 8081\n\nspring:\n  application:\n    name: sc-gateway-service\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true\n          lowerCaseServiceId: true\n          \neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n\n</code></pre>\n<p>其中，spring.cloud.gateway.discovery.locator.enabled为true，表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。spring.cloud.gateway.discovery.locator.lowerCaseServiceId是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。</p>\n<p>在浏览器上请求输入localhost:8081/service-hi/hi?name=1323，网页获取以下的响应：</p>\n<pre><code class="prism language-text">hi 1323 ,i am from port:8762\n\n</code></pre>\n<p>在上面的例子中，向gateway-service发送的请求时，url必须带上服务名service-hi这个前缀，才能转发到service-hi上，转发之前会将service-hi去掉。<br>\n那么我能不能自定义请求路径呢，毕竟根据服务名有时过于太长，或者历史的原因不能根据服务名去路由，需要由自定义路径并转发到具体的服务上。答案是肯定的是可以的，只需要修改工程的配置文件application.yml，具体配置如下：</p>\n<pre><code>spring:\n  application:\n    name: sc-gateway-server\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: false\n          lowerCaseServiceId: true\n      routes:\n      - id: service-hi\n        uri: lb://SERVICE-HI\n        predicates:\n          - Path=/demo/**\n        filters:\n          - StripPrefix=1\n         \n\n</code></pre>\n<p>在上面的配置中，配置了一个Path 的predict,将以/demo/**开头的请求都会转发到uri为lb://SERVICE-HI的地址上，lb://SERVICE-HI即service-hi服务的负载均衡地址，并用StripPrefix的filter 在转发之前将/demo去掉。同时将spring.cloud.gateway.discovery.locator.enabled改为false，如果不改的话，之前的localhost:8081/service-hi/hi?name=1323这样的请求地址也能正常访问，因为这时为每个服务创建了2个router。</p>\n<p>在浏览器上请求localhost:8081/demo/hi?name=1323，浏览器返回以下的响应：</p>\n<pre><code>hi 1323 ,i am from port:8762\n\n</code></pre>\n<p>返回的结果跟我们预想的一样。</p>\n<h2><a id="_114"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-gateway-cloud</p>\n<h2><a id="_118"></a>参考资料</h2>\n<p>https://juejin.im/post/5aa4eacbf265da237a4ca36f</p>\n<p>https://www.jianshu.com/p/1c942a8abe18</p>\n<p>https://juejin.im/post/5ba8daa56fb9a05cfe486ebf</p>\n<h3><a id="_126"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/79638403', 'title': '书籍《深入理解Spring Cloud 与微服务构建》勘误、源码下载', 'readNum': '44918', 'commentNum': '35', 'publishTime': '2018-03-21 12:50:45', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="https://blog.csdn.net/forezp/article/details/79638403">https://blog.csdn.net/forezp/article/details/79638403</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h4><a id="SpringCloud_Spring_Boothttpswwwfangzhipengcomshare20171001resourcesharinghtml_5"></a><a href="https://www.fangzhipeng.com/share/2017/10/01/resource-sharing.html" rel="nofollow">点击获取SpringCloud 、Spring Boot视频</a></h4>\n<h3><a id="_7"></a>文章勘误</h3>\n<p>错误在所难免，欢迎大家批评指正，在文章下方留言即可。有任何问题加我微信miles02，由于可能问的人较多，建议把问题描述清楚，我有空回答，多谢大家的支持。<br>\n<em><strong>读者QQ交流群：719761942</strong></em></p>\n\n<table>\n<thead>\n<tr>\n<th>页数</th>\n<th>修改前</th>\n<th>修改后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>p32最后一行</td>\n<td>@GetMappin</td>\n<td>修改为： @GetMapping</td>\n</tr>\n<tr>\n<td>p49 20行</td>\n<td>开启RestControllerde</td>\n<td>修改为： 开启RestController</td>\n</tr>\n<tr>\n<td>p51 6行</td>\n<td>port: 9001</td>\n<td>修改为：prot: 9091</td>\n</tr>\n<tr>\n<td>p52 8行</td>\n<td>heath</td>\n<td>修改为: health</td>\n</tr>\n<tr>\n<td>p55 10行</td>\n<td>关闭应该程序</td>\n<td>修改为： 关闭应用程序</td>\n</tr>\n<tr>\n<td>p58 28行</td>\n<td>第一次简表</td>\n<td>修改为： 第一次建表</td>\n</tr>\n<tr>\n<td>p63 14行</td>\n<td>restfun风格</td>\n<td>修改为： restful风格</td>\n</tr>\n<tr>\n<td>p74 11行</td>\n<td>Eureka Serve</td>\n<td>修改为：Eureka Server</td>\n</tr>\n<tr>\n<td>p110 18行</td>\n<td>OKhHttp</td>\n<td>修改为： OkHttp</td>\n</tr>\n<tr>\n<td>p116 12行</td>\n<td>问服务系统</td>\n<td>修改为： 微服务系统</td>\n</tr>\n<tr>\n<td>p125 11行</td>\n<td>clusterConfig</td>\n<td>修改为： appConfig</td>\n</tr>\n<tr>\n<td>p138 31行</td>\n<td>用作eureka-client工程的dev</td>\n<td>修改为：用作config-client工程的dev</td>\n</tr>\n<tr>\n<td>p140 15行</td>\n<td>eureka-server工程</td>\n<td>修改为：config-server工程</td>\n</tr>\n<tr>\n<td>p145 1行</td>\n<td>消息代理组建</td>\n<td>修改为： 消息代理组件</td>\n</tr>\n<tr>\n<td>p155 倒数第5行</td>\n<td>消息代组件RabbitMQ</td>\n<td>修改为： 消息代理组件RabbitMQ</td>\n</tr>\n<tr>\n<td>p161 倒数第五行</td>\n<td>ureka Client</td>\n<td>修改为： Eureka Client</td>\n</tr>\n<tr>\n<td>p196 8行</td>\n<td>Oauth2</td>\n<td>修改为：OAuth2</td>\n</tr>\n<tr>\n<td>p225 14行</td>\n<td>请读者查看 11.3.4节</td>\n<td>修改后：请读者查看13.3.5节</td>\n</tr>\n<tr>\n<td>p119 9行和12行</td>\n<td>访问htpp://localhost:8765/hi</td>\n<td>修改为：访问htpp://localhost:8764/hi</td>\n</tr>\n</tbody>\n</table><p>影响理解的错误为： p51 6行 、p125 11行、p138 31行、p140 15行、p225 14行、p119 9行和12行 。读各位读者造成的困扰表示道歉，望读者多多海涵。</p>\n<p>p39最后2段落修改前为：</p>\n<blockquote>\n<p>eureka-server工程启动成功后，启动eureka-client工程，你会在控制台发现eureka-client会向http://localhost:8769读取配置文件，最终程序启动的端口为8762，这个端口是在eureka-server的Resouces/shared目录下的eureka-client-dev.yml文件下的配置，可见eureka-client成功地向eureka-server读取了配置文件。<br>\n为了进一步验证，在eureka-clien工程写一个API接口，读取配置文件的foo变量，并通过API接口返回，代码如下：</p>\n</blockquote>\n<p>修改后为(修改的部分黑体加粗了)：</p>\n<blockquote>\n<p>eureka-server工程启动成功后，启动eureka-client工程，你会在控制台发现eureka-client会向http://localhost:8769读取配置文件，最终程序启动的端口为8762，这个端口是在<strong>config-server</strong>的Resouces/shared目录下的eureka-client-dev.yml文件下的配置，可见eureka-client成功地向<strong>config-server</strong>读取了配置文件。<br>\n为了进一步验证，在<strong>eureka-client</strong>工程写一个API接口，读取配置文件的foo变量，并通过API接口返回，代码如下：<br>\n|</p>\n</blockquote>\n<p>p82第二段代码修改为：</p>\n<pre><code>java –jar eureka-server-0.0.1-SNAPSHOT.jar            - -spring.profiles.active=peer1\njava –jar eureka-server-0.0.1-SNAPSHOT.jar\n- - spring.profiles.active=peer2\n\n</code></pre>\n<p>p172代码片段修改为：</p>\n<pre><code>security:\n  user:\n    name: admin\n    password: 123456\n\neureka:\n  instance:\n    metadata-map:\n      user.name: admin\n      user.password: 123456\n\n\n</code></pre>\n<p>p187页为了理解更容易最后一段修改为：</p>\n<p>应用程序启动成功之后，在浏览器上访问http://localhost:8080/blogs，由于该页面受Spring Security保护，需要登录。使用用户名为admin，密码为123456登录，该用户名对应的用户具有“ADMIN”的角色权限。登录成功之后，页面显示“/blogs/list”的界面，该界面如图13-5所示。</p>\n<h3><a id="_82"></a>源码下载</h3>\n<p>github下载：<a href="https://github.com/forezp/springcloud-book">https://github.com/forezp/springcloud-book</a></p>\n<p>码云下载： <a href="https://gitee.com/forezp/springcloud-book" rel="nofollow">https://gitee.com/forezp/springcloud-book</a></p>\n<h3><a id="_88"></a>书籍购买地址</h3>\n<p><img src="https://upload-images.jianshu.io/upload_images/2279594-3d9ee1555f555040.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="1.jpg"></p>\n<p><a href="https://item.jd.com/12312724.html" rel="nofollow">点击购买书籍-京东</a></p>\n<p><a href="http://product.dangdang.com/25231114.html" rel="nofollow">点击购买书籍-当当</a></p>\n<p><a href="https://www.amazon.cn/dp/B079J8SCGY/ref=sr_1_2?ie=UTF8&amp;qid=1521344315&amp;sr=8-2&amp;keywords=spring+cloud" rel="nofollow">点击购买书籍-亚马逊</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616856', 'title': 'Openresty最佳案例 | 汇总', 'readNum': '44844', 'commentNum': '1', 'publishTime': '2017-11-23 17:07:20', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/78616856">http://blog.csdn.net/forezp/article/details/78616856</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h4><a id="SpringCloud_Spring_Boothttpswwwfangzhipengcomshare20171001resourcesharinghtml_5"></a><a href="https://www.fangzhipeng.com/share/2017/10/01/resource-sharing.html" rel="nofollow">点击获取SpringCloud 、Spring Boot视频</a></h4>\n<h2><a id="_6"></a>目录</h2>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616591">Openresty最佳案例 | 第1篇：Nginx介绍</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616622">Openresty最佳案例 | 第2篇：Lua入门</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616645">Openresty最佳案例 | 第3篇：Openresty安装</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616660">Openresty最佳案例 | 第4篇：OpenResty常见的api</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616672">Openresty最佳案例 | 第5篇：http和c_json模块</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616698">Openresty最佳案例 | 第6篇：OpenResty连接Mysql</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616714">Openresty最佳案例 | 第7篇：模块开发、OpenResty连接Redis</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616738">Openresty最佳案例 | 第8篇：RBAC介绍、sql和redis模块工具类</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78616779">Openresty最佳案例 | 第9篇：Openresty实现的网关权限控制</a></li>\n</ul>\n<h2><a id="_18"></a>为什么有这系列文章</h2>\n<p>权限控制在任何的系统中都为一个基本模块，没有权限，就不要谈系统。权限控制的重要性不言而喻。在我所做的Spring Cloud微服务系统，采用的权限控制框架为Spring Cloud Oauth2和Spring Boot Securtiy，这两个框架组合构成了一个强大的权限安全模块。搭建好，设置好，其实是非常简单的。Spring Boot Securtiy是对方法层面的控制，所以要在方法上加注解。随着业务的扩张，注解这种方式无疑给开发人员带来了非常大的工作量，由于开发人员的不规范，甚至连注解都不愿意写了。我在思考能不能废弃掉Spring Cloud Oauth2和Spring Boot Securtiy，废弃掉注解，让开发人员从注解中解放出来。</p>\n<p>带着这样的思考，我首先想到的是kong api gateway，kong提供了非常多的插件化的模块，能够满足大部分的业务需求，但不能满足RBAC（基于角色的权限控制）。后来就想自己去实现。实现的过程就是不断学习和探索的过程，我从0基础的lua和openresty，花了三天的时间就实现了本系列文章所写的全部功能。另外花了两个周末把这系列文章整理出来。</p>\n<p>之所以说是整理文章，因为很多东西并非我原创，甚至直接拿了很多资料、博客的代码，直接复制粘贴。那我为什么要粘贴，为什么不自己写？一是个人时间精力有限，二是已经有了轮子，为什么要自己造一个？三是，为了保证系列文章的完整性。感谢openresty的作者章亦春、openresty 最佳实践的作者<a href="https://github.com/moonbingbing">WenMing</a>、<a href="http://jinnianshilongnian.iteye.com/" rel="nofollow">张开涛</a>等众多开源者和知名博主。</p>\n<h2><a id="_27"></a>参考资料</h2>\n<p>所以在此说明下，我参考了甚至copy了以下的博客或者资料：</p>\n<p>openresty官方网站：<a href="http://openresty.org/en/" rel="nofollow">http://openresty.org/en/</a></p>\n<p>openresty 最佳实践： <a href="http://wiki.jikexueyuan.com/project/openresty/" rel="nofollow">http://wiki.jikexueyuan.com/project/openresty/</a></p>\n<p>跟我学Nginx+Lua开发：<a href="http://www.iteye.com/blogs/subjects/nginx-lua">http://www.iteye.com/blogs/subjects/nginx-lua</a></p>\n<p>lua入门教程：<a href="http://www.runoob.com/lua/lua-tutorial.html" rel="nofollow">http://www.runoob.com/lua/lua-tutorial.html</a></p>\n<h2><a id="_39"></a>系列文章的源码下载</h2>\n<p>本系列的文章源码下载地址：<br>\n<a href="https://github.com/forezp/openresty-best-samples">https://github.com/forezp/openresty-best-samples</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70341818', 'title': 'SpringBoot非官方教程 | 终章：文章汇总', 'readNum': '148631', 'commentNum': '15', 'publishTime': '2017-04-22 00:08:27', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/70341818<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/springboot/2017/06/06/springboot-all.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/06/06/springboot-all.html</a></strong></p>\n<h1><a id="SpringBoot___6"></a>SpringBoot非官方教程 | 终章：文章汇总</h1>\n<p>springboot非官方教程，可能最接近于官方的一个教程，大多数案例都来自于官方文档，为了更好的理解，加入了个人的改造。</p>\n<p>码云下载：<a href="https://git.oschina.net/forezp/SpringBootLearning" rel="nofollow">https://git.oschina.net/forezp/SpringBootLearning</a></p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a>,谢谢支持，记得star哦。</p>\n<p>欢迎访问我的个人博客：https://www.fangzhipeng.com/springboot/2017/07/11/springboot-all/</p>\n<h2><a id="_19"></a>入门篇</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/70341651">SpringBoot非官方教程 | 第一篇：构建第一个SpringBoot工程</a></p>\n<h2><a id="_22"></a>配置篇</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/70437576"> SpringBoot非官方教程 | 第二篇：Spring Boot配置文件详解</a></p>\n<h2><a id="_26"></a>数据库篇</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/70477821">SpringBoot非官方教程 | 第三篇：SpringBoot用JdbcTemplates访问Mysql</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/70545038">SpringBoot非官方教程 |  第四篇：SpringBoot 整合JPA</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/70662983">SpringBoot非官方教程 | 第五篇：springboot整合 beatlsql</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/70768477">SpringBoot非官方教程 | 第六篇：springboot整合mybatis</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/70833629">SpringBoot非官方教程 | 第七篇：springboot开启声明式事务</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/70941577">SpringBoot非官方教程 | 第八篇：springboot整合mongodb</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/70991675"> SpringBoot非官方教程 | 第九篇： springboot整合Redis</a></p>\n<h2><a id="_42"></a>构架文档篇</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023510">SpringBoot非官方教程 | 第十篇： 用spring Restdocs创建API文档</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023536"> SpringBoot非官方教程 | 第十一篇：springboot集成swagger2，构建优雅的Restful API</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023579">SpringBoot非官方教程 | 第十二篇：springboot集成apidoc</a></p>\n<h2><a id="_50"></a>缓存篇</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023614">SpringBoot非官方教程 | 第十三篇：springboot集成spring cache</a></p>\n<h2><a id="_53"></a>消息队列</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023652">SpringBoot非官方教程 | 第十四篇：在springboot中用redis实现消息队列</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023692"> SpringBoot非官方教程 | 第十五篇：Springboot整合RabbitMQ</a></p>\n<h2><a id="_59"></a>网络相关</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023724">SpringBoot非官方教程 | 第十六篇：用restTemplate消费服务</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023752">SpringBoot非官方教程 | 第十七篇：上传文件</a></p>\n<h2><a id="_65"></a>任务调度</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023783">SpringBoot非官方教程 | 第十八篇： 定时任务（Scheduling Tasks）</a></p>\n<h2><a id="_69"></a>表单相关</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023817">SpringBoot非官方教程 | 第十九篇： 验证表单信息</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71023868">SpringBoot非官方教程 | 第二十篇： 处理表单提交</a></p>\n<h2><a id="_74"></a>其他</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/71024024"> SpringBoot非官方教程 | 第二十一篇： springboot集成JMS</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71024153">SpringBoot非官方教程 | 第二十二篇： 创建含有多module的springboot工程</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71024169"> SpringBoot非官方教程 | 第二十三篇： 异步方法</a></p>\n<p><a href="http://blog.csdn.net/forezp/article/details/71024219"> SpringBoot非官方教程 | 第二十四篇： springboot整合docker</a></p>\n<h2><a id="_84"></a>案例</h2>\n<p><a href="http://blog.csdn.net/forezp/article/details/61472783"> SpringBoot非官方教程 | 第二十五篇： 2小时学会springboot</a></p>\n<h2><a id="_87"></a>未完结</h2>\n<ul>\n<li>待续。。。</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70148833', 'title': '史上最简单的 SpringCloud 教程 | 终章', 'readNum': '1659634', 'commentNum': '361', 'publishTime': '2017-04-12 23:14:39', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/70148833<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/spring-cloud.html" rel="nofollow">https://www.fangzhipeng.com/spring-cloud.html</a></strong></p>\n<p>错过了这一篇，你可能再也学不会 Spring Cloud 了！Spring Boot做为下一代 web 框架，Spring Cloud 作为最新最火的微服务的翘楚，你还有什么理由拒绝。赶快上船吧，老船长带你飞。终章不是最后一篇，它是一个汇总，未来还会写很多篇。</p>\n<p>我为什么这些文章？一是巩固自己的知识，二是希望有更加开放和与人分享的心态，三是接受各位大神的批评指教，有任何问题可以联系我: miles02@163.com .</p>\n<p>码农下载：<a href="https://git.oschina.net/forezp/SpringCloudLearning" rel="nofollow">https://git.oschina.net/forezp/SpringCloudLearning</a></p>\n<p>github下载：<a href="https://github.com/forezp/SpringCloudLearning">https://github.com/forezp/SpringCloudLearning</a>,记得star哦！</p>\n<p>欢迎大家访问我的个人博客：https://www.fangzhipeng.com/</p>\n<p><strong><a href="https://www.fangzhipeng.com/share/2017/10/01/resource-sharing.html" rel="nofollow">点击获取SpringCloud 、Spring Boot视频</a></strong></p>\n<h3><a id="_SpringCloud__31"></a>《史上最简单的 SpringCloud 教程》系列：</h3>\n<h3><a id="Spring_Cloud_Alibaba_33"></a>Spring Cloud Alibaba教程</h3>\n<ul>\n<li><a href="https://blog.csdn.net/forezp/article/details/90142744">Spring Cloud Alibaba教程：使用Nacos作为服务注册发现组件</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/90729945">Spring Cloud Alibaba教程：使用Nacos作为配置中心</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/93140393">Spring Cloud Alibaba教程：Sentinel的使用<br>\n</a></li>\n</ul>\n<h3><a id="Greenwich_38"></a>Greenwich版本</h3>\n<ul>\n<li><a href="https://blog.csdn.net/forezp/article/details/87273153">Spring Cloud Consul 之Greenwich版本全攻略</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/87866560">spring cloud config将配置存储在数据库中</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/87075651">Spring Cloud Sleuth 之Greenwich版本全攻略</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/86105850">Spring Boot Admin 2.1.0 全攻略</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/86634907">阿里分布式事务框架GTS开源了！</a></li>\n</ul>\n<h3><a id="Finchley_46"></a>Finchley版本</h3>\n<p>Spring Cloud Finchley; Spring Boot 2.0.3</p>\n<ul>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81040925">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81040946">史上最简单的SpringCloud教程 | 第二篇: 服务消费者（rest+ribbon）(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81040965">史上最简单的SpringCloud教程 | 第三篇: 服务消费者（Feign）(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81040990">史上最简单的SpringCloud教程 | 第四篇:断路器（Hystrix）(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041012"> 史上最简单的SpringCloud教程 | 第五篇: 路由网关(zuul)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041028">史上最简单的SpringCloud教程 | 第六篇: 分布式配置中心(Spring Cloud Config)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041045">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041062">史上最简单的SpringCloud教程 | 第八篇: 消息总线(Spring Cloud Bus)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041078">史上最简单的SpringCloud教程 | 第九篇: 服务链路追踪(Spring Cloud Sleuth)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041101">史上最简单的SpringCloud教程 | 第十篇: 高可用的服务注册中心(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041113">史上最简单的SpringCloud教程 | 第十二篇: 断路器监控(Hystrix Dashboard)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="http://blog.csdn.net/forezp/article/details/81041125">史上最简单的SpringCloud教程 | 第十三篇: 断路器聚合监控(Hystrix Turbine)(Finchley版本)</a></p>\n</li>\n<li>\n<p><a href="https://blog.csdn.net/forezp/article/details/83792388">史上最简单的SpringCloud教程 | 第十四篇: Spring Cloud Gateway初体验</a></p>\n</li>\n<li>\n<p><a href="https://blog.csdn.net/forezp/article/details/84926662">史上最简单的SpringCloud教程 | 第十五篇: Spring Cloud Gateway 之Predict篇</a></p>\n</li>\n<li>\n<p><a href="https://blog.csdn.net/forezp/article/details/85057268">史上最简单的SpringCloud教程 | 第十六篇: Spring Cloud Gateway 之filter篇</a></p>\n</li>\n<li>\n<p><a href="https://blog.csdn.net/forezp/article/details/85081162">史上最简单的SpringCloud教程 | 第十七篇: Spring Cloud Gateway 之限流篇</a></p>\n</li>\n<li>\n<p><a href="https://blog.csdn.net/forezp/article/details/85210153">史上最简单的SpringCloud教程 | 第十八篇: spring cloud gateway之服务注册与发现</a></p>\n</li>\n</ul>\n<h3><a id="_68"></a>源码篇：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/73480304">深入理解Feign之源码解析</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/73017664">深入理解Eureka之源码解析</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/74820899">深入理解Ribbon之源码解析</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/75333088"> 深入理解Hystrix之文档翻译</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/76211680">深入理解Zuul之源码解析</a></li>\n</ul>\n<h3><a id="_76"></a>进阶篇</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/76795269"> Spring Cloud Sleuth超详细实战</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/83999882">拜托！面试请不要再问我Spring Cloud底层原理</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/83999947">微服务注册中心如何承载大型系统的千万级访问？</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/83999975">每秒上万并发下的Spring Cloud参数优化实战</a></li>\n</ul>\n<h4><a id="D_84"></a>D版本</h4>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69788938">史上最简单的SpringCloud教程 | 第二篇: 服务消费者（rest+ribbon）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69808079">史上最简单的SpringCloud教程 | 第三篇: 服务消费者（Feign）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69934399">史上最简单的SpringCloud教程 | 第四篇:断路器（Hystrix）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69939114"> 史上最简单的SpringCloud教程 | 第五篇: 路由网关(zuul)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037291">史上最简单的SpringCloud教程 | 第六篇: 分布式配置中心(Spring Cloud Config)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148235">史上最简单的SpringCloud教程 | 第八篇: 消息总线(Spring Cloud Bus)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70162074">史上最简单的SpringCloud教程 | 第九篇: 服务链路追踪(Spring Cloud Sleuth)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70183572">史上最简单的SpringCloud教程 | 第十篇: 高可用的服务注册中心</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70198649">史上最简单的SpringCloud教程 | 第十一篇:docker部署spring cloud项目</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70217283">史上最简单的SpringCloud教程 | 第十二篇: 断路器监控(Hystrix Dashboard)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70233227">史上最简单的SpringCloud教程 | 第十三篇: 断路器聚合监控(Hystrix Turbine)</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70245644"> 史上最简单的 SpringCloud 教程 | 第十四篇: 服务注册(consul)</a></li>\n<li>未完。。。</li>\n<li>还有很多篇。。。</li>\n</ul>\n<h3><a id="_103"></a>番外篇：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/69056017">如何使用MongoDB+Springboot实现分布式ID?</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/68957681"> 如何在springcloud分布式系统中实现分布式锁？</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70305336"> 如何用Redlock实现分布式锁</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/76408139"> 如何在IDEA启动多个Spring Boot工程实例</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/78676036"> JWT如何在Spring Cloud微服务系统中在服务相互调时传</a></li>\n</ul>\n<h3><a id="_114"></a>怎么支持我？</h3>\n<ul>\n<li>\n<p>这个系列会持续更新，敬请关注！</p>\n</li>\n<li>\n<p>关注我的公众号,精彩内容不能错过！</p>\n</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/102499026', 'title': 'Nepxion Discovery【探索】微服务企业级解决方案', 'readNum': '846', 'commentNum': '6', 'publishTime': '2019-10-11 12:41:22', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h1><a id="Nepxion_Discovery_1"></a>Nepxion Discovery【探索】微服务企业级解决方案</h1>\n<p>Nepxion Discovery【探索】使用指南，基于Spring Cloud Greenwich版、Finchley版和Hoxton版而制作，对于Edgware版，使用者需要自行修改。使用指南主要涉及的功能包括：</p>\n<ul>\n<li>基于Header传递的全链路灰度路由，网关为路由触发点。采用配置中心配置路由规则映射在网关过滤器中植入Header信息而实现，路由规则传递到全链路服务中。路由方式主要包括版本和区域的匹配路由、版本和区域的权重路由、基于机器IP地址和端口的路由</li>\n<li>基于规则订阅的全链路灰度发布。采用配置中心配置灰度规则映射在全链路服务而实现，所有服务都订阅某个共享配置。发布方式主要包括版本和区域的匹配发布、版本和区域的权重发布</li>\n<li>全链路服务隔离。包括注册隔离、消费端隔离和提供端服务隔离，示例仅提供基于Group隔离。除此之外，不在本文介绍内的，还包括：\n<ul>\n<li>注册隔离：黑/白名单的IP地址的注册隔离、最大注册数限制的注册隔离</li>\n<li>消费端隔离：黑/白名单的IP地址的消费端隔离</li>\n</ul>\n</li>\n<li>全链路服务限流熔断降级权限，集成阿里巴巴Sentinel，有机整合灰度路由，扩展LimitApp的机制，通过动态的Http Header方式实现组合式防护机制，包括基于服务名、基于灰度组、基于灰度版本、基于灰度区域、基于机器地址和端口等防护机制，支持自定义任意的业务参数组合实现该功能。支持原生的流控规则、降级规则、授权规则、系统规则、热点参数流控规则</li>\n<li>全链路灰度调用链。包括Header方式和日志方式，Header方式框架内部集成，日志方式通过MDC输出（需使用者自行集成）</li>\n<li>同城双活多机房切换支持。它包含在“基于Header传递的全链路灰度路由”里</li>\n<li>数据库灰度发布。内置简单的数据库灰度发布策略，它不在本文的介绍范围内</li>\n<li>灰度路由和发布的自动化测试</li>\n<li>Docker容器化和Kubernetes平台的无缝支持部署</li>\n</ul>\n<p>[<strong>Nacos</strong>] 阿里巴巴中间件部门开发的新一代集服务注册发现中心和配置中心为一体的中间件。它是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施，支持几乎所有主流类型的“服务”的发现、配置和管理，更敏捷和容易地构建、交付和管理微服务平台</p>\n<p>[<strong>Sentinel</strong>] 阿里巴巴中间件部门开发的新一代以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性的分布式系统的流量防卫兵。它承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等</p>\n<p>[<strong>Spring Cloud Alibaba</strong>] 阿里巴巴中间件部门开发的Spring Cloud增强套件，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过Spring Cloud编程模型轻松使用这些组件来开发分布式应用服务。依托Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将Spring Cloud应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统</p>\n<p>示例以Nacos为服务注册中心和配置中心（使用者可自行换成其它服务注册中心和配置中心），集成Spring Cloud Alibaba，通过Gateway和Zuul调用两个版本或者区域的服务，模拟网关灰度路由和服务灰度权重的功能</p>\n<p>如果使用者需要更强大的功能，请参考<a href="https://github.com/Nepxion/Discovery">源码主页</a>。规则策略很多，请使用者选择最适合自己业务场景的方式</p>\n<h2><a id="_26"></a>目录</h2>\n<ul>\n<li><a href="#%E8%AF%B7%E8%81%94%E7%B3%BB%E6%88%91" rel="nofollow">请联系我</a></li>\n<li><a href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5" rel="nofollow">相关链接</a>\n<ul>\n<li><a href="#%E6%BA%90%E7%A0%81%E4%B8%BB%E9%A1%B5" rel="nofollow">源码主页</a></li>\n<li><a href="#%E6%8C%87%E5%8D%97%E4%B8%BB%E9%A1%B5" rel="nofollow">指南主页</a></li>\n<li><a href="#%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A1%B5" rel="nofollow">文档主页</a></li>\n</ul>\n</li>\n<li><a href="#%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%A4%BA" rel="nofollow">相关图示</a>\n<ul>\n<li><a href="#%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91%E5%9B%BE" rel="nofollow">部署架构拓扑图</a></li>\n<li><a href="#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">服务治理架构图</a></li>\n<li><a href="#%E7%81%B0%E5%BA%A6%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB%E5%9B%BE" rel="nofollow">灰度方式区别图</a></li>\n</ul>\n</li>\n<li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" rel="nofollow">环境搭建</a></li>\n<li><a href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow">启动服务</a></li>\n<li><a href="#%E7%8E%AF%E5%A2%83%E9%AA%8C%E8%AF%81" rel="nofollow">环境验证</a></li>\n<li><a href="#%E5%9F%BA%E4%BA%8EHeader%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BD%91%E5%85%B3%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">基于Header传递方式的网关灰度路由策略</a>\n<ul>\n<li><a href="#%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">灰度路由架构图</a>\n<ul>\n<li><a href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">多版本灰度路由架构图</a></li>\n<li><a href="#%E5%A4%9A%E5%8C%BA%E5%9F%9F%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">多区域灰度路由架构图</a></li>\n<li><a href="#%E5%A4%9AIP%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">多IP和端口灰度路由架构图</a></li>\n</ul>\n</li>\n<li><a href="#%E9%85%8D%E7%BD%AE%E7%BD%91%E5%85%B3%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">配置网关灰度路由策略</a>\n<ul>\n<li><a href="#%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">版本匹配灰度路由策略</a></li>\n<li><a href="#%E7%89%88%E6%9C%AC%E6%9D%83%E9%87%8D%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">版本权重灰度路由策略</a></li>\n<li><a href="#%E5%8C%BA%E5%9F%9F%E5%8C%B9%E9%85%8D%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">区域匹配灰度路由策略</a></li>\n<li><a href="#%E5%8C%BA%E5%9F%9F%E6%9D%83%E9%87%8D%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">区域权重灰度路由策略</a></li>\n</ul>\n</li>\n<li><a href="#%E9%80%9A%E8%BF%87%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%85%B3%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">通过其它方式设置网关灰度路由策略</a>\n<ul>\n<li><a href="#%E9%80%9A%E8%BF%87%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%85%A5%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">通过前端传入灰度路由策略</a></li>\n<li><a href="#%E9%80%9A%E8%BF%87%E4%B8%9A%E5%8A%A1%E5%8F%82%E6%95%B0%E5%9C%A8%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">通过业务参数在网关过滤器中自定义灰度路由策略</a></li>\n<li><a href="#%E9%80%9A%E8%BF%87%E4%B8%9A%E5%8A%A1%E5%8F%82%E6%95%B0%E5%9C%A8%E7%AD%96%E7%95%A5%E7%B1%BB%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5" rel="nofollow">通过业务参数在策略类中自定义灰度路由策略</a></li>\n</ul>\n</li>\n<li><a href="#%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E7%81%B0%E5%BA%A6&amp;%E7%BD%91%E5%85%B3%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E7%BB%84%E5%90%88%E5%BC%8F%E7%AD%96%E7%95%A5" rel="nofollow">配置前端灰度&amp;网关灰度路由组合式策略</a></li>\n</ul>\n</li>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E8%AE%A2%E9%98%85%E6%96%B9%E5%BC%8F%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E8%A7%84%E5%88%99" rel="nofollow">基于订阅方式的全链路灰度发布规则</a>\n<ul>\n<li><a href="#%E9%85%8D%E7%BD%AE%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99" rel="nofollow">配置全链路灰度匹配规则</a>\n<ul>\n<li><a href="#%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E7%81%B0%E5%BA%A6%E8%A7%84%E5%88%99" rel="nofollow">版本匹配灰度规则</a></li>\n<li><a href="#%E5%8C%BA%E5%9F%9F%E5%8C%B9%E9%85%8D%E7%81%B0%E5%BA%A6%E8%A7%84%E5%88%99" rel="nofollow">区域匹配灰度规则</a></li>\n</ul>\n</li>\n<li><a href="#%E9%85%8D%E7%BD%AE%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E6%9D%83%E9%87%8D%E8%A7%84%E5%88%99" rel="nofollow">配置全链路灰度权重规则</a>\n<ul>\n<li><a href="#%E5%85%A8%E5%B1%80%E7%89%88%E6%9C%AC%E6%9D%83%E9%87%8D%E7%81%B0%E5%BA%A6%E8%A7%84%E5%88%99" rel="nofollow">全局版本权重灰度规则</a></li>\n<li><a href="#%E5%B1%80%E9%83%A8%E7%89%88%E6%9C%AC%E6%9D%83%E9%87%8D%E7%81%B0%E5%BA%A6%E8%A7%84%E5%88%99" rel="nofollow">局部版本权重灰度规则</a></li>\n<li><a href="#%E5%85%A8%E5%B1%80%E5%8C%BA%E5%9F%9F%E6%9D%83%E9%87%8D%E7%81%B0%E5%BA%A6%E8%A7%84%E5%88%99" rel="nofollow">全局区域权重灰度规则</a></li>\n<li><a href="#%E5%B1%80%E9%83%A8%E5%8C%BA%E5%9F%9F%E6%9D%83%E9%87%8D%E7%81%B0%E5%BA%A6%E8%A7%84%E5%88%99" rel="nofollow">局部区域权重灰度规则</a></li>\n</ul>\n</li>\n<li><a href="#%E9%85%8D%E7%BD%AE%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E6%9D%83%E9%87%8D&amp;%E7%81%B0%E5%BA%A6%E7%89%88%E6%9C%AC%E7%BB%84%E5%90%88%E5%BC%8F%E8%A7%84%E5%88%99" rel="nofollow">配置全链路灰度权重&amp;灰度版本组合式规则</a></li>\n</ul>\n</li>\n<li><a href="#%E5%85%A8%E9%93%BE%E8%B7%AF%E6%9C%8D%E5%8A%A1%E9%9A%94%E7%A6%BB" rel="nofollow">全链路服务隔离</a>\n<ul>\n<li><a href="#%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E9%9A%94%E7%A6%BB" rel="nofollow">注册服务隔离</a></li>\n<li><a href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E6%9C%8D%E5%8A%A1%E9%9A%94%E7%A6%BB" rel="nofollow">消费端服务隔离</a></li>\n<li><a href="#%E6%8F%90%E4%BE%9B%E7%AB%AF%E6%9C%8D%E5%8A%A1%E9%9A%94%E7%A6%BB" rel="nofollow">提供端服务隔离</a></li>\n</ul>\n</li>\n<li><a href="#%E5%9F%BA%E4%BA%8ESentinel%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E6%9D%83%E9%99%90%E5%92%8C%E7%81%B0%E5%BA%A6%E8%9E%8D%E5%90%88" rel="nofollow">基于Sentinel的全链路服务限流熔断降级权限和灰度融合</a>\n<ul>\n<li><a href="#%E5%8E%9F%E7%94%9FSentinel%E6%B3%A8%E8%A7%A3" rel="nofollow">原生Sentinel注解</a></li>\n<li><a href="#%E5%8E%9F%E7%94%9FSentinel%E8%A7%84%E5%88%99" rel="nofollow">原生Sentinel规则</a>\n<ul>\n<li><a href="#%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99" rel="nofollow">流控规则</a></li>\n<li><a href="#%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99" rel="nofollow">降级规则</a></li>\n<li><a href="#%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99" rel="nofollow">授权规则</a></li>\n<li><a href="#%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99" rel="nofollow">系统规则</a></li>\n<li><a href="#%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99" rel="nofollow">热点参数流控规则</a></li>\n</ul>\n</li>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E7%81%B0%E5%BA%A6%E8%B7%AF%E7%94%B1%E5%92%8CSentinel-LimitApp%E6%89%A9%E5%B1%95%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">基于灰度路由和Sentinel-LimitApp扩展的防护机制</a>\n<ul>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">基于服务名的防护机制</a></li>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E7%81%B0%E5%BA%A6%E7%BB%84%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">基于灰度组的防护机制</a></li>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E7%81%B0%E5%BA%A6%E7%89%88%E6%9C%AC%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">基于灰度版本的防护机制</a></li>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E7%81%B0%E5%BA%A6%E5%8C%BA%E5%9F%9F%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">基于灰度区域的防护机制</a></li>\n<li><a href="#%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">基于机器地址和端口的防护机制</a></li>\n<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%9A%E5%8A%A1%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8F%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6" rel="nofollow">自定义业务参数的组合式防护机制</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href="#%E5%9F%BA%E4%BA%8EHystrix%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E5%92%8C%E7%81%B0%E5%BA%A6%E8%9E%8D%E5%90%88" rel="nofollow">基于Hystrix的全链路服务限流熔断和灰度融合</a></li>\n<li><a href="#%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E8%B0%83%E7%94%A8%E9%93%BE" rel="nofollow">全链路灰度调用链</a>\n<ul>\n<li><a href="#Header%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F" rel="nofollow">Header输出方式</a></li>\n<li><a href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F" rel="nofollow">日志输出方式</a></li>\n</ul>\n</li>\n<li><a href="#%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E8%B0%83%E7%94%A8%E9%93%BE" rel="nofollow">全链路Header传递</a>\n<ul>\n<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89Feign-Header%E4%BC%A0%E9%80%92" rel="nofollow">自定义Feign-Header传递</a></li>\n<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89RestTemplate-Header%E4%BC%A0%E9%80%92" rel="nofollow">自定义RestTemplate-Header传递</a></li>\n</ul>\n</li>\n<li><a href="#Docker%E5%AE%B9%E5%99%A8%E5%8C%96%E5%92%8CKubernetes%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81" rel="nofollow">Docker容器化和Kubernetes平台支持</a></li>\n</ul>\n<h2><a id="_92"></a>请联系我</h2>\n<p>微信、公众号和文档</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mNRitzbx-1570768849987)(https://github.com/Nepxion/Docs/raw/master/zxing-doc/微信-1.jpg)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iYv4OIkZ-1570768849990)(https://github.com/Nepxion/Docs/raw/master/zxing-doc/公众号-1.jpg)]<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL3p4aW5nLWRvYy8lRTYlOTYlODclRTYlQTElQTMtMS5qcGc?x-oss-process=image/format,png" alt="Alt text"></p>\n<h2><a id="_97"></a>相关链接</h2>\n<h3><a id="_99"></a>源码主页</h3>\n<p><a href="https://github.com/Nepxion/Discovery">源码主页</a></p>\n<h3><a id="_102"></a>指南主页</h3>\n<p><a href="https://github.com/Nepxion/DiscoveryGuide">指南主页</a></p>\n<h3><a id="_105"></a>文档主页</h3>\n<p><a href="https://pan.baidu.com/s/1i57rXaNKPuhGRqZ2MONZOA" rel="nofollow">文档主页</a></p>\n<h2><a id="_108"></a>相关图示</h2>\n<h3><a id="_110"></a>部署架构拓扑图</h3>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZUSCbUdp-1570768849993)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/BasicTopology.jpg)]</p>\n<h3><a id="_113"></a>服务治理架构图</h3>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-siuGLujW-1570768850003)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/Govern.jpg)]</p>\n<h3><a id="_116"></a>灰度方式区别图</h3>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0ugbfsLD-1570768850005)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/Difference.jpg)]</p>\n<h2><a id="_119"></a>环境搭建</h2>\n<ul>\n<li>下载代码\n<ul>\n<li>Git clone https://github.com/Nepxion/DiscoveryGuide.git</li>\n</ul>\n</li>\n<li>代码导入IDE</li>\n<li>下载Nacos服务器\n<ul>\n<li>从<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a>获取nacos-server-x.x.x.zip，并解压</li>\n</ul>\n</li>\n<li>启动Nacos服务器\n<ul>\n<li>Windows环境下，运行bin目录下的startup.cmd</li>\n<li>Linux环境下，运行bin目录下的startup.sh</li>\n</ul>\n</li>\n</ul>\n<h2><a id="_129"></a>启动服务</h2>\n<ul>\n<li>在IDE中，启动四个应用服务和两个网关服务，如下：</li>\n</ul>\n\n<table>\n<thead>\n<tr>\n<th>类名</th>\n<th>微服务</th>\n<th>服务端口</th>\n<th>版本</th>\n<th>区域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DiscoveryGuideServiceA1.java</td>\n<td>A1</td>\n<td>3001</td>\n<td>1.0</td>\n<td>dev</td>\n</tr>\n<tr>\n<td>DiscoveryGuideServiceA2.java</td>\n<td>A2</td>\n<td>3002</td>\n<td>1.1</td>\n<td>qa</td>\n</tr>\n<tr>\n<td>DiscoveryGuideServiceB1.java</td>\n<td>B1</td>\n<td>4001</td>\n<td>1.0</td>\n<td>qa</td>\n</tr>\n<tr>\n<td>DiscoveryGuideServiceB2.java</td>\n<td>B2</td>\n<td>4002</td>\n<td>1.1</td>\n<td>dev</td>\n</tr>\n<tr>\n<td>DiscoveryGuideGateway.java</td>\n<td>Gateway</td>\n<td>5001</td>\n<td>1.0</td>\n<td>无</td>\n</tr>\n<tr>\n<td>DiscoveryGuideZuul.java</td>\n<td>Zuul</td>\n<td>5002</td>\n<td>1.0</td>\n<td>无</td>\n</tr>\n</tbody>\n</table><p>注：启动不分前后次序</p>\n<h2><a id="_143"></a>环境验证</h2>\n<ul>\n<li>\n<p>导入Postman的测试脚本，<a href="https://github.com/Nepxion/Discovery/raw/master/postman.json">脚本地址</a></p>\n</li>\n<li>\n<p>在Postman中执行目录结构下 ”Nepxion“ -&gt; ”Discovery指南网关接口“ -&gt; ”Gateway网关调用示例“，调用地址为<a href="http://localhost:5001/discovery-guide-service-a/invoke/gateway" rel="nofollow">http://localhost:5001/discovery-guide-service-a/invoke/gateway</a>，相关的Header值已经预设，供开发者修改。测试通过Spring Cloud Gateway网关的调用结果，结果为如下格式：</p>\n</li>\n</ul>\n<pre><code>gateway -&gt; discovery-guide-service-a[192.168.0.107:3001][V=1.0][R=dev][G=discovery-guide-group] \n-&gt; discovery-guide-service-b[192.168.0.107:4001][V=1.0][R=qa][G=discovery-guide-group]\n</code></pre>\n<ul>\n<li>在Postman中执行目录结构下 ”Nepxion“ -&gt; ”Discovery指南网关接口“ -&gt; ”Zuul网关调用示例“，调用地址为<a href="http://localhost:5002/discovery-guide-service-a/invoke/zuul" rel="nofollow">http://localhost:5002/discovery-guide-service-a/invoke/zuul</a>，相关的Header值已经预设，供开发者修改。测试通过Zuul网关的调用结果，结果为如下格式：</li>\n</ul>\n<pre><code>zuul -&gt; discovery-guide-service-a[192.168.0.107:3001][V=1.0][R=dev][G=discovery-guide-group] \n-&gt; discovery-guide-service-b[192.168.0.107:4001][V=1.0][R=qa][G=discovery-guide-group]\n</code></pre>\n<ul>\n<li>上述步骤在下面每次更改规则策略的时候执行，并验证结果和规则策略的期望值是否相同</li>\n</ul>\n<h2><a id="Header_160"></a>基于Header传递方式的网关灰度路由策略</h2>\n<h3><a id="_162"></a>灰度路由架构图</h3>\n<h4><a id="_164"></a>多版本灰度路由架构图</h4>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvUm91dGVWZXJzaW9uLmpwZw?x-oss-process=image/format,png" alt="Alt text"></p>\n<h4><a id="_168"></a>多区域灰度路由架构图</h4>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eIg1Z6Ve-1570768850007)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/RouteRegion.jpg)]</p>\n<h4><a id="IP_172"></a>多IP和端口灰度路由架构图</h4>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-soqjD6Yw-1570768850008)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/RouteAddress.jpg)]</p>\n<h3><a id="_176"></a>配置网关灰度路由策略</h3>\n<p>在Nacos配置中心，增加网关灰度路由策略</p>\n<h4><a id="_179"></a>版本匹配灰度路由策略</h4>\n<p>增加Spring Cloud Gateway的基于版本匹配路由的灰度策略，Group为discovery-guide-group，Data Id为discovery-guide-gateway，策略内容如下，实现从Spring Cloud Gateway发起的调用都走版本为1.0的服务：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Fk6uAan2-1570768850009)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide2-1.jpg)]</p>\n<p>每个服务调用的版本都可以自行指定，见下面第二条。当所有服务都选同一版本的时候，可以简化成下面第一条</p>\n<pre><code>1. &lt;version&gt;1.0&lt;/version&gt;\n2. &lt;version&gt;{"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.0"}&lt;/version&gt;\n</code></pre>\n<p>如果上述表达式还未满足需求，也可以采用通配符（具体详细用法，参考Spring AntPathMatcher）</p>\n<pre><code>* - 表示调用范围为所有服务的所有版本\n1.* - 表示调用范围为所有服务的1开头的所有版本\n</code></pre>\n<p>或者</p>\n<pre><code>"discovery-guide-service-b":"1.*;1.2.?"\n</code></pre>\n<p>表示discovery-guide-service-b服务的版本调用范围是1开头的所有版本，或者是1.2开头的所有版本（末尾必须是1个字符）</p>\n<h4><a id="_208"></a>版本权重灰度路由策略</h4>\n<p>增加Spring Cloud Gateway的基于版本权重路由的灰度策略，Group为discovery-guide-group，Data Id为discovery-guide-gateway，策略内容如下，实现从Spring Cloud Gateway发起的调用1.0版本流量调用为90%，1.1流量调用为10%：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version-weight</span><span class="token punctuation">&gt;</span></span>1.0=90;1.1=10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version-weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1IEREVj4-1570768850014)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide2-2.jpg)]</p>\n<p>每个服务调用的版本权重都可以自行指定，见下面第二条。当所有服务都选相同版本权重的时候，可以简化成下面第一条</p>\n<pre><code>1. &lt;version-weight&gt;1.0=90;1.1=10&lt;/version-weight&gt;\n2. &lt;version-weight&gt;{"discovery-guide-service-a":"1.0=90;1.1=10", "discovery-guide-service-b":"1.0=90;1.1=10"}&lt;/version-weight&gt;\n</code></pre>\n<h4><a id="_226"></a>区域匹配灰度路由策略</h4>\n<p>增加Zuul的基于区域匹配路由的灰度策略，Group为discovery-guide-group，Data Id为discovery-guide-zuul，策略内容如下，实现从Zuul发起的调用都走区域为dev的服务：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>region</span><span class="token punctuation">&gt;</span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>region</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LwCOwEOx-1570768850016)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide2-3.jpg)]</p>\n<p>每个服务调用的区域都可以自行指定，见下面第二条。当所有服务都选同一区域的时候，可以简化成下面第一条</p>\n<pre><code>1. &lt;region&gt;dev&lt;/region&gt;\n2. &lt;region&gt;{"discovery-guide-service-a":"dev", "discovery-guide-service-b":"dev"}&lt;/region&gt;\n</code></pre>\n<p>如果上述表达式还未满足需求，也可以采用通配符（具体详细用法，参考Spring AntPathMatcher）</p>\n<pre><code>* - 表示调用范围为所有服务的所有区域\nd* - 表示调用范围为所有服务的d开头的所有区域\n</code></pre>\n<p>或者</p>\n<pre><code>"discovery-guide-service-b":"d*;q?"\n</code></pre>\n<p>表示discovery-guide-service-b服务的区域调用范围是d开头的所有区域，或者是q开头的所有区域（末尾必须是1个字符）</p>\n<h4><a id="_255"></a>区域权重灰度路由策略</h4>\n<p>增加Zuul的基于区域权重路由的灰度策略，Group为discovery-guide-group，Data Id为discovery-guide-zuul，策略内容如下，实现从Zuul发起的调用dev区域流量调用为85%，qa区域流量调用为15%：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>region-weight</span><span class="token punctuation">&gt;</span></span>dev=85;qa=15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>region-weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GDxrY0Vf-1570768850019)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide2-4.jpg)]</p>\n<p>每个服务调用的区域权重都可以自行指定，见下面第二条。当所有服务都选相同区域权重的时候，可以简化成下面第一条</p>\n<pre><code>1. &lt;region-weight&gt;dev=85;qa=15&lt;/region-weight&gt;\n2. &lt;region-weight&gt;{"discovery-guide-service-a":"dev=85;qa=15", "discovery-guide-service-b":"dev=85;qa=15"}&lt;/region-weight&gt;\n</code></pre>\n<h3><a id="_273"></a>通过其它方式设置网关灰度路由策略</h3>\n<p>除了上面通过配置中心发布灰度规路由则外，还有如下三种方式:</p>\n<h4><a id="_276"></a>通过前端传入灰度路由策略</h4>\n<p>通过前端（Postman）方式传入灰度路由策略，来代替配置中心方式，传递全链路路由策略。注意：当配置中心和界面都配置后，以界面传入优先</p>\n<ul>\n<li>版本匹配策略，Header格式如下任选一个：</li>\n</ul>\n<pre><code>1. n-d-version=1.0\n2. n-d-version={"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.0"}\n</code></pre>\n<ul>\n<li>版本权重策略，Header格式如下任选一个：</li>\n</ul>\n<pre><code>1. n-d-version-weight=1.0=90;1.1=10\n2. n-d-version-weight={"discovery-guide-service-a":"1.0=90;1.1=10", "discovery-guide-service-b":"1.0=90;1.1=10"}\n</code></pre>\n<ul>\n<li>区域匹配策略，Header格式如下任选一个：</li>\n</ul>\n<pre><code>1. n-d-region=qa\n2. n-d-region={"discovery-guide-service-a":"qa", "discovery-guide-service-b":"qa"}\n</code></pre>\n<ul>\n<li>区域权重策略，Header格式如下任选一个：</li>\n</ul>\n<pre><code>1. n-d-region-weight=dev=99;qa=1\n2. n-d-region-weight={"discovery-guide-service-a":"dev=99;qa=1", "discovery-guide-service-b":"dev=99;qa=1"}\n</code></pre>\n<ul>\n<li>机器IP地址和端口策略：</li>\n</ul>\n<pre><code>n-d-address={"discovery-guide-service-a":"127.0.0.1:3001", "discovery-guide-service-b":"127.0.0.1:4002"}\n</code></pre>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGUyLTUuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGUyLTYuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<p>当外界传值Header的时候，网关也设置并传递同名的Header，需要决定哪个Header传递到后边的服务去。需要通过如下开关做控制：</p>\n<pre><code class="prism language-vb"># 当外界传值Header的时候，网关也设置并传递同名的Header，需要决定哪个Header传递到后边的服务去。如果下面开关为true，以网关设置为优先，否则以外界传值为优先。缺失则默认为true\nspring.application.strategy.gateway.header.priority=false\n# 当以网关设置为优先的时候，网关未配置Header，而外界配置了Header，仍旧忽略外界的Header。缺失则默认为true\nspring.application.strategy.gateway.original.header.ignored=true\n\n# 当外界传值Header的时候，网关也设置并传递同名的Header，需要决定哪个Header传递到后边的服务去。如果下面开关为true，以网关设置为优先，否则以外界传值为优先。缺失则默认为true\nspring.application.strategy.zuul.header.priority=false\n# 当以网关设置为优先的时候，网关未配置Header，而外界配置了Header，仍旧忽略外界的Header。缺失则默认为true\nspring.application.strategy.zuul.original.header.ignored=true\n</code></pre>\n<h4><a id="_325"></a>通过业务参数在网关过滤器中自定义灰度路由策略</h4>\n<p>通过网关过滤器传递Http Header的方式传递全链路灰度路由策略。下面代码只适用于Zuul和Spring Cloud Gateway网关，Service微服务不需要加该方式</p>\n<ul>\n<li>内置策略解析映射到过滤器的自定义方式</li>\n</ul>\n<p>增加Spring Cloud Gateway的解析策略，Group为discovery-guide-group，Data Id为discovery-guide-gateway，或者，增加Spring Cloud Gateway的解析策略，Group为discovery-guide-group，Data Id为discovery-guide-zuul，策略内容见下面XML内容，它所表达的功能逻辑：</p>\n<pre><code>1. 当外部调用带有的Http Header中的值a=1同时b=2\n   &lt;condition&gt;节点中header="a=1;b=2"对应的version-id="version-route1"，找到下面\n   &lt;route&gt;节点中id="version-route1" type="version"的那项，那么路由即为：\n   {"discovery-guide-service-a":"1.1", "discovery-guide-service-b":"1.1"}\n\n2. 当外部调用带有的Http Header中的值a=1\n   &lt;condition&gt;节点中header="a=1"对应的version-id="version-route2"，找到下面\n   &lt;route&gt;中id="version-route2" type="version"的那项，那么路由即为：\n   {"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.1"}\n\n3. 当外部调用带有的Http Header中的值都不命中，找到上面\n   &lt;strategy&gt;节点中的全局缺省路由，那么路由即为：\n   {"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.0"}\n\n4. 策略解析总共支持5种，可以单独一项使用，也可以多项叠加使用：\n   1）version 版本路由\n   2）region 区域路由\n   3）address 机器地址路由\n   4）version-weight 版本权重路由\n   5）region-weight 区域权重路由\n</code></pre>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token comment">&lt;!-- 基于Http Header传递的策略路由，全局缺省路由 --&gt;</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>{"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.0"}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy</span><span class="token punctuation">&gt;</span></span>\n\n    <span class="token comment">&lt;!-- 基于Http Header传递的策略路由，客户定制化控制，跟业务参数绑定。如果不命中，则执行上面的全局缺省路由 --&gt;</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy-customization</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>conditions</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>condition</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>condition1<span class="token punctuation">"</span></span> <span class="token attr-name">header</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a=1<span class="token punctuation">"</span></span> <span class="token attr-name">version-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>condition</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>condition2<span class="token punctuation">"</span></span> <span class="token attr-name">header</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a=1;b=2<span class="token punctuation">"</span></span> <span class="token attr-name">version-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>conditions</span><span class="token punctuation">&gt;</span></span>\n\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>routes</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>route</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{"discovery-guide-service-a":"1.1", "discovery-guide-service-b":"1.1"}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>route</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>route</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.1"}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>route</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>routes</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy-customization</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6Wy7DQIK-1570768850021)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide2-7.jpg)]</p>\n<ul>\n<li>用户覆盖过滤器的自定义方式</li>\n</ul>\n<p>继承GatewayStrategyRouteFilter或者ZuulStrategyRouteFilter，覆盖掉如下方法中的一个或者多个，通过@Bean方式覆盖框架内置的过滤类</p>\n<pre><code class="prism language-java"><span class="token keyword">protected</span> String <span class="token function">getRouteVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">protected</span> String <span class="token function">getRouteRegion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">protected</span> String <span class="token function">getRouteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>GatewayStrategyRouteFilter示例</p>\n<p>在代码里根据不同的Header选择不同的路由路径</p>\n<pre><code class="prism language-java"><span class="token comment">// 适用于A/B Testing或者更根据某业务参数决定灰度路由路径。可以结合配置中心分别配置A/B两条路径，可以动态改变并通知</span>\n<span class="token comment">// 当Header中传来的用户为张三，执行一条路由路径；为李四，执行另一条路由路径</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGatewayStrategyRouteFilter</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultGatewayStrategyRouteFilter</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_A_ROUTE_VERSION <span class="token operator">=</span> <span class="token string">"{\\"discovery-guide-service-a\\":\\"1.0\\", \\"discovery-guide-service-b\\":\\"1.1\\"}"</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_B_ROUTE_VERSION <span class="token operator">=</span> <span class="token string">"{\\"discovery-guide-service-a\\":\\"1.1\\", \\"discovery-guide-service-b\\":\\"1.0\\"}"</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${a.route.version:"</span> <span class="token operator">+</span> DEFAULT_A_ROUTE_VERSION <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> String aRouteVersion<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${b.route.version:"</span> <span class="token operator">+</span> DEFAULT_B_ROUTE_VERSION <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> String bRouteVersion<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> String <span class="token function">getRouteVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String user <span class="token operator">=</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> aRouteVersion<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> bRouteVersion<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getRouteVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行过滤类创建，覆盖框架内置的过滤类</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> GatewayStrategyRouteFilter <span class="token function">gatewayStrategyRouteFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyGatewayStrategyRouteFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>ZuulStrategyRouteFilter示例</p>\n<p>在代码里根据不同的Header选择不同的路由路径</p>\n<pre><code class="prism language-java"><span class="token comment">// 适用于A/B Testing或者更根据某业务参数决定灰度路由路径。可以结合配置中心分别配置A/B两条路径，可以动态改变并通知</span>\n<span class="token comment">// 当Header中传来的用户为张三，执行一条路由路径；为李四，执行另一条路由路径</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyZuulStrategyRouteFilter</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultZuulStrategyRouteFilter</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_A_ROUTE_VERSION <span class="token operator">=</span> <span class="token string">"{\\"discovery-guide-service-a\\":\\"1.0\\", \\"discovery-guide-service-b\\":\\"1.1\\"}"</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_B_ROUTE_VERSION <span class="token operator">=</span> <span class="token string">"{\\"discovery-guide-service-a\\":\\"1.1\\", \\"discovery-guide-service-b\\":\\"1.0\\"}"</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${a.route.version:"</span> <span class="token operator">+</span> DEFAULT_A_ROUTE_VERSION <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> String aRouteVersion<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${b.route.version:"</span> <span class="token operator">+</span> DEFAULT_B_ROUTE_VERSION <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> String bRouteVersion<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> String <span class="token function">getRouteVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String user <span class="token operator">=</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> aRouteVersion<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> bRouteVersion<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getRouteVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行过滤类创建，覆盖框架内置的过滤类</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> ZuulStrategyRouteFilter <span class="token function">zuulStrategyRouteFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyZuulStrategyRouteFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4><a id="_465"></a>通过业务参数在策略类中自定义灰度路由策略</h4>\n<p>通过策略方式自定义灰度路由策略。下面代码既适用于Zuul和Spring Cloud Gateway网关，也适用于Service微服务，同时全链路中网关和服务都必须加该方式</p>\n<pre><code class="prism language-java"><span class="token comment">// 实现了组合策略，版本路由策略+区域路由策略+IP和端口路由策略+自定义策略</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyDiscoveryEnabledStrategy</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultDiscoveryEnabledStrategy</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOG <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyDiscoveryEnabledStrategy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 对Rest调用传来的Header参数（例如：mobile）做策略</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span>Server server<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String mobile <span class="token operator">=</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String serviceId <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerServiceId</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String version <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerVersion</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String region <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerRegion</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"负载均衡用户定制触发：mobile={}, serviceId={}, version={}, region={}"</span><span class="token punctuation">,</span> mobile<span class="token punctuation">,</span> serviceId<span class="token punctuation">,</span> version<span class="token punctuation">,</span> region<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>mobile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 手机号以移动138开头，路由到1.0版本的服务上</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>mobile<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"138"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span> <span class="token string">"1.0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                <span class="token comment">// 手机号以联通133开头，路由到2.0版本的服务上</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mobile<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"133"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span> <span class="token string">"1.1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 其它情况，直接拒绝请求</span>\n                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行策略类创建</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> DiscoveryEnabledStrategy <span class="token function">discoveryEnabledStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyDiscoveryEnabledStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在网关和服务中支持基于Rest Header传递的自定义灰度路由策略，除此之外，服务还支持基于Rpc方法参数传递的自定义灰度路由策略，它包括接口名、方法名、参数名或参数值等多种形式。下面的示例表示在服务中同时开启基于Rest Header传递和Rpc方法参数传递的自定义组合式灰度路由策略</p>\n<pre><code class="prism language-java"><span class="token comment">// 实现了组合策略，版本路由策略+区域路由策略+IP和端口路由策略+自定义策略</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyDiscoveryEnabledStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">DiscoveryEnabledStrategy</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOG <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyDiscoveryEnabledStrategy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token keyword">private</span> PluginAdapter pluginAdapter<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token keyword">private</span> ServiceStrategyContextHolder serviceStrategyContextHolder<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span>Server server<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">boolean</span> enabled <span class="token operator">=</span> <span class="token function">applyFromHeader</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token function">applyFromMethod</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 根据Rest调用传来的Header参数（例如：mobile），选取执行调用请求的服务实例</span>\n    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">applyFromHeader</span><span class="token punctuation">(</span>Server server<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String mobile <span class="token operator">=</span> serviceStrategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String serviceId <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerServiceId</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String version <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerVersion</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String region <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerRegion</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"负载均衡用户定制触发：mobile={}, serviceId={}, version={}, region={}"</span><span class="token punctuation">,</span> mobile<span class="token punctuation">,</span> serviceId<span class="token punctuation">,</span> version<span class="token punctuation">,</span> region<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>mobile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 手机号以移动138开头，路由到1.0版本的服务上</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>mobile<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"138"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span> <span class="token string">"1.0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                <span class="token comment">// 手机号以联通133开头，路由到2.0版本的服务上</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mobile<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"133"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span> <span class="token string">"1.1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 其它情况，直接拒绝请求</span>\n                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 根据RPC调用传来的方法参数（例如接口名、方法名、参数名或参数值等），选取执行调用请求的服务实例</span>\n    <span class="token comment">// 本示例只作用在discovery-guide-service-a服务上</span>\n    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">applyFromMethod</span><span class="token punctuation">(</span>Server server<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> attributes <span class="token operator">=</span> serviceStrategyContextHolder<span class="token punctuation">.</span><span class="token function">getRpcAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String serviceId <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerServiceId</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String version <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerVersion</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String region <span class="token operator">=</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getServerRegion</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"负载均衡用户定制触发：attributes={}, serviceId={}, version={}, region={}"</span><span class="token punctuation">,</span> attributes<span class="token punctuation">,</span> serviceId<span class="token punctuation">,</span> version<span class="token punctuation">,</span> region<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>attributes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>ServiceStrategyConstant<span class="token punctuation">.</span>PARAMETER_MAP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> parameterMap <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> attributes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ServiceStrategyConstant<span class="token punctuation">.</span>PARAMETER_MAP<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            String value <span class="token operator">=</span> parameterMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 输入值包含dev，路由到dev区域的服务上</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"dev"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>region<span class="token punctuation">,</span> <span class="token string">"dev"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                    <span class="token comment">// 输入值包含qa，路由到qa区域的服务上</span>\n                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"qa"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>region<span class="token punctuation">,</span> <span class="token string">"qa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 其它情况，直接通过请求</span>\n                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>需要通过如下开关开启该功能</p>\n<pre><code class="prism language-vb"># 启动和关闭路由策略的时候，对RPC方式的调用拦截。缺失则默认为false\nspring.application.strategy.rpc.intercept.enabled=true\n</code></pre>\n<h3><a id="_591"></a>配置前端灰度&amp;网关灰度路由组合式策略</h3>\n<p>当前端（例如：APP）和后端微服务同时存在多个版本时，可以执行“前端灰度&amp;网关灰度路由组合式策略”</p>\n<p>例如：前端存在1.0和2.0版本，微服务存在1.0和2.0版本，由于存在版本不兼容的情况（前端1.0版本只能调用微服务的1.0版本，前端2.0版本只能调用微服务的2.0版本），那么前端调用网关时候，可以通过Header传递它的版本号给网关，网关根据前端版本号，去路由对应版本的微服务</p>\n<p>该场景可以用“通过业务参数在网关过滤器中自定义灰度路由策略”的方案来解决，如下：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strategy-customization</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>conditions</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>condition</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>condition1<span class="token punctuation">"</span></span> <span class="token attr-name">header</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app-version=1.0<span class="token punctuation">"</span></span> <span class="token attr-name">version-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>condition</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>condition2<span class="token punctuation">"</span></span> <span class="token attr-name">header</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app-version=2.0<span class="token punctuation">"</span></span> <span class="token attr-name">version-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>conditions</span><span class="token punctuation">&gt;</span></span>\n\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>routes</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>route</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{"discovery-guide-service-a":"1.0", "discovery-guide-service-b":"1.0"}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>route</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>route</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version-route2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{"discovery-guide-service-a":"1.1", "discovery-guide-service-b":"1.1"}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>route</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>routes</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strategy-customization</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>上述配置，模拟出全链路中，两条独立不受干扰的调用路径：</p>\n<pre><code>1. APP v1.0 -&gt; 网关 -&gt; A服务 v1.0 -&gt; B服务 v1.0\n2. APP v1.1 -&gt; 网关 -&gt; A服务 v1.1 -&gt; B服务 v1.1\n</code></pre>\n<h2><a id="_622"></a>基于订阅方式的全链路灰度发布规则</h2>\n<p>在Nacos配置中心，增加全链路灰度发布规则<br>\n注意：该功能和网关灰度路由和灰度权重功能会叠加，为了不影响演示效果，请先清除网关灰度路由的策略</p>\n<h3><a id="_626"></a>配置全链路灰度匹配规则</h3>\n<h4><a id="_628"></a>版本匹配灰度规则</h4>\n<p>增加版本匹配的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现a服务1.0版本只能访问b服务1.0版本，a服务1.1版本只能访问b服务1.1版本：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">consumer-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0<span class="token punctuation">"</span></span> <span class="token attr-name">provider-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">consumer-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.1<span class="token punctuation">"</span></span> <span class="token attr-name">provider-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8Noczb6R-1570768850022)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide3-1.jpg)]</p>\n<h4><a id="_643"></a>区域匹配灰度规则</h4>\n<p>增加区域匹配的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现dev区域的a服务只能访问dev区域的b服务，qa区域的a服务只能访问qa区域的b服务：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>region</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">consumer-region-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev<span class="token punctuation">"</span></span> <span class="token attr-name">provider-region-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">consumer-region-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>qa<span class="token punctuation">"</span></span> <span class="token attr-name">provider-region-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>qa<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>region</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tXmS36fo-1570768850029)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide3-2.jpg)]</p>\n<h3><a id="_658"></a>配置全链路灰度权重规则</h3>\n<h4><a id="_660"></a>全局版本权重灰度规则</h4>\n<p>增加全局版本权重的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现版本为1.0的服务提供90%的流量，版本为1.1的服务提供10%的流量：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0=90;1.1=10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jPMZEAty-1570768850030)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide4-1.jpg)]</p>\n<h4><a id="_674"></a>局部版本权重灰度规则</h4>\n<p>增加局部版本权重的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现a服务1.0版本提供90%的流量，1.1版本提供10%的流量；b服务1.0版本提供20%的流量，1.1版本提供80%的流量：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0=90;1.1=10<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0=20;1.1=80<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU0LTIuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<h4><a id="_689"></a>全局区域权重灰度规则</h4>\n<p>增加全局区域权重的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现区域为dev的服务提供90%的流量，区域为qa的服务提供10%的流量：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>region</span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev=90;qa=10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU0LTMuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<h4><a id="_703"></a>局部区域权重灰度规则</h4>\n<p>增加局部区域权重的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现a服务dev区域提供90%的流量，qa区域提供10%的流量；b服务dev区域提供20%的流量，qa区域提供80%的流量：</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev=90;qa=10<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>region<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev=20;qa=80<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>region<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU0LTQuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<p>注意：局部权重优先级高于全局权重，版本权重优先级高于区域权重</p>\n<p>请执行Postman操作，请仔细观察服务被随机权重调用到的概率</p>\n<h3><a id="_722"></a>配置全链路灰度权重&amp;灰度版本组合式规则</h3>\n<p>增加组合式的灰度规则，Group为discovery-guide-group，Data Id为discovery-guide-group（全局发布，两者都是组名），规则内容如下，实现功能：</p>\n<ul>\n<li>a服务1.0版本向网关提供90%的流量，1.1版本向网关提供10%的流量</li>\n<li>a服务1.0版本只能访问b服务1.0版本，1.1版本只能访问b服务1.1版本</li>\n</ul>\n<p>该功能的意义是，网关随机权重调用服务，而服务链路按照版本匹配方式调用</p>\n<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>discovery</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">consumer-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0<span class="token punctuation">"</span></span> <span class="token attr-name">provider-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-b<span class="token punctuation">"</span></span> <span class="token attr-name">consumer-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.1<span class="token punctuation">"</span></span> <span class="token attr-name">provider-version-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>weight</span><span class="token punctuation">&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-gateway<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0=90;1.1=10<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span> <span class="token attr-name">consumer-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-zuul<span class="token punctuation">"</span></span> <span class="token attr-name">provider-service-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>discovery-guide-service-a<span class="token punctuation">"</span></span> <span class="token attr-name">provider-weight-value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.0=90;1.1=10<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>version<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>weight</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>discovery</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E4R3Ub9T-1570768850036)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide5-1.jpg)]</p>\n<p>图形化界面验证</p>\n<ul>\n<li>下载<a href="https://github.com/Nepxion/Discovery">源码主页</a>的工程，并导入IDE</li>\n<li>启动源码工程下的discovery-springcloud-example-console/ConsoleApplication</li>\n<li>启动源码工程下的discovery-console-desktop/ConsoleLauncher</li>\n<li>通过admin/admin登录，点击“显示服务拓扑”按钮，将呈现如下界面<br>\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-grOEKF6w-1570768850038)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide5-2.jpg)]</li>\n<li>在加入上述规则前，选中网关节点，右键点击“执行灰度路由”，在弹出路由界面中，依次加入“discovery-guide-service-a”和“discovery-guide-service-b”，点击“执行路由”按钮，将呈现如下界面<br>\n<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU1LTMuanBn?x-oss-process=image/format,png" alt="Alt text"></li>\n<li>在加入上述规则后，在路由界面中，再次点击“执行路由”按钮，将呈现如下界面<br>\n<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU1LTQuanBn?x-oss-process=image/format,png" alt="Alt text"></li>\n</ul>\n<h2><a id="_758"></a>全链路服务隔离</h2>\n<p>元数据中的Group在一定意义上代表着系统ID或者系统逻辑分组，基于Group策略意味着只有同一个系统中的服务才能调用</p>\n<h3><a id="_762"></a>注册服务隔离</h3>\n<p>基于Group黑/白名单的策略，即当前的服务所在的Group，不在Group的黑名单或者在白名单里，才允许被注册。只需要在网关或者服务端，开启如下配置即可：</p>\n<pre><code class="prism language-vb"># 启动和关闭注册的服务隔离（基于Group黑/白名单的策略）。缺失则默认为false\nspring.application.strategy.register.isolation.enabled=true\n</code></pre>\n<p>黑/白名单通过如下方式配置</p>\n<pre><code class="prism language-vb">spring.application.strategy.register.isolation.group.blacklist=\nspring.application.strategy.register.isolation.group.whitelist=\n</code></pre>\n<h3><a id="_774"></a>消费端服务隔离</h3>\n<p>基于Group是否相同的策略，即消费端拿到的提供端列表，两者的Group必须相同。只需要在网关或者服务端，开启如下配置即可：</p>\n<pre><code class="prism language-vb"># 启动和关闭消费端的服务隔离（基于Group是否相同的策略）。缺失则默认为false\nspring.application.strategy.consumer.isolation.enabled=true\n</code></pre>\n<p>通过修改discovery-guide-service-b的Group名为其它名称，执行Postman调用，将发现从discovery-guide-service-a无法拿到discovery-guide-service-b的任何实例。意味着在discovery-guide-service-a消费端进行了隔离</p>\n<h3><a id="_782"></a>提供端服务隔离</h3>\n<p>基于Group是否相同的策略，即服务端被消费端调用，两者的Group必须相同，否则拒绝调用，异构系统可以通过Header方式传递n-d-service-group值进行匹配。只需要在服务端（不适用网关），开启如下配置即可：</p>\n<pre><code class="prism language-vb"># 启动和关闭提供端的服务隔离（基于Group是否相同的策略）。缺失则默认为false\nspring.application.strategy.provider.isolation.enabled=true\n\n# 灰度路由策略的时候，需要指定对业务RestController类的扫描路径。此项配置作用于RPC方式的调用拦截和消费端的服务隔离两项工作\nspring.application.strategy.scan.packages=com.nepxion.discovery.guide.service.feign\n</code></pre>\n<p>在Postman调用，执行<a href="http://localhost:4001/invoke/abc" rel="nofollow">http://localhost:4001/invoke/abc</a>，去调用discovery-guide-service-b服务，将出现如下异常。意味着在discovery-guide-service-b提供端进行了隔离</p>\n<pre><code>Reject to invoke because of isolation with different service group\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bO2JLs40-1570768850046)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide6-1.jpg)]<br>\n如果加上n-d-service-group=discovery-guide-group的Header，那么两者保持Group相同，则调用通过。这是解决异构系统调用微服务被隔离的一种手段<br>\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Spl5mSaO-1570768850047)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide6-2.jpg)]</p>\n<h2><a id="Sentinel_800"></a>基于Sentinel的全链路服务限流熔断降级权限和灰度融合</h2>\n<p>通过集成Sentinel，在服务端实现该功能</p>\n<p>封装NacosDataSource和ApolloDataSource，支持Nacos和Apollo两个远程配置中心，零代码实现Sentinel功能。更多的远程配置中心，请参照Sentinel官方的DataSource并自行集成</p>\n<pre><code>1. Nacos的Key格式：Group为元数据中配置的[组名]，Data Id为[服务名]-[规则类型]\n2. Apollo的Key格式：[组名]-[服务名]-[规则类型]\n</code></pre>\n<p>支持远程配置中心和本地规则文件的读取逻辑，即优先读取远程配置，如果不存在或者规则错误，则读取本地规则文件。动态实现远程配置中心对于规则的热刷新</p>\n<p>支持如下开关开启该动能，默认是关闭的</p>\n<pre><code class="prism language-vb"># 启动和关闭Sentinel限流降级熔断权限等功能。缺失则默认为false\nspring.application.strategy.sentinel.enabled=true\n</code></pre>\n<h3><a id="Sentinel_818"></a>原生Sentinel注解</h3>\n<p>参照下面代码，为接口方法增加@SentinelResource注解，value为sentinel-resource，blockHandler和fallback是防护其作用后需要执行的方法</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> DiscoveryConstant<span class="token punctuation">.</span>SPRING_APPLICATION_NAME<span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"discovery-guide-service-b"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BFeignImpl</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFeignImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BFeign</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOG <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>BFeignImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"sentinel-resource"</span><span class="token punctuation">,</span> blockHandler <span class="token operator">=</span> <span class="token string">"handleBlock"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> <span class="token string">"handleFallback"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"value"</span><span class="token punctuation">)</span> String value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        value <span class="token operator">=</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"调用路径：{}"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> String <span class="token function">handleBlock</span><span class="token punctuation">(</span>String value<span class="token punctuation">,</span> BlockException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token string">"-&gt; B server sentinel block, cause="</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", rule="</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limitApp="</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getRuleLimitApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> String <span class="token function">handleFallback</span><span class="token punctuation">(</span>String value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token string">"-&gt; B server sentinel fallback"</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3><a id="Sentinel_848"></a>原生Sentinel规则</h3>\n<p>原生Sentinel规则的用法，请参照Sentinel官方文档</p>\n<h4><a id="_852"></a>流控规则</h4>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-flow，规则内容如下：</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "default",\n        "grade": 1,\n        "count": 1,\n        "strategy": 0,\n        "refResource": null,\n        "controlBehavior": 0,\n        "warmUpPeriodSec": 10,\n        "maxQueueingTimeMs": 500,\n        "clusterMode": false,\n        "clusterConfig": null\n    }\n]\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2Cyqzcmx-1570768850048)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide7-1.jpg)]</p>\n<h4><a id="_874"></a>降级规则</h4>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-degrade，规则内容如下：</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "default",\n        "count": 2,\n        "timeWindow": 10,\n        "grade": 0,\n        "passCount": 0\n    }\n]\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nH61WfH9-1570768850049)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide7-2.jpg)]</p>\n<h4><a id="_891"></a>授权规则</h4>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下：</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "discovery-guide-service-a",\n        "strategy": 0\n    }\n]\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j8OjYMqC-1570768850052)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide7-3.jpg)]</p>\n<h4><a id="_905"></a>系统规则</h4>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-system，规则内容如下：</p>\n<pre><code>[\n    {\n        "resource": null,\n        "limitApp": null,\n        "highestSystemLoad": -1.0,\n        "highestCpuUsage": -1.0,\n        "qps": 200.0,\n        "avgRt": -1,\n        "maxThread": -1\n    }\n]\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qJopR4DB-1570768850054)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide7-4.jpg)]</p>\n<h4><a id="_923"></a>热点参数流控规则</h4>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-param-flow，规则内容如下：</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "default",\n        "grade": 1,\n        "paramIdx": 0,\n        "count": 1,\n        "controlBehavior": 0,\n        "maxQueueingTimeMs": 0,\n        "burstCount": 0,\n        "durationInSec": 1,\n        "paramFlowItemList": [],\n        "clusterMode": false\n    }\n]\n</code></pre>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CCt3gFa1-1570768850056)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/DiscoveryGuide7-5.jpg)]</p>\n<h3><a id="SentinelLimitApp_945"></a>基于灰度路由和Sentinel-LimitApp扩展的防护机制</h3>\n<p>该方式对于上面5种规则都有效，这里以授权规则展开阐述</p>\n<p>授权规则中，limitApp，如果有多个，可以通过“,”分隔。“strategy”: 0 表示白名单，“strategy”: 1 表示黑名单</p>\n<h4><a id="_951"></a>基于服务名的防护机制</h4>\n<p>修改配置项Sentinel Request Origin Key为服务名的Header名称，修改授权规则中limitApp为对应的服务名，可实现基于服务名的防护机制</p>\n<p>配置项，该配置项默认为n-d-service-id，可以不配置</p>\n<pre><code class="prism language-vb">spring.application.strategy.service.sentinel.request.origin.key=n-d-service-id\n</code></pre>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下，表示所有discovery-guide-service-a服务允许访问discovery-guide-service-b服务</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "discovery-guide-service-a",\n        "strategy": 0\n    }\n]\n</code></pre>\n<h4><a id="_971"></a>基于灰度组的防护机制</h4>\n<p>修改配置项Sentinel Request Origin Key为灰度组的Header名称，修改授权规则中limitApp为对应的组名，可实现基于组名的防护机制</p>\n<p>配置项</p>\n<pre><code class="prism language-vb">spring.application.strategy.service.sentinel.request.origin.key=n-d-service-group\n</code></pre>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下，表示隶属my-group组的所有服务都允许访问服务discovery-guide-service-b</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "my-group",\n        "strategy": 0\n    }\n]\n</code></pre>\n<h4><a id="_991"></a>基于灰度版本的防护机制</h4>\n<p>修改配置项Sentinel Request Origin Key为灰度版本的Header名称，修改授权规则中limitApp为对应的版本，可实现基于版本的防护机制</p>\n<p>配置项</p>\n<pre><code class="prism language-vb">spring.application.strategy.service.sentinel.request.origin.key=n-d-service-version\n</code></pre>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下，表示版本为1.0的所有服务都允许访问服务discovery-guide-service-b</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "1.0",\n        "strategy": 0\n    }\n]\n</code></pre>\n<h4><a id="_1011"></a>基于灰度区域的防护机制</h4>\n<p>修改配置项Sentinel Request Origin Key为灰度区域的Header名称，修改授权规则中limitApp为对应的区域，可实现基于区域的防护机制</p>\n<p>配置项</p>\n<pre><code class="prism language-vb">spring.application.strategy.service.sentinel.request.origin.key=n-d-service-region\n</code></pre>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下，表示区域为dev的所有服务都允许访问服务discovery-guide-service-b</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "dev",\n        "strategy": 0\n    }\n]\n</code></pre>\n<h4><a id="_1031"></a>基于机器地址和端口的防护机制</h4>\n<p>修改配置项Sentinel Request Origin Key为灰度区域的Header名称，修改授权规则中limitApp为对应的区域值，可实现基于机器地址和端口的防护机制</p>\n<p>配置项</p>\n<pre><code class="prism language-vb">spring.application.strategy.service.sentinel.request.origin.key=n-d-service-address\n</code></pre>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下，表示地址和端口为192.168.0.88:8081和192.168.0.88:8082的服务都允许访问服务discovery-guide-service-b</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "192.168.0.88:8081,192.168.0.88:8082",\n        "strategy": 0\n    }\n]\n</code></pre>\n<h4><a id="_1051"></a>自定义业务参数的组合式防护机制</h4>\n<p>通过适配类实现自定义业务参数的组合式防护机制</p>\n<pre><code class="prism language-java"><span class="token comment">// 自定义版本号+用户名，实现组合式熔断</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServiceSentinelRequestOriginAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultServiceSentinelRequestOriginAdapter</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> String <span class="token function">parseOrigin</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String version <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>DiscoveryConstant<span class="token punctuation">.</span>N_D_SERVICE_VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        String user <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> version <span class="token operator">+</span> <span class="token string">"&amp;"</span> <span class="token operator">+</span> user<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行适配类创建</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> ServiceSentinelRequestOriginAdapter <span class="token function">ServiceSentinelRequestOriginAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceSentinelRequestOriginAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>增加服务discovery-guide-service-b的规则，Group为discovery-guide-group，Data Id为discovery-guide-service-b-sentinel-authority，规则内容如下，表示版本为1.0且传入的Http Header的user=zhangsan，同时满足这两个条件下的所有服务都允许访问服务discovery-guide-service-b</p>\n<pre><code>[\n    {\n        "resource": "sentinel-resource",\n        "limitApp": "1.0&amp;zhangsan",\n        "strategy": 0\n    }\n]\n</code></pre>\n<p>运行效果</p>\n<ul>\n<li>当传递的Http Header中user=zhangsan，当全链路调用中，API网关负载均衡discovery-guide-service-a服务到1.0版本后再去调用discovery-guide-service-b服务，最终调用成功</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU3LTYuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<ul>\n<li>当传递的Http Header中user=lisi，不满足条件，最终调用在discovery-guide-service-b服务端被拒绝掉</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU3LTcuanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<ul>\n<li>当传递的Http Header中user=zhangsan，满足条件之一，当全链路调用中，API网关负载均衡discovery-guide-service-a服务到1.1版本后再去调用discovery-guide-service-b服务，不满足version=1.0的条件，最终调用在discovery-guide-service-b服务端被拒绝掉</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05lcHhpb24vRG9jcy9yYXcvbWFzdGVyL2Rpc2NvdmVyeS1kb2MvRGlzY292ZXJ5R3VpZGU3LTguanBn?x-oss-process=image/format,png" alt="Alt text"></p>\n<h2><a id="Hystrix_1099"></a>基于Hystrix的全链路服务限流熔断和灰度融合</h2>\n<p>通过引入Hystrix组件实现服务限流熔断的功能，在执行灰度发布和路由时候，线程池隔离模式下进行调用会丢失上下文，那么需要下述步骤避免该情况。下面步骤同时适用于网关端和服务端</p>\n<ul>\n<li>Pom引入</li>\n</ul>\n<pre><code class="prism language-xml"><span class="token comment">&lt;!-- 当服务用Hystrix做线程隔离的时候，才需要导入下面的包 --&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.nepxion<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>discovery-plugin-strategy-starter-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${discovery.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\n</code></pre>\n<ul>\n<li>配置开启</li>\n</ul>\n<pre><code class="prism language-vb"># 开启服务端实现Hystrix线程隔离模式做服务隔离时，必须把spring.application.strategy.hystrix.threadlocal.supported设置为true，同时要引入discovery-plugin-strategy-starter-hystrix包，否则线程切换时会发生ThreadLocal上下文对象丢失。缺失则默认为false\nspring.application.strategy.hystrix.threadlocal.supported=true\n</code></pre>\n<h2><a id="_1119"></a>全链路灰度调用链</h2>\n<p>灰度调用链主要包括如下6个参数。使用者可以自行定义要传递的调用链参数，例如：traceId, spanId等；也可以自行定义要传递的业务调用链参数，例如：mobile, user等</p>\n<pre><code>1. n-d-service-group - 服务所属组或者应用\n2. n-d-service-type - 服务类型，分为“网关”和“服务”\n3. n-d-service-id - 服务ID\n4. n-d-service-address - 服务地址，包括Host和Port\n5. n-d-service-version - 服务版本\n6. n-d-service-region - 服务所属区域\n</code></pre>\n<p>灰度调用链输出分为Header方式和日志方式</p>\n<h3><a id="Header_1132"></a>Header输出方式</h3>\n<p>Header方式框架内部集成</p>\n<ul>\n<li>Spring Cloud Gateway网关端自行会传输Header值（参考Discovery源码中的AbstractGatewayStrategyRouteFilter.java）</li>\n<li>Zuul网关端自行会传输Header值（参考Discovery源码中的AbstractZuulStrategyRouteFilter.java）</li>\n<li>服务端通过Feign和RestTemplate拦截器传输Header值（参考Discovery源码中的FeignStrategyInterceptor.java和RestTemplateStrategyInterceptor.java）</li>\n</ul>\n<h3><a id="_1139"></a>日志输出方式</h3>\n<ul>\n<li>Spring Cloud Gateway网关</li>\n</ul>\n<p>继承GatewayStrategyTracer.java，trace方法里把6个参数（参考父类里debugTraceHeader方法）或者更多通过MDC方式输出到日志</p>\n<pre><code class="prism language-java"><span class="token comment">// 自定义调用链和灰度调用链通过MDC输出到日志。使用者集成时候，关注trace方法中的MDC.put和release方法中MDC.clear代码部分即可</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGatewayStrategyTracer</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultGatewayStrategyTracer</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trace</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token comment">// 输出到日志</span>\n        MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"traceid"</span><span class="token punctuation">,</span> <span class="token string">"traceid="</span> <span class="token operator">+</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"traceid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n        MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>DiscoveryConstant<span class="token punctuation">.</span>N_D_SERVICE_GROUP<span class="token punctuation">,</span> <span class="token string">"服务组名="</span> <span class="token operator">+</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>DiscoveryConstant<span class="token punctuation">.</span>N_D_SERVICE_GROUP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        MDC<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行调用链类创建，覆盖框架内置的调用链类</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> StrategyConstant<span class="token punctuation">.</span>SPRING_APPLICATION_STRATEGY_TRACE_ENABLED<span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> GatewayStrategyTracer <span class="token function">gatewayStrategyTracer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyGatewayStrategyTracer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<ul>\n<li>Zuul网关</li>\n</ul>\n<p>继承ZuulStrategyTracer.java，trace方法里把6个参数（参考父类里debugTraceHeader方法）或者更多通过MDC方式输出到日志</p>\n<pre><code class="prism language-java"><span class="token comment">// 自定义调用链和灰度调用链通过MDC输出到日志。使用者集成时候，关注trace方法中的MDC.put和release方法中MDC.clear代码部分即可</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyZuulStrategyTracer</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultZuulStrategyTracer</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trace</span><span class="token punctuation">(</span>RequestContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token comment">// 输出到日志</span>\n        MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"traceid"</span><span class="token punctuation">,</span> <span class="token string">"traceid="</span> <span class="token operator">+</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"traceid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n        MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>DiscoveryConstant<span class="token punctuation">.</span>N_D_SERVICE_GROUP<span class="token punctuation">,</span> <span class="token string">"服务组名="</span> <span class="token operator">+</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>DiscoveryConstant<span class="token punctuation">.</span>N_D_SERVICE_GROUP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span>RequestContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        MDC<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行调用链类创建，覆盖框架内置的调用链类</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> StrategyConstant<span class="token punctuation">.</span>SPRING_APPLICATION_STRATEGY_TRACE_ENABLED<span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> ZuulStrategyTracer <span class="token function">zuulStrategyTracer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyZuulStrategyTracer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<ul>\n<li>Service服务</li>\n</ul>\n<p>继承ServiceStrategyTracer.java，trace方法里把6个参数（参考父类里debugTraceLocal方法）或者更多通过MDC方式输出到日志</p>\n<pre><code class="prism language-java"><span class="token comment">// 自定义调用链和灰度调用链通过MDC输出到日志。使用者集成时候，关注trace方法中的MDC.put和release方法中MDC.clear代码部分即可</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServiceStrategyTracer</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultServiceStrategyTracer</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trace</span><span class="token punctuation">(</span>ServiceStrategyTracerInterceptor interceptor<span class="token punctuation">,</span> MethodInvocation invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        \n        <span class="token comment">// 输出到日志</span>\n        MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"traceid"</span><span class="token punctuation">,</span> <span class="token string">"traceid="</span> <span class="token operator">+</span> strategyContextHolder<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"traceid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\n        MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>DiscoveryConstant<span class="token punctuation">.</span>N_D_SERVICE_GROUP<span class="token punctuation">,</span> <span class="token string">"服务组名="</span> <span class="token operator">+</span> pluginAdapter<span class="token punctuation">.</span><span class="token function">getGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span>ServiceStrategyTracerInterceptor interceptor<span class="token punctuation">,</span> MethodInvocation invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        MDC<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行调用链类创建，覆盖框架内置的调用链类</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> StrategyConstant<span class="token punctuation">.</span>SPRING_APPLICATION_STRATEGY_TRACE_ENABLED<span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> ServiceStrategyTracer <span class="token function">serviceStrategyTracer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyServiceStrategyTracer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>请参考在IDE控制台打印的结果<br>\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gx4rHNh4-1570768850063)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/Tracer.jpg)]</p>\n<p>对于调用链功能的开启和关闭，需要通过如下开关做控制：</p>\n<pre><code class="prism language-vb"># 启动和关闭调用链。缺失则默认为false\nspring.application.strategy.trace.enabled=true\n# 启动和关闭调用链的Debug日志打印，注意每调用一次都会打印一次，会对性能有所影响，建议压测环境和生产环境关闭。缺失则默认为false\nspring.application.strategy.trace.debug.enabled=true\n</code></pre>\n<h2><a id="Header_1249"></a>全链路Header传递</h2>\n<p>框架会默认把相关的Header，进行全链路传递，可以通过如下配置进行。除此之外，凡是以“n-d-”开头的任何Header，框架都会默认全链路传递</p>\n<pre><code class="prism language-vb"># 启动和关闭路由策略的时候，对REST方式的调用拦截。缺失则默认为true\nspring.application.strategy.rest.intercept.enabled=true\n# 启动和关闭Header传递的Debug日志打印，注意每调用一次都会打印一次，会对性能有所影响，建议压测环境和生产环境关闭。缺失则默认为false\nspring.application.strategy.rest.intercept.debug.enabled=true\n# 灰度路由策略的时候，对REST方式调用拦截的时候（支持Feign或者RestTemplate调用），希望把来自外部自定义的Header参数（用于框架内置上下文Header，例如：traceid, spanid等）传递到服务里，那么配置如下值。如果多个用“;”分隔，不允许出现空格\nspring.application.strategy.context.request.headers=traceid;spanid\n# 灰度路由策略的时候，对REST方式调用拦截的时候（支持Feign或者RestTemplate调用），希望把来自外部自定义的Header参数（用于业务系统子定义Header，例如：mobile）传递到服务里，那么配置如下值。如果多个用“;”分隔，不允许出现空格\nspring.application.strategy.business.request.headers=user;mobile\n</code></pre>\n<p>原生的Feign Header传递可以使用RequestInterceptor拦截器实现，原生的RestTemplate Header传递可以使用ClientHttpRequestInterceptor拦截器实现</p>\n<p>本框架也使用这些原生的拦截器用作Header在灰度功能上的传递，为了避免使用者再去多创建一层拦截器，框架抽象出两个拦截适配器，用法和原生的两个拦截器一致，可以帮助使用者实现自定义Header的传递</p>\n<h3><a id="FeignHeader_1267"></a>自定义Feign-Header传递</h3>\n<p>实现FeignStrategyInterceptorAdapter.java，在apply方法里加入自定义的Header传递</p>\n<pre><code class="prism language-java"><span class="token comment">// 自定义Feign拦截器中的Header传递</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyFeignStrategyInterceptorAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultFeignStrategyInterceptorAdapter</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span>RequestTemplate requestTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        requestTemplate<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"n-d-my-id"</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行拦截适配器创建</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> FeignStrategyInterceptorAdapter <span class="token function">feignStrategyInterceptorAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyFeignStrategyInterceptorAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3><a id="RestTemplateHeader_1287"></a>自定义RestTemplate-Header传递</h3>\n<p>实现RestTemplateStrategyInterceptorAdapter.java，在intercept方法里加入自定义的Header传递</p>\n<pre><code class="prism language-java"><span class="token comment">// 自定义RestTemplate拦截器中的Header传递</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRestTemplateStrategyInterceptorAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultRestTemplateStrategyInterceptorAdapter</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> ClientHttpResponse <span class="token function">intercept</span><span class="token punctuation">(</span>HttpRequest request<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span> ClientHttpRequestExecution execution<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>\n        HttpHeaders headers <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"n-d-my-id"</span><span class="token punctuation">,</span> <span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">return</span> execution<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>在配置类里@Bean方式进行拦截适配器创建</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> RestTemplateStrategyInterceptorAdapter <span class="token function">restTemplateStrategyInterceptorAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyRestTemplateStrategyInterceptorAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2><a id="DockerKubernetes_1310"></a>Docker容器化和Kubernetes平台</h2>\n<h3><a id="Docker_1312"></a>Docker容器化</h3>\n<ul>\n<li>搭建Windows10操作系统或者Linux操作系统下的Docker环境\n<ul>\n<li>Windows10环境下，具体步骤参考<a href="https://github.com/Nepxion/Thunder/blob/master/thunder-spring-boot-docker-example/README.md">Docker安装步骤</a></li>\n<li>Linux环境请自行研究</li>\n</ul>\n</li>\n<li>全自动部署和运行Docker化的服务。在根目录下\n<ul>\n<li>一键运行install-docker-gateway.bat或者.sh，把Spring Cloud Gateway网关全自动部署且运行起来</li>\n<li>一键运行install-docker-zuul.bat或者.sh，把Zuul网关全自动部署且运行起来</li>\n<li>一键运行install-docker-service-xx.bat或者.sh，把微服务全自动部署且运行起来。注意，必须依次运行，即等上一个部署完毕后才能执行下一个</li>\n</ul>\n</li>\n</ul>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zQy2sFJZ-1570768850064)(https://github.com/Nepxion/Docs/raw/master/discovery-doc/Docker.jpg)]</p>\n<h3><a id="Kubernetes_1324"></a>Kubernetes平台</h3>\n<p>请自行研究</p>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/101986453', 'title': 'Linux磁盘简介', 'readNum': '1457', 'commentNum': '0', 'publishTime': '2019-10-03 12:42:59', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/101986453<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：https://www.fangzhipeng.com/db/2019/09/10/linux-disc.html</p>\n<p>本文主要从以下几个方面介绍Linux磁盘：</p>\n<ul>\n<li>磁盘的接口</li>\n<li>硬盘的设备名称</li>\n<li>文件系统</li>\n<li>RAID独立冗余磁盘阵列</li>\n</ul>\n<!--more-->\n<h2><a id="_17"></a>磁盘的接口</h2>\n<p>现在磁盘最常用的可简单分为普通的机械盘和SSD(Solid-state drive或Solid-state disk)两种，他们都已不同的接口协议和主板链接，在了解命令之前，我们先来看下，现在服务器磁盘的接口协议。这样可以更好的了解磁盘。</p>\n<p>现阶段磁盘的接口主要有以下几种：</p>\n<h4><a id="ATA_23"></a>ATA</h4>\n<p>全称Advanced Technology Attachment，是用传统的40-pin并口数据线连接主板与硬盘的，接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利计算机内部散热，已逐渐被SATA所取代。</p>\n<h4><a id="SATA_27"></a>SATA</h4>\n<p>全称Serial ATA，也就是使用串口的ATA接口，特点是抗干扰性强，对数据线的要求比ATA低很多，且支持热插拔等功能。SATA-II的接口速度为300MiB/s，而新的SATA-III标准可达到600MiB/s的传输速度。SATA的数据线也比ATA的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>\n<h4><a id="SCSI_31"></a>SCSI</h4>\n<p>全称Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的SCSI-II，到当前的Ultra320 SCSI以及Fiber-Channel（光纤通道），接口型式也多种多样。SCSI硬盘广为工作站级个人计算机以及服务器所使用，因此会使用较为先进的技术，如碟片转速15000rpm的高转速，且资料传输时CPU占用率较低，但是单价也比相同容量的ATA及SATA硬盘更加昂贵。</p>\n<h4><a id="SAS_35"></a>SAS</h4>\n<p>全称Serial Attached SCSI，是新一代的SCSI技术，可兼容SATA硬盘，都是采取序列式技术以获得更高的传输速度，可达到12Gb/s。此外也透过缩小连接线改善系统内部空间等。</p>\n<p>此外，由于SAS硬盘可以与SATA硬盘共享同样的背板，因此在同一个SAS存储系统中，可以用SATA硬盘来取代部分昂贵的SAS硬盘，节省整体的存储成本。但SATA存储系统并不能连接SAS硬盘。</p>\n<h4><a id="FC_41"></a>FC</h4>\n<p>全称Fibre Channel（光纤通道接口），拥有此接口的硬盘在使用光纤联接时具有热插拔性、高速带宽（4Gb/s或10Gb/s）、远程连接等特点；内部传输速率也比普通硬盘更高。但其价格高昂，因此FC接口通常只用于高端服务器领域。</p>\n<p>现在，普通机械盘接口多为SATA，固态盘接口多为SAS。更多磁盘知识可参考<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" rel="nofollow">Wiki百科</a>。</p>\n<h2><a id="_50"></a>硬盘设备名称</h2>\n<p>在linux中世界中，一切皆文件，设备也是文件。系统内核中的 udev 设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等;这对于陌生的设备来说特别方便。另外，udev 设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。</p>\n<p>linux的硬盘设备SCSI/SATA/U 盘，它的文件名称为/dev/sd[a-p],系统采用 a-p来表示16块不同的硬盘，硬盘的分区也是有讲究的，主分区或扩展分区为编号1-4，逻辑分区是从编号5开始。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mb3JlenAub2JzLm15aHVhd2VpY2xvdWQuY29tL2ltZy8yMDE5MTIvMjI3OTU5NC1lNGQ0NjUwOTI0YTE0OThkLnBuZw?x-oss-process=image/format,png" alt="11.png"></p>\n<h2><a id="_59"></a>文件系统</h2>\n<p>用户在硬件存储设备中执行的文件建立、写入、读取、修改、转存与控制等操作都是依 靠文件系统来完成的。文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。Linux 系统支持数十种的文件系统，而最常见的文件系统如下所示。</p>\n<ul>\n<li>\n<p>Ext3:是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并 能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也 会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入 动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分， 然后尝试进行修复。</p>\n</li>\n<li>\n<p>Ext4:Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容 量高达 1EB(1EB=1,073,741,824GB)，且能够有无限多的子目录。另外，Ext4 文件系 统能够批量分配 block 块，从而极大地提高了读写效率。</p>\n</li>\n<li>\n<p>XFS:是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的 优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的 日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB， 这几乎满足了所有需求。</p>\n</li>\n</ul>\n<p>计算机系统在发展过程中产生了众多的文件系统，为了使用户在读取或写入文件时不用<br>\n关心底层的硬盘结构，Linux 内核中的软件层为用户程序提供了一个 VFS(Virtual File System， 虚拟文件系统)接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作 了。如图所示为 VFS 的架构示意图。从中可见，<br>\n实际文件系统在 VFS 下隐藏了自己的特性 和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令 在任何文件系统中进行各种操作了(比如使用 cp 命令来复制文件)。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mb3JlenAub2JzLm15aHVhd2VpY2xvdWQuY29tL2ltZy8yMDE5MTIvMjI3OTU5NC1lN2NjZmM2ZWRmMmE1YTA0LnBuZw?x-oss-process=image/format,png" alt="WX20190909-225358@2x.png"></p>\n<h2><a id="_75"></a>添加磁盘设备</h2>\n<p>在实际的生产环境中，在虚拟机扩容磁盘是非常常见的，虚拟机一般有一个系统盘，还有大容量存储的数据盘。在虚拟机中添加磁盘设备，需要进行格式化、挂载等操作，最后通过检查系统的挂载状态来验证硬盘设备是否成功添加。<br>\n格式化磁盘可以用mkfs命令–&gt;make filesystem的缩写；用来在特定的分区格式化并建立Linux文件系统。<br>\n在Shell 终端中输入mkfs 名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果：</p>\n<pre><code>[root@fzp~]# mkfs\nmkfs         mkfs.btrfs   mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.ext4    mkfs.fat     mkfs.minix   mkfs.msdos   mkfs.vfat    mkfs.xfs   \n</code></pre>\n<p>这个mkfs 命令把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单。</p>\n<pre><code>[root@fzp~]# mkfs.ext3 /dev/sda\n</code></pre>\n<p>上面的命令格式化了存储设备，并创建了文件系统。接下来就是要来挂载并使用存储设备了。需要创建一个挂载目录，比如/data目录，然后用mount命令，首先是创建一个用于挂载设备的挂载点目录；然后使用mount 命<br>\n令将存储设备与挂载点进行关联；最后使用df -h 命令来查看挂载状态和硬盘使用量信息。</p>\n<pre><code>[root@fzp ~]# mkdir /data\n[root@fzp ~]# mount /dev/sda /data/\n[root@fzp ~]# df -h\n/dev/sdb1 200G 33M 200G 1% /data\n</code></pre>\n<h2><a id="RAID_102"></a>RAID独立冗余磁盘阵列</h2>\n<p>RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列）。</p>\n<p>RAID 技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。</p>\n<p>使用Raid需要额外的存储设备，增加了成本。但RAID 不仅降低了硬盘设备损坏后丢失数据的几率，还提升了硬盘设备的读写速度，所以它在绝大多数运营商或大中型企业中得以广泛部署和应用。常见的RAID 磁盘阵列有十几种，最常见的为Raid0,raid1,raid5,raid10。</p>\n<h3><a id="raid0_112"></a>raid0</h3>\n<p>RAID0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间（如图 2 所示），将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。由于可以并发执行 I/O 操作，总线带宽得到充分利用。再加上不需要进行数据校验，RAID0 的性能在所有 RAID 等级中是最高的。理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。</p>\n<p>RAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。 因此， RAID0 一般适用于对性能要求严格但对数据安全性和可靠性不高的应用，如视频、音频存储、临时数据缓存空间等。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTkxMi8yMDE3MDYyMTExMjA0NDgzMi5wbmc?x-oss-process=image/format,png" alt=""></p>\n<h3><a id="raid1_120"></a>raid1</h3>\n<p>RAID1 称为镜像，它将数据完全一致地分别写到工作磁盘和镜像 磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统自动从镜像磁盘读取数据，不会影响用户工作</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTkxMi8yMDE3MDYyMTExMjA0NDk0OC5wbmc?x-oss-process=image/format,png" alt=""></p>\n<h3><a id="raid5_126"></a>raid5</h3>\n<p>RAID5 应该是目前最常见的 RAID 等级，RAID5 技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。</p>\n<p>RAID 5 磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命缺陷。</p>\n<p>RAID5 的磁盘上同时存储数据和校验数据，数据块和对应的校验信息存保存在不同的磁盘上，当一个数据盘损坏时，系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。RAID5 兼顾存储性能、数据安全和存储成本等各方面因素，它可以理解为 RAID0 和 RAID1 的折中方案，是目前综合性能最佳的数据保护解决方案。 RAID5 基本上可以满足大部分的存储应用需求，数据中心大多采用它作为应用数据的保护方案。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTkxMi8yMDE3MDYyMTExMjA0NTYyMC5wbmc?x-oss-process=image/format,png" alt=""></p>\n<h3><a id="raid10_136"></a>raid10</h3>\n<p>RAID 10 技术是RAID 1+RAID 0 技术的一个“组合体”。RAID 10 技术需要至少4 块硬盘来组建，其中先分别两两制作成RAID 1 磁盘阵列，以保证数据的安全性；然后再对两个RAID1 磁盘阵列实施RAID0 技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID10 技术继承了RAID0的高读写速度和RAID1 的数据安全性，在不考虑成本的情况下RAID10 的性能都超过了RAID 5，因此当前成为广泛使用的一种存储技术。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTkxMi8yMDE3MDYyMTExMjA0NTgxMi5wbmc?x-oss-process=image/format,png" alt=""></p>\n<h2><a id="_142"></a>参考资料</h2>\n<p>https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98</p>\n<p>http://www.jiangxinlingdu.com/thought/2018/09/14/linuxio.html</p>\n<p>https://blog.csdn.net/ensp1/article/details/81318135</p>\n<p>书籍《linux 就该这么学》</p>\n<p>书籍《鸟哥的Linux私房菜》</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/101986307', 'title': 'ElasticSearch使用优化之拙见', 'readNum': '644', 'commentNum': '0', 'publishTime': '2019-10-03 12:40:11', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/94174577<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：https://www.fangzhipeng.com/db/2019/09/03/es-optimized.html</p>\n<p>Elasticsearch常常作为日志存储和分析的工具，在企业级应用中常常使用。Elasticsearch提供强大的搜索、分析功能，已经是后端技术栈不可缺少的一部分。<br>\n在维护ElastciSearch集群的时候，对Elasticsearch进行了一些调优和分析，现整理成文，纯属拙见，如果有不合理之处，欢迎指出探讨。我所使用的Elasticsearch版本为5.x。</p>\n<!--more-->\n<h2><a id="_15"></a>文件句柄优化</h2>\n<p>Elasticsearch有大量的查询数据和插入数据的请求，需要大量文件句柄，centos系统默认的1024个文件句柄。如果文件句柄用完了，这就意味着操作系统会拒绝连接，意味着数据可能丢失，这是灾难性的后果，<br>\n不能被接受。登陆Elasticsearch的启动用户，用一下命令查看：</p>\n<pre><code>ulimit -a\n</code></pre>\n<p>查看结果：</p>\n<pre><code>core file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 127673\nmax locked memory       (kbytes, -l) unlimited\nmax memory size         (kbytes, -m) unlimited\nopen files                      (-n) 1024\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 2056474\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n</code></pre>\n<p>上面的文件句柄（open files）的个数为1024，在ElasticSearch大量请求的情况下，这个句柄数量是不够的，可以改成655360。</p>\n<p>临时修改可以通过执行以下命令，即可立即生效，但是机器重启后又会失效：</p>\n<pre><code>ulimit -n 655360\n</code></pre>\n<p>永久生效，修改/etc/security/limits.conf，需要重启机器生效：</p>\n<pre><code>u_es - nofile 655360\n</code></pre>\n<p>上述配置中u_es为启动ElasticSearch的用户，设置了该用户的ElasticSearch的文件句柄为655360、</p>\n<h2><a id="JVM_61"></a>JVM参数优化</h2>\n<p>Elasticsearch是运行在JVM上的，对其做JVM参数调优至关重要。最常见的调优是Java内存的分配。下面是JVM的内存模型，具体每块的作用，不在这里阐述。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mb3JlenAub2JzLm15aHVhd2VpY2xvdWQuY29tL2ltZy9qaWFuc2h1LzIyNzk1OTQtM2IyYjBiYzcxZjE3YWQzNy5wbmc?x-oss-process=image/format,png" alt=""></p>\n<h3><a id="_67"></a>新生代和老年代分配的内存比例给多大？</h3>\n<p>Jvm内存分为新生代和老年代。</p>\n<ul>\n<li>新生代（或者伊甸园）<br>\n新实例化的对象分配的空间。新生代空间通常都非常小，一般在 100 MB–500 MB。新生代也包含两个 幸存 空间。</li>\n<li>老年代<br>\n较老的对象存储的空间。这些对象预计将长期留存并持续上很长一段时间。老生代通常比新生代大很多。</li>\n</ul>\n<p>新生代、老生代的垃圾回收都有一个阶段会“stop the world”。在这段时间里，JVM 停止了程序运行，以便对对象进行可达性分析，收集死亡对象。在这个时间停止阶段，一切都不会发生。请求不被服务，ping 不被回应，分片不被分配。整个世界都真的停止了。<br>\n对于新生代，这不是什么大问题；那么小的空间意味着 GC 会很快执行完。但是老生代大很多，而这里面一个慢 GC 可能就意味着 1 秒乃至 15 秒的暂停——对于服务器软件来说这是不可接受的。</p>\n<p>那一般我们给新生代和老年代分配多大的内存呢？他们的比例是多少呢？<br>\n一般来说，老年代和新生代的内存比例为2：1是比较合适的。比如给堆内存分配3G，则新生代分配1G，其余都给老年代。在ElasticSearce的配置文件jvm.options文件配置：</p>\n<pre><code>-Xms3g  //配置堆初始化大小\n-Xmx3g   //配置堆的最大内存\n-Xmn1g   //配置新生代内存。\n</code></pre>\n<h3><a id="Elasticesearch_89"></a>该分配多大的内存给Elasticesearch？</h3>\n<p>在使用Elasticesearch的时候，我们对装Elasticesearch的机器进行了升级，从最小的8G内存升级到了16G内存，然后到目前的32G内存。一台机器装一个Elasticesearch节点，我们应该怎么分配机器的内存呢？<br>\n官方给出了解决方案，把一半（少于）的内存分配给Luence，另外的内存分配给ElasticSearch.</p>\n<p>内存对于 Elasticsearch 来说绝对是重要的，它可以被许多内存数据结构使用来提供更快的操作。但是说到这里， 还有另外一个内存消耗大户 非堆内存 （off-heap）：Lucene。</p>\n<p>Lucene 被设计为可以利用操作系统底层机制来缓存内存数据结构。 Lucene 的段是分别存储到单个文件中的。因为段是不可变的，这些文件也都不会变化，这是对缓存友好的，同时操作系统也会把这些段文件缓存起来，以便更快的访问。</p>\n<p>Lucene 的性能取决于和操作系统的相互作用。如果你把所有的内存都分配给 Elasticsearch 的堆内存，那将不会有剩余的内存交给 Lucene。 这将严重地影响全文检索的性能。</p>\n<p>标准的建议是把 50％ 的可用内存作为 Elasticsearch 的堆内存，保留剩下的 50％。当然它也不会被浪费，Lucene 会很乐意利用起余下的内存。</p>\n<p>我们实际的解决办法是将机器的一半分给Elasticesearch的堆，栈内存、方法区、常量池、非堆内存占用另外一半。</p>\n<h3><a id="_32766_mb3199_gb_105"></a>分配给堆最大内存应该小于 32766 mb（~31.99 gb）</h3>\n<p>JVM 在内存小于 32 GB 的时候会采用一个内存对象指针压缩技术。<br>\n对于 32 位的系统，意味着堆内存大小最大为 4 GB。对于 64 位的系统， 可以使用更大的内存，但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。更糟糕的是， 更大的指针在主内存和各级缓存（例如 LLC，L1 等）之间移动数据的时候，会占用更多的带宽。<br>\nJava 使用一个叫作 内存指针压缩（compressed oops）的技术来解决这个问题。 它的指针不再表示对象在内存中的精确位置，而是表示 偏移量 。这意味着 32 位的指针可以引用 40 亿个 对象 ， 而不是 40 亿个字节。最终， 也就是说堆内存增长到 32 GB 的物理内存，也可以用 32 位的指针表示。<br>\n一旦你越过那个神奇的 ~32 GB 的边界，指针就会切回普通对象的指针。 每个对象的指针都变长了，就会使用更多的 CPU 内存带宽，也就是说你实际上失去了更多的内存。事实上，当内存到达 40–50 GB 的时候，有效内存才相当于使用内存对象指针压缩技术时候的 32 GB 内存。<br>\n这段描述的意思就是说：即便你有足够的内存，也尽量不要 超过 32 GB。因为它浪费了内存，降低了 CPU 的性能，还要让 GC 应对大内存。</p>\n<h2><a id="swap_114"></a>关掉swap</h2>\n<p>内存交换 到磁盘对服务器性能来说是 致命 的。</p>\n<p>如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p>\n<p>用以下命令关掉swap:</p>\n<pre><code>sudo swapoff -a\n</code></pre>\n<h2><a id="_126"></a>不要碰以下的配置</h2>\n<p>所有的调整就是为了优化，但是这些调整，你真的不需要理会它。因为它们经常会被乱用，从而造成系统的不稳定或者糟糕的性能，甚至两者都有可能。</p>\n<h3><a id="_130"></a>线程池配置</h3>\n<p>许多人 喜欢 调整线程池。 无论什么原因，人们都对增加线程数无法抵抗。索引太多了？增加线程！搜索太多了？增加线程！节点空闲率低于 95％？增加线程！<br>\nElasticsearch 默认的线程设置已经是很合理的了。对于所有的线程池（除了 搜索 ），线程个数是根据 CPU 核心数设置的。 如果你有 8 个核，你可以同时运行的只有 8 个线程，只分配 8 个线程给任何特定的线程池是有道理的。<br>\n搜索线程池设置的大一点，配置为 int（（ 核心数 ＊ 3 ）／ 2 ）＋ 1 。</p>\n<h3><a id="_136"></a>垃圾回收器</h3>\n<p>Elasticsearch 默认的垃圾回收器（ GC ）是 CMS。 这个垃圾回收器可以和应用并行处理，以便它可以最小化停顿。 然而，它有两个 stop-the-world 阶段，处理大内存也有点吃力。</p>\n<p>尽管有这些缺点，它还是目前对于像 Elasticsearch 这样低延迟需求软件的最佳垃圾回收器。官方建议使用 CMS。</p>\n<h2><a id="_142"></a>合理设置最小主节点</h2>\n<p>minimum_master_nodes 设置及其重要，为了防止集群脑裂，这个参数应该设置为法定个数就是 ( master 候选节点个数 / 2) + 1。</p>\n<h2><a id="Master_146"></a>分片均匀，磁盘优化，剔除掉高负载的Master竞选？</h2>\n<p>笔者在实际生产环境中遇到了有一个节点的负载是其他节点的几倍，从虚拟机监控上看，所有的节点的qps是差不多的。机器的配置是一样的，为什么负载会有如此大的差距？</p>\n<ul>\n<li>首先，我们怀疑数据分配不均匀，我们排查了下，没有这种现象。</li>\n<li>然后，我们监控到了高负载的节点磁盘IO非常的高，经常达到100%，我们怀疑是那个虚拟机磁盘性能不行。但是我们当时没有更好的磁盘。</li>\n<li>我们找到了一个适中的解决办法是将这台高负载的节点剔除Master竞选，即将elasticsearch.yml文件中的node.master改为false然后重启，负载下降了一些。</li>\n</ul>\n<h2><a id="_154"></a>数据存储天数的优化</h2>\n<p>存储天数的优化，这个需要根据实际的业务来，下面是删除过期数据的脚本，该脚本来源于https://stackoverflow.com/questions/33430055/removing-old-indices-in-elasticsearch#answer-39746705  ；</p>\n<pre><code>#!/bin/bash\nsearchIndex=logstash-monitor\nelastic_url=logging.core.k94.kvk.nl\nelastic_port=9200\n\ndate2stamp () {\n    date --utc --date "$1" +%s\n}\n\ndateDiff (){\n    case $1 in\n        -s)   sec=1;      shift;;\n        -m)   sec=60;     shift;;\n        -h)   sec=3600;   shift;;\n        -d)   sec=86400;  shift;;\n        *)    sec=86400;;\n    esac\n    dte1=$(date2stamp $1)\n    dte2=$(date2stamp $2)\n    diffSec=$((dte2-dte1))\n    if ((diffSec &lt; 0)); then abs=-1; else abs=1; fi\n    echo $((diffSec/sec*abs))\n}\n\nfor index in $(curl -s "${elastic_url}:${elastic_port}/_cat/indices?v" |     grep -E " ${searchIndex}-20[0-9][0-9]\\.[0-1][0-9]\\.[0-3][0-9]" | awk \'{     print $3 }\'); do\n  date=$(echo ${index: -10} | sed \'s/\\./-/g\')\n  cond=$(date +%Y-%m-%d)\n  diff=$(dateDiff -d $date $cond)\n  echo -n "${index} (${diff})"\n  if [ $diff -gt 1 ]; then\n    echo " / DELETE"\n    # curl -XDELETE "${elastic_url}:${elastic_port}/${index}?pretty"\n  else\n    echo ""\n  fi\ndone\n</code></pre>\n<p>然后使用crontab每天定时执行一次这个脚本。</p>\n<h2><a id="_201"></a>集群分片设置</h2>\n<p>ES一旦创建好索引后，就无法调整分片的设置，而在ES中，一个分片实际上对应一个lucene 索引，而lucene索引的读写会占用很多的系统资源，因此，分片数不能设置过大；所以，在创建索引时，合理配置分片数是非常重要的。一般来说，我们遵循一些原则：</p>\n<ol>\n<li>控制每个分片占用的硬盘容量不超过ES的最大JVM的堆空间设置（一般设置不超过32G，参加上文的JVM设置原则），因此，如果索引的总容量在500G左右，那分片大小在16个左右即可；当然，最好同时考虑原则2。</li>\n<li>考虑一下node数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了1个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的3倍。</li>\n</ol>\n<h2><a id="_209"></a>索引优化</h2>\n<p>1.修改index_buffer_size 的设置，可以设置成百分数，也可设置成具体的大小，大小可根据集群的规模做不同的设置测试。</p>\n<pre><code>indices.memory.index_buffer_size：10%（默认）\nindices.memory.min_index_buffer_size： 48mb（默认）\nindices.memory.max_index_buffer_size\n\n</code></pre>\n<ol start="2">\n<li>\n<p>_id字段的使用，应尽可能避免自定义_id, 以避免针对ID的版本管理；建议使用ES的默认ID生成策略或使用数字类型ID做为主键。</p>\n</li>\n<li>\n<p>_all字段及_source字段的使用，应该注意场景和需要，_all字段包含了所有的索引字段，方便做全文检索，如果无此需求，可以禁用；_source存储了原始的document内容，如果没有获取原始文档数据的需求，可通过设置includes、excludes 属性来定义放入_source的字段。</p>\n</li>\n<li>\n<p>合理的配置使用index属性，analyzed 和not_analyzed，根据业务需求来控制字段是否分词或不分词。只有 groupby需求的字段，配置时就设置成not_analyzed, 以提高查询或聚类的效率。</p>\n</li>\n</ol>\n<h2><a id="_227"></a>查询优化</h2>\n<ul>\n<li>查询优化，调整filter过滤顺序</li>\n</ul>\n<p>如果把过滤效果不明显的条件放在了前面，导致查询出大量不需要的数据，导致查询变慢。<br>\n把过滤效果明显的条件提前，按照过滤效果把过滤条件排序</p>\n<ul>\n<li>索引时间精度优化</li>\n</ul>\n<p>研究Filter的工作原理可以看出，它每次工作都是遍历整个索引的，所以时间粒度越大，对比越快，搜索时间越短，在不影响功能的情况下，时间精度越低越好，有时甚至牺牲一点精度也值得，当然最好的情况是根本不作时间限制。<br>\nes重新刷索引，增加冗余的时间字段，精确到天。带有时间范围的查询使用该字段进行查询</p>\n<ul>\n<li>查询Fetch Source优化</li>\n</ul>\n<p>业务查询语句获取的数据集比较大，并且从source中获取了非必须的字段，导致查询较慢。<br>\n举例：只需要从es中查询id这一个字段，却把所有字段查询了出来</p>\n<ul>\n<li>预索引数据</li>\n</ul>\n<p>利用索引查询数据是最优的方式。例如，如果所有的文档都有 price 字段，并且大多数查询都在一个固定的范围列表中运行范围聚合，那么可以通过将 index 预索引到 index 和使用 terms 聚合来更快地实现聚合。</p>\n<p>例如，像下面这样：</p>\n<pre><code>PUT index/type/1\n{\n  "designation": "spoon",\n  "price": 13\n}\n\n</code></pre>\n<p>像这样的查询：</p>\n<pre><code>GET index/_search\n{\n  "aggs": {\n    "price_ranges": {\n      "range": {\n        "field": "price",\n        "ranges": [\n          { "to": 10 },\n          { "from": 10, "to": 100 },\n          { "from": 100 }\n        ]\n      }\n    }\n  }\n}\n\n</code></pre>\n<p>文档在索引的时候要使用 price_range ，应该被映射为关键词：</p>\n<pre><code>PUT index\n{\n  "mappings": {\n    "type": {\n      "properties": {\n        "price_range": {\n          "type": "keyword"\n        }\n      }\n    }\n  }\n}\n\nPUT index/type/1\n{\n  "designation": "spoon",\n  "price": 13,\n  "price_range": "10-100"\n}\n\n</code></pre>\n<p>然后这个请求就直接聚合新字段，而不是在 price 字段运行范围查询：</p>\n<pre><code>GET index/_search\n{\n  "aggs": {\n    "price_ranges": {\n      "terms": {\n        "field": "price_range"\n      }\n    }\n  }\n}\n\n</code></pre>\n<h2><a id="_324"></a>总结</h2>\n<p>总的来说，ElasticSearch的优化，优化可以从以下方面的考虑：</p>\n<ul>\n<li>硬件的优化：机器分配，机器配置，机器内存，机器CPU，机器网络，机器磁盘性能</li>\n<li>操作系统设置优化：文件句柄优化、swap关闭</li>\n<li>ElasticSearch合理分配节点，合理分配参加竞选Master的节点</li>\n<li>ElasticSearch的存储的优化，副本数量、索引数量、分片数量</li>\n<li>ElasticSearch的使用优化，索引的优化，查询的优化</li>\n</ul>\n<h2><a id="_334"></a>参考资料</h2>\n<p>https://www.elastic.co/guide/cn/elasticsearch/guide/current/_monitoring_individual_nodes.html</p>\n<p>https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html</p>\n<p>https://www.fangzhipeng.com/javainterview/2019/04/09/jmm.html</p>\n<p>https://www.elastic.co/guide/cn/elasticsearch/guide/current/important-configuration-changes.html</p>\n<p>https://stackoverflow.com/questions/33430055/removing-old-indices-in-elasticsearch#answer-39746705</p>\n<p>https://zhuanlan.zhihu.com/p/43437056</p>\n<p>http://doc.codingdict.com/elasticsearch/497/</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:22 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/100060686', 'title': 'RateLimiter 源码分析(Guava 和 Sentinel 实现)', 'readNum': '2876', 'commentNum': '4', 'publishTime': '2019-08-25 10:28:47', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>作者javadoop，资深Java工程师。本文已获作者授权发布。</p>\n\n<p>原文链接https://www.javadoop.com/post/rate-limiter</p>\n</blockquote>\n\n<p>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2019/08/20/ratelimit-guava-sentinel.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/08/20/ratelimit-guava-sentinel.html</a></p>\n\n<p>本文主要介绍关于流控的两部分内容。</p>\n\n<p>第一部分介绍 Guava 中 RateLimiter 的源码，包括它的两种模式，目前网上大部分文章只分析简单的 SmoothBursty 模式，而没有分析带有预热的 SmoothWarmingUp。</p>\n\n<p>第二部分介绍 Sentinel 中流控的实现，本文不要求读者了解 Sentinel，这部分内容和 Sentinel 耦合很低，所以读者不需要有阅读压力。</p>\n\n<p>Sentinel 中流控设计是参考 Guava RateLimiter 的，所以阅读第二部分内容，需要有第一部分内容的背景。</p>\n\n<h2>Guava RateLimiter</h2>\n\n<p>RateLimiter 基于漏桶算法，但它参考了令牌桶算法，这里不讨论流控算法，请自行查找资料。</p>\n\n<h3>RateLimiter 使用介绍</h3>\n\n<p>RateLimiter 的接口非常简单，它有两个静态方法用来实例化，实例化以后，我们只需要关心 acquire 就行了，甚至都没有 release 操作。</p>\n\n<p>// RateLimiter 接口列表：</p>\n\n<pre class="has">\n<code>// 实例化的两种方式：\npublic static RateLimiter create(double permitsPerSecond){}\npublic static RateLimiter create(double permitsPerSecond,long warmupPeriod,TimeUnit unit) {}\n\npublic double acquire() {}\npublic double acquire(int permits) {}\n\npublic boolean tryAcquire() {}\npublic boolean tryAcquire(int permits) {}\npublic boolean tryAcquire(long timeout, TimeUnit unit) {}\npublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) {}\n\npublic final double getRate() {}\npublic final void setRate(double permitsPerSecond) {}</code></pre>\n\n<p>RateLimiter 的作用是用来限流的，我们知道 java 并发包中提供了 Semaphore，它也能够提供对资源使用进行控制，我们看一下下面的代码：</p>\n\n<p>\xa0</p>\n\n<pre class="has">\n<code>// Semaphore\nSemaphore semaphore = new Semaphore(10);\nfor (int i = 0; i &lt; 100; i++) {\n    executor.submit(new Runnable() {\n        @Override\n        public void run() {\n            semaphore.acquireUninterruptibly(1);\n            try {\n                doSomething();\n            } finally {\n                semaphore.release();\n            }\n        }\n    });\n}\n</code></pre>\n\n<p>Semaphore 用来控制同时访问某个资源的并发数量，如上面的代码，我们设置 100 个线程工作，但是我们能做到最多只有 10 个线程能同时到 doSomething() 方法中。它控制的是并发数量。</p>\n\n<p>而 RateLimiter 是用来控制访问资源的速率（rate）的，它强调的是控制速率。比如控制每秒只能有 100 个请求通过，比如允许每秒发送 1MB 的数据。</p>\n\n<p>它的构造方法指定一个 permitsPerSecond 参数，代表每秒钟产生多少个 permits，这就是我们的速率。</p>\n\n<p>RateLimiter 允许预占未来的令牌，比如，每秒产生 5 个 permits，我们可以单次请求 100 个，这样，紧接着的下一个请求需要等待大概 20 秒才能获取到 permits。</p>\n\n<h3>SmoothRateLimiter 介绍</h3>\n\n<p>RateLimiter 目前只有一个子类，那就是抽象类 SmoothRateLimiter，SmoothRateLimiter 有两个实现类，也就是我们这边要介绍的两种模式，我们先简单介绍下 SmoothRateLimiter，然后后面分两个小节分别介绍它的两个实现类。</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyLzEucG5n?x-oss-process=image/format,png"></p>\n\n<p>RateLimiter 作为抽象类，只有两个属性：</p>\n\n<pre class="has">\n<code>private final SleepingStopwatch stopwatch;\n\nprivate volatile Object mutexDoNotUseDirectly;</code></pre>\n\n<p>stopwatch 非常重要，它用来“计时”，RateLimiter 把实例化的时间设置为 0 值，后续都是取相对时间，用微秒表示。</p>\n\n<p>mutexDoNotUseDirectly 用来做锁，RateLimiter 依赖于 synchronized 来控制并发，所以我们之后可以看到，各个属性甚至都没有用 volatile 修饰。</p>\n\n<p>然后我们来看 SmoothRateLimiter 的属性，分别代表什么意思。</p>\n\n<pre class="has">\n<code>// 当前还有多少 permits 没有被使用，被存下来的 permits 数量\ndouble storedPermits;\n\n// 最大允许缓存的 permits 数量，也就是 storedPermits 能达到的最大值\ndouble maxPermits;\n\n// 每隔多少时间产生一个 permit，\n// 比如我们构造方法中设置每秒 5 个，也就是每隔 200ms 一个，这里单位是微秒，也就是 200,000\ndouble stableIntervalMicros;\n\n// 下一次可以获取 permits 的时间，这个时间是相对 RateLimiter 的构造时间的，是一个相对时间，理解为时间戳吧\nprivate long nextFreeTicketMicros = 0L; </code></pre>\n\n<p>其实，看到这几个属性，我们就可以大致猜一下它的内部实现了：</p>\n\n<p>nextFreeTicketMicros 是一个很关键的属性。我们每次获取 permits 的时候，先拿 storedPermits 的值，如果够，storedPermits 减去相应的值就可以了，如果不够，那么还需要将 nextFreeTicketMicros 往前推，表示我预占了接下来多少时间的量了。那么下一个请求来的时候，如果还没到 nextFreeTicketMicros 这个时间点，需要 sleep 到这个点再返回，当然也要将这个值再往前推。</p>\n\n<p>大家在这里可能会有疑惑，因为时间是一直往前走的，所以 storedPermits 的信息可能是不准确的，不过，只需要在关键的操作中同步一下，重新计算就好了。</p>\n\n<h3>SmoothBursty 分析</h3>\n\n<p>我们先从比较简单的 SmoothBursty 出发，来分析 RateLimiter 的源码，之后我们再分析 SmoothWarmingUp。</p>\n\n<blockquote>\n<p>Bursty 是突发的意思，它说的不是下面这个意思：我们设置了 1k 每秒，而我们可以一次性获取 5k 的 permits，这个场景表达的不是突发，而是在说预先占有了接下来几秒产生的 permits。</p>\n\n<p>突发说的是，RateLimiter 会缓存一定数量的 permits 在池中，这样对于突发请求，能及时得到满足。想象一下我们的某个接口，很久没有请求过来，突然同时来了好几个请求，如果我们没有缓存一些 permits 的话，很多线程就需要等待了。</p>\n\n<p>SmoothBursty 默认缓存最多 1 秒钟的 permits，不可以修改。</p>\n</blockquote>\n\n<p>RateLimiter 的静态构造方法：</p>\n\n<pre class="has">\n<code>public static RateLimiter create(double permitsPerSecond) {\n    return create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());\n}</code></pre>\n\n<p>构造参数 permitsPerSecond 指定每秒钟可以产生多少个 permits。</p>\n\n<pre class="has">\n<code>static RateLimiter create(double permitsPerSecond, SleepingStopwatch stopwatch) {\n    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);\n    rateLimiter.setRate(permitsPerSecond);\n    return rateLimiter;\n}</code></pre>\n\n<p>我们看到，这里实例化的是 SmoothBursty 的实例，它的构造方法很简单，而且它只有一个属性 maxBurstSeconds，这里就不贴代码了。</p>\n\n<p>构造函数指定了 maxBurstSeconds 为 1.0，也就是说，最多会缓存 1 秒钟，也就是 (1.0 * permitsPerSecond) 这么多个 permits 到池中。</p>\n\n<blockquote>\n<p>这个 1.0 秒，关系到 storedPermits 和 maxPermits：</p>\n\n<p>0 &lt;= storedPermits &lt;= maxPermits = permitsPerSecond</p>\n</blockquote>\n\n<p>我们继续往后看 setRate 方法：</p>\n\n<pre class="has">\n<code>public final void setRate(double permitsPerSecond) {\n  checkArgument(\n      permitsPerSecond &gt; 0.0 &amp;&amp; !Double.isNaN(permitsPerSecond), "rate must be positive");\n  synchronized (mutex()) {\n    doSetRate(permitsPerSecond, stopwatch.readMicros());\n  }\n}</code></pre>\n\n<p>setRate 这个方法是一个 public 方法，它可以用来调整速率。我们这边继续跟的是初始化过程，但是大家提前知道这个方法是用来调整速率用的，对理解源码有很大的帮助。注意看，这里用了 synchronized 控制并发。</p>\n\n<pre class="has">\n<code>@Override\nfinal void doSetRate(double permitsPerSecond, long nowMicros) {\n    // 同步\n    resync(nowMicros);\n    // 计算属性 stableIntervalMicros\n    double stableIntervalMicros = SECONDS.toMicros(1L) / permitsPerSecond;\n    this.stableIntervalMicros = stableIntervalMicros;\n    doSetRate(permitsPerSecond, stableIntervalMicros);\n}</code></pre>\n\n<p>resync 方法很简单，它用来调整 storedPermits 和 nextFreeTicketMicros。这就是我们说的，在关键的节点，需要先更新一下 storedPermits 到正确的值。</p>\n\n<pre class="has">\n<code>void resync(long nowMicros) {\n  // 如果 nextFreeTicket 已经过掉了，想象一下很长时间都没有再次调用 limiter.acquire() 的场景\n  // 需要将 nextFreeTicket 设置为当前时间，重新计算 storedPermits\n  if (nowMicros &gt; nextFreeTicketMicros) {\n    double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();\n    storedPermits = min(maxPermits, storedPermits + newPermits);\n    nextFreeTicketMicros = nowMicros;\n  }\n}</code></pre>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>coolDownIntervalMicros() 这个方法大家先不用关注，可以看到，在 SmoothBursty 类中的实现是直接返回了 stableIntervalMicros 的值，也就是我们说的，每产生一个 permit 的时间长度。</p>\n\n<p>当然了，细心的读者，可能会发现，此时的 stableIntervalMicros 其实没有设置，也就是说，上面发生了一次除以 0 值的操作，得到的 newPermits 其实是一个无穷大。而 maxPermits 此时还是 0 值，不过这里其实没有关系。</p>\n</blockquote>\n\n<p>我们回到前面一个方法，resync 同步以后，会设置 stableIntervalMicros 为一个正确的值，然后进入下面的方法：</p>\n\n<pre class="has">\n<code>@Override\nvoid doSetRate(double permitsPerSecond, double stableIntervalMicros) {\n  double oldMaxPermits = this.maxPermits;\n  // 这里计算了，maxPermits 为 1 秒产生的 permits\n  maxPermits = maxBurstSeconds * permitsPerSecond;\n  if (oldMaxPermits == Double.POSITIVE_INFINITY) {\n    // if we don\'t special-case this, we would get storedPermits == NaN, below\n    storedPermits = maxPermits;\n  } else {\n    // 因为 storedPermits 的值域变化了，需要等比例缩放\n    storedPermits =\n        (oldMaxPermits == 0.0)\n            ? 0.0 // initial state\n            : storedPermits * maxPermits / oldMaxPermits;\n  }\n}</code></pre>\n\n<p>上面这个方法，我们要这么看，原来的 RateLimiter 是用某个 permitsPerSecond 值初始化的，现在我们要调整这个频率。对于 maxPermits 来说，是重新计算，而对于 storedPermits 来说，是做等比例的缩放。</p>\n\n<p>到此，构造方法就完成了，我们得到了一个 RateLimiter 的实现类 SmoothBursty 的实例，可能上面的源码你还是会有一些疑惑，不过也没关系，继续往下看，可能你的很多疑惑就解开了。</p>\n\n<p>接下来，我们来分析 acquire 方法：</p>\n\n<pre class="has">\n<code>@CanIgnoreReturnValue\npublic double acquire() {\n  return acquire(1);\n}\n\n@CanIgnoreReturnValue\npublic double acquire(int permits) {\n  // 预约，如果当前不能直接获取到 permits，需要等待\n  // 返回值代表需要 sleep 多久\n  long microsToWait = reserve(permits);\n  // sleep\n  stopwatch.sleepMicrosUninterruptibly(microsToWait);\n  // 返回 sleep 的时长\n  return 1.0 * microsToWait / SECONDS.toMicros(1L);\n}</code></pre>\n\n<p>我们来看 reserve 方法：</p>\n\n<pre class="has">\n<code>final long reserve(int permits) {\n  checkPermits(permits);\n  synchronized (mutex()) {\n    return reserveAndGetWaitLength(permits, stopwatch.readMicros());\n  }\n}\n\nfinal long reserveAndGetWaitLength(int permits, long nowMicros) {\n  // 返回 nextFreeTicketMicros\n  long momentAvailable = reserveEarliestAvailable(permits, nowMicros);\n  // 计算时长\n  return max(momentAvailable - nowMicros, 0);\n}</code></pre>\n\n<p>继续往里看：</p>\n\n<pre class="has">\n<code>@Override\nfinal long reserveEarliestAvailable(int requiredPermits, long nowMicros) {\n  // 这里做一次同步，更新 storedPermits 和 nextFreeTicketMicros (如果需要)\n  resync(nowMicros);\n  // 返回值就是 nextFreeTicketMicros，注意刚刚已经做了 resync 了，此时它是最新的正确的值\n  long returnValue = nextFreeTicketMicros;\n  // storedPermits 中可以使用多少个 permits\n  double storedPermitsToSpend = min(requiredPermits, this.storedPermits);\n  // storedPermits 中不够的部分\n  double freshPermits = requiredPermits - storedPermitsToSpend;\n  // 为了这个不够的部分，需要等待多久时间\n  long waitMicros =\n      storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) // 这部分固定返回 0\n          + (long) (freshPermits * stableIntervalMicros);\n  // 将 nextFreeTicketMicros 往前推\n  this.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);\n  // storedPermits 减去被拿走的部分\n  this.storedPermits -= storedPermitsToSpend;\n  return returnValue;\n}\n</code></pre>\n\n<p>我们可以看到，获取 permits 的时候，其实是获取了两部分，一部分来自于存量 storedPermits，存量不够的话，另一部分来自于预占未来的 freshPermits。</p>\n\n<p>这里提一个关键点吧，我们看到，返回值是 nextFreeTicketMicros 的旧值，因为只要到这个时间点，就说明当次 acquire 可以成功返回了，而不管 storedPermits 够不够。如果 storedPermits 不够，会将 nextFreeTicketMicros 往前推一定的时间，预占了一定的量。</p>\n\n<p>到这里，acquire 方法就分析完了，大家看到这里，逆着往前看就是了。应该说，SmoothBursty 的源码还是非常简单的。</p>\n\n<h3>SmoothWarmingUp 分析</h3>\n\n<p>分析完了 SmoothBursty，我们再来分析 SmoothWarmingUp 会简单一些。我们说过，SmoothBursty 可以处理突发请求，因为它会缓存最多 1 秒的 permits，而待会我们会看到 SmoothWarmingUp 完全不同的设计。</p>\n\n<p>SmoothWarmingUp 适用于资源需要预热的场景，比如我们的某个接口业务，需要使用到数据库连接，由于连接需要预热才能进入到最佳状态，如果我们的系统长时间处于低负载或零负载状态（当然，应用刚启动也是一样的），连接池中的连接慢慢释放掉了，此时我们认为连接池是冷的。</p>\n\n<p>假设我们的业务在稳定状态下，正常可以提供最大 1000 QPS 的访问，但是如果连接池是冷的，我们就不能让 1000 个请求同时进来，因为这会拖垮我们的系统，我们应该有个预热升温的过程。</p>\n\n<p>对应到 SmoothWarmingUp 中，如果系统处于低负载状态，storedPermits 会一直增加，当请求来的时候，我们要从 storedPermits 中取 permits，最关键的点在于，从 storedPermits 中取 permits 的操作是比较耗时的，因为没有预热。</p>\n\n<p>回顾一下前面介绍的 SmoothBursty，它从 storedPermits 中获取 permits 是不需要等待时间的，而这边洽洽相反，从 storedPermits 获取需要更多的时间，这是最大的不同，先理解这一点，能帮助你更好地理解源码。</p>\n\n<p>大家先有一些粗的概念，然后我们来看下面这个图：</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyL3Ntb290aC13YXJtLXVwLnBuZw?x-oss-process=image/format,png"></p>\n\n<p>这个图不容易看懂，X 轴代表 storedPermits 的数量，Y 轴代表获取一个 permits 需要的时间。</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>假设指定 permitsPerSecond 为 10，那么 stableInterval 为 100ms，而 coldInterval 是 3 倍，也就是 300ms（coldFactor，3 倍是写死的，用户不能修改）。也就是说，当达到 maxPermits 时，此时处于系统最冷的时候，获取一个 permit 需要 300ms，而如果 storedPermits 小于 thresholdPermits 的时候，只需要 100ms。</p>\n</blockquote>\n\n<p>想象有一条垂直线 x=k，它与 X 轴的交点 k 代表当前 storedPermits 的数量：</p>\n\n<ul><li>当系统在非常繁忙的时候，这条线停留在 x=0 处，此时 storedPermits 为 0</li>\n\t<li>当 limiter 没有被使用的时候，这条线慢慢往右移动，直到 x=maxPermits 处；</li>\n\t<li>如果 limiter 被重新使用，那么这条线又慢慢往左移动，直到 x=0 处；<br>\n\t当 storedPermits 处于 maxPermits 状态时，我们认为 limiter 中的 permits 是冷的，此时获取一个 permit 需要较多的时间，因为需要预热，有一个关键的分界点是 thresholdPermits。</li>\n</ul><p>预热时间是我们在构造的时候指定的，图中梯形的面积就是预热时间，因为预热完成后，我们能进入到一个稳定的速率中（stableInterval），下面我们来计算出 thresholdPermits 和 maxPermits 的值。</p>\n\n<p>有一个关键点，从 thresholdPermits 到 0 的时间，是从 maxPermits 到 thresholdPermits 时间的一半，也就是梯形的面积是长方形面积的 2 倍，梯形的面积是 warmupPeriod。</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyLzcucG5n?x-oss-process=image/format,png"></p>\n\n<blockquote>\n<p>之所以长方形的面积是 warmupPeriod/2，是因为 coldFactor 是硬编码的 3。</p>\n</blockquote>\n\n<p>梯形面积为 warmupPeriod，即：</p>\n\n<pre class="has">\n<code>warmupPeriod = 2 * stableInterval * thresholdPermits</code></pre>\n\n<p>由此，我们得出 thresholdPermits 的值：</p>\n\n<pre class="has">\n<code>thresholdPermits = 0.5 * warmupPeriod / stableInterval</code></pre>\n\n<p>然后我们根据梯形面积的计算公式：</p>\n\n<pre class="has">\n<code>warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)</code></pre>\n\n<p>得出 maxPermits 为：</p>\n\n<pre class="has">\n<code>maxPermits = thresholdPermits + 2.0 * warmupPeriod / (stableInterval + coldInterval)</code></pre>\n\n<p>这样，我们就得到了 thresholdPermits 和 maxPermits 的值。</p>\n\n<p>接下来，我们来看一下冷却时间间隔，它指的是 storedPermits 中每个 permit 的增长速度，也就是我们前面说的 x=k 这条垂直线往右的移动速度，为了达到从 0 到 maxPermits 花费 warmupPeriodMicros 的时间，我们将其定义为：</p>\n\n<pre class="has">\n<code>@Override\ndouble coolDownIntervalMicros() {\n    return warmupPeriodMicros / maxPermits;\n}\n贴一下代码，大家就知道了，在 resync 中用到的这个：\n\nvoid resync(long nowMicros) {\n  if (nowMicros &gt; nextFreeTicketMicros) {\n    // coolDownIntervalMicros 在这里使用\n    double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();\n    storedPermits = min(maxPermits, storedPermits + newPermits);\n    nextFreeTicketMicros = nowMicros;\n  }\n}\n</code></pre>\n\n<p>基于上面的分析，我们来看 SmoothWarmingUp 的其他源码。</p>\n\n<p>首先，我们来看它的 doSetRate 方法，有了前面的介绍，这个方法的源码非常简单：</p>\n\n<pre class="has">\n<code>@Override\nvoid doSetRate(double permitsPerSecond, double stableIntervalMicros) {\n    double oldMaxPermits = maxPermits;\n    // coldFactor 是固定的 3\n    double coldIntervalMicros = stableIntervalMicros * coldFactor;\n    // 这个公式我们上面已经说了\n    thresholdPermits = 0.5 * warmupPeriodMicros / stableIntervalMicros;\n    // 这个公式我们上面也已经说了\n    maxPermits =\n        thresholdPermits + 2.0 * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);\n    // 计算那条斜线的斜率。数学知识，对边 / 临边\n    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);\n    if (oldMaxPermits == Double.POSITIVE_INFINITY) {\n        // if we don\'t special-case this, we would get storedPermits == NaN, below\n        storedPermits = 0.0;\n    } else {\n        storedPermits =\n            (oldMaxPermits == 0.0)\n                ? maxPermits // initial state is cold\n                : storedPermits * maxPermits / oldMaxPermits;\n    }\n}</code></pre>\n\n<p>setRate 方法非常简单，接下来，我们要分析的是 storedPermitsToWaitTime 方法，我们回顾一下下面的代码：</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyLzMucG5n?x-oss-process=image/format,png"></p>\n\n<p>这段代码是 acquire 方法的核心，waitMicros 由两部分组成，一部分是从 storedPermits 中获取花费的时间，一部分是等待 freshPermits 产生花费的时间。在 SmoothBursty 的实现中，从 storedPermits 中获取 permits 直接返回 0，不需要等待。</p>\n\n<p>而在 SmoothWarmingUp 的实现中，由于需要预热，所以从 storedPermits 中取 permits 需要花费一定的时间，其实就是要计算下图中，阴影部分的面积。</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyLzYucG5n?x-oss-process=image/format,png"></p>\n\n<pre class="has">\n<code>@Override\nlong storedPermitsToWaitTime(double storedPermits, double permitsToTake) {\n  double availablePermitsAboveThreshold = storedPermits - thresholdPermits;\n  long micros = 0;\n  // 如果右边梯形部分有 permits，那么先从右边部分获取permits，计算梯形部分的阴影部分的面积\n  if (availablePermitsAboveThreshold &gt; 0.0) {\n    // 从右边部分获取的 permits 数量\n    double permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);\n    // 梯形面积公式：(上底+下底)*高/2\n    double length =\n        permitsToTime(availablePermitsAboveThreshold)\n            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);\n    micros = (long) (permitsAboveThresholdToTake * length / 2.0);\n    permitsToTake -= permitsAboveThresholdToTake;\n  }\n  // 加上 长方形部分的阴影面积\n  micros += (long) (stableIntervalMicros * permitsToTake);\n  return micros;\n}\n\n// 对于给定的 x 值，计算 y 值\nprivate double permitsToTime(double permits) {\n  return stableIntervalMicros + permits * slope;\n}\n</code></pre>\n\n<p>到这里，SmoothWarmingUp 也已经说完了。</p>\n\n<p>如果大家对于 Guava RateLimiter 还有什么疑惑，欢迎在留言区留言，对于 Sentinel 中的流控不感兴趣的读者，看到这里就可以结束了。</p>\n\n<p>\xa0</p>\n\n<h2>Sentinel 中的流控</h2>\n\n<p>Sentinel 是阿里开源的流控、熔断工具，这里不做过多的介绍，感兴趣的读者请自行了解。</p>\n\n<p>在 Sentinel 的流控中，我们可以配置流控规则，主要是控制 QPS 和线程数，这里我们不讨论控制线程数，控制线程数的代码不在我们这里的讨论范围内，下面的介绍都是指控制 QPS。</p>\n\n<h3>RateLimiterController</h3>\n\n<p>RateLimiterController 非常简单，它通过使用 latestPassedTime 属性来记录最后一次通过的时间，然后根据规则中 QPS 的限制，计算当前请求是否可以通过。</p>\n\n<p>举个非常简单的例子：设置 QPS 为 10，那么每 100 毫秒允许通过一个，通过计算当前时间是否已经过了上一个请求的通过时间 latestPassedTime 之后的 100 毫秒，来判断是否可以通过。假设才过了 50ms，那么需要当前线程再 sleep 50ms，然后才可以通过。如果同时有另一个请求呢？那需要 sleep 150ms 才行。</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyL3NlbnRpbmVsLTMucG5n?x-oss-process=image/format,png"></p>\n\n<pre class="has">\n<code>public class RateLimiterController implements TrafficShapingController {\n\n    // 排队最大时长，默认 500ms\n    private final int maxQueueingTimeMs;\n    // QPS 设置的值\n    private final double count;\n        // 上一次请求通过的时间\n    private final AtomicLong latestPassedTime = new AtomicLong(-1);\n\n    public RateLimiterController(int timeOut, double count) {\n        this.maxQueueingTimeMs = timeOut;\n        this.count = count;\n    }\n\n    @Override\n    public boolean canPass(Node node, int acquireCount) {\n        return canPass(node, acquireCount, false);\n    }\n\n    // 通常 acquireCount 为 1，这里不用关心参数 prioritized\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        // Pass when acquire count is less or equal than 0.\n        if (acquireCount &lt;= 0) {\n            return true;\n        }\n        // \n        if (count &lt;= 0) {\n            return false;\n        }\n\n        long currentTime = TimeUtil.currentTimeMillis();\n        // 计算每 2 个请求之间的间隔，比如 QPS 限制为 10，那么间隔就是 100ms\n        long costTime = Math.round(1.0 * (acquireCount) / count * 1000);\n\n        // Expected pass time of this request.\n        long expectedTime = costTime + latestPassedTime.get();\n\n        // 可以通过，设置 latestPassedTime 然后就返回 true 了\n        if (expectedTime &lt;= currentTime) {\n            // Contention may exist here, but it\'s okay.\n            latestPassedTime.set(currentTime);\n            return true;\n        } else {\n            // 不可以通过，需要等待\n            long waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();\n            // 等待时长大于最大值，返回 false\n            if (waitTime &gt; maxQueueingTimeMs) {\n                return false;\n            } else {\n                // 将 latestPassedTime 往前推\n                long oldTime = latestPassedTime.addAndGet(costTime);\n                try {\n                    // 需要 sleep 的时间\n                    waitTime = oldTime - TimeUtil.currentTimeMillis();\n                    if (waitTime &gt; maxQueueingTimeMs) {\n                        latestPassedTime.addAndGet(-costTime);\n                        return false;\n                    }\n                    // in race condition waitTime may &lt;= 0\n                    if (waitTime &gt; 0) {\n                        Thread.sleep(waitTime);\n                    }\n                    return true;\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return false;\n    }\n\n}\n</code></pre>\n\n<p>这个策略还是非常好理解的，简单粗暴，快速失败。</p>\n\n<h3>WarmUpController</h3>\n\n<p>WarmUpController 用来防止突发流量迅速上升，导致系统负载严重过高，本来系统在稳定状态下能处理的，但是由于许多资源没有预热，导致这个时候处理不了了。比如，数据库需要建立连接、需要连接到远程服务等，这就是为什么我们需要预热。</p>\n\n<p>啰嗦一句，这里不仅仅指系统刚刚启动需要预热，对于长时间处于低负载的系统，突发流量也需要重新预热。</p>\n\n<p>Guava 的 SmoothWarmingUp 是用来控制获取令牌的速率的，和这里的控制 QPS 还是有一点区别，但是中心思想是一样的。我们在看完源码以后再讨论它们的区别。</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMuamF2YWRvb3AuY29tL2ltZ3MvMjA1MTAwNzkvcmF0ZS1saW1pdGVyL3NlbnRpbmVsLTIucG5n?x-oss-process=image/format,png"></p>\n\n<p>为了帮助大家理解源码，我们这边先设定一个场景：QPS 设置为 100，预热时间设置为 10 秒。代码中使用 “【】” 代表根据这个场景计算出来的值。</p>\n\n<pre class="has">\n<code>public class WarmUpController implements TrafficShapingController {\n\n    // 阈值\n    protected double count;\n    // 3\n    private int coldFactor;\n    // 转折点的令牌数，和 Guava 的 thresholdPermits 一个意思\n    // [500]\n    protected int warningToken = 0;\n    // 最大的令牌数，和 Guava 的 maxPermits 一个意思\n    // [1000]\n    private int maxToken;\n    // 斜线斜率\n    // [1/25000]\n    protected double slope;\n\n    // 累积的令牌数，和 Guava 的 storedPermits 一个意思\n    protected AtomicLong storedTokens = new AtomicLong(0);\n    // 最后更新令牌的时间\n    protected AtomicLong lastFilledTime = new AtomicLong(0);\n\n    public WarmUpController(double count, int warmUpPeriodInSec, int coldFactor) {\n        construct(count, warmUpPeriodInSec, coldFactor);\n    }\n\n    public WarmUpController(double count, int warmUpPeriodInSec) {\n        construct(count, warmUpPeriodInSec, 3);\n    }\n\n    // 下面的构造方法，和 Guava 中是差不多的，只不过 thresholdPermits 和 maxPermits 都换了个名字\n    private void construct(double count, int warmUpPeriodInSec, int coldFactor) {\n\n        if (coldFactor &lt;= 1) {\n            throw new IllegalArgumentException("Cold factor should be larger than 1");\n        }\n\n        this.count = count;\n\n        this.coldFactor = coldFactor;\n\n        // warningToken 和 thresholdPermits 是一样的意思，计算结果其实是一样的\n        // thresholdPermits = 0.5 * warmupPeriod / stableInterval.\n        // 【warningToken = (10*100)/(3-1) = 500】\n        warningToken = (int)(warmUpPeriodInSec * count) / (coldFactor - 1);\n\n        // maxToken 和 maxPermits 是一样的意思，计算结果其实是一样的\n        // maxPermits = thresholdPermits + 2*warmupPeriod/(stableInterval+coldInterval)\n        // 【maxToken = 500 + (2*10*100)/(1.0+3) = 1000】\n        maxToken = warningToken + (int)(2 * warmUpPeriodInSec * count / (1.0 + coldFactor));\n\n        // 斜率计算\n        // slope\n        // slope = (coldIntervalMicros-stableIntervalMicros)/(maxPermits-thresholdPermits);\n        // 【slope = (3-1.0) / 100 / (1000-500) = 1/25000】\n        slope = (coldFactor - 1.0) / count / (maxToken - warningToken);\n\n    }\n\n    @Override\n    public boolean canPass(Node node, int acquireCount) {\n        return canPass(node, acquireCount, false);\n    }\n\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n\n        // Sentinel 的 QPS 统计使用的是滑动窗口\n\n        // 当前时间窗口的 QPS \n        long passQps = (long) node.passQps();\n\n        // 这里是上一个时间窗口的 QPS，这里的一个窗口跨度是1分钟\n        long previousQps = (long) node.previousPassQps();\n\n        // 同步。设置 storedTokens 和 lastFilledTime 到正确的值\n        syncToken(previousQps);\n\n        long restToken = storedTokens.get();\n        // 令牌数超过 warningToken，进入梯形区域\n        if (restToken &gt;= warningToken) {\n\n            // 这里简单说一句，因为当前的令牌数超过了 warningToken 这个阈值，系统处于需要预热的阶段\n            // 通过计算当前获取一个令牌所需时间，计算其倒数即是当前系统的最大 QPS 容量\n\n            long aboveToken = restToken - warningToken;\n\n            // 这里计算警戒 QPS 值，就是当前状态下能达到的最高 QPS。\n            // (aboveToken * slope + 1.0 / count) 其实就是在当前状态下获取一个令牌所需要的时间\n            double warningQps = Math.nextUp(1.0 / (aboveToken * slope + 1.0 / count));\n            // 如果不会超过，那么通过，否则不通过\n            if (passQps + acquireCount &lt;= warningQps) {\n                return true;\n            }\n        } else {\n            // count 是最高能达到的 QPS\n            if (passQps + acquireCount &lt;= count) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    protected void syncToken(long passQps) {\n        // 下面几行代码，说明在第一次进入新的 1 秒钟的时候，做同步\n        // 题外话：Sentinel 默认地，1 秒钟分为 2 个时间窗口，分别 500ms\n        long currentTime = TimeUtil.currentTimeMillis();\n        currentTime = currentTime - currentTime % 1000;\n        long oldLastFillTime = lastFilledTime.get();\n        if (currentTime &lt;= oldLastFillTime) {\n            return;\n        }\n\n        // 令牌数量的旧值\n        long oldValue = storedTokens.get();\n        // 计算新的令牌数量，往下看\n        long newValue = coolDownTokens(currentTime, passQps);\n\n        if (storedTokens.compareAndSet(oldValue, newValue)) {\n            // 令牌数量上，减去上一分钟的 QPS，然后设置新值\n            long currentValue = storedTokens.addAndGet(0 - passQps);\n            if (currentValue &lt; 0) {\n                storedTokens.set(0L);\n            }\n            lastFilledTime.set(currentTime);\n        }\n\n    }\n\n    // 更新令牌数\n    private long coolDownTokens(long currentTime, long passQps) {\n        long oldValue = storedTokens.get();\n        long newValue = oldValue;\n\n        // 当前令牌数小于 warningToken，添加令牌\n        if (oldValue &lt; warningToken) {\n            newValue = (long)(oldValue + (currentTime - lastFilledTime.get()) * count / 1000);\n        } else if (oldValue &gt; warningToken) {\n            // 当前令牌数量处于梯形阶段，\n            // 如果当前通过的 QPS 大于 count/coldFactor，说明系统消耗令牌的速度，大于冷却速度\n            //    那么不需要添加令牌，否则需要添加令牌\n            if (passQps &lt; (int)count / coldFactor) {\n                newValue = (long)(oldValue + (currentTime - lastFilledTime.get()) * count / 1000);\n            }\n        }\n        return Math.min(newValue, maxToken);\n    }\n\n}\n</code></pre>\n\n<p>coolDownTokens 这个方法用来计算新的 token 数量，其实我也没有完全理解作者的设计：</p>\n\n<ul><li>第一、对于令牌的增加，在 Guava 中，使用 warmupPeriodMicros / maxPermits 作为增长率，因为它实现的是 storedPermits 从 0 到 maxPermits 花费的时间为 warmupPeriod。而这里是以每秒 count 个作为增长率，为什么？</li>\n\t<li>第二、else if 分支中的决定我没有理解，为什么用 passQps 和 count / coldFactor 进行对比来决定是否继续添加令牌？</li>\n\t<li>我自己的理解是，count/coldFactor 就是指冷却速度，那么就是说得通的。欢迎大家一起探讨。</li>\n</ul><p>最后，我们再简单说说 Guava 的 SmoothWarmingUp 和 Sentinel 的 WarmupController 的区别。</p>\n\n<p>Guava 在于控制获取令牌的速率，它关心的是，获取 permits 需要多少时间，包括从 storedPermits 中获取，以及获取 freshPermits，以此推进 nextFreeTicketMicros 到未来的某个时间点。</p>\n\n<p>而 Sentinel 在于控制 QPS，它用令牌数来标识当前系统处于什么状态，根据时间推进一直增加令牌，根据通过的 QPS 一直减少令牌。如果 QPS 持续下降，根据推演，可以发现 storedTokens 越来越多，然后越过 warningTokens 这个阈值，之后只有当 QPS 下降到 count/3 以后，令牌才会继续往上增长，一直到 maxTokens。</p>\n\n<blockquote>\n<p>storedTokens 是以 “count 每秒”的增长率增长的，减少是以 前一分钟的 QPS 来减少的。其实这里我也有个疑问，为什么增加令牌的时候考虑了时间，而减少的时候却不考虑时间因素，提了 issue，似乎没人搭理。</p>\n</blockquote>\n\n<h3>WarmUpRateLimiterController</h3>\n\n<p>注意，这个类继承自刚刚介绍的 WarmUpController，它的流控效果定义为排队等待。它的代码其实就是前面介绍的 RateLimiterController 加上 WarmUpController。</p>\n\n<pre class="has">\n<code>\npublic class WarmUpRateLimiterController extends WarmUpController {\n\n    private final int timeoutInMs;\n    private final AtomicLong latestPassedTime = new AtomicLong(-1);\n\n    public WarmUpRateLimiterController(double count, int warmUpPeriodSec, int timeOutMs, int coldFactor) {\n        super(count, warmUpPeriodSec, coldFactor);\n        this.timeoutInMs = timeOutMs;\n    }\n\n    @Override\n    public boolean canPass(Node node, int acquireCount) {\n        return canPass(node, acquireCount, false);\n    }\n\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        long previousQps = (long) node.previousPassQps();\n        syncToken(previousQps);\n\n        long currentTime = TimeUtil.currentTimeMillis();\n\n        long restToken = storedTokens.get();\n        long costTime = 0;\n        long expectedTime = 0;\n\n        // 和 RateLimiterController 比较，区别主要就是这块代码\n\n        if (restToken &gt;= warningToken) {\n            long aboveToken = restToken - warningToken;\n\n            // current interval = restToken*slope+1/count\n            double warmingQps = Math.nextUp(1.0 / (aboveToken * slope + 1.0 / count));\n            costTime = Math.round(1.0 * (acquireCount) / warmingQps * 1000);\n        } else {\n            costTime = Math.round(1.0 * (acquireCount) / count * 1000);\n        }\n        expectedTime = costTime + latestPassedTime.get();\n\n        if (expectedTime &lt;= currentTime) {\n            latestPassedTime.set(currentTime);\n            return true;\n        } else {\n            long waitTime = costTime + latestPassedTime.get() - currentTime;\n            if (waitTime &gt; timeoutInMs) {\n                return false;\n            } else {\n                long oldTime = latestPassedTime.addAndGet(costTime);\n                try {\n                    waitTime = oldTime - TimeUtil.currentTimeMillis();\n                    if (waitTime &gt; timeoutInMs) {\n                        latestPassedTime.addAndGet(-costTime);\n                        return false;\n                    }\n                    if (waitTime &gt; 0) {\n                        Thread.sleep(waitTime);\n                    }\n                    return true;\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return false;\n    }\n}</code></pre>\n\n<p>这个代码很简单，就是 RateLimiter 中的代码，然后加入了预热的内容。</p>\n\n<p>在 RateLimiter 中，单个请求的 costTime 是固定的，就是 1/count，比如设置 100 qps，那么 costTime 就是 10ms。</p>\n\n<p>但是这边，加入了 WarmUp 的内容，就是说，通过令牌数量，来判断当前系统的 QPS 应该是多少，如果当前令牌数超过 warningTokens，那么系统的 QPS 容量已经低于我们预设的 QPS，相应的，costTime 就会延长。</p>\n\n<h2>小结</h2>\n\n<p>有段时间没写文章了，写得不好之处，欢迎指正。</p>\n\n<p>关注作者公众号：<img alt="" class="has" src="https://img-blog.csdnimg.cn/20190825102847378.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70"></p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:22'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/99722099', 'title': '再见微服务', 'readNum': '2994', 'commentNum': '2', 'publishTime': '2019-08-19 13:44:38', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>个人博客纯净版：https://www.fangzhipeng.com/springcloud/2019/08/20/goodbye-ms.html</p>\n<p>本文翻译自Alexandra Noonan 的 Goodbye Microservices: From 100s of problem children to 1 superstar。内容是描述 Segment 的架构如何从 「单体应用」 -&gt; 「微服务」 -&gt; 「140+ 微服务」 -&gt; 「单体应用」 的一个历程。翻译比较粗糙，如有疏漏，请不吝指教。</p>\n<p>注：下文说的目的地就是对应的不同的数据平台（例如Google Analytics， Optimizely）</p>\n<blockquote>\n<p>除非你生活在石器时代，不然你一定知道「微服务」是当世最流行的架构。我们Segment早在2015年就开始实践这一架构。这让我们在一些方面上吃了不少甜头，但很快我们发现：在其他场景，他时不时让我们吃了苦头。</p>\n</blockquote>\n<p>简而言之，微服务的主要宣传点在于：模块化优化，减少测试负担，更好的功能组成，环境独立，而且开发团队是自治的（因为每一个服务的内部逻辑是自洽且独立的）。而另一头的单体应用：「巨大无比且难以测试，而且服务只能作为一个整理来伸缩（如果你要提高某一个服务的性能，只能把服务器整体提高）」</p>\n<p>2017 早期，我们陷入了僵局，复杂的微服务树让我们的开发效率骤减，并且每一个开发小组都发现自己每次实现都会陷入巨大的复杂之中，此时，我们的缺陷率也迅速上升。</p>\n<p>最终，我们不得不用三个全职工程师来维护每一个微服务系统的正常运行。这次我们意识到改变必须发生了，本文会讲述我们如何后退一步，让团队需要和产品需求完全一致的方法。</p>\n<h2><a id="_16"></a>为什么微服务曾经可行？</h2>\n<p>Segment 的客户数据基础设施吸收每秒成百上千个事件，将每一个伙伴服务的API 请求结果一个个返回给对应的服务端的「目的地」。而「目的地」有上百种类别，例如Google Analytics， Optimizely，或者是一些自定义的webhook。</p>\n<p>几年前，当产品初步发布，当时架构很简单。仅仅是一个接收事件并且转发的消息队列。在这个情况下，事件是由Web或移动应用程序生成的JSON对象，例子如下：</p>\n<pre><code class="prism language-java"><span class="token punctuation">{</span>\n  <span class="token string">"type"</span><span class="token operator">:</span> <span class="token string">"identify"</span><span class="token punctuation">,</span>\n  <span class="token string">"traits"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"Alex Noonan"</span><span class="token punctuation">,</span>\n    <span class="token string">"email"</span><span class="token operator">:</span> <span class="token string">"anoonan@segment.com"</span><span class="token punctuation">,</span>\n    <span class="token string">"company"</span><span class="token operator">:</span> <span class="token string">"Segment"</span><span class="token punctuation">,</span>\n    <span class="token string">"title"</span><span class="token operator">:</span> <span class="token string">"Software Engineer"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token string">"userId"</span><span class="token operator">:</span> <span class="token string">"97980cfea0067"</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>事件是从队列中消耗的，客户的设置会决定这个事件将会发送到哪个目的地。这个事件被纷纷发送</p>\n<p>到每个目的地的API，这很有用，开发人员只需要将他们的事件发送到一个特定的目的地——也就是</p>\n<p>Segment 的API，而不是你自己实现几十个项目集成。</p>\n<p>如果一个请求失败了，有时候我们会稍后重试这个事件。一些失败的重试是安全的，但有些则不。可重试的错误可能会对事件目的地不造成改变，例如：50x错误，速率限制，请求超时等。不可重试的错误一般是这个请求我们确定永远都不会被目的地接受的。例如：请求包含无效的认证亦或是缺少必要的字段。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTM5MzMzZjNlM2Y2YTRmOGEucG5n" alt="image.png"></p>\n<p>此时，一个简单的队列包含了新的事件请求以及若干个重试请求，彼此之间事件的目的地纵横交错，会导致的结果显而易见：队头阻塞。意味着在这个特定的场景下，如果一个目的地变慢了或者挂掉了，重试请求将会充斥这个队列，从而整个请求队列会被拖慢。</p>\n<p>想象下我们有一个 目的地 X 遇到一个临时问题导致每一个请求都会超时。这不仅会产生大量尚未到达目的地 X的请求，而且每一个失败的事件将会被送往重试的队列。即便我们的系统会根据负载进行弹性伸缩，但是请求队列深度突然间的增长会超过我们伸缩的能力，结果就是新的时间推送会延迟。发送时间到每一个目的地的时间将会增加因为目的地X 有一个短暂的停止服务（因为临时问题）。客户依赖于我们的实时性，所以我们无法承受任何程度上的缓慢。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LWM2MWFhNGYxZjBjN2JiMDEucG5n" alt="image.png"></p>\n<p>为了解决这个队头阻塞问题，我们团队给每一个目的地都分开实现了一个队列，这种新架构由一个额外的路由器进程组成，该进程接收入站事件并将事件的副本分发给每个选定的目标。现在如果一个目的地有超时问题，那么也仅仅是这个队列会进入阻塞而不会影响整体。这种「微服务风格」的架构分离把目的地彼此分开，当一个目的地老出问题，这种设计就显得很关键了。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTM5Yjk2OTcyODQ4NjdlODMucG5n" alt="image.png"></p>\n<h2><a id="Repo__56"></a>个人Repo 的例子</h2>\n<p>每一个目的地的API 的请求格式都不同，需要自定义的代码去转换事件来匹配格式。一个简单的例子：还是目的地X，有一个更新生日的接口，作为请求内容的格式字段为 dob ，API 会对你要求字段为 birthday，那么转换代码就会如下:</p>\n<pre><code>const traits = {}\ntraits.dob = segmentEvent.birthday\n</code></pre>\n<p>许多现代的目的地终点都用了Segment 的请求格式，所以转换会很简单。但是，这些转换也可能会</p>\n<p>十分复杂，取决于目的地API 的结构。</p>\n<p>起初，目的地分成几个拆分的服务的时候，所有的代码都会在一个repo 里。一个巨大的挫折点就是一个测试的失败常常会导致整个项目测试无法跑通。我们可能会为此付出大量的时间只是为了让他像之前一样正常运行通过测试。为了解决这个问题，我们把每一个服务都拆分成一个单独的repo，所有的目的地的测试错误都只会影响自己，这个过渡十分自然。</p>\n<p>拆分出来的repo 来隔离开每一个目的地会让测试的实现变得更容易，这种隔离允许开发团队快速开发以及维护每一个目的地。</p>\n<h2><a id="Repo__73"></a>伸缩微服务和Repo 们</h2>\n<p>随着时间的偏移，我们加了50多个新的目的地，这意味着有50个新的repo。为了减轻开发和维护这些codebase 的负担，我们创建一个共享的代码库来做实现一些通用的转换和功能，例如HTTP 请求的处理，不同目的地之间代码实现更具有一致性。</p>\n<p>例如：如果我们要一个事件中用户的名字，event.name() 可以是任何一个目的地里头的调用。共享的类库会去尝试判断event 里的 name 或者 Name 属性，如果没有，他会去查 first name，那么就回去查找first_name 和 FirstName，往下推：last name 也会做这样的事情。然后吧first name 和last name 组合成full name.</p>\n<pre><code>Identify.prototype.name = function() {\n  var name = this.proxy(\'traits.name\');\n  if (typeof name === \'string\') {\n    return trim(name)\n  }\n  var firstName = this.firstName();\n  var lastName = this.lastName();\n  if (firstName &amp;&amp; lastName) {\n    return trim(firstName + \' \' + lastName)\n  }\n}\n</code></pre>\n<p>共享的代码库让我们能快速完成新的目的地的实现，他们之间的相似性带给我们一致性的实现而且维护上也让我们减少了不少头疼的地方。</p>\n<p>尽管如此，一个新的问题开始发生并蔓延。共享库代码改变后的测试和部署会影响所有的目的地。这开始让我们需要大量时间精力来维护它。修改或者优化代码库，我们得先测试和部署几十个服务，这其中会带来巨大的风险。时间紧迫的时候，工程师只会在某个特定的目的地去更新特定版本的共享库代码。</p>\n<p>紧接着，这些共享库的版本开始在不同的目标代码库中发生分歧。微服务起初带给我们的种种好处，在我们给每一个目的地都做了定制实现后开始反转。最终，所有的微服务都在使用不同版本的共享库——我们本可以用自动化地发布最新的修改。但在此时，不仅仅是开发团队在开发中受阻，我们还在其他方面遇到了微服务的弊端。</p>\n<p>这额外的问题就是每一个服务都有一个明确的负载模式。一些服务每天仅处理寥寥几个请求，但有的服务每秒就要处理上千个请求。对于处理事件较少的目的地，当负载出现意外峰值时，运维必须手动伸缩服务以满足需求。（编者注，肯定有解决方案，但原作者突出的还是复杂度和成本。）</p>\n<p>当我们实现了自动伸缩的实现，每个服务都具有所需CPU和内存资源的明显混合，这让我们的自动伸缩配置与其说是科学的，不如说更具有艺术性（其实就是蒙的）。</p>\n<p>目的地的数量极速增长，团队以每个月三个（目的地）的速度增长着，这意味着更多的repo，更多的队列，更多的服务。我们的微服务架构的运维成本也是线性地增长着。因此，我们决定退后一步，重新考虑整个流程。</p>\n<h2><a id="_105"></a>深挖微服务以及队列</h2>\n<p>这时列表上第一件事就是如何巩固当前超过140个服务到一个服务中，管理所有服务的带来的各种成本成了团队巨大的技术债务。运维工程师几乎无眠，因为随时出现的流量峰值必须让工程师随时上线处理。</p>\n<p>尽管如此，当时把项目变成单一服务的架构是一个巨大的挑战。要让每一个目的地拥有一个分离的队列，每一个 worker进程需要检查检查每一队列是否运行，这种给目的地服务增加一层复杂的实现让我们感到了不适。这是我们「离心机」的主要灵感来源，「离心机」将替换我们所有的个体队列，并负责将事件发送到一个单体服务。</p>\n<p>译者注：「离心机」其实就是Segment 制作的一个事件分发系统。 相关地址</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LWFmNGIzNGZkMDBmZWMyZWMucG5n" alt="image.png"></p>\n<h2><a id="Repo_115"></a>搬到一个单体Repo</h2>\n<p>所以我们开始把所有的目的地代码合并到了一个repo，这意味着所有的依赖和测试都在一个单一的repo 里头了，我们知道我们要面对的，会是一团糟。</p>\n<p>120个依赖，我们都提交了一个特定的版本让每一个目的地都兼容。当我们搬完了目的地，我们开始检查每一个对应的代码是否都是用的最新的依赖。我们保证每一个目的地在最新的依赖版本下，都能正确运行。</p>\n<p>这些改变中，我们再也不用跟踪依赖的版本了。所有目的地都使用同一版本，这显著地减小了codebase 的代码复杂度。维护目的地变得快捷而且风险也变小了。</p>\n<p>另一方面我们也需要测试能简单快速地运行起来，之前我们得出的结论之一就是：「不去修改共享库文件主要的阻碍就是得把测试都跑一次。」</p>\n<p>幸运的是，目的地测试都有着相似的架构。他们都有基础的单元测试来验证我们的自定义转换逻辑是否正确，而且也能验证HTTP 的返回是否符合我们的期望值。</p>\n<p>回想起我们的出新是分离每一个目的地的codebase 到各自的repo 并且分离各自测试的问题。尽管如此，现在看来这个想法是一个虚假的优势。HTTP 请求的发送仍然以某种频率失败着。因为目的地分离到各自的repo，所以大家也没有动力去处理这类失败的请求。这也让我们走进了某种令人沮丧的恶性循环。本应只需几个小时的小改动常常要花上我们几天甚至一周的时间。</p>\n<h2><a id="_129"></a>构建一个弹性测试套件</h2>\n<p>给目的地发送的HTTP 请求失败是我们主要的失败测试原因，过期凭证等无关的问题不应该使测试失败。我们从中也发现一些目的地的请求会比其他目的地慢不少。一些目的地的测试得花上5 分钟才能跑完，我们的测试套件要花上一小时时间才能全部跑完。</p>\n<p>为了解决这个问题，我们制作了一个「Traffic Recorder」，「Traffic Recorder」是一个基于yakbak 实现的工具，用于记录并且保存一些请求。无论何时一个测试在他第一次跑的时候，对应的请求都会被保存到一个文件里。后来的测试跑的时候，就会复用里头的返回结果。同时这个请求结果也会进入repo，以便在测试中也是一致的。这样一来，我们的测试就不再依赖于网络HTTP请求，为了接下来的单一repo 铺好了路。</p>\n<p>记得第一次整合「Traffic Recorder」后，我们尝试跑一个整体的测试，完成 140+ 目的地的项目整体测试只需几毫秒。这在过去，一个目的地的测试就得花上几分钟，这快得像魔术一般。</p>\n<h2><a id="_137"></a>为何单体应用可行</h2>\n<p>只要每个目的地都被整合到一个repo，那么他就能作为一个单一的服务运行。所有目的地都在一个服务中，开发团队的效率显著提高。我们不因为修改了共享库而部署140+ 个服务，一个工程师可以一分钟内重新完成部署。</p>\n<p>速度是肉眼可见地被提升了，在我们的微服务架构时期，我们做了32个共享库的优化。再变成单体之后我们做了46个，过去6个月的优化甚至多过2016年整年。</p>\n<p>这个改变也让我们的运维工程师大为受益，每一个目的地都在一个服务中，我们可以很好进行服务的伸缩。巨大的进程池也能轻松地吸收峰值流量，所以我们也不用为小的服务突然出现的流量担惊受怕了。</p>\n<h2><a id="_144"></a>坏处</h2>\n<p>尽管改变成单体应用给我们带来巨大的好处，尽管如此，以下是坏处：</p>\n<ul>\n<li>\n<ol>\n<li>故障隔离很难，所有东西都在一个单体应用运行的时候，如果一个目的地的bug 导致了服务的崩溃，那么这个目的地会让所有的其他的目的地一起崩溃（因为是一个服务）。我们有全面的自动化测试，但是测试只能帮你一部分。我们现在在研究一种更加鲁棒的方法，来让一个服务的崩溃不会影响整个单体应用。</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>内存缓存的效果变低效了。之前一个服务对应一个目的地，我们的低流量目的地只有少量的进程，这意味着他的内存缓存可以让很多的数据都在热缓存中。现在缓存都分散给了3000+个进程所以缓存命中率大大降低。最后，我们也只能在运维优化的前提下接受了这一结果。</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>更新共享库代码的版本可能会让几个目的地崩溃。当把项目整合的到一起的时候，我们解决过之前的依赖问题，这意味着每个目的地都能用最新版本的共享库代码。但是接下来的共享库代码更新意味着我们可能还需要修改一些目的地的代码。在我们看来这个还是值得的，因为自动化测试环节的优化，我们可以更快的发现新的依赖版本的问题。</li>\n</ol>\n</li>\n</ul>\n<h2><a id="_151"></a>结论</h2>\n<p>我们起初的微服务架构是符合当时的情况的，也解决了当时的性能问题还有目的地之间孤立实现。尽管如此，我们没有准备好服务激增的改变准备。当需要批量更新时，我们缺乏适当的工具来测试和部署微服务。结果就是，我们的研发效率因此出现了滑坡。</p>\n<p>转向单体结构使我们能够摆脱运维问题，同时显着提高开发人员的工作效率。我们并没有轻易地进行这种转变，直到确信它能够发挥作用。</p>\n<ul>\n<li>\n<ol>\n<li>我们需要靠谱的测试套件来让所有东西都放到一个repo。没有它，我们可能最终还是又把它拆分出去。频繁的失败测试在过去损害了我们的生产力，我们不希望再次发生这种情况。</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>我们接受一些单体架构的固有的坏处而且确保我们能最后得到一个好的结果。我们对这个牺牲是感到满意的。</li>\n</ol>\n</li>\n</ul>\n<p>在单体应用和微服务之间做决定的时候，有些不同的因素是我们考虑的。在我们基础设施的某些部分，微服务运行得很好。但我们的服务器端，这种架构也是真实地伤害了生产力和性能的完美示例。但到头来，我们最终的解决方案是单体应用。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/100060140', 'title': '日志排查问题困难？分布式日志链路跟踪来帮你', 'readNum': '2832', 'commentNum': '0', 'publishTime': '2019-08-25 09:39:58', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>作者：朱乐陶，软件架构师，具备多年Java开发及架构设计经验，擅长微服务领域</p>\n\n<p>作者博客：https://blog.csdn.net/zlt2000</p>\n</blockquote>\n\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/springcloud/2019/08/21/distributed-logs.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/08/21/distributed-logs.html</a></strong></p>\n\n<h2>背景</h2>\n\n<p>开发排查系统问题用得最多的手段就是查看系统日志，在分布式环境中一般使用ELK来统一收集日志，但是在并发大时使用日志定位问题还是比较麻烦，由于大量的其他用户/其他线程的日志也一起输出穿行其中导致很难筛选出指定请求的全部相关日志，以及下游线程/服务对应的日志。</p>\n\n<p>\xa0</p>\n\n<h2>解决思路</h2>\n\n<p>每个请求都使用一个唯一标识来追踪全部的链路显示在日志中，并且不修改原有的打印方式(代码无入侵)使用Logback的MDC机制日志模板中加入traceId标识，取值方式为%X{traceId}</p>\n\n<blockquote>\n<p>MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。MDC 可以看成是一个与当前线程绑定的Map，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p>\n</blockquote>\n\n<h2>方案实现</h2>\n\n<p>由于MDC内部使用的是ThreadLocal所以只有本线程才有效，子线程和下游的服务MDC里的值会丢失；所以方案主要的难点是解决值的传递问题，主要包括以几下部分：</p>\n\n<ul><li>API网关中的MDC数据如何传递给下游服务</li>\n\t<li>服务如何接收数据，并且调用其他远程服务时如何继续传递</li>\n\t<li>异步的情况下(线程池)如何传给子线程</li>\n</ul><h3>修改日志模板</h3>\n\n<p>logback配置文件模板格式添加标识%X{traceId}</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190815162715676.png"></p>\n\n<h3>网关添加过滤器</h3>\n\n<p>生成traceId并通过header传递给下游服务</p>\n\n<pre class="has">\n<code>@Component\npublic class TraceFilter extends ZuulFilter {\n    @Autowired\n    private TraceProperties traceProperties;\n\n    @Override\n    public String filterType() {\n        return FilterConstants.PRE_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return FORM_BODY_WRAPPER_FILTER_ORDER - 1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        //根据配置控制是否开启过滤器\n        return traceProperties.getEnable();\n    }\n\n    @Override\n    public Object run() {\n        //链路追踪id\n        String traceId = IdUtil.fastSimpleUUID();\n        MDC.put(CommonConstant.LOG_TRACE_ID, traceId);\n        RequestContext ctx = RequestContext.getCurrentContext();\n        ctx.addZuulRequestHeader(CommonConstant.TRACE_ID_HEADER, traceId);\n        return null;\n    }\n}\n\n</code></pre>\n\n<p>\xa0</p>\n\n<h3>下游服务增加spring拦截器</h3>\n\n<p>接收并保存traceId的值<strong>拦截器</strong></p>\n\n<pre class="has">\n<code>public class TraceInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {\n        String traceId = request.getHeader(CommonConstant.TRACE_ID_HEADER);\n        if (StrUtil.isNotEmpty(traceId)) {\n            MDC.put(CommonConstant.LOG_TRACE_ID, traceId);\n        }\n        return true;\n    }\n}\n</code></pre>\n\n<p><strong>注册拦截器</strong></p>\n\n<pre class="has">\n<code>public class DefaultWebMvcConfig extends WebMvcConfigurationSupport {\n  @Override\n  protected void addInterceptors(InterceptorRegistry registry) {\n    //日志链路追踪拦截器\n    registry.addInterceptor(new TraceInterceptor()).addPathPatterns("/**");\n\n    super.addInterceptors(registry);\n  }\n}\n</code></pre>\n\n<p>\xa0</p>\n\n<h3>下游服务增加feign拦截器</h3>\n\n<p>继续把当前服务的traceId值传递给下游服务</p>\n\n<pre class="has">\n<code>public class FeignInterceptorConfig {\n    @Bean\n    public RequestInterceptor requestInterceptor() {\n        RequestInterceptor requestInterceptor = template -&gt; {\n            //传递日志traceId\n            String traceId = MDC.get(CommonConstant.LOG_TRACE_ID);\n            if (StrUtil.isNotEmpty(traceId)) {\n                template.header(CommonConstant.TRACE_ID_HEADER, traceId);\n            }\n        };\n        return requestInterceptor;\n    }\n}\n</code></pre>\n\n<p>\xa0</p>\n\n<h3>解决父子线程传递问题</h3>\n\n<p>主要针对业务会使用线程池(异步、并行处理)，并且spring自己也有@Async注解来使用线程池，要解决这个问题需要以下两个步骤</p>\n\n<p>重写logback的LogbackMDCAdapter</p>\n\n<p>由于logback的MDC实现内部使用的是ThreadLocal不能传递子线程，所以需要重写替换为阿里的TransmittableThreadLocal</p>\n\n<blockquote>\n<p>TransmittableThreadLocal 是Alibaba开源的、用于解决 “在使用线程池等会缓存线程的组件情况下传递ThreadLocal” 问题的 InheritableThreadLocal 扩展。若希望 TransmittableThreadLocal 在线程池与主线程间传递，需配合 TtlRunnable 和 TtlCallable 使用。</p>\n</blockquote>\n\n<p>TtlMDCAdapter类</p>\n\n<pre class="has">\n<code>package org.slf4j;\n\nimport com.alibaba.ttl.TransmittableThreadLocal;\nimport org.slf4j.spi.MDCAdapter;\n\npublic class TtlMDCAdapter implements MDCAdapter {\n    /**\n     * 此处是关键\n     */\n    private final ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnInheritThreadLocal = new TransmittableThreadLocal&lt;&gt;();\n\n    private static TtlMDCAdapter mtcMDCAdapter;\n\n    static {\n        mtcMDCAdapter = new TtlMDCAdapter();\n        MDC.mdcAdapter = mtcMDCAdapter;\n    }\n\n    public static MDCAdapter getInstance() {\n        return mtcMDCAdapter;\n    }</code></pre>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>其他代码与ch.qos.logback.classic.util.LogbackMDCAdapter一样，只需改为调用copyOnInheritThreadLocal变量</p>\n</blockquote>\n\n<p>TtlMDCAdapterInitializer类用于程序启动时加载自己的mdcAdapter实现</p>\n\n<pre class="has">\n<code>public class TtlMDCAdapterInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {\n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) {\n        //加载TtlMDCAdapter实例\n        TtlMDCAdapter.getInstance();\n    }\n}\n</code></pre>\n\n<p>\xa0</p>\n\n<h3>扩展线程池实现</h3>\n\n<p>增加TtlRunnable和TtlCallable扩展实现TTL</p>\n\n<pre class="has">\n<code>public class CustomThreadPoolTaskExecutor extends ThreadPoolTaskExecutor {\n    @Override\n    public void execute(Runnable runnable) {\n        Runnable ttlRunnable = TtlRunnable.get(runnable);\n        super.execute(ttlRunnable);\n    }\n\n    @Override\n    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {\n        Callable ttlCallable = TtlCallable.get(task);\n        return super.submit(ttlCallable);\n    }\n\n    @Override\n    public Future&lt;?&gt; submit(Runnable task) {\n        Runnable ttlRunnable = TtlRunnable.get(task);\n        return super.submit(ttlRunnable);\n    }\n\n    @Override\n    public ListenableFuture&lt;?&gt; submitListenable(Runnable task) {\n        Runnable ttlRunnable = TtlRunnable.get(task);\n        return super.submitListenable(ttlRunnable);\n    }\n\n    @Override\n    public &lt;T&gt; ListenableFuture&lt;T&gt; submitListenable(Callable&lt;T&gt; task) {\n        Callable ttlCallable = TtlCallable.get(task);\n        return super.submitListenable(ttlCallable);\n    }\n}\n</code></pre>\n\n<p>\xa0</p>\n\n<h2>场景测试</h2>\n\n<p>\xa0</p>\n\n<h3>测试代码如下</h3>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190815162750256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psdDIwMDA=,size_16,color_FFFFFF,t_70"></p>\n\n<h3>api网关打印的日志</h3>\n\n<p>网关生成traceId值为13d9800c8c7944c78a06ce28c36de670</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190815162806994.png"></p>\n\n<h3>请求跳转到文件服务时打印的日志</h3>\n\n<p>显示的traceId与网关相同，这里特意模拟发生异常的场景</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://img-blog.csdnimg.cn/20190815162815639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psdDIwMDA=,size_16,color_FFFFFF,t_70"></p>\n\n<h3>ELK聚合日志通过traceId查询整条链路日志</h3>\n\n<p>当系统出现异常时，可直接通过该异常日志的traceId\u200b的值，在日志中心中询该请求的所有日志信息</p>\n\n<p style="text-align:center;"><img alt="" class="has" src="https://img-blog.csdnimg.cn/2019081516283177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psdDIwMDA=,size_16,color_FFFFFF,t_70"></p>\n\n<h2>源码下载</h2>\n\n<p>附上我的开源微服务框架(包含本文中的代码)，欢迎 star 关注</p>\n\n<blockquote>\n<p>https://gitee.com/zlt2000/microservices-platform</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p><img alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" class="has" height="258" src="https://img-blog.csdnimg.cn/20190825093958777.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="258"><br>\n扫一扫，支持下作者吧</p>\n\n<p><strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/99559611', 'title': '网络：TCP、IP协议族(三) 数字签名与HTTPS详解', 'readNum': '2100', 'commentNum': '0', 'publishTime': '2019-08-14 13:19:59', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>前面几篇博客聊了HTTP的相关东西，今天就来聊一聊HTTPS的东西。因为HTTP协议本身存在着明文传输、不能很好的验证通信方的身份和无法验证报文的完整性等一些安全方面的确点，所以才有了HTTPS的缺陷。HTTPS确切的的说不是一种协议，而是HTTP + SSL (TSL)的结合体。HTTP报文经过SSL层加密后交付给TCP层进行传输。SSL(安全套节层)主要采取的是RSA（非对称加密）与AES（对称加密）结合的加密方式。先通过RSA交互AES的密钥，然后通过AES进行报文加密和解密。本篇博客主要聊的就是HTTPS具体的工作过程。</p>\n<!--more-->\n<h2><a id="RSAAES_5"></a>RSA与AES简述</h2>\n<p>在本篇博客的第一部分呢，先聊一下RAS与AES这两个加密策略，如果你在公司做过支付相关的东西，对数据传输的安全性要求比较高，这时候就得采取一些加密措施将传输的报文进行加密，必要时再进行MD5验签。当然本部分聊的RAS与AES是比较简洁的，关于这两者具体的内容，请自行Google吧。因为HTTPS在传输的过程中使用到了RSA与AES加密算法，所以在聊HTTP+SSL之前呢，我们先简单的聊一下AES与RSA。</p>\n<h3><a id="Advanced_Encryption_Standard_AES__9"></a>Advanced Encryption Standard （AES: 高级加密标准）</h3>\n<p>AES，全称：Advanced Encryption Standard----高级加密标准。该加密算法有一个密钥，该密钥可以用来加密，也可以用来解密，所以AES是对称加密算法。下方这个就是AES加密和解密的过程。Client端与Server端有一个共同的Key, 这个Key是用来加密和解密的。如果报文在传输的过程中被窃取了，没有这个key, 对加密的内容进行破解是非常困难的，当然窃取者如果有key的话，也是可以轻而易举的解密的。所以在AES中，key是关键。这也就相当于你们家的门钥匙，谁拿到钥匙后都可以打开你们家的门。即使门锁再结实，再安全，在钥匙面前也是不行呢。</p>\n<p>所以对于AES加密策略来说这个Key的保密措施要做足一些，如果之后有时间的话可以分享一些具体的AES加密策略。比如每次加密的Key都是从一个密码本中动态生成的，而这个密码本服务端和客户端都有同一本，每次传输的是一些参数。这些参数在经过一些算法的映射，从密码本中取出相应的key用来解密。这样一来，就相当于给AES加了一层防盗门，加大了破解的难度。这样做的好处是每次加密的key都是不同的，而且需要密码本以及映射算法的支持。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNjJjYmIzOTU2MWI3ZDJhZS5wbmc" alt="image"></p>\n<h3><a id="RSA__17"></a>RSA 公钥加密算法</h3>\n<p>RAS这个名字，就是该算法三位发明者的名字的首字母的组合。RAS是非对称加密，其在加密和解密的过程中，需要两个Key，一个公钥（public key），一个是私钥（private key）。公钥负责加密，而私钥负责解密。从名字就可以看出，公钥是可以开放出去的，任何人都可以持有公钥进行加密。而私钥必须得进行保护，因为是用来解密的。</p>\n<p>这样一来，加密和解密就可以用不同的钥匙来处理。对于加密放来说，即使你可以对报文进行加密，如果没有私有的话也是不可以对你加密的内容进行解密的。这就相当于一个盒子，盒子上有把锁。你可以把东西放进去，然后再锁上盒子。但是如果你没有钥匙的话，也是打不开这把锁的。</p>\n<p>下方这个简图就是服务端单向验证的RAS非对称加密算法，Client内置了一个公钥，该公钥与Server端的私钥是配对的，所以Client端可以使用这个内置的Public key加密，而服务端就可以使用这个private key进行解密。目前最常用的是服务端单向认证机制。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNzVlMGEyYzEyYjBmM2IzZi5wbmc" alt="image"></p>\n<h2><a id="CA_27"></a>CA证书</h2>\n<p>如果你自己通过RAS算法生成了一个私钥和公钥，在公钥发送给客户端的过程中有可能被篡改成其他的公钥，而客户端在没有其他措施的保护下是不知道该公钥是否就是服务器那边的私钥对应的公钥的。这种自己做的RAS的公钥和私钥有可能在公钥分发的过程中被篡改。下方就是Client从Server端获取公钥时被中间者篡改了，将public换成了自己的伪public key, 同样这个中间者持有这个伪public key所对应的伪private key。如果客户端使用的伪public key进行加密传输的话，那么中间者是可以使用自己的private key进行解密的。</p>\n<p>举个例子来类比一下这个问题。</p>\n<p>假设你在古代，你出门在外，妻子在家养子。你们家有个箱子，箱子上有把锁，这就是你和你妻子互通的工具。你媳妇儿负责往箱子里放东西，然后上锁。你有把独特的钥匙，你负责开锁，取东西。可是你再将箱子给镖局托运的的过程中，被镖局的“小黑”掉包了，箱子的外表一致，锁看起来也一样，可是已经不是你的箱子了。因为路途遥远，古代又没有什么iPhone啥的，你媳妇没办法来辨别该箱子是否是原装的。然后就将一些东西放在了箱子里边，然后上锁交给了镖局的“小黑”。</p>\n<p>因为“小黑”掉包的箱子，所以小黑有箱子的钥匙呢，然后就可以打开这个箱子，取东西了。原来的箱子又在小黑那，小黑就可以往原来的箱子里边随便往箱子放点没有价值的东西给你就行了。当你发现箱子里的东西不是你想要的时候，完了，小黑从镖局辞职了，找不到人了。找镖局的人讨说法，可是镖局的人说“小黑”是镖局的临时工，这个责任镖局说了，我们不能担。鉴于你无权无势，这事儿也就此罢了。（故事纯属虚构，如有雷同纯属巧合）</p>\n<p>关于更多骗子的故事请移步网络剧《毛骗》一二三季。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMjg0NzQ2NDQ3MWEzMzM0NC5wbmc" alt="image"></p>\n<p>为了防止“小黑”再次作案，所以颁布一个公正机构来证明你媳妇收到的箱子就是你发出的箱子。在RAS加密中也有一个第三方机构来充当这个角色，负责证明客户端收到的证书就是你发送的证书，中间没有被篡改。这个中间认证机构，就是数组证书认证机构, 其颁发的证书也就是我们常说的CA证书（CA , Certificate Authority）。</p>\n<p>下面我们就来详细的叙述一下证书签名，证书分发以及证书验证的整个过程。</p>\n<ul>\n<li>1、服务端人员使用RSA算法生成两个密钥，一个用来加密一个用来解密。将负责加密的那个密钥公布出去，所以我们称之为公钥（Public Key），而用来解密的那个密钥，不能对外公布，只有服务端持有，所以我们称之为私钥（Private Key）。服务端在将Public Key进行分发证书之前需要向CA机构申请给将要分发的公钥进行数字签名。（服务器公钥负责加密，服务器私钥负责解密）</li>\n<li>2、生成数字签名公钥证书：对于CA机构来说，其也有两个密钥，我们暂且称之为CA私钥和CA公钥。CA机构将服务端的Public Key作为输入参数将其转换为一个特有的Hash值。然后使用CA私钥将这个Hash值进行加密处理，并与服务端的Public Key绑定在一起，生成数字签名证书。其实数字签名证书的本质就是服务端的公钥+CA私钥加密的Hash值。（CA私钥负责签名，CA公钥负责验证）</li>\n<li>3、服务器获取到这个已经含有数字签名并带有公钥的证书，将该证书发送给客户端。当客户端收到该公钥数字证书后，会验证其有效性。大部分客户端都会预装CA机构的公钥，也就是CA公钥。客户端使用CA公钥对数字证书上的签名进行验证，这个验证的过程就是使用CA公钥对CA私钥加密的内容进行解密，将解密后的内容与服务端的Public Key所生成的Hash值进行匹配，如果匹配成功，则说明该证书就是相应的服务端发过来的。否则就是非法证书。</li>\n<li>4、验证完服务端公钥的合法性后，就可以使用该公钥进行加密通信了。</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtYjc0ZjVhMjM3OWE1MGE5OS5wbmc" alt="image"></p>\n<p>下方这个截图就是苹果的根证书的一些信息，从下方可以看出，CA证书内容中包括加密算法，公共密钥以及数字签名。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZGQ4ZjhjYWY4NTE2ZTViYy5wbmc" alt="image"></p>\n<p>下方就是公钥以及数字签名的具体内容，当对下方公共密钥进行验证时，需要使用内置的CA公钥将数字签名进行解密。然后将解密后的内容，与公钥生成的Hash值进行比较，如果匹配成功，那么该证书就是CA机构颁布的合法证书。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNDIwMTBmMDViNDUxMjU0Ny5wbmc" alt="image"></p>\n<h2><a id="HTTPS_63"></a>HTTPS安全通信机制的建立</h2>\n<p>上面我们聊完AES与RSA加密策略，然后又聊了带有数字签名的公共密钥。上面这两部分内容都是为HTTPS做铺垫的，接下来就看一看HTTP+SSL是如何进行数据传输的。</p>\n<h3><a id="HTTPS_67"></a>HTTPS简介</h3>\n<p>在开头的部分也说了，HTTPS不是一个新的通信协议，而是HTTP与SSL（或TSL）的组合。SSL–安全套节层(Secure Socket Layer), TSL（Transport Layer Security 安全传输层）是以SSL为原型开发的协议，IETF以SSL3.0为基准后又制定了TLS1.0、TLS1.1和TLS1.2，当前主流版本为SSL3.0与TLS1.0。</p>\n<p>HTTPS就是在HTTP与TCP层中间添加了一个SSL层。因为HTTPS被HTTP多了这层加密的流程，所以HTTPS的速度要比HTTP慢的多。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNjc5OTg1YzdkOWI3MDhhOS5wbmc" alt="image"></p>\n<h3><a id="HTTPS_75"></a>HTTPS的通信过程</h3>\n<p>SSL的加密过程是RSA与AES混合进行的。简单概括一下，就是通过RSA加密方式来交换AES加解密的密钥，然后使用AES加密的方式来传输报文。下方是SSL建立连接以及传输数据的图解。在下图中大体可以分为四步：</p>\n<ul>\n<li>第一步：有客户端发起的第一次握手，此次握手过程的主要目的是从服务端获取数字签名证书，服务端在发送数字签名证书之前要先确认客户端的SSL版本、加密算法等信息。</li>\n<li>第二步：完成第一次握手后，接着进行第二次握手。第二次握手是在客户端收到证书后发起的，主要目的是将AES加解密使用的Key （Pre-master secret）发送给服务端。当然这个AES_KEY是使用第一次握手获取的公钥进行加密的。客户端收到这个使用公钥加密后的AES_KEY，使用服务端的私钥进行解密。这样客户端和服务端经过二次握手后都持有了AES加解密的KEY。</li>\n<li>第三步：当Client与Server端都持有AES_KEY后，就可以对HTTP报文进行加解密了。</li>\n<li>END: 最后就是断开连接了。具体如下图所示：</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtOTNhNGY5YmE0MjlhOTEwYi5wbmc" alt="image"></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/99559475', 'title': '网络：TCP、IP协议族(二) HTTP报文头解析', 'readNum': '2048', 'commentNum': '0', 'publishTime': '2019-08-14 13:18:55', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>本篇博客我们就来详细的聊一下HTTP协议的常用头部字段，当然我们将其分为请求头和响应头进行阐述。下方是报文头每个字段的格式，首先是头部字段的名称，如Accept，冒号后方紧跟的是该字段名所对应的值，每个值之间有逗号分隔。如果该值需要优先级，那么在值的后方跟上优先级q=0.8(q的值由0~1，优先级从低到高)。值与优先级中间由分号相隔。</p>\n<!--more-->\n<blockquote>\n<p>头部字段名：值1, 值2;q=0.8</p>\n</blockquote>\n<p>下方就是截取的网络请求中Request Headers的部分内容。红框中的Accept-Language就是头部字段名，冒号后边就是该字段相应的值了。如下所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtYzQ4OGI3YThkZDYwZThjMS5wbmc" alt="image"></p>\n<p>HTTP头部字段可以分为通用头部字段，请求头部字段，响应头部字段以及实体头部字段，下方会给出详细的介绍。</p>\n<h2><a id="_General_Header_Fields_15"></a>通用头部字段 （General Header Fields）</h2>\n<p>该字段在请求头和响应头都会使用到，下方是常用的通用头部字段：</p>\n<h3><a id="CacheControl_19"></a>Cache-Control</h3>\n<p>用来操作缓存的工作机制，下方截图响应头中的的Cache-Control的参数为private和max-age=10。private缓存是私有的，仅像特定用户提供相应的缓存信息。如果是public，那么就意味着可向任意方提供相应的缓存信息。max-age = 10表示缓存有效期为10秒。从下方的Expires(过期时间)和Last-Modified(最后修改时间)就可以看出，这两者之间的差值正好是10秒。</p>\n<p>该字段还可以对应其他的参数：</p>\n<ul>\n<li>no-cache：如果是客户端的话，说明客户端不会接收缓存过的响应，要请求最新的内容。而服务器端则表示缓存服务器不能对相应的资源进行缓存。</li>\n<li>no-store：表示缓存不能在本地存储。</li>\n<li>max-age：该参数后方会被赋值上相应的秒数，在请求头中表示如果缓存时间没有超过这个值就返回给我。而在响应头中时，则表示资源在缓存服务器中缓存的最大时间。</li>\n<li>only-if-cached：表示客户端仅仅请求缓存服务器上的内容，如果缓存服务器上没有请求的内容，那么返回504 Gateway Timeout。</li>\n<li>must-revalidata：表示缓存服务器在返回资源是，必须向资源服务器确认其缓存的有效性。</li>\n<li>no-transform：无论请求还是响应，都不能在传输的过程中改变报文体的媒体类型。</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMDU0NDg3OGJmYTlmYjc0OS5wbmc" alt="image"></p>\n<h3><a id="Connection_35"></a>Connection</h3>\n<p>该字段可以控制不转发给代理服务器的首部字段以及管理持久连接，下方这个响应报文头中的Connection就是用来管理持久连接的，其参数为keep-alive，就是保持持久连接的意思。可以使用close参数将其关闭。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNThmYzYxOTJjMmY5MTBiMy5wbmc" alt="image"></p>\n<h3><a id="TransferEncoding_41"></a>Transfer-Encoding</h3>\n<p>该字段表示报文在传输过程中采用的编码方式，在HTTP/1.1的报文传输过程中仅对分块编码有效。下方这个截图就是Transfer-Encoding在Response Header中的使用，后边根的chunked(分块)的参数，说明报文是分块进行传输的。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMTAyM2ZlODg4YjY0YTYwYS5wbmc" alt="image"></p>\n<h3><a id="Via_47"></a>Via</h3>\n<p>该字段是为了追踪请求和响应报文测传输路径，报文经过代理或者网关是会在Via字段添加该服务器的信息，然后再进行转发。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZDlkYTRjZDczZjA1YzgxMS5wbmc" alt="image"></p>\n<h2><a id="_Request_Header_Fields_53"></a>请求头部字段 （Request Header Fields）</h2>\n<p>顾名思义，请求头部字段当然是在请求头中才使用的字段。该字段用于补充请求的附加信息，客户端信息等。接下来将给出常用而且比较重要的几个请求头部字段。</p>\n<h3><a id="Accept_58"></a>Accept</h3>\n<p>该字段可通知服务器用户代理能够处理的媒体类型以及该媒体类型对应的优先级。媒体类型可使用“type/subtype”这种形式来指定，分号后边紧跟着的是该类型的优先级。如下所示。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtYWE5ZjQ4MTJkMjdkNWU2My5wbmc" alt="image"></p>\n<h3><a id="AcceptEncoding_64"></a>Accept-Encoding</h3>\n<p>该字段用来告知服务器，客户端这边可支持的内容编码以及相应内容编码的优先级, 下方就是Accept-Encoding的用法。gzip表示由文件压缩程序gzip(GNU zip)生成的编码格式。compress表示UNIX文件压缩程序compress生成的编码格式。deflate表示组合使用zlib格式以及有deflate压缩算法生成的编码格式。identity表示不执行压缩或者使用一致的默认编码格式。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZGQxMDc2MGRiN2E0NTA5Mi5wbmc" alt="image"></p>\n<h3><a id="AcceptLanguage_70"></a>Accept-Language</h3>\n<p>该字段用来告知服务器，客户端可处理的自然语言集，以及对应语言集的优先级。以下方的截图为例，Accept-Language后方跟了三个属性，分别是“zh-CN”, “zh;q=0.8”，“en;q=0.6”。也就是说客户端可处理三种自然预言集，zh-CN，其优先级是1（最高）。第二种是zh ，其优先级是0.8，次之。第三个是en，优先级为0.6，优先级在三者之间最低。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtY2EyYWY2ZWNiYTg3ZDAxZS5wbmc" alt="image"></p>\n<h3><a id="Authorization_76"></a>Authorization</h3>\n<p>用来告知服务器用户端的认证信息，下方就是连接公司内部SVN系统时需要认证时的请求头部信息。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMzIxYmNhZGRjZDg3N2E5Zi5wbmc" alt="image"></p>\n<p>如果你没有填写认证信息的话，那么就会返回401 Unauthorized。如下所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMWUwZjQ1ZTQ2M2Y5MTFkNi5wbmc" alt="image"></p>\n<h3><a id="IfMatch_IfNoneMatch_86"></a>If-Match 与If-None-Match</h3>\n<p>上面这两个请求头部字段都是带有逻辑判断的，从上面的英文我们不难看出两者恰好相反。两者后方都跟着串字符串，如If-Match “xcsldjh49773hce”, 后边这个字符的匹配对象是ETag(稍后会介绍)。If-Match的请求是如果后方的字符串与ETag相等则服务器端进行请求，否则不进行处理。If-None-Match是If-Match的非操作，同样是匹配ETag, 如果Etag没有匹配成功就处理请求，否则不处理。</p>\n<h3><a id="IfModifiedSinceIfUnmodifiedSince_90"></a>If-Modified-Since与If-Unmodified-Since</h3>\n<p>If-Modified-Since也是带有逻辑判断的请求头部字段，该字段后方跟的是一个日期，意思是在该日期后发生了资源更新，那么服务器就会处理该请求。If-Unmodified-Since就是 If-Modified-Since的非操作。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZjlmZGNiMmE5NWViMWYyNC5wbmc" alt="image"></p>\n<h3><a id="IfRange_96"></a>If-Range</h3>\n<p>if-Range字段后方也是跟的Etag, 该字段要结合着Range字段进行使用。其所代表的意思就是如果Etag匹配成功，请求的内容就按照Range字段所规定的范围进行返回，否则返回全部的内容。用法如下所示：</p>\n<blockquote>\n<p>If-Range: “etag_code”</p>\n<p>Range: bytes=1000-5000</p>\n</blockquote>\n<h3><a id="Referer_104"></a>Referer</h3>\n<p>其实Referer是一个错误的拼写，但是一直在使用。正确的英文单词应该是Referrer(此处可翻译为:来历、来路)。Referer字段后方跟的是一个URI, 该URI就是发起请求的URI，具体如下所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMWFhNDJiN2EzYTQzNWZiNC5wbmc" alt="image"></p>\n<h3><a id="UserAgent_110"></a>User-Agent</h3>\n<p>该字段会将请求方的浏览器和用户代理名称等信息传达给服务器。下方就是从我当前笔记本的Chrome浏览器请求网络时的User-Agent信息。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMTRjMmFmNDM5ZjU5NmI2ZS5wbmc" alt="image"></p>\n<h2><a id="_Request_Header_Fields_117"></a>响应头部字段 （Request Header Fields）</h2>\n<p>聊完请求报文头部字段后，我们接下来来聊一下响应报文头部字段。响应头是由Server向Client返回响应报文中使用的头部信息。用户补充响应的附加信息、服务信息等。下方是几个常见响应头部字段。</p>\n<h3><a id="AcceptRanges_121"></a>Accept-Ranges</h3>\n<p>该字段用来告知客户端服务器那边是否支持范围请求（请求部分内容，请求头中使用Range字段）。Accept-Ranges的值为bytes时，就说明服务器支持范围请求，为none时，说明服务器不支持客户端的范围请求。下方是博客园的页面的加载，从下方可以看出是支持范围请求的，如下所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZmFlODRiMjNhMjFlZTkxMS5wbmc" alt="image"></p>\n<h3><a id="Age_127"></a>Age</h3>\n<p>该字段告知客户端，源服务器在多久前创建了该响应。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtYTlkNTk3YmE5YTYzZDlhZi5wbmc" alt="image"></p>\n<h3><a id="Etag_133"></a>Etag</h3>\n<p>Etag是服务器当前请求的服务器资源（图片，HTML页面等）所对应的一个独有的字符串。不同资源间的Etag是不同的，当资源更新时Etag也会进行更新。</p>\n<p>所以结合着请求头中的If-Match等逻辑请求头，可以判断当前Client端已经加载的资源在服务器端是否已经更新了。当初次请求一个资源，如图片时，我们可以将其Etag进行保存，在此请求时，可放在If-None-Match后方，进行资源更新。如果服务器资源并未修改，就不对该请求做出响应。下方就是网页中某张图片对应着的Etag，如下所示。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZjZlZmZhYWRlNjk5ZjE4Yi5wbmc" alt="image"></p>\n<h3><a id="Location_141"></a>Location</h3>\n<p>Location字段一般与重定向结合着使用。下方是我访问“<a href="http://www.baidu.com/hello%E2%80%9D%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E3%80%82%E5%9B%A0%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%B9%B6%E6%B2%A1%E6%9C%89/hello%E8%BF%99%E4%B8%AA%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%89%80%E4%BB%A5%E7%BB%99%E6%88%91%E9%87%8D%E5%AE%9A%E5%90%91%E4%BA%86error.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84URL%E5%B0%B1%E5%AD%98%E5%82%A8%E5%9C%A8Location%E5%AD%97%E6%AE%B5%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A" rel="nofollow">www.baidu.com/hello”这个连接的响应报文。因为服务器上并没有/hello这个资源路径，所以给我重定向了error.html页面，这个重定向的URL就存储在Location字段中，如下所示：</a></p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZDQ2YjRjMzVkNDE1N2VmOC5wbmc" alt="image"></p>\n<h3><a id="Server_147"></a>Server</h3>\n<p>该响应字段表明了服务器端使用的服务器型号，下方是博客园某张图片的响应头，使用的Web服务器是Tengine, Tengin是淘宝发起的Web服务器项目，是基于Nginx的，关于Tengin的相关内容，请自行Google吧。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtYTZkMmRhYzExMDQwN2IxMS5wbmc" alt="image"></p>\n<h3><a id="Vary_153"></a>Vary</h3>\n<p>Vary可对缓存进行控制，通过该字段，源服务器会向代理服务器传达关于本地缓存使用方法的命令。下方就是Vary的使用，Vary后方的参数是Accept-Encoding。其意思是返回的缓存要以Accept-Encoding为准。当请求的Accept-Encoding的参数与缓存内容的Accept-Encoding参数一致时就返回缓存内容，否则就请求源服务器。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNjViYzJiNDA0OGQ5NjNjOS5wbmc" alt="image"></p>\n<h3><a id="WWWAuthenticate_159"></a>WWW-Authenticate</h3>\n<p>该字段用于HTTP的访问认证，在状态码401 Unauthorized中肯定带有此字段，该字段用来指定客户端的认证方案（Basic或者Digest）。参数realm的字符串是为了辨别请求URL指定资源所受到的保护策略。如下所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMmU2Mzc0ZmY2MjEyODk4Yy5wbmc" alt="image"></p>\n<h2><a id="Content_Header_Fields_165"></a>实体头部字段（Content Header Fields）</h2>\n<p>接下来我们就来聊聊常见的实体头部字段，实体头部字段是报文实体所使用的头部，用来补充与报文实体相关的信息。</p>\n<h3><a id="Allow_169"></a>Allow</h3>\n<p>该字段用于服务器通知客户端服务器这边所支持的所有请求方法（GET、POST等）。如果服务器找不到客户端请求中所提到的方法的话，就会返回405 Method Not Allowed，于此同时还会把所有能支持的HTTP方法写入到首部字段Allow后返回。</p>\n<blockquote>\n<p>Allow : GET, POST, HEAD, PUT, DELETE</p>\n</blockquote>\n<h3><a id="ContentEncoding_177"></a>Content-Encoding</h3>\n<p>该字段用来说明报文实体的编码方式，下方这段报文头中的Content-Encoding的参数为gzip，说明是使用gzip对报文实体进行压缩的。<br>\n<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZjhiYzY5MDQyMDkwNGY0Yi5wbmc" alt="image"></p>\n<h3><a id="ContentLanguage_182"></a>Content-Language</h3>\n<p>该字段表示报文实体使用的自然语言，使用方式如下所示：</p>\n<blockquote>\n<p>Content-Language: zh-CN</p>\n</blockquote>\n<h3><a id="ContentLength_188"></a>Content-Length</h3>\n<p>顾名思义，该字段用来指定报文实体的字节长度，如下所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtODBhODFlMzAxMTIzZDczNS5wbmc" alt="image"></p>\n<h3><a id="ContentMD5_194"></a>Content-MD5</h3>\n<p>该字段中存储的是报文实体进行MD5加密然后再使用Base64进行编码的字符串。客户端收到响应报文后，可以对报文实体进行MD5加密，然后再对其进行Base64编码，然后与Content-MD5中的字符串进行比较来确定报文是否进行修改，可以说这是一个简单的验签功能。但是此方法并不能确定报文是否被修改了，因为Content-MD5这个值也有可能被篡改。</p>\n<h2><a id="Cookie_199"></a>Cookie相关的头部字段</h2>\n<p>因为HTTP协议本身是无状态的，在Web站点中使用Cookie来管理服务器与客户端之间的状态。解析来我就来介绍一下Cookie相关的头部字段。</p>\n<h3><a id="SetCookie_204"></a>Set-Cookie</h3>\n<p>响应报文中会使用到该字段。当服务器准备开始管理客户端的状态时，会事先告知其各种信息。下方字段是登录知乎时所返回的所要设置的Cookie信息。接下来我们就要对这串Cookie信息进行解析。</p>\n<ul>\n<li>键值对：在Set-Cookie字段中，“z_co=Mi4……”这就是要存入Cookie中的信息，当然可以是多个键值对，中间使用逗号进行分割即可。</li>\n<li>Domain：然后是Domain属性，由下方不难看出，Domain中存储的就是Cookie适用对象的域名，若不指定Domain的值，那么默认就是创建Cookie的服务器的域名。</li>\n<li>expire：该字段属性的值是一个时间，也就是Cookie的有效期，若不指定该属性的值，默认就是当前会话有效，关闭浏览器Cookie即失效。</li>\n<li>httponly：设置该属性的目的是让JavaScript脚本无法获取Cookie，其主要目的是防止跨站脚本攻击对Cookie信息的窃取。</li>\n<li>path： 用于限制指定Cookie的发送范围的文件目录。</li>\n<li>Secure：仅在HTTPS安全通信时才会发送Cookie。</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtM2NkYjI2ZGMwODU0ZjVlMC5wbmc" alt="image"></p>\n<h3><a id="Cookie_220"></a>Cookie</h3>\n<p>请求报文头中会使用该字段，用于将本地存储的Cookie信息发送给服务端。下方就是知乎上每次请求文章所带有的Cookie信息，当然下方只是部分信息，但是我们还是从中可以找到之前我们存储的“z_co=Mi4……”这个键值对的。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtOTBiMmQ1NmI3ODVlNDU1Yi5wbmc" alt="image"></p>\n<p>其他比较常见而且比较简单的头部字段就不做过多赘述了，今天博客就先到这儿吧。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/98322521', 'title': 'ELK教程3：logstash的部署、SpringBoot整合ELK+Filebeat', 'readNum': '2959', 'commentNum': '1', 'publishTime': '2019-08-03 12:16:49', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/98322521">http://blog.csdn.net/forezp/article/details/98322521</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>本篇文章主要讲解如下安装Logstash，logstash依赖于Java环境，首先安装Java，安装脚本如下：</p>\n<pre><code>yum install java\n</code></pre>\n<h2><a id="logstash_12"></a>logstash安装</h2>\n<p>Logstash的安装脚本如下：</p>\n<pre><code># 下载logstash的压缩包\nwget https://artifacts.elastic.co/downloads/logstash/logstash-7.2.0.zip\n# 解压压缩包 \nupzip logstash-7.2.0.zip\n# 将解压的包移到/usr/share目录下\nmv logstash-7.2.0 /usr/share/\ncd /usr/share/logstash-7.2.0/\n</code></pre>\n<h2><a id="stash_26"></a>stash第一个事件</h2>\n<p>Logstash管道有两个必需元素，输入和输出，以及一个可选元素filter。 输入插件使用来自源的数据，过滤器插件在您指定时修改数据，输出插件将数据写入目标。<br>\n如下如</p>\n<p><img src="https://img-blog.csdnimg.cn/20190804193203784.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>要测试Logstash安装成功，运行最基本的Logstash管道。 执行以下的命令</p>\n<pre><code> bin/logstash -e \'input { stdin { } } output { stdout {} }\'\n\n</code></pre>\n<p>-e标志使您可以直接从命令行指定配置。 通过在命令行指定配置，可以快速测试配置，而无需在迭代之间编辑文件。 示例中的管道从标准输入stdin获取输入，并以结构化格式将输入移动到标准输出stdout。<br>\n启动Logstash后，等到看到“Pipeline main started”，然后在命令提示符下输入hello world，显示的如下：</p>\n<pre><code>hello world\n{\n          "host" =&gt; "VM_0_13_centos",\n       "message" =&gt; "hello world",\n      "@version" =&gt; "1",\n    "@timestamp" =&gt; 2019-07-02T06:26:28.684Z\n}\n\n</code></pre>\n<h2><a id="logstashelasticsearch_54"></a>配置logstash输出到elasticsearch</h2>\n<p>修改logstash的安装目录的config目录下的logstash-sample.conf文件，配置如下：</p>\n<pre><code>input {\n  beats {\n    port =&gt; 5044\n  }\n}\n\noutput {\n  elasticsearch {\n    hosts =&gt; ["http://10.0.0.5:9200", "http://10.0.0.13:9200", "http://10.0.0.17:9200"]\n    index =&gt; "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"\n    #user =&gt; "elastic"\n    #password =&gt; "changeme"\n  }\n}\n\n</code></pre>\n<p>在上面的配置中，输入数据源为filebeat，关于filebeat见下一小节，输出源为elasticsearch。更多的输入和输出源的配置见官网https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html</p>\n<p>用下面的命令从后台启动logstash：</p>\n<pre><code>./bin/logstash -f config/logstash-sample.conf &gt;logstash.log  2&gt;&amp;1 &amp;\n\n</code></pre>\n<h2><a id="logstashfilebeat_88"></a>logstash结合filebeat</h2>\n<p>在分布式系统中，一台主机可能有多个应用，应用将日志输出到主机的指定目录，这时由logstash来搬运日志并解析日志，然后输出到elasticsearch上。由于于<br>\nlogstash是java应用，解析日志是非的消耗cpu和内存，logstash安装在应用部署的机器上显得非常的笨重。最常见的做法是用filebeat部署在应用的机器上，logstash单独部署，然后由<br>\nfilebeat将日志输出给logstash解析，解析完由logstash再传给elasticsearch。</p>\n<p>下载filebeat，下载命令如下：</p>\n<pre><code> wget  https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.2.0-linux-x86_64.tar.gz\ntar -zxvf filebeat-7.2.0-linux-x86_64.tar.gz\nmv filebeat-7.2.0-linux-x86_64 /usr/share/\ncd /usr/share/filebeat-7.2.0-linux-x86_64/\n\n</code></pre>\n<p>vim filebeat.yml修改配置：</p>\n<pre><code>filebeat.inputs:\n- type: log\n  enabled: true\n  paths:\n    - /var/log/service-hi.log\noutput.logstash:\n  hosts: ["192.168.1.4:5044"]\n\n</code></pre>\n<p>主要配置的是日志的搜集目录为/var/log/service-hi.log，这个目录是应用service-hi输出日志的文件。输出到logstsh的地址为192.168.1.4</p>\n<p>启动filebeat，执行一下命令：</p>\n<pre><code>sudo chown root filebeat.yml\nsudo ./filebeat -e &gt;filebeat.log 2&gt;&amp;1 &amp;\n</code></pre>\n<h2><a id="Spring_BootELKFilebear_124"></a>Spring Boot整合ELK+Filebear构建日志系统</h2>\n<p>在SpringBoot应用service-hi，定时输出日志如下：</p>\n<pre><code>@SpringBootApplication\npublic class ElkTestApplication {\n    Logger logger= LoggerFactory.getLogger(ElkTestApplication.class);\n    Random random=new Random(10000);\n\n    public static void main(String[] args) {\n        SpringApplication.run(ElkTestApplication.class, args);\n        new ElkTestApplication().initTask();\n    }\n\n    private void initTask(){\n        Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                logger.info("seed:"+random.nextInt(999999));\n            }\n        },100,100, TimeUnit.MILLISECONDS);\n    }\n}\n</code></pre>\n<p>然后在部署了filebeat的机器上部署该应用，应用的输出文件为/var/log/service-hi.log，应用启动命令如下：</p>\n<pre><code>nohup java -jar  elk-test-0.0.1-SNAPSHOT.jar &gt; /var/log/service-hi.log 2&gt;&amp;1  &amp;\n</code></pre>\n<p>应用启动成功后日志输出如下：</p>\n<pre><code>2019-07-02 17:13:13.530  INFO 31579 --- [pool-1-thread-1] com.example.elktest.ElkTestApplication   : seed:562779\n2019-07-02 17:13:13.630  INFO 31579 --- [pool-1-thread-1] com.example.elktest.ElkTestApplication   : seed:963836\n2019-07-02 17:13:13.730  INFO 31579 --- [pool-1-thread-1] com.example.elktest.ElkTestApplication   : seed:825694\n2019-07-02 17:13:13.830  INFO 31579 --- [pool-1-thread-1] com.example.elktest.ElkTestApplication   : seed:33228\n2019-07-02 17:13:13.930  INFO 31579 --- [pool-1-thread-1] com.example.elktest.ElkTestApplication   : seed:685589\n</code></pre>\n<p>这时的日志数据的传输路径如下图：<br>\n<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTVlOTc0ZmM3OWY2MWFlNGMucG5n" alt="1.png"></p>\n<p>在kibana组件上查看，可以看到创建了一个filebeat开头的数据索引，如下图:</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTIzNTllNTkzMDhkOWQ3ODcucG5n" alt="微信截图_20190702170554.png"></p>\n<p>在日志搜索界面，可以看到service-hi应用输出的日志，如图所示：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTgzMzhiNTUxYmRjYmNkMTAucG5n" alt="微信截图_20190702171411.png"></p>\n<h2><a id="_178"></a>参考资料</h2>\n<p><a href="https://www.elastic.co/guide/en/logstash/7.2/installing-logstash.html#_yum" rel="nofollow">https://www.elastic.co/guide/en/logstash/7.2/installing-logstash.html#_yum</a><br>\n<a href="https://www.elastic.co/guide/en/logstash/7.2/first-event.html" rel="nofollow">https://www.elastic.co/guide/en/logstash/7.2/first-event.html</a><br>\n<a href="https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html" rel="nofollow">https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/98322359', 'title': 'ELK教程2：Kibana的安装', 'readNum': '2037', 'commentNum': '0', 'publishTime': '2019-08-03 12:15:09', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/98322359">http://blog.csdn.net/forezp/article/details/98322359</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>kibana作为ElastciSearch的数据查询展示界面，集成了很多的功能，本文主要讲述如下部署kibana。</p>\n<h2><a id="_7"></a>安装</h2>\n<p>安装命令如下：</p>\n<pre><code># 下载kibana的npm\nwget https://artifacts.elastic.co/downloads/kibana/kibana-7.2.0-x86_64.rpm\n# 检查版本\nshasum -a 512 kibana-7.2.0-x86_64.rpm \n# 安装\nsudo rpm --install kibana-7.2.0-x86_64.rpm\n</code></pre>\n<p>安装成功后，启动kibana进程，并设为开机自启：</p>\n<pre><code>sudo /bin/systemctl daemon-reload\nsudo /bin/systemctl enable kibana.service\nsudo systemctl start kibana.service\n</code></pre>\n<h2><a id="kibana_28"></a>kibana的配置</h2>\n<p>kibana的配置和目录如下表所示：</p>\n\n<table>\n<thead>\n<tr>\n<th>配置类型</th>\n<th align="right">描述</th>\n<th align="center">路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>home</td>\n<td align="right">Kibana 的home目录</td>\n<td align="center">/usr/share/kibana</td>\n</tr>\n<tr>\n<td>bin</td>\n<td align="right">Kibana 的bin目录</td>\n<td align="center">/usr/share/kibana/bin</td>\n</tr>\n<tr>\n<td>config</td>\n<td align="right">Kibana 的配置目录</td>\n<td align="center">/etc/kibana</td>\n</tr>\n<tr>\n<td>data</td>\n<td align="right">Kibana 的data目录</td>\n<td align="center">/var/lib/kibana</td>\n</tr>\n<tr>\n<td>plugins</td>\n<td align="right">Kibana 的plugins目录</td>\n<td align="center">/usr/share/kibana/plugins</td>\n</tr>\n</tbody>\n</table><p>需要配置ElasticSearch的地址，配置文件在/etc/kibana/kibana.yml 。<br>\n在kibana.yml文件需要配置配置的选项如下：</p>\n<pre><code>server.host: "0.0.0.0"\nelasticsearch.hosts: ["http://10.0.0.5:9200","http://10.0.13:9200","http://10.0.0.17:9200"]\n\n</code></pre>\n<p>配置完成后，需要重新启动kibana，执行如下的命令：</p>\n<pre><code>sudo systemctl stop kibana.service\nsudo systemctl start kibana.service\n\n</code></pre>\n<p>启动完成后，在浏览器上访问：<a href="http://localhost:5601" rel="nofollow">http://localhost:5601</a>,首页显示如下：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTc2NjllMDU1MmQ4OThiODUucG5n" alt="微信截图_20190702180503.png"></p>\n<p>依次点击Discovery-&gt;Elasticsearch 下面的Index Management，显示的界面如下：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTQyZDBkZjQzODMzNGIxOWQucG5n" alt="微信截图_20190702163143.png"></p>\n<p>其中有一个customer的索引，读者无需关注。</p>\n<h2><a id="_66"></a>参考资料</h2>\n<p><a href="https://www.elastic.co/guide/en/kibana/current/index.html" rel="nofollow">https://www.elastic.co/guide/en/kibana/current/index.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/98322077', 'title': 'ELK教程1：ElasticSearch集群的部署ELK', 'readNum': '2815', 'commentNum': '0', 'publishTime': '2019-08-03 12:12:38', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/98322077">http://blog.csdn.net/forezp/article/details/98322077</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>在分布式系统中，应用数量众多，应用调用链复杂，常常使用ELK作为日志收集、分析和展示的组件。本篇文章将讲讲解如何部署ELK，然后讲解如何<br>\n使用Filebeat采集Spring Boot的日志输出到Logstash上，logstash再将日志输出到Elasticsearch上，最后展示到kibana上面。整个日志采集流程如下图：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTVlOTc0ZmM3OWY2MWFlNGMucG5n" alt="1.png"></p>\n<p>在传统的日志采集只会用ELK，那么为什么需要使用filebeat呢，因为<br>\nlogstash是java应用，解析日志是非的消耗cpu和内存，logstash安装在应用部署的机器上显得非常的影响应用的性能。最常见的做法是用filebeat部署在应用的机器上，logstash单独部署，然后由<br>\nfilebeat将日志输出给logstash解析，解析完由logstash再传给elasticsearch。</p>\n<h2><a id="_14"></a>安装计划</h2>\n<p>本文主要讲解如何部署ElasticSearch 集群，部署的ElasticSearch的版本为7.2，计划用三台机器组成一个ElasticSearch集群，从而组成高可用，机器分配如下：</p>\n<p>| 节点        | 规则    |  数量  |<br>\n| --------   | -----:   | :----: |<br>\n| 192.168.1.1        | 2核4G      |   1   |<br>\n| 192.168.1.2        | 2核4G      |   1    |<br>\n| 192.168.1.3        | 2核4G      |   1    |</p>\n<h2><a id="_25"></a>安装</h2>\n<p>下载安装执行以下命令：</p>\n<pre><code># 下载elasticsearch-7.2.0-x86_64的rpm包\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.2.0-x86_64.rpm\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.2.0-x86_64.rpm.sha512\n# shasum 检查版本信息\nshasum -a 512 -c elasticsearch-7.2.0-x86_64.rpm.sha512 \n# rpm本地安装\nsudo rpm --install elasticsearch-7.2.0-x86_64.rpm\n\n</code></pre>\n<p>安装成功ElasticSearch成功后，执行一下命令启动elasticSearch，并设置为开启自启动：</p>\n<pre><code>sudo systemctl daemon-reload\nsudo systemctl enable elasticsearch.service\nsudo systemctl start elasticsearch.service\n\n</code></pre>\n<p>elasticSearch的默认端口为9200，启动成功后，执行以下命令：</p>\n<pre><code>curl -X GET "localhost:9200/"\n\n</code></pre>\n<p>如果返回以下的信息，则证明安装成功：</p>\n<pre><code>{\n  "name" : "VM_0_5_centos",\n  "cluster_name" : "elasticsearch",\n  "cluster_uuid" : "gst98AuET6a648YmAkXyMw",\n  "version" : {\n    "number" : "7.2.0",\n    "build_flavor" : "default",\n    "build_type" : "rpm",\n    "build_hash" : "508c38a",\n    "build_date" : "2019-06-20T15:54:18.811730Z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.0.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "You Know, for Search"\n}\n\n</code></pre>\n<p>查看节点的健康状态，执行命令 curl localhost:9200/_cluster/health ，如果返回以下信息，则Elasticsearch则为监控状态。</p>\n<pre><code>{\n  "cluster_name" : "elasticsearch",\n  "status" : "green",\n  "timed_out" : false,\n  "number_of_nodes" : 1,\n  "number_of_data_nodes" : 1,\n  "active_primary_shards" : 0,\n  "active_shards" : 0,\n  "relocating_shards" : 0,\n  "initializing_shards" : 0,\n  "unassigned_shards" : 0,\n  "delayed_unassigned_shards" : 0,\n  "number_of_pending_tasks" : 0,\n  "number_of_in_flight_fetch" : 0,\n  "task_max_waiting_in_queue_millis" : 0,\n  "active_shards_percent_as_number" : 100.0\n}\n\n</code></pre>\n<p>可以执行以下的命令，查看es的 journal：</p>\n<pre><code>sudo journalctl --unit elasticsearch\n</code></pre>\n<h2><a id="_106"></a>配置</h2>\n<p>以下的路径的配置文件可以配置es的java_home,es_config_home ：</p>\n<pre><code>/etc/sysconfig/elasticsearch\n\n</code></pre>\n<p>es本身的一些配置在以下的路径，在这里可以配置elasticsearch的堆内存，数据保留天数等信息：</p>\n<pre><code>/etc/elasticsearch\n</code></pre>\n<p>所有的配置文件描述和路径如下表所示：</p>\n\n<table>\n<thead>\n<tr>\n<th>配置类型</th>\n<th align="right">描述</th>\n<th align="center">路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>home</td>\n<td align="right">elasticsearch的home目录</td>\n<td align="center">/usr/share/elasticsearch</td>\n</tr>\n<tr>\n<td>bin</td>\n<td align="right">elasticsearch的bin目录</td>\n<td align="center">/usr/share/elasticsearch/bin</td>\n</tr>\n<tr>\n<td>conf</td>\n<td align="right">elasticsearch的配置文件</td>\n<td align="center">/etc/elasticsearch</td>\n</tr>\n<tr>\n<td>conf</td>\n<td align="right">elasticsearch的环境变量配置</td>\n<td align="center">/etc/sysconfig/elasticsearch</td>\n</tr>\n<tr>\n<td>data</td>\n<td align="right">elasticsearch的数据目录</td>\n<td align="center">/var/lib/elasticsearch</td>\n</tr>\n<tr>\n<td>logs</td>\n<td align="right">elasticsearch的日志目录</td>\n<td align="center">/var/log/elasticsearch</td>\n</tr>\n<tr>\n<td>plugins</td>\n<td align="right">elasticsearch的插件目录</td>\n<td align="center">/usr/share/elasticsearch/plugins</td>\n</tr>\n</tbody>\n</table><h2><a id="_132"></a>集群搭建</h2>\n<p>在三台机器上分别装完elasticsearch，在主节点vim /etc/elasticsearch/，配置一下的信息：</p>\n<p>主节点的配置如下：</p>\n<pre><code>#三个集群需要同样的集群名\ncluster.name: my-application\n# 每个node的名字需要唯一\nnode.name: node-1\n\nnode.master: true\n#允许该节点存储数据(默认开启)\nnode.data: true\n#注意一定要是路径后面加上/var/lib/elasticsearch/nodes，要不然无法加入集群\npath.data: /var/lib/elasticsearch/nodes\npath.logs: /var/log/elasticsearch\nnetwork.host: 0.0.0.0\nhttp.port: 9200\ntransport.tcp.port: 9300\nhttp.cors.enabled: true\nhttp.cors.allow-origin: "*"\nxpack.security.enabled: false\ndiscovery.seed_hosts: ["192.168.1.1", "192.168.1.2", "192.168.1.3"]\ncluster.initial_master_nodes: ["192.168.1.1", "192.168.1.2", "192.168.1.3"]\n\n</code></pre>\n<p>同理从节点的配置：</p>\n<pre><code>cluster.name: my-application\n# 每个node的名字需要唯一，两个从节点的名字不能相同\nnode.name: node-2\nnode.master: true\n#允许该节点存储数据(默认开启)\nnode.data: true\npath.data: /var/lib/elasticsearch/nodes\npath.logs: /var/log/elasticsearch\nnetwork.host: 0.0.0.0\nhttp.port: 9200\ntransport.tcp.port: 9300\nxpack.security.enabled: false\nhttp.cors.enabled: true\nhttp.cors.allow-origin: "*"\ndiscovery.seed_hosts: ["192.168.1.1", "192.168.1.2", "192.168.1.3"]\ncluster.initial_master_nodes: ["192.168.1.1", "192.168.1.2", "192.168.1.3"]\n\n</code></pre>\n<p>配置完主从节点，需要重启三台elasticsearch，重启命令如下：</p>\n<pre><code>sudo systemctl restart elasticsearch.service\n\n</code></pre>\n<p>重启三台Elasticsearch后，执行curl <a href="http://localhost:9200/_cat/master%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%93%8D%E5%BA%94%E5%A6%82%E4%B8%8B%EF%BC%8C%E5%88%99%E8%AF%81%E6%98%8E%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F" rel="nofollow">http://localhost:9200/_cat/master，如果响应如下，则证明安装成功</a></p>\n<pre><code>SHBUDVUAQhi7FauSoI8bMg 192.168.1.1 192.168.1.1 node-1\n\n</code></pre>\n<p>也路执行命令curl -XGET ‘<a href="http://127.0.0.1:9200/_cat/nodes?pretty" rel="nofollow">http://127.0.0.1:9200/_cat/nodes?pretty</a>’，返回类型如下的数据则安装成功：</p>\n<pre><code>192.168.1.2   9 97 1 0.00 0.03 0.05 mdi - node-2\n192.168.1.3  97 0 0.01 0.07 0.07 mdi - node-3\n192.168.1.1  18 97 2 0.05 0.05 0.05 mdi * node-1\n\n</code></pre>\n<p>也可以通过命令curl localhost:9200/_cluster/health?pretty，查看集群的健康状态：</p>\n<pre><code>{\n  "cluster_name" : "my-application",\n  "status" : "green",\n  "timed_out" : false,\n  "number_of_nodes" : 3,\n  "number_of_data_nodes" : 3,\n  "active_primary_shards" : 5,\n  "active_shards" : 10,\n  "relocating_shards" : 0,\n  "initializing_shards" : 0,\n  "unassigned_shards" : 0,\n  "delayed_unassigned_shards" : 0,\n  "number_of_pending_tasks" : 0,\n  "number_of_in_flight_fetch" : 0,\n  "task_max_waiting_in_queue_millis" : 0,\n  "active_shards_percent_as_number" : 100.0\n}\n</code></pre>\n<p>Elasticsearch中信息很多，同时ES也有很多信息查看命令，可以帮助开发者快速查询Elasticsearch的相关信息。</p>\n<pre><code>$ curl localhost:9200/_cat\n=^.^=\n/_cat/allocation\n/_cat/shards\n/_cat/shards/{index}\n/_cat/master\n/_cat/nodes\n/_cat/indices\n/_cat/indices/{index}\n/_cat/segments\n/_cat/segments/{index}\n/_cat/count\n/_cat/count/{index}\n/_cat/recovery\n/_cat/recovery/{index}\n/_cat/health\n/_cat/pending_tasks\n/_cat/aliases\n/_cat/aliases/{alias}\n/_cat/thread_pool\n/_cat/plugins\n/_cat/fielddata\n/_cat/fielddata/{fields}\n\n</code></pre>\n<h2><a id="head_257"></a>head安装</h2>\n<p>在elasticsearch的高级版本之后，head不在是一个插件，而是一个独立的应用来部署，源码地址在https://github.com/mobz/elasticsearch-head。</p>\n<p>需要提前安装node，安装命令如下：</p>\n<pre><code>git clone git://github.com/mobz/elasticsearch-head.git\ncd elasticsearch-head\nnpm install\nnpm run start\n\n</code></pre>\n<p>安装成功后，打开 <a href="http://localhost:9100/%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%88%99%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%EF%BC%9A" rel="nofollow">http://localhost:9100/，浏览器显示如下的界面，则安装成功：</a></p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LWE0MmUzMzYzOTZlZDM1NGQucG5n" alt="322.png"></p>\n<p>如上图所示，在Head组件的界面上，可以很方便的查看集群的状态和数据。</p>\n<h2><a id="_276"></a>参考资料</h2>\n<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/rpm.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/rpm.html</a><br>\n<a href="https://www.elastic.co/guide/index.html" rel="nofollow">https://www.elastic.co/guide/index.html</a><br>\n<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/installation.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/plugins/current/installation.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:23 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/99559206', 'title': '网络：TCP、IP协议族(一) HTTP简介、请求方法与响应状态码', 'readNum': '2076', 'commentNum': '0', 'publishTime': '2019-08-14 13:16:42', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>接下来想系统的回顾一下TCP/IP协议族的相关东西，当然这些东西大部分是在大学的时候学过的，但是那句话，基础的东西还是要不时的回顾回顾的。接下来的几篇博客都是关于TCP/IP协议族的，本篇博客就先简单的聊一下TCP/IP协议族，然后聊一下HTTP协议，然后再聊一下SSL上的HTTP（也就是HTTPS）了。当然TCP/IP协议族是个老生常谈的话题，网络上关于该内容的文章一抓一大把呢，但是鉴于其重要性，还是有必要系统的总结一下的。</p>\n<!--more-->\n<h2><a id="TCPIP_5"></a>TCP/IP协议组简述</h2>\n<p>在聊HTTP与HTTPS之前呢，我们先简单的聊一下TCP/IP协议族。TCP/IP不单单指的就是TCP和IP这两个协议，而是指的与其相关的各种协议。比如HTTP, FTP, DNS, TCP, UDP, IP, SNMP等等都属于TCP/IP协议族的范畴。</p>\n<h3><a id="TCPIP_9"></a>TCP/IP协议的分层</h3>\n<p>TCP/IP协议族是分层管理的，在OSI标准中可以分为7层（应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，可记为：应表会传网数物），本篇博客我们采用的是TCP/IP协议族中的四层（应用层、传输层、网络层、链路层）。下方是对四层中每层的简单介绍：</p>\n<ul>\n<li>应用层：该层是面向用户的一层，也就是说用户可以直接操作该层，该层决定了向用户提供应用服务时的通信活动。本篇博客要聊的HTTP（HyperText Transfer Protocol：超文本传输协议）就位于该层。我们经常使用的FTP(File Transfer Protocol: 文件传输协议)和DNS (Domain Name System: 域名系统)都位于该层。FTP简单的说就是用来文件传输的。而DNS则负责域名解析的，通过DNS可以将域名（比如：<a href="http://www.cnblogs.com" rel="nofollow">www.cnblogs.com</a>）与IP地址（201.33.xx.09）进行相互的转换。在7层中，又将该层分为：应用层、表示层和会话层。</li>\n<li>传输层：应用层的下方是传输层，应用层会将数据交付给传输层进行传输。TCP(Transmission Control Prococol:传输控制协议)和UDP(User Data Protocol: 用户数据协议)位于该层，当然见名知意，该层是用来提供处于网络连接中的两台计算机直接的数据传输的。TCP建立连接是需要三次握手来确认连接情况，而UDP则没有三次握手的过程。稍后会介绍。</li>\n<li>网络层：传输层的下方是网络层，网络层用来处理在网络上流动的数据包，IP(Internet Protocol: 网际协议)就位于这层。该层负责在众多网络线路中选择一条传输线路。当然这个选择传输线路的过程需要IP地址和MAC地址的支持。</li>\n<li>链路层：在7层协议中，将链路层分为数据链路层和物理层。该部分主要是用来处理网络的硬件部分，我们常说的NIC（Net Work Card），也就是网卡就位于这一部分，当然光纤也是链路层的一部分。</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZjBmMGM5Mzg4YjdlYTcyYS5wbmc" alt="image"></p>\n<p>在TCP/IP协议族中的每次直接在传输数据时的协作关系，以及交互过程，还是引用《图解HTTP》一书上的一张图来解释吧。下图就是这四层协议在数据传输过程中的工作方式。下面这张图还是相当直观的。在发送端是应用层–&gt;链路层这个方向的封包过程，每经过一层都会增加该层的头部。而接收端则是从链路层–&gt;应用层解包的过程，每经过一层则会去掉相应的首部。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNWYyZGM4ZDI5YjhiY2Q2Yy5wbmc" alt="image"></p>\n<h3><a id="TCP_24"></a>TCP协议的三次握手</h3>\n<p>在聊HTTP协议之前，我们先简单的聊一下TCP三次握手的过程，在后面的博客中我们将会对TCP和IP协议进行详述，本篇博客就先简单的聊一下做HTTP协议的基础。</p>\n<p>TCP协议位于传输层，为了确保传输的可靠性，TCP协议在建立连接时需要三次握手（Three-way handshaking）。下方这个简图就是TCP协议建立连接时三次握手的过程。</p>\n<ul>\n<li>第一次握手：发送端发送一个带SYN(Synchronize)标志的数据包给接收端，用于询问接收端是否可以接收。如果可以，就进行第二次握手。</li>\n<li>第二次握手：接收端回传给发送端一个带有SYN/ACK(Acknowledgement)的数据包，给发送端说，我收到你给我发送的SYN标志了，我再给你传一个ACK标志，你能收到吗？如果发送端收到了SYN/ACK这个数据包，就可以确认接收端收到了之前发送的SYN, 然后进行第三次握手。</li>\n<li>第三次握手：发送端会给接收端发送一个带有ACK标志的数据包，告诉接收端我可以收到你给我发送的SYN/ACK标志。接收端如果收到了这个来自客户端的ACK标志，就意味着三次握手完成，连接建立，就可以开始传输数据了。</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMDg3YTY5ZDI1ODc1Y2M2OS5wbmc" alt="image"></p>\n<h2><a id="HTTP_36"></a>HTTP报文结构</h2>\n<p>HTTP协议全称是HyperText Transfer Protocol，即超文本传输协议，用户客户端和服务器之前的通信，目前普遍使用版本为HTTP/1.1。协议本质上就是规范，我们之前提到过的“面向接口”编程，其实就是“面向协议”编程。先定义好类的协议，也就是接口，相关类都遵循该协议，这样一来我们就规范了这些类的调用方式。而HTTP协议是规范客户端和服务器之间通信的协议。也就是说所有的客户端或者服务器都遵循了HTTP这个通信协议，那么也就是意味着他们对外传输数据的接口是一直的，就可以在其中间连接上管道，这样一来就可以进行传输了。</p>\n<p>这些协议就是接口，有着共同的通信协议，多个端就可以相互通信。采用相同的协议，就是便于个个设备之间进行沟通交流。HTTP协议的作用如下所示。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtMGJkOTE0M2E5MDQyZjFlNi5wbmc" alt="image"></p>\n<p>HTTP协议的作用是用来规范通信内容的，在HTTP协议中可以分为请求报文和响应报文。顾名思义，请求报文是请求方发出的信息，而响应报文是响应端收到请求后响应的内容。接下来我们就来看看请求报文和响应报文的整体结构。</p>\n<h3><a id="Request_Message_46"></a>请求报文（Request Message）结构</h3>\n<p>下方是请求报文的整体结构。请求报文主要分为两大部分，一个是请求头（Request Headers）另一个是请求体（Request Body）。这两者之间由空行分割。在请求头中又分为请求行（Request Line），请求头部字段，通用头部字段和实体头部字段等，这个稍后会详细介绍。下方就是请求报文的结构。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtN2U1YjliN2NkMTZjMTQ5NC5wbmc" alt="image"></p>\n<p>下方这个截图就是请求博客园某个页面时的Request Headers。在请求行中的第一个“GET”是当前请求的方法，稍后会做介绍。中间的就是请求资源的路径，最后一个HTTP/1.1就是当前使用请求协议及其版本。下方这些就是请求头了，稍后会对常用的请求头进行解说。而请求体就是你往服务端传输的数据，比如form表单神马的。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZWViY2RjYjk4YjI5YzQ4Mi5wbmc" alt="image"></p>\n<h3><a id="Response_Message_56"></a>响应报文（Response Message）结构</h3>\n<p>聊完请求报文，接下来我们来聊聊响应报文，响应报文的结构与请求报文的结构类似，也分为报文头和报文体。下方就是响应报文的结构图。响应头（Response Headers）分为状态行（State Line），响应头部字段，通用头部字段、实体头部字段等。响应头与响应体中间也是有空行进行分割的。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtNWExN2Y1ZTc1OWE2MTJiNy5wbmc" alt="image"></p>\n<p>下方截图就是上述请求报文发出后的响应头，响应体就是对于的HTML等前端资源了。在响应头中，第一行就是状态行，“HTTP/1.1”表示使用的HTTP协议的1.1版本，状态200表示响应成功，"OK"则是状态原因短语。常用状态，稍后会详细介绍。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ZvcmV6cC5vYnMubXlodWF3ZWljbG91ZC5jb20vaW1nLzIwMTlqaWFuc2h1LzIyNzk1OTQtZjA1ZDc2ZTAwOTc4YTdjOS5wbmc" alt="image"></p>\n<h2><a id="HTTP_66"></a>HTTP的请求方法以及响应状态码</h2>\n<p>上面在介绍请求报文中提到的“GET”就是请求请求方法，而在响应报文中提到的“200”状态码，就是稍后要聊的响应状态码。请求方法和响应状态码在HTTP协议中算是比较重要的内容了。之前我们在使用Perfect框架开发服务器端的时候，曾聊过请求方法中的GET、POST、PUT以及DELETE，并且这四种方法可以结合着REST使用。本部分是以HTTP协议的角度来聊的请求方法，所以与之前会有稍稍的不同。本部分我们就来聊一下HTTP协议的请求方法和响应状态码。</p>\n<h3><a id="_70"></a>请求方法</h3>\n<p>接下来我们要聊的请求方法有GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT。当然上述方法是基于HTTP/1.1的，HTTP/1.0中独有的方法就不说了。</p>\n<ul>\n<li>GET----获取资源<br>\nGET方法一般用来从服务器上获取资源的方法。服务器端接到GET请求后，就会明白客户端是要从服务器端获取相应的资源，然后就会根据请求报文中相应的参数，将需要的资源返回给客户端。使用GET方式的请求，传输的参数是拼接在URI上的。</li>\n<li>POST----数据提交<br>\nPOST方法一般用于表单提交，将客户端的数据塞到请求体中发送给服务器端。</li>\n<li>PUT----上传文件<br>\nPUT方法主要用来上传文件，将文件内容塞到请求报文体中，传输给服务器。因为HTTP/1.1的PUT方法自身不带验证机制，所以任何人都可以上传文件，存在安全性，所以上传文件时不推荐使用。但是之前我们在设计接口使用REST标准时，可以使用PUT来做相应内容的更新。</li>\n<li>HEAD----获取响应报文头<br>\n响应端收到HEAD请求后，只会返回相应的响应头，不会返回响应体。</li>\n<li>DELETE----删除文件<br>\nDELETE用于删除URI指定的资源，与PUT一样，自身也是不带验证机制的，不过在REST标准中可以用来做相应API的删除功能。</li>\n<li>OPTIONS----查询支持的方法<br>\nOPTIONS方法是用来查询服务器可对那些请求方法做出相应，返回内容就是响应端所支持的方法。</li>\n<li>TRACE----追踪路径<br>\nTRACE方法可追踪请求经过的代理路径，在发送请求时会为Max-Forwards头部字段填入数字，每经过一个代理中转Max-Forwards的值就会减一，直至Max-Forwards为零后，才会返回200。因为该方法易引起XST(Cross-Site Tracing，跨站追踪)攻击，所以不常用呢。</li>\n<li>CONNECT----要求用隧道协议连接代理<br>\nCONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL(Secure Sockets Layer, 安全套接层)和TLS(Transport Layer Security, 传输安全层)协议将通信内容进行加密后经网络隧道传输。</li>\n</ul>\n<h3><a id="_91"></a>响应状态码</h3>\n<p>聊完请求方法后，接下来我们来聊聊HTTP协议的响应状态码。顾名思义，响应状态码是用来标志HTTP响应状态的，响应状态由响应状态码和响应原因短语构成，当然状态码有很多中，本部分就挑出来常用的状态码进行讨论。下方是响应状态码可以分为的几大类：</p>\n<ul>\n<li>1xx ---- Informational（信息性状态码），表示接受的请求正在处理。</li>\n<li>2xx ---- Success (成功)，表示请求正常处理完毕。</li>\n<li>3xx ---- Redirection (重定向)，表示要对请求进行重定向操作，当然其中的304除外。</li>\n<li>4xx ---- Client Error (客户端错误)，服务器无法处理请求。</li>\n<li>5xx ---- Server Error (服务器错误)，服务器处理请求时出错。</li>\n</ul>\n<p>上面是响应状态码的整体分类，接下来介绍一些常用的响应状态码。</p>\n<ul>\n<li>(01)、200 OK : 表示服务端正确处理了客户端发送过来的请求。</li>\n<li>(02)、204 No Content : 表示服务端正确处理请求，但没有报文实体要返回。</li>\n<li>(03)、206 Partial Content ：表示服务端正确处理了客户端的范围请求，并按照请求范围返回该指定范围内的实体内容。</li>\n<li>(04)、301 Moved Permanently：永久性重定向，若之前的URI保存到了书签，则更新书签中的URI。</li>\n<li>(05)、302 Found：临时重定向，该重定向不会变更书签中的内容。</li>\n<li>(06)、303 See Other：临时重定向，与302功能相同，但是303状态吗明确表示客户端应当采用GET方法获取资源。</li>\n<li>(07)、304 Not Modified: 资源未变更，该状态码与重定向并没有什么关系，当返回该状态码时，告诉客户端请求的资源并没有更新，响应报文体中并不会返回所请求的内容。</li>\n<li>(08)、400 Bad Request： 错误请求，表示请求报文中包含语法错误。</li>\n<li>(09)、401 Unauthorized：请求未认证，表示此发送的请求需要客户端进行HTTP认证（稍后会提到）。</li>\n<li>(10)、404 Not Found：找不到相应的资源，表示服务器找不到客户端请求的资源。</li>\n<li>(11)、500 Internal Server Error：服务器内部错误，表示服务器在处理请求时出现了错误，发生了异常。</li>\n<li>(12)、503 Service Unavailable：服务不可用，表示服务器处于停机状态，无法处理客户端发来的请求。</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:23'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/94343671', 'title': 'Sharding-JDBC教程：Spring Boot整合Sharding-JDBC实现分库分表+读写分离', 'readNum': '5974', 'commentNum': '7', 'publishTime': '2019-06-30 18:04:58', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/94343671<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/db/2019/07/01/shardingjdbc-dbs-tbls-ms.html" rel="nofollow">https://www.fangzhipeng.com/db/2019/07/01/shardingjdbc-dbs-tbls-ms.html</a></strong></p>\n<p>在上一篇文章介绍了如何使用Sharding-jdbc进行分库+读写分离，这篇文章将讲述如何使用Sharding-jdbc进行分库分表+读写分离。</p>\n<h2><a id="_11"></a>架构回顾</h2>\n<p>在数据量不是很多的情况下，我们可以将数据库进行读写分离，以应对高并发的需求，通过水平扩展从库，来缓解查询的压力。如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190630180142696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在数据量达到500万的时候，这时数据量预估千万级别，我们可以将数据进行分表存储。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190630180156149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在数据量继续扩大，这时可以考虑分库分表，将数据存储在不同数据库的不同表中，如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190630180217231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_25"></a>案例详解</h2>\n<p>本案例有6个数据库，两个主库，四个从库，信息如下：</p>\n\n<table>\n<thead>\n<tr>\n<th align="center">数据库类型</th>\n<th align="center">数据库</th>\n<th align="center">ip</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">主</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.3</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.13</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.17</td>\n</tr>\n<tr>\n<td align="center">主</td>\n<td align="center">cool2</td>\n<td align="center">10.0.0.3</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool2</td>\n<td align="center">10.0.0.13</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool2</td>\n<td align="center">10.0.0.17</td>\n</tr>\n</tbody>\n</table><p>在主库主机的Mysql执行以下脚本，分别为数据库cool和cool2创建5个表，这5个表分别为user_0、user_1、user_2、user_3、user_4。<br>\n执行的脚本如下：</p>\n<pre><code>USE `cool`;\n\n\n/*Table structure for table `user_0` */\n\nDROP TABLE IF EXISTS `user_0`;\n\nCREATE TABLE `user_0` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=149 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_1` */\n\nDROP TABLE IF EXISTS `user_1`;\n\nCREATE TABLE `user_1` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=150 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_2` */\n\nDROP TABLE IF EXISTS `user_2`;\n\nCREATE TABLE `user_2` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=147 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_3` */\n\nDROP TABLE IF EXISTS `user_3`;\n\nCREATE TABLE `user_3` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=148 DEFAULT CHARSET=utf8;\nCREATE TABLE `user_4` (\n  `id` INT(12) NOT NULL AUTO_INCREMENT,\n  `username` VARCHAR(12) NOT NULL,\n  `password` VARCHAR(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=INNODB AUTO_INCREMENT=148 DEFAULT CHARSET=utf8;\n\n\nUSE `cool2`;\n\n\n/*Table structure for table `user_0` */\n\nDROP TABLE IF EXISTS `user_0`;\n\nCREATE TABLE `user_0` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=149 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_1` */\n\nDROP TABLE IF EXISTS `user_1`;\n\nCREATE TABLE `user_1` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=150 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_2` */\n\nDROP TABLE IF EXISTS `user_2`;\n\nCREATE TABLE `user_2` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=147 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_3` */\n\nDROP TABLE IF EXISTS `user_3`;\n\nCREATE TABLE `user_3` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=148 DEFAULT CHARSET=utf8;\n\nCREATE TABLE `user_4` (\n  `id` INT(12) NOT NULL AUTO_INCREMENT,\n  `username` VARCHAR(12) NOT NULL,\n  `password` VARCHAR(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=INNODB AUTO_INCREMENT=148 DEFAULT CHARSET=utf8;\n\n</code></pre>\n<p>案例的工程是在上一篇文章的工程基础上进行改造，其中pom文件的依赖包不变，详情可见源码。</p>\n<p>在工程的application中做sharding-jdbc的分库分表配置，代码如下：</p>\n<pre><code>sharding.jdbc.datasource.names=ds-master-0,ds-master-1,ds-master-0-slave-0,ds-master-0-slave-1,ds-master-1-slave-0,ds-master-1-slave-1\n        \nsharding.jdbc.datasource.ds-master-0.type=com.alibaba.druid.pool.DruidDataSource\nsharding.jdbc.datasource.ds-master-0.driver-class-name=com.mysql.jdbc.Driver\nsharding.jdbc.datasource.ds-master-0.url=jdbc:mysql://10.0.0.3:3306/cool?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT\nsharding.jdbc.datasource.ds-master-0.username=root\nsharding.jdbc.datasource.ds-master-0.password=\n\nsharding.jdbc.datasource.ds-master-0-slave-0.type=com.alibaba.druid.pool.DruidDataSource\nsharding.jdbc.datasource.ds-master-0-slave-0.driver-class-name=com.mysql.jdbc.Driver\nsharding.jdbc.datasource.ds-master-0-slave-0.url=jdbc:mysql://10.0.0.13:3306/cool?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\nsharding.jdbc.datasource.ds-master-0-slave-0.username=root\nsharding.jdbc.datasource.ds-master-0-slave-0.password=\nsharding.jdbc.datasource.ds-master-0-slave-1.type=com.alibaba.druid.pool.DruidDataSource\nsharding.jdbc.datasource.ds-master-0-slave-1.driver-class-name=com.mysql.jdbc.Driver\nsharding.jdbc.datasource.ds-master-0-slave-1.url=jdbc:mysql://10.0.0.17:3306/cool?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\nsharding.jdbc.datasource.ds-master-0-slave-1.username=root\nsharding.jdbc.datasource.ds-master-0-slave-1.password=\n\nsharding.jdbc.datasource.ds-master-1.type=com.alibaba.druid.pool.DruidDataSource\nsharding.jdbc.datasource.ds-master-1.driver-class-name=com.mysql.jdbc.Driver\nsharding.jdbc.datasource.ds-master-1.url=jdbc:mysql://10.0.0.3:3306/cool2?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT\nsharding.jdbc.datasource.ds-master-1.username=root\nsharding.jdbc.datasource.ds-master-1.password=\n\nsharding.jdbc.datasource.ds-master-1-slave-0.type=com.alibaba.druid.pool.DruidDataSource\nsharding.jdbc.datasource.ds-master-1-slave-0.driver-class-name=com.mysql.jdbc.Driver\nsharding.jdbc.datasource.ds-master-1-slave-0.url=jdbc:mysql://10.0.0.13:3306/cool2?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\nsharding.jdbc.datasource.ds-master-1-slave-0.username=root\nsharding.jdbc.datasource.ds-master-1-slave-0.password=\nsharding.jdbc.datasource.ds-master-1-slave-1.type=com.alibaba.druid.pool.DruidDataSource\nsharding.jdbc.datasource.ds-master-1-slave-1.driver-class-name=com.mysql.jdbc.Driver\nsharding.jdbc.datasource.ds-master-1-slave-1.url=jdbc:mysql://10.0.0.17:3306/cool2?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\nsharding.jdbc.datasource.ds-master-1-slave-1.username=root\nsharding.jdbc.datasource.ds-master-1-slave-1.password=\n\nsharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column=id\nsharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression=ds_$-&gt;{id % 2}\n\nsharding.jdbc.config.sharding.tables.user.actual-data-nodes=ds_$-&gt;{0..1}.user_$-&gt;{0..4}\nsharding.jdbc.config.sharding.tables.user.table-strategy.inline.sharding-column=id\nsharding.jdbc.config.sharding.tables.user.table-strategy.inline.algorithm-expression=user_$-&gt;{id % 5}\nsharding.jdbc.config.sharding.tables.user.key-generator-column-name=id\n\nsharding.jdbc.config.sharding.master-slave-rules.ds_0.master-data-source-name=ds-master-0\nsharding.jdbc.config.sharding.master-slave-rules.ds_0.slave-data-source-names=ds-master-0-slave-0, ds-master-0-slave-1\nsharding.jdbc.config.sharding.master-slave-rules.ds_1.master-data-source-name=ds-master-1\nsharding.jdbc.config.sharding.master-slave-rules.ds_1.slave-data-source-names=ds-master-1-slave-0, ds-master-1-slave-1\n\n</code></pre>\n<ul>\n<li>在上面的配置中，其中sharding.jdbc.datasource部分是配置数据库的信息，配置了6个数据库。</li>\n<li>sharding.jdbc.config.sharding.master-slave-rules.ds_0.master-data-source-name配置的是ds_0区的的主库名称，同理ds_1。</li>\n<li>sharding.jdbc.config.sharding.master-slave-rules.ds_0.slave-data-source-names配置的是ds_0区的的从库名称，同理ds_1。</li>\n<li>sharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column配置的分库的字段，本案例是根据id进行分。</li>\n<li>sharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression配置的分库的逻辑，根据id%2进行分。</li>\n<li>sharding.jdbc.config.sharding.tables.user.actual-data-nodes配置的是user表在真实数据库中的位置，ds_<span class="katex--inline">KaTeX parse error: Expected group after \'_\' at position 14: -&gt;{0..1}.user_̲</span>-&gt;{0…4}表示<br>\n数据在ds_0和ds_1中的user_0、user_1、user_2、user_3、user_4中。</li>\n<li>sharding.jdbc.config.sharding.tables.user.table-strategy.inline.sharding-column，配置user表数据切分的字段</li>\n<li>sharding.jdbc.config.sharding.tables.user.table-strategy.inline.algorithm-expression=user_$-&gt;{id % 5}，配置user表数据切分的策略。</li>\n<li>sharding.jdbc.config.sharding.tables.user.key-generator-column-name=id 自动生成id。</li>\n</ul>\n<p>然后在Spring Boot启动类的注解@SpringBootApplication，加上exclude={DataSourceAutoConfiguration.class}，代码如下：</p>\n<pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})\n@EnableConfigurationProperties\npublic class ShardingJdbcDbMsTblApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ShardingJdbcDbMsTblApplication.class, args);\n    }\n\n}\n\n</code></pre>\n<h2><a id="_245"></a>测试</h2>\n<p>测试同上一篇文章，这里不在重复。</p>\n<h2><a id="_249"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringBootLearning/tree/master/sharding-jdbc-example/sharding-jdbc-db-ms-tbl</p>\n<h2><a id="_253"></a>资料参考</h2>\n<p>https://github.com/apache/incubator-shardingsphere-example/releases/tag/3.1.0.M1</p>\n<p>https://shardingsphere.apache.org/document/current/cn/overview/</p>\n<p>https://github.com/apache/incubator-shardingsphere</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/94174114', 'title': 'Sharding-JDBC教程：Spring Boot整合Sharding-JDBC实现读写分离', 'readNum': '5397', 'commentNum': '9', 'publishTime': '2019-06-29 16:48:08', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/94174114<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：https://www.fangzhipeng.com/db/2019/06/26/shardingjdbc-master-slave.html</p>\n<h2><a id="ShardingJDBC_7"></a>Sharding-JDBC简介</h2>\n<p>Sharding-JDBC是的分布式数据库中间件解决方案。Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）是3款相互独立的产品，共同<br>\n组成了ShardingSphere。Sharding-JDBC定位于轻量级的Java框架，它使用客户端直连数据库，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>\n<ul>\n<li>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li>\n<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</li>\n<li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。</li>\n</ul>\n<p>架构图如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190629164908744.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>支持以下的特效：</p>\n<ul>\n<li>分库分表</li>\n<li>读写分离</li>\n<li>柔性事务</li>\n<li>分布式主键</li>\n<li>分布式治理能力</li>\n</ul>\n<h2><a id="_28"></a>工程准备</h2>\n<p>在上一篇文章中已经详细的讲解了如何构建Mysql5.7的读写分离，并且已经构建好了。详细信息如下：</p>\n\n<table>\n<thead>\n<tr>\n<th align="center">数据库类型</th>\n<th align="center">数据库</th>\n<th align="center">ip</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">主</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.3</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.13</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.17</td>\n</tr>\n</tbody>\n</table><p>在主库里面执行以下的数据库初始化脚本：</p>\n<pre><code>USE `cool`;\n\nDROP TABLE IF EXISTS `user`;\n\nCREATE TABLE `user` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;\n\n</code></pre>\n<p>在上一篇文章中，主从数据库已经搭建好了，所以执行完上面的脚本后，2个从库应该也有user表。</p>\n<h2><a id="_63"></a>案例讲解</h2>\n<p>在本篇文章中使用Spring Boot 2.0.3+MyBatis+Druid+Sharding-JDBC+MySQL进行读写分离的案件讲解。<br>\n关于Mybatis部分的代码生成可以参考https://github.com/forezp/mybatis-generator这里，Mybatis部分的配置和代码在这里<br>\n就不详细说明，详情可以查看源代码。工程结构如下图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190629164651787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在工程的pom文件引入以下的依赖，包括Spring Boot的Web起步依赖spring-boot-starter-web，mybatis的起步依赖mybatis-spring-boot-starter，<br>\nmysql的连机器，连接池druid的起步依赖druid-spring-boot-starter，sharding-jdbc的起步依赖sharding-jdbc-spring-boot-starter。代码如下：</p>\n<pre><code>  &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;1.3.2&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;1.1.10&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.1.0.M1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n</code></pre>\n<p>在spring boot工程配置文件application.yml做以下的配置：</p>\n<pre><code>\n\nsharding:\n  jdbc:\n    dataSource:\n      names: db-test0,db-test1,db-test2\n      # 配置主库\n      db-test0: #org.apache.tomcat.jdbc.pool.DataSource\n        type: com.alibaba.druid.pool.DruidDataSource\n        driverClassName: com.mysql.jdbc.Driver\n        url: jdbc:mysql://10.0.0.3:3306/cool?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT\n        username: root\n        password:\n        #最大连接数\n        maxPoolSize: 20\n      db-test1: # 配置第一个从库\n        type: com.alibaba.druid.pool.DruidDataSource\n        driverClassName: com.mysql.jdbc.Driver\n        url: jdbc:mysql://10.0.0.13:3306/cool?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\n        username: root\n        password:\n        maxPoolSize: 20\n      db-test2: # 配置第二个从库\n        type: com.alibaba.druid.pool.DruidDataSource\n        driverClassName: com.mysql.jdbc.Driver\n        url: jdbc:mysql://10.0.0.17:3306/cool?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\n        username: root\n        password:\n        maxPoolSize: 20\n    config:\n      masterslave: # 配置读写分离\n        load-balance-algorithm-type: round_robin # 配置从库选择策略，提供轮询与随机，这里选择用轮询//random 随机 //round_robin 轮询\n        name: db1s2\n        master-data-source-name: db-test0\n        slave-data-source-names: db-test1,db-test2\n    props:\n      sql: # 开启SQL显示，默认值: false，注意：仅配置读写分离时不会打印日志！！！\n        show: true\n\n</code></pre>\n<p>sharding.jdbc.dataSource.names配置的是数据库的名称，就是多个数据源的名称。<br>\nsharding.jdbc.dataSource配置多个数据源。需要配置数据库名称，和上面配置的对应。以及数据的配置，包括连接池的类型、连接器、数据库地址、<br>\n数据库账户密码信息等。<br>\nsharding.jdbc.config.masterslave.load-balance-algorithm-type查询时的负载均衡算法，目前有2种算法，round_robin（轮询）和random（随机）。<br>\nsharding.jdbc.config.masterslave.master-data-source-name主数据源名称。<br>\nsharding.jdbc.config.masterslave.slave-data-source-names从数据源名称，多个用逗号隔开。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190629164730341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_157"></a>案例验证</h2>\n<p>写2个接口，代码如下：</p>\n<pre><code>@RestController\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping("/users")\n    public Object list() {\n        return userService.list();\n    }\n\n    @GetMapping("/add")\n    public Object add(@RequestParam Integer id,@RequestParam String username,@RequestParam String  password) {\n        User user = new User();\n        user.setId(id);\n        user.setUsername(username);\n        user.setPassword(password);\n        return userService.addUser(user);\n    }\n}\n\n</code></pre>\n<p>在上一篇文章中，已经开启了数据库的CRUD日志，日志目录在/var/lib/mysql目录下。</p>\n<p>调用2个接口，可以在主库对应主机的日志目录下查看插入数据的日志：</p>\n<pre><code>2019-06-20T02:50:25.183174Z\t 2030 Query\tselect @@session.transaction_read_only\n2019-06-20T02:50:25.193506Z\t 2030 Query\tINSERT INTO user (\n          id, username, password\n        )\n        VALUES (\n        134,\n        \'forezp134\',\n        \'1233edwd\'\n        )\n\n</code></pre>\n<p>从库对应主机的日志目录下查看查询数据的日志：</p>\n<pre><code>2019-06-20T02:41:28.450643Z\t 7367 Query\tSELECT u.* FROM user u\n</code></pre>\n<p>这就说明，Sharding-JDBC实现了数据库的读写分离。</p>\n<h2><a id="_211"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringBootLearning/tree/master/sharding-jdbc-example/sharding-jdbc-master-slave</p>\n<h2><a id="_215"></a>参考资料</h2>\n<p>https://github.com/apache/incubator-shardingsphere-example/releases/tag/3.1.0.M1</p>\n<p>https://shardingsphere.apache.org/document/current/cn/overview/</p>\n<p>https://github.com/apache/incubator-shardingsphere</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/94174577', 'title': 'Sharding-JDBC教程：Spring Boot整合Sharding-JDBC实现数据分表+读写分离', 'readNum': '4204', 'commentNum': '6', 'publishTime': '2019-06-29 16:51:21', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/94174577<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版： https://www.fangzhipeng.com/db/2019/06/30/sharding-jdbc-tables-ms.html</p>\n<h2><a id="_9"></a>读写分离</h2>\n<p>在上一篇文章介绍了如何使用Sharing-JDBC实现数据库的读写分离。读写分离的好处就是在并发量比较大的情况下，将查询数据库的压力<br>\n分担到多个从库中，能够满足高并发的要求。比如上一篇实现的那样，架构图如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190629165031256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_16"></a>数据分表</h2>\n<p>当数据量比较大的时候，比如单个表的数据量超过了500W的数据，这时可以考虑将数据存储在不同的表中。比如将user表拆分为四个表user_0、user_1、<br>\nuser_2、user_3装在四个表中。此时如图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190629165047382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_22"></a>案例详解</h2>\n<p>和上一篇文章使用的数据库是同一个数据库，数据库信息如下：</p>\n\n<table>\n<thead>\n<tr>\n<th align="center">数据库类型</th>\n<th align="center">数据库</th>\n<th align="center">ip</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">主</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.3</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.13</td>\n</tr>\n<tr>\n<td align="center">从</td>\n<td align="center">cool</td>\n<td align="center">10.0.0.17</td>\n</tr>\n</tbody>\n</table><p>在主库初始化Mysql数据的脚本，初始化完后，从库也会创建这些表，脚本信息如下：</p>\n<pre><code>USE `cool`;\n\n/*Table structure for table `user_0` */\n\nDROP TABLE IF EXISTS `user_0`;\n\nCREATE TABLE `user_0` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=149 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_1` */\n\nDROP TABLE IF EXISTS `user_1`;\n\nCREATE TABLE `user_1` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=150 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_2` */\n\nDROP TABLE IF EXISTS `user_2`;\n\nCREATE TABLE `user_2` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=147 DEFAULT CHARSET=utf8;\n\n/*Table structure for table `user_3` */\n\nDROP TABLE IF EXISTS `user_3`;\n\nCREATE TABLE `user_3` (\n  `id` int(12) NOT NULL AUTO_INCREMENT,\n  `username` varchar(12) NOT NULL,\n  `password` varchar(30) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx-username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=148 DEFAULT CHARSET=utf8;\n\n</code></pre>\n<p>本案例还是在上一篇文章的案例基础之上进行改造，工程的目录和pom的依赖见上一篇文章或者源码。在工程的配置<br>\n文件application.yml做Sharding-JDBC的配置，代码如下：</p>\n<pre><code>\nsharding:\n  jdbc:\n    dataSource:\n      names: db-test0,db-test1,db-test2\n      db-test0: #org.apache.tomcat.jdbc.pool.DataSource\n        type: com.alibaba.druid.pool.DruidDataSource\n        driverClassName: com.mysql.jdbc.Driver\n        url: jdbc:mysql://10.0.0.3:3306/cool?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT\n        username: root\n        password: \n        maxPoolSize: 20\n      db-test1:\n        type: com.alibaba.druid.pool.DruidDataSource\n        driverClassName: com.mysql.jdbc.Driver\n        url: jdbc:mysql://10.0.0.13:3306/cool?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\n        username: root\n        password: \n        maxPoolSize: 20\n      db-test2:\n        type: com.alibaba.druid.pool.DruidDataSource\n        driverClassName: com.mysql.jdbc.Driver\n        url: jdbc:mysql://10.0.0.17:3306/cool?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT\n        username: root\n        password: \n        maxPoolSize: 20\n    props:\n      sql:\n        show: true\nsharding.jdbc.config.sharding.tables.user.actual-data-nodes: ds_0.user_$-&gt;{0..3}\nsharding.jdbc.config.sharding.tables.user.table-strategy.standard.sharding-column: id\nsharding.jdbc.config.sharding.tables.user.table-strategy.standard.precise-algorithm-class-name: com.forezp.sharedingjdbcmasterslavetables.MyPreciseShardingAlgorithm\n\nsharding.jdbc.config.sharding.master-slave-rules.ds_0.master-data-source-name: db-test0\nsharding.jdbc.config.sharding.master-slave-rules.ds_0.slave-data-source-names: db-test1,db-test2\n\n</code></pre>\n<ul>\n<li>\n<p>在上面的配置中，sharding.jdbc.dataSource部分是配置的数据源的信息，本案例有三个数据源db-test0、db-test1、db-test2。</p>\n</li>\n<li>\n<p>sharding.jdbc.config.sharding.master-slave-rules.ds_0.master-data-source-name配置的是主库的数据库名，本案例为db-test0，其中ds_0为分区名。</p>\n</li>\n<li>\n<p>sharding.jdbc.config.sharding.master-slave-rules.ds_0.slave-data-source-names配置的是从库的数据库名，本案例为db-test1、db-test2。</p>\n</li>\n<li>\n<p>sharding.jdbc.config.sharding.tables.user.actual-data-nodes配置的分表信息，真实的数据库信息。ds_0.user_$-&gt;{0…3}，表示读取ds_0数据源的user_0、user_1、user_2、user_3。</p>\n</li>\n<li>\n<p>sharding.jdbc.config.sharding.tables.user.table-strategy.standard.sharding-column配置的数据分表的字段，是根据id来分的。</p>\n</li>\n<li>\n<p>sharding.jdbc.config.sharding.tables.user.table-strategy.standard.precise-algorithm-class-name是配置数据分表的策略的类，这里是自定义的类MyPreciseShardingAlgorithm。</p>\n</li>\n</ul>\n<p>MyPreciseShardingAlgorithm是根据id取模4来获取表名的，代码如下：</p>\n<pre><code>public class MyPreciseShardingAlgorithm implements PreciseShardingAlgorithm&lt;Integer&gt; {\n\n\t@Override\n\tpublic String doSharding(Collection&lt;String&gt; availableTargetNames, PreciseShardingValue&lt;Integer&gt; shardingValue) {\n\t\tfor (String tableName : availableTargetNames) {\n\t\t\tif (tableName.endsWith(shardingValue.getValue() % 4 + "")) {\n\t\t\t\treturn tableName;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException();\n\t}\n\n}\n\n</code></pre>\n<h2><a id="_154"></a>测试</h2>\n<p>写一个API来测试，代码如下：</p>\n<pre><code>@RestController\npublic class UserController {\n\n    Logger logger= LoggerFactory.getLogger(UserController.class);\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping("/users")\n    public Object list() {\n        return userService.list();\n    }\n\n    @GetMapping("/add")\n    public Object add() {\n\n        for(int i=100;i&lt;150;i++) {\n            User user = new User();\n            user.setId(i);\n            user.setUsername("forezp"+(i));\n            user.setPassword("1233edwd");\n           long resutl=   userService.addUser(user);\n            logger.info("insert:"+user.toString()+" result:"+resutl);\n        }\n        return "ok";\n    }\n}\n\n</code></pre>\n<p>启动Spring Boot工程，在浏览器上执行localhost:8080/add，然后去数据库中查询，可以看到user_0、user_1、user_2、user_3分别插入了数据。<br>\n然后访问localhost:8080/users，可以查询数据库中四个表中的所有数据。可见Sharding-JDBC在插入数据的时候，根据数据分表策略，将数据存储在<br>\n不同的表中，查询的时候将数据库从多个表中查询并聚合。</p>\n<p>在数据库的主机的日志里面，可以看到查询的日志也验证了这个结论，如下：</p>\n<pre><code>2019-06-20T02:50:25.183174Z\t 2030 Query\tselect @@session.transaction_read_only\n2019-06-20T02:50:25.193506Z\t 2030 Query\tINSERT INTO user_2 (\n          id, username, password\n        )\n        VALUES (\n        134,\n        \'forezp134\',\n        \'1233edwd\'\n        )\n\n...省略\n</code></pre>\n<p>从库查询日志：</p>\n<pre><code>2019-06-20T02:41:28.450643Z\t 7367 Query\tSELECT u.* FROM user_1 u\n2019-06-20T02:41:28.450644Z\t 7366 Query\tSELECT u.* FROM user_0 u\n2019-06-20T02:41:28.461238Z\t 7367 Query\tSELECT u.* FROM user_3 u\n2019-06-20T02:41:28.462188Z\t 7366 Query\tSELECT u.* FROM user_2 u\n\n</code></pre>\n<h2><a id="_219"></a>源码</h2>\n<p>https://github.com/forezp/SpringBootLearning/tree/master/sharding-jdbc-example/shareding-jdbc-master-slave-tables</p>\n<h2><a id="_223"></a>参考资料</h2>\n<p>https://github.com/apache/incubator-shardingsphere-example/releases/tag/3.1.0.M1</p>\n<p>https://shardingsphere.apache.org/document/current/cn/overview/</p>\n<p>https://github.com/apache/incubator-shardingsphere</p>\n<p>https://mp.weixin.qq.com/s/VlJ_3oN0Us2e_ZPk0sDT7w</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/90729945', 'title': 'Spring Cloud Alibaba教程：使用Nacos作为配置中心', 'readNum': '11903', 'commentNum': '6', 'publishTime': '2019-06-01 15:50:48', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/90729945<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/springcloud/2019/06/01/sc-nacos-config.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/06/01/sc-nacos-config.html</a></strong></p>\n<p>在上一篇文章中讲解了如何使用Nacos作为服务注册中心注册。Nacos除了可以作为服务注册中心，它还有服务配置中心的功能。类似于consul config，Nacos 是支持热加载的。本篇文章将讲述如何使用Nacos作为配置中心。</p>\n<p>本案例是在上一篇文章（Nacos作为服务注册与发现）的nacos-provider工程上改造的，在工程的pom文件引入nacos-config的Spring cloud依赖，版本为0.9.0. RELEASE，代码如下：</p>\n<pre><code class="prism language-text">&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t&lt;artifactId&gt;spring-cloud-alibaba-nacos-config&lt;/artifactId&gt;\n\t&lt;version&gt;0.9.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>在bootstrap.yml(一定是bootstrap.yml文件，不是application.yml文件)文件配置以下内容：</p>\n<pre><code class="prism language-text">spring:\n  application:\n    name: nacos-provider\n  cloud:\n    nacos:\n      config:\n        server-addr: 127.0.0.1:8848\n        file-extension: yaml\n        prefix: nacos-provider\n  profiles:\n    active: dev\n</code></pre>\n<p>在上面的配置中，配置了nacos config server的地址，配置的扩展名是ymal（目前仅支持ymal和properties）。注意是没有配置server.port的，sever.port的属性在nacos中配置。上面的配置是和Nacos中的<code>dataId</code> 的格式是对应的，nacos的完整格式如下：</p>\n<pre><code class="prism language-text">${prefix}-${spring.profile.active}.${file-extension}\n</code></pre>\n<ul>\n<li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li>\n<li><code>spring.profile.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles" rel="nofollow">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profile.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>${prefix}.${file-extension}</code></strong></li>\n<li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li>\n</ul>\n<p>启动nacos，登陆localhost:8848/nacos，创建一个data id ，完整的配置如图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601155136396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>\n写一个RestController,在Controller上添加 @RefreshScope 实现配置的热加载。代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RefreshScope</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${username:lily}"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/username"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> username<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>启动工程nacos-provider，在浏览器上访问localhost:8761/username，可以返回在nacos控制台上配置的username。在nacos 网页上更改username的配置，在不重启nacos-provider工程的情况下，重新访问localhost:8761/username，返回的事修改后的值，可见nacos作为配置中心实现了热加载功能。</p>\n<h2><a id="_67"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/springcloud-alibaba/nacos-config</p>\n<h2><a id="_72"></a>参考资料</h2>\n<p>https://nacos.io/zh-cn/docs/what-is-nacos.html</p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/94173427', 'title': 'Sharding-JDBC教程：Mysql数据库主从搭建', 'readNum': '5602', 'commentNum': '8', 'publishTime': '2019-06-29 16:44:53', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/94173427<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：<a href="https://www.fangzhipeng.com/db/2019/06/25/mysql-install-ms.html" rel="nofollow">https://www.fangzhipeng.com/db/2019/06/25/mysql-install-ms.html</a></p>\n<h2><a id="mysql_57__7"></a>mysql 5.7 安装</h2>\n<p>这是系列文章Sharding-jdbc文章的第一篇，本篇文章主要讲述如何搭建Mysql的主从。搭建环境为centos 7.5，数据库版本为5.7。需要三台虚拟机，一主两从，读者可以在自己的电脑上创建虚拟机，也可以在云服务商买三台，按小时计费，一小时几毛钱，比较实惠。Ip分配如下：</p>\n<ul>\n<li>10.0.0.5 主</li>\n<li>10.0.0.13 从</li>\n<li>10.0.0.17 从</li>\n</ul>\n<h3><a id="Mysql_57_16"></a>安装Mysql 5.7</h3>\n<p>下载yum源</p>\n<pre><code> wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n\n</code></pre>\n<p>本地安装yum源</p>\n<pre><code>yum localinstall mysql57-community-release-el7-11.noarch.rpm\n</code></pre>\n<p>检查 mysql 源是否安装成功</p>\n<pre><code> yum repolist enabled | grep "mysql.*-community.*"\n\n</code></pre>\n<p>出现以下信息，说明安装成功：</p>\n<pre><code>mysql-connectors-community/x86_64    MySQL Connectors Community              108\nmysql-tools-community/x86_64         MySQL Tools Community                    90\nmysql57-community/x86_64             MySQL 5.7 Community Server              347\n\n</code></pre>\n<p>使用 yum install 命令安装Mysql:</p>\n<pre><code>yum install -y mysql-community-server\n</code></pre>\n<p>这个安装过程时间可能较长。安装成功后，启动mysql：</p>\n<pre><code>systemctl start mysqld\n</code></pre>\n<p>启动完成后，查看Mysql的状态：</p>\n<pre><code>systemctl status mysqld\n\n</code></pre>\n<p>上述命令显示以下信息，则安装成功：</p>\n<pre><code>● mysqld.service - MySQL Server\n   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)\n   Active: active (running) since Thu 2019-06-20 10:24:39 CST; 4s ago\n     Docs: man:mysqld(8)\n           http://dev.mysql.com/doc/refman/en/using-systemd.html\n  Process: 13879 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)\n  Process: 13799 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)\n Main PID: 13883 (mysqld)\n   CGroup: /system.slice/mysqld.service\n           └─13883 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid\n\n</code></pre>\n<p>设置开机启动：</p>\n<pre><code>systemctl enable mysqld\n\n</code></pre>\n<h3><a id="Mydql__90"></a>修改Mydql 密码</h3>\n<p>mysql 安装完成之后，生成的默认密码在 /var/log/mysqld.log 文件中。使用 grep 命令找到日志中的密码。</p>\n<pre><code>grep \'temporary password\' /var/log/mysqld.log\n</code></pre>\n<p>上面的命令显示的密码如下：</p>\n<pre><code>2019-06-20T02:24:34.544392Z 1 [Note] A temporary password is generated for root@localhost: SrwXhkgt9t+;\n</code></pre>\n<p>首次登录mysql，修改密码：</p>\n<pre><code>mysql -uroot -p\nmysql&gt; ALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'Forezp@2019\'; \n</code></pre>\n<h3><a id="_110"></a>允许远程登录</h3>\n<p>修改 root 为允许远程连接，生产环境不建议：</p>\n<pre><code>mysql&gt; use mysql;\nmysql&gt; UPDATE user SET Host=\'%\' WHERE User=\'root\';\nmysql&gt; flush privileges;\n\n</code></pre>\n<h3><a id="_121"></a>开启日志（非必须）</h3>\n<p><strong>（非必须）开启sql语句的日志，生产环境不建议开启：</strong></p>\n<p>查看日志目录，并开启sql语句的日志：</p>\n<pre><code>mysql&gt;  show variables like \'%general_log%\';\nmysql&gt;  set global general_log=on;\n</code></pre>\n<p>开启后，重启Mysql ，上述开启日志配置将失效。</p>\n<h2><a id="Mysql_134"></a>Mysql的主从配置</h2>\n<h3><a id="_136"></a>机器准备</h3>\n<p>在三台机器上按照上面的步骤安装完Mysql5.7，三台机器的ip分别为:</p>\n<ul>\n<li>10.0.0.5 主</li>\n<li>10.0.0.13 从</li>\n<li>10.0.0.17 从</li>\n</ul>\n<p>在三台机器上分别创建2个数据库，分别为cool和cool2，字符编码为utf8:</p>\n<pre><code>CREATE DATABASE `cool` CHARACTER SET utf8 COLLATE utf8_general_ci;\nCREATE DATABASE `cool2` CHARACTER SET utf8 COLLATE utf8_general_ci;\n</code></pre>\n<p>关闭防火墙</p>\n<p>要保证防火墙3306端口开放，如果只是为了学习，可以直接关闭防火墙。</p>\n<p>centos关闭防火墙方法：service iptables stop或者systemctl stop firewalld</p>\n<h3><a id="master__156"></a>master 节点配置</h3>\n<p>在10.0.0.5机器上配置</p>\n<p>vim /etc/my.inc</p>\n<pre><code>#server-id给数据库服务的唯一标识\nserver-id=1\n#\n##log-bin设置此参数表示启用binlog功能，并指定路径名称\nlog-bin=/var/lib/mysql/mysql-bin\nsync_binlog=0\n##设置日志的过期天数\nexpire_logs_days=7\nbinlog-do-db=cool\nbinlog-do-db=cool2\nbinlog-ignore-db=information_schema\nbinlog-ignore-db=sys\nbinlog-ignore-db=mysql\nbinlog-ignore-db=performance_schema\n</code></pre>\n<ul>\n<li>这里的server-id用于标识唯一的数据库，在从库必须设置为不同的值。</li>\n<li>binlog-ignore-db：表示同步的时候忽略的数据库</li>\n<li>binlog-do-db：指定需要同步的数据库</li>\n</ul>\n<p>重启mysql，配置生效，执行以下的命令：systemctl restart mysqld</p>\n<p>重启成功后，登录mysql。</p>\n<p>赋予从库权限账号，允许用户在主库上读取日志，赋予10.0.0.13和10.0.0.17也就是Slave机器有File权限，<br>\n只赋予Slave机器有File权限还不行，还要给它REPLICATION SLAVE的权限才可以。</p>\n<pre><code>mysql&gt; grant FILE on *.* to \'root\'@\'10.0.0.13\' identified by \'Forezp@2019\';\nmysql&gt; grant replication slave on *.* to \'root\'@\'10.0.0.13\' identified by \'Forezp@2019\';\nmysql&gt; flush privileges;\n\nmysql&gt; grant FILE on *.* to \'root\'@\'10.0.0.17\' identified by \'Forezp@2019\';\nmysql&gt; grant replication slave on *.* to \'root\'@\'10.0.0.17\' identified by \'Forezp@2019\';\nmysql&gt; flush privileges;\n\n</code></pre>\n<p>这里的用户是同步的时候从库使用的用户。</p>\n<p>重启mysql(systemctl restart mysqld)，登录mysql，查看主库信息</p>\n<pre><code>mysql&gt; show master status;\n+------------------+----------+--------------+-------------------------------------------------+-------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB                                | Executed_Gtid_Set |\n+------------------+----------+--------------+-------------------------------------------------+-------------------+\n| mysql-bin.000010 |      154 | cool,cool2   | information_schema,sys,mysql,performance_schema |                   |\n+------------------+----------+--------------+-------------------------------------------------+-------------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<p>File是同步会使用到的binlog文件，Position是同步的时候也要用到的。</p>\n<h3><a id="_217"></a>配置从库</h3>\n<p>1、修改/etc/my.conf</p>\n<pre><code>log-bin=mysql-bin\nserver-id=3\nbinlog-ignore-db=information_schema\nbinlog-ignore-db=sys\nbinlog-ignore-db=mysql\nreplicate-do-db=cool\nreplicate-do-db=cool2\nreplicate-ignore-db=mysql\nlog-slave-updates\nslave-skip-errors=all\nslave-net-timeout=60\n</code></pre>\n<p>注意：两个从库的server-id不一样，需要唯一。</p>\n<p>2.修改完/etc/my.cnf后，重启一下mysql(systemctl restart mysqld)</p>\n<p>进入Slave的mysql控制台，执行下面操作：</p>\n<pre><code>mysql&gt; stop slave;\nmysql&gt; change master to master_host=\'10.0.0.5\',master_user=\'root\',master_password=\'Forezp@2019\',master_log_file=\'mysql-bin.000010\', master_log_pos=154;\nstart slave;\n</code></pre>\n<p>注意：上面的master_log_file是在Master中show master status显示的File，<br>\n而master_log_pos是在Master中show master status显示的Position。</p>\n<p>配置第二个从库的时候，需要重新从matser获取File和position。</p>\n<p>3.然后可以通过show slave status查看配置信息。</p>\n<pre><code>\nmysql&gt; show slave status \\G\n*************************** 1. row ***************************\n               Slave_IO_State: Waiting for master to send event\n                  Master_Host: 10.0.0.5\n                  Master_User: root\n                  Master_Port: 3306\n                Connect_Retry: 60\n              Master_Log_File: mysql-bin.000010\n          Read_Master_Log_Pos: 154\n               Relay_Log_File: VM_0_13_centos-relay-bin.000002\n                Relay_Log_Pos: 320\n        Relay_Master_Log_File: mysql-bin.000010\n             Slave_IO_Running: Yes\n            Slave_SQL_Running: Yes\n              Replicate_Do_DB: cool,cool2\n          Replicate_Ignore_DB: mysql\n           Replicate_Do_Table: \n       Replicate_Ignore_Table: \n      Replicate_Wild_Do_Table: \n  Replicate_Wild_Ignore_Table: \n\n</code></pre>\n<p>上面的信息有Slave_IO_Running: Yes和Slave_SQL_Running: Yes，证明主从同步成功。</p>\n<p>4.出错清理掉之前的配置，防止同步已经同步了的数据，执行以下命令：</p>\n<pre><code>mysql&gt; stop slave;\nmysql&gt; reset slave all;\n</code></pre>\n<p>上述的步骤需要在2个从库中操作，操作完成后。可以在Master建表插入数据，然后再从2个库中查看，如果2个都有数据，则证明主从数据库同步成功。</p>\n<h2><a id="_289"></a>总结</h2>\n<p>本篇文章以实战的方式讲解如何搭建Mysql数据库的主从。后面的文章将讲述如何使用Sharding-jdbc+mybatis+springboot2，来实现数据库主从的读写分离。</p>\n<h2><a id="_294"></a>参考资料</h2>\n<p>https://www.jianshu.com/p/1dab9a4d0d5f<br>\nhttps://www.cnblogs.com/eleven24/p/7350000.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/90142744', 'title': 'Spring Cloud Alibaba教程：使用Nacos作为服务注册发现组件', 'readNum': '16851', 'commentNum': '17', 'publishTime': '2019-05-12 17:29:06', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/90142744<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2019/05/30/sc-nacos-discovery.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2019/05/30/sc-nacos-discovery.html</a></strong></p>\n<h2><a id="Nacos_6"></a>什么是Nacos?</h2>\n<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>\n是Spring Cloud A 中的服务注册发现组件，类似于Consul、Eureka，同时它又提供了分布式配置中心的功能，这点和Consul的config类似，支持热加载。</p>\n<p><strong>Nacos 的关键特性包括:</strong></p>\n<ul>\n<li>服务发现和服务健康监测</li>\n<li>动态配置服务，带管理界面，支持丰富的配置维度。</li>\n<li>动态 DNS 服务</li>\n<li>服务及其元数据管理</li>\n</ul>\n<p><strong>Nacos下载</strong></p>\n<p>Nacos依赖于Java环境，所以必须安装Java环境。然后从官网下载Nacos的解压包，安装稳定版的，下载地址：https://github.com/alibaba/nacos/releases</p>\n<p>本次案例下载的版本为1.0.0 ，下载完成后，解压，在解压后的文件的/bin目录下，windows系统点击startup.cmd就可以启动nacos。linux或mac执行以下命令启动nacos。</p>\n<pre><code class="prism language-text">sh startup.sh -m standalone\n</code></pre>\n<p>启动时会在控制台，打印相关的日志。nacos的启动端口为8848,在启动时要保证端口不被占用。珠穆拉马峰的高度是8844，nacos的端口是8848，有点巧合。</p>\n<p>启动成功，在浏览器上访问：http://localhost:8848/nacos，会跳转到登陆界面，默认的登陆用户名为nacos，密码也为nacos。</p>\n<p>登陆成功后，展示的界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010037271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>从界面可知，此时没有服务注册到Nacos上。</p>\n<h2><a id="Nacos_40"></a>使用Nacos服务注册和发现</h2>\n<p>服务注册和发现是微服务治理的根基，服务注册和发现组件是整个微服务系统的灵魂，选择合适的服务注册和发现组件至关重要，目前主流的服务注册和发现组件有Consul、Eureka、Etcd等。<br>\n随着Eureka的闭源，Spring cloud netflix-oss组件大规模的进入到了维护期，不再提供新功能，spring cloud alibaba受到开源社区的大力拥护。</p>\n<h3><a id="_46"></a>服务注册</h3>\n<p>在本案例中，使用2个服务注册到Nacos上，分别为nacos-provider和nacos-consumer。</p>\n<h4><a id="nacosprovider_50"></a>构建服务提供者nacos-provider</h4>\n<p>新建一个Spring Boot项目，Spring boot版本为2.1.4.RELEASE，Spring Cloud 版本为Greenwich.RELEASE，在pom文件引入nacos的Spring Cloud起步依赖，代码如下：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;0.9.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>在工程的配置文件application.yml做相关的配置，配置如下：</p>\n<pre><code class="prism language-text">\nserver:\n  port: 8762\nspring:\n  application:\n    name: nacos-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\n\n\n</code></pre>\n<p>在上述的配置的中，程序的启动端口为8762，应用名为nacos-provider，向nacos server注册的地址为127.0.0.1:8848。</p>\n<p>然后在Spring Boot的启动文件NacosProviderApplication加上@EnableDiscoveryClient注解，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableDiscoveryClient</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NacosProviderApplication</span> <span class="token punctuation">{</span>\n\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\tSpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>NacosProviderApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h4><a id="nacosconsuer_99"></a>构建服务消费者nacos-consuer</h4>\n<p>和nacos-provider一样，构建服务消费者nacos-consumer，nacos-cosumer的启动端口8763。构建过程同nacos-provider，这里省略。</p>\n<h4><a id="_103"></a>验证服务注册个发现</h4>\n<p>分别启动2个工程，待工程启动成功之后，在访问localhost:8848，可以发现nacos-provider和nacos-consumer，均已经向nacos-server注册，如下图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010100848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_111"></a>服务调用</h2>\n<p>nacos作为服务注册和发现组件时，在进行服务消费，可以选择RestTemplate和Feign等方式。这和使用Eureka和Consul作为服务注册和发现的组件是一样的，没有什么区别。这是因为spring-cloud-starter-alibaba-nacos-discovery依赖实现了Spring Cloud服务注册和发现的相关接口，可以和其他服务注册发现组件无缝切换。</p>\n<h3><a id="_116"></a>提供服务</h3>\n<p>在nacos-provider工程，写一个Controller提供API服务，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProviderController</span> <span class="token punctuation">{</span>\n\nLogger logger<span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>ProviderController<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> String <span class="token function">hi</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">,</span>defaultValue <span class="token operator">=</span> <span class="token string">"forezp"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\n        <span class="token keyword">return</span> <span class="token string">"hi "</span><span class="token operator">+</span>name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3><a id="_134"></a>消费服务</h3>\n<p>在这里使用2种方式消费服务，一种是RestTemplate，一种是Feign。</p>\n<h4><a id="RestTemplate_138"></a>使用RestTemplate消费服务</h4>\n<p>RestTemplate可以使用Ribbon作为负载均衡组件，在nacos-consumer工程中引入ribbon的依赖：</p>\n<pre><code>\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n\n</code></pre>\n<p>在NacosConsumerApplication启动文件注入RestTemplate的Bean，代码如下：</p>\n<pre><code class="prism language-java">\t<span class="token annotation punctuation">@LoadBalanced</span>\n\t<span class="token annotation punctuation">@Bean</span>\n\t<span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\n</code></pre>\n<p>加上@LoadBalanced注解即可在RestTemplate上开启LoadBalanced负载均衡的功能。</p>\n<p>写一个消费服务的ConsumerController，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    RestTemplate restTemplate<span class="token punctuation">;</span>\n\n <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi-resttemplate"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">hiResttemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://nacos-provider/hi?name=resttemplate"</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n</code></pre>\n<p>重启工程，在浏览器上访问http://localhost:8763/hi-resttemplate，可以在浏览器上展示正确的响应，这时nacos-consumer调用nacos-provider服务成功。</p>\n<h4><a id="FeignClient_188"></a>是FeignClient调用服务</h4>\n<p>在nacos-consumer的pom文件引入以下的依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n   &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>在NacosConsumerApplication启动文件上加上@EnableFeignClients注解开启FeignClient的功能。</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableFeignClients</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NacosConsumerApplication</span> <span class="token punctuation">{</span>\n\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\tSpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>NacosConsumerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\n</code></pre>\n<p>写一个FeignClient，调用nacos-provider的服务，代码如下：</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"nacos-provider"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProviderClient</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">)</span>\n    String <span class="token function">hi</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">,</span> defaultValue <span class="token operator">=</span> <span class="token string">"forezp"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>写一个消费API，该API使用ProviderClient来调用nacos-provider的API服务，代码如下：</p>\n<pre><code class="prism language-java">\n\n<span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerController</span> <span class="token punctuation">{</span>\n\n\n    <span class="token annotation punctuation">@Autowired</span>\n    ProviderClient providerClient<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hi-feign"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">hiFeign</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n       <span class="token keyword">return</span> providerClient<span class="token punctuation">.</span><span class="token function">hi</span><span class="token punctuation">(</span><span class="token string">"feign"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n\n</code></pre>\n<p>重启工程，在浏览器上访问http://localhost:8763/hi-feign，可以在浏览器上展示正确的响应，这时nacos-consumer调用nacos-provider服务成功。</p>\n<h2><a id="_246"></a>总结</h2>\n<p>本文比较详细的介绍了如何使用Nacos作为服务注册中心，并使用案例介绍了如何在使用nacos作为服务注册中心时消费服务。下一篇教程将介绍如何使用nacos作为分布式配置中心。</p>\n<h2><a id="_250"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/springcloud-alibaba/nacos-discovery</p>\n<h2><a id="_255"></a>参考资料</h2>\n<p>https://nacos.io/zh-cn/docs/what-is-nacos.html</p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/88149085', 'title': '这 10 道 Spring Boot 常见面试题你需要了解下', 'readNum': '13814', 'commentNum': '3', 'publishTime': '2019-04-30 17:11:29', 'content': '<div class="htmledit_views" id="content_views">\n                                            <p><span style="color:#888888;">点击上方</span>“<span style="color:#0052ff;">方志朋</span>”，<span style="color:#888888;">选择“置顶或者星标”</span></p>\n\n<p style="margin-left:16px;"><span style="color:#7f7f7f;">你的关注意义重大！</span></p>\n\n<p style="margin-left:16px;">\xa0</p>\n\n<blockquote>\n<p style="margin-left:16px;">本文转载于公众号：Java团长</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p><span style="color:#159957;">1.什么是Spring Boot？</span></p>\n\n<p>多年来，随着新功能的增加，spring变得越来越复杂。只需访问https://spring.io/projects页面，我们就会看到可以在我们的应用程序中使用的所有Spring项目的不同功能。</p>\n\n<p>如果必须启动一个新的Spring项目，我们必须添加构建路径或添加Maven依赖关系，配置应用程序服务器，添加spring配置。</p>\n\n<p>因此，开始一个新的spring项目需要很多努力，因为我们现在必须从头开始做所有事情。</p>\n\n<p>Spring Boot是解决这个问题的方法。Spring Boot已经建立在现有spring框架之上。使用spring启动，我们避免了之前我们必须做的所有样板代码和配置。</p>\n\n<p>因此，Spring Boot可以帮助我们以最少的工作量，更加健壮地使用现有的Spring功能。</p>\n\n<h1>2.Spring Boot有哪些优点？</h1>\n\n<ul><li>\n\t<p><span style="color:#4a4a4a;">减少开发，测试时间和努力。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">使用JavaConfig有助于避免使用XML。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">避免大量的Maven导入和各种版本冲突。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">提供意见发展方法。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">通过提供默认值快速开始开发。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">没有单独的Web服务器需要。这意味着你不再需要启动Tomcat，Glassfish或其他任何东西。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">需要更少的配置 因为没有web.xml文件。只需添加用@ Configuration注释的类，然后添加用@Bean注释的方法，Spring将自动加载对象并像以前一样对其进行管理。您甚至可以将@Autowired添加到bean方法中，以使Spring自动装入需要的依赖关系中。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应用程序属性文件后，Spring将在（application{environment} .properties）中加载后续的应用程序属性文件。</span></p>\n\t</li>\n</ul><h1>3.什么是JavaConfig？</h1>\n\n<p>Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：</p>\n\n<p>面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。</p>\n\n<p>减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。</p>\n\n<p>JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。</p>\n\n<p>从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。</p>\n\n<p>类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。</p>\n\n<h1>4.如何重新加载Spring Boot上的更改，而无需重新启动服务器？</h1>\n\n<p>这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。</p>\n\n<p>Spring Boot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。</p>\n\n<p>开发人员可以重新加载Spring Boot上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot在发布它的第一个版本时没有这个功能。</p>\n\n<p>这是开发人员最需要的功能。DevTools模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供H2数据库控制台以更好地测试应用程序。</p>\n\n<pre>\n\n\xa0</pre>\n\n<ol><li>\n\t<p><span style="color:#4a4a4a;"><code style="margin-left:-20px;"><span style="color:#f22c40;">&lt;dependency&gt;</span></code></span></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;"><code style="margin-left:-20px;"><span style="color:#f22c40;">&lt;groupId&gt;</span><span style="color:#1b1918;">org.springframework.boot</span><span style="color:#f22c40;">&lt;/groupId&gt;</span></code></span></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;"><code style="margin-left:-20px;"><span style="color:#f22c40;">&lt;artifactId&gt;</span><span style="color:#1b1918;">spring-boot-devtools</span><span style="color:#f22c40;">&lt;/artifactId&gt;</span></code></span></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;"><code style="margin-left:-20px;"><span style="color:#f22c40;">&lt;optional&gt;</span><span style="color:#1b1918;">true</span><span style="color:#f22c40;">&lt;/optional&gt;</span></code></span></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;"><code style="margin-left:-20px;"><span style="color:#f22c40;">&lt;/dependency&gt;</span></code></span></p>\n\t</li>\n</ol><h1>5.Spring Boot中的监视器是什么？</h1>\n\n<p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。</p>\n\n<p>有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p>\n\n<h1>6.如何在Spring Boot中禁用Actuator端点安全性？</h1>\n\n<p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。</p>\n\n<p>安全性是使用标准的HttpServletRequest.isUserInRole方法实施的。 我们可以使用management.security.enabled = false 来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>\n\n<p>如何在自定义端口上运行Spring Boot应用程序？ 为了在自定义端口上运行Spring Boot应用程序，您可以在application.properties中指定端口。 server.port = 8090</p>\n\n<h1>7.什么是YAML？</h1>\n\n<p>YAML是一种人类可读的数据序列化语言。它通常用于配置文件。 与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆。可以看出YAML具有分层配置数据。</p>\n\n<h1>8.如何实现Spring Boot应用程序的安全性？</h1>\n\n<p>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</p>\n\n<h1>9.如何集成Spring Boot和ActiveMQ？</h1>\n\n<p>对于集成Spring Boot和ActiveMQ，我们使用spring-boot-starter-activemq 依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>\n\n<h1>10.如何使用Spring Boot实现分页和排序？</h1>\n\n<p>使用Spring Boot实现分页非常简单。使用Spring Data-JPA可以实现将可分页的org.springframework.data.domain.Pageable传递给存储库方法。</p>\n\n<p style="margin-left:0em;">\xa0</p>\n\n<p><span style="color:#3da742;">-更多文章-</span></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485203&amp;idx=1&amp;sn=56a66cc9fe8177749b07c2bb9b7449d0&amp;chksm=9bed2661ac9aaf77ca53fb718bb2c552608f58a4c49cdb34ca653a33fb8099bcdc70dec65373&amp;scene=21#wechat_redirect" rel="nofollow">最详细排序解析，七大排序横评（校正篇）</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485198&amp;idx=1&amp;sn=7c6661bc530c226c0243208253fc6246&amp;chksm=9bed267cac9aaf6a7d05ff1230d466a8d81fd7374d979a2b07fdb1d6c312a77863504364ac47&amp;scene=21#wechat_redirect" rel="nofollow">面试总被问高并发，你真的会么？</a></u></p>\n\n<p><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485188&amp;idx=1&amp;sn=8c190150ae3dd2a2f35aed0b8b8b0779&amp;chksm=9bed2676ac9aaf6061fb9db8353f0caca333ae8d19ca71a5f89198b491b8bcb034ba32cda581&amp;scene=21#wechat_redirect" rel="nofollow">高并发编程知识体系</a></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485182&amp;idx=1&amp;sn=f9e3fb858cd8dc6c91a7297aeab2c28a&amp;chksm=9bed278cac9aae9ae2b6d80cb4a0adc4cc59888cdb9e4f6d9f5184787ac2cfb8149418f32a5b&amp;scene=21#wechat_redirect" rel="nofollow">再有人问你Netty是什么，就把这篇文章发给他</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485170&amp;idx=1&amp;sn=58f62aa0b9a4c38b8aa9995923ec7ebf&amp;chksm=9bed2780ac9aae9695eaeb4de51b36a28d1f53583e777aae8ef0167c4f6064aef6f70d757ec9&amp;scene=21#wechat_redirect" rel="nofollow">缓存穿透，缓存击穿，缓存雪崩解决方案分析</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485153&amp;idx=1&amp;sn=f4d4e708eb6b2ebd69df9f4488f008d6&amp;chksm=9bed2793ac9aae85ee6a826f645d46c962ec3f2a9f385ac768929b47ddfdb2ae202e044ea596&amp;scene=21#wechat_redirect" rel="nofollow">聊聊 SpringCloud 中的父子容器</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485143&amp;idx=1&amp;sn=2fa1c9f11b5763e41b433bcbdcc207ac&amp;chksm=9bed27a5ac9aaeb39edf44782b4856634008efa0fee274ecdf25231f6e9088e02abd7b05f604&amp;scene=21#wechat_redirect" rel="nofollow">刚出炉的一套面试题(JAVA岗)</a></u></p>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-关注我-</span></p>\n\n<p style="text-align:center;"><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png"></p>\n\n<p style="margin-left:8px;"><strong><span style="color:#3da742;">看完了，帮我点个“好看”鸭</span></strong></p>\n\n<p style="margin-left:8px;"><span style="color:#3da742;"><strong>点鸭点鸭</strong></span></p>\n\n<p><span style="color:#3da742;">↓↓↓↓</span></p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83895998', 'title': '对业务系统的监控 No.118', 'readNum': '14127', 'commentNum': '1', 'publishTime': '2019-04-30 17:11:14', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文转载于公众号“一名叫大蕉的程序员”</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>这篇文章是写给想对目前的业务系统进行监控但是又不知道从何入手的小伙伴看的，又或者是对于现有监控机制的一个反思，具体为什么要做这件事情，可以参照一下下边这篇，结合着看看。</p>\n\n<p>\xa0</p>\n\n<p><a href="http://mp.weixin.qq.com/s?__biz=MzUxMDAwNDM0OA==&amp;mid=2247484481&amp;idx=1&amp;sn=99ee0168f6db9944f3de0c4d861ed11a&amp;chksm=f908d952ce7f5044086d6622949acb91f8244a5d16c9827bf3473964ee05ffdaf57dbf6bb151&amp;scene=21#wechat_redirect" rel="nofollow">工程师们你们写完代码后还做些什么No.115</a></p>\n\n<p>\xa0</p>\n\n<p>如下翻译，checkpoint -&gt; cp</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp1 : 业务系统宿主机监控</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>现在一般系统都不直接跑物理机了，基本都跑在虚拟机或者容器上边，无论你们所谓的宿主机或者迁移做到多好，都要密切关注宿主机这块事情，很可能分分钟被其他业务或者宿主机本身把系统搞挂。一旦有异常必须关注起来，特别是机器数量比较少的时候，系统没发起自动迁移的情况下，及时迁移宿主机。</p>\n\n<p>\xa0</p>\n\n<p>大概需要关注的东西：宿主机网络、磁盘IO、CPU load、memory load</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp2 : 数据库监控</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>对于一个普通的业务系统来说，最重要的底层组件莫过于数据库了，根据我的经验，现在非常多业务并没有对数据库进行设计，所以一般情况下，数据库要是挂了，那么这时候业务系统通常来说就是直接不可用状态。数据库本身的容灾固然重要，但是数据库一般情况下来说，并不能识别哪些业务SQL是重要的，哪些是不重要的，它只能根据它固有的线程池、CPU、内存来提供一定量级的服务。</p>\n\n<p>\xa0</p>\n\n<p>一旦发现有异常，一定要第一优先级介入，业务上进行限流，数据库层面SQL处理，比如强行kill慢SQL。</p>\n\n<p>\xa0</p>\n\n<p>大概需要关注的东西：连接池、读/写RT(响应时间)、读/写QPS(每秒请求数)、CPU、网络IO、内存命中率、慢SQL</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp3 : 虚拟机或容器健康度</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>关注点跟宿主机一样，宿主机做了什么监控，这里就做什么监控。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp4: 业务系统基础关键参数监控</p>\n</blockquote>\n\n<p>对于虚拟机或者容器来说，可能一切都是正常的，但是业务系统上已经出现了大面积拒绝服务，大面积的响应超时，这时候其实可能已经出现了极大的问题，还需要结合一定的监控和排查才能发现问题所在。</p>\n\n<p>\xa0</p>\n\n<p>大概需要关注的东西：HTTP RT(响应时间)、HTTP\xa0QPS(每秒请求数)、HTTP 空闲连接数。对于 Java 类系统来说还有JVM各种参数的监控，比如 各个代的gc时间、总gc次数和时间、堆内存、堆外内存、线程数 等。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp5: 关键公共依赖系统的监控</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>很多业务系统本身并不止有数据库，还有很多外部系统。比如 Redis、Memcached 这类外部缓存系统。比如类似 ElasticSearch 、 Solor 、阿里云 OpenSearch 这类搜索系统。比如Kafka 、RocketMQ、RabbitMQ 这类消息中间件。而且业务系统对于这些外部系统的依赖性一般来说还是比较高的，这类系统一旦出现问题，对于业务的影响也不容小嘘，很多时候也是致命的。</p>\n\n<p>\xa0</p>\n\n<p>大概需要关注的东西：外部系统本身的稳定性监控，这类应该有专人维护，只需要要求他们做好监控，有任何告警订阅一下就好了。主要监控的还是业务系统本身对于外部系统的调用情况，比如连接池、读/写RT(响应时间)、读/写QPS(每秒请求数)、读/写成功率、网络IO。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp6: 关键业务接口系统性监控</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>就算上边一切都是正常的，你系统可能还是崩溃的，为什么呢？可能你的系统早就拒绝服务了，返回了一大堆 isSuccess=false 的数据，这对于用户，对于业务方来说就是系统不可用，所以我们还要针对我们自己的业务进行一些业务层面的监控。一旦发现关键接口有问题，尽快介入排查原因，比如对于异常接口进行限流保障其他系统。比如对于关键接口的失败进行原因排查，尽快定位原因恢复业务。这块其实是很多人平时在写业务系统忽略最多的点，目前实现路径还是比较多的比如数据库实时查询，http连接实时检查、日志实时采集分析，业务数据准实时分析。</p>\n\n<p>\xa0</p>\n\n<p>大概需要关注的东西：各个关键接口的成功率、RT(响应时间)、QPS。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp7: 监控自动化和可视化</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>cp6做完善后，如果需要人实时盯着，其实用处也比较有限，还是要有一套机制自动化告警甚至自动化处理的机制。如果是正常轮班有人在盯着呢，最好是对于监控数据进行可视化。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<blockquote>\n<p>cp8: 异常数据监控</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>业务流程处理是成功的，系统业务成功的，但是还是有一些隐患，比如数据不正确或者关键数据丢失。这类问题会出现在调用方或者某些代码分支出现问题的时候，一些关键数据丢失了，导致最终在进行客户履约的时候数据缺失。比如外卖丢了送货地址护着送货电话等，依然需要以自动化的形式做好异常数据监控。</p>\n\n<p>\xa0</p>\n\n<p>大概需要关注的东西：关键业务节点的关键参数。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>以上，吃面去了，饿了，你不点个赞吗？</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0（转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83896074', 'title': '消息队列之 RabbitMQ', 'readNum': '16559', 'commentNum': '3', 'publishTime': '2019-04-30 17:11:00', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文为转载文章：</p>\n\n<p>原文地址：<a href="https://www.jianshu.com/p/79ca08116d57/" rel="nofollow">https://www.jianshu.com/p/79ca08116d57/</a></p>\n</blockquote>\n\n<p>关于消息队列，从前年开始断断续续看了些资料，想写很久了，但一直没腾出空，近来分别碰到几个朋友聊这块的技术选型，是时候把这块的知识整理记录一下了。</p>\n\n<p>市面上的消息队列产品有很多，比如老牌的 ActiveMQ、RabbitMQ ，目前我看最火的 Kafka ，还有 ZeroMQ ，去年底阿里巴巴捐赠给 Apache 的 RocketMQ ，连 redis 这样的 NoSQL 数据库也支持 MQ 功能。总之这块知名的产品就有十几种，就我自己的使用经验和兴趣只打算谈谈 RabbitMQ、Kafka 和 ActiveMQ ，本文先讲 RabbitMQ ，在此之前先看下消息队列的相关概念。</p>\n\n<h1>什么叫消息队列</h1>\n\n<p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p>\n\n<p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p>\n\n<h1>为何用消息队列</h1>\n\n<p>从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用 MQ 呢？</p>\n\n<p>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。</p>\n\n<p>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。</p>\n\n<h1>RabbitMQ 特点</h1>\n\n<p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p>\n\n<p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>\n\n<p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>\n\n<ol><li>\n\t<p>可靠性（Reliability）<br>\n\tRabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p>\n\t</li>\n\t<li>\n\t<p>灵活的路由（Flexible Routing）<br>\n\t在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p>\n\t</li>\n\t<li>\n\t<p>消息集群（Clustering）<br>\n\t多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p>\n\t</li>\n\t<li>\n\t<p>高可用（Highly Available Queues）<br>\n\t队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p>\n\t</li>\n\t<li>\n\t<p>多种协议（Multi-protocol）<br>\n\tRabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p>\n\t</li>\n\t<li>\n\t<p>多语言客户端（Many Clients）<br>\n\tRabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p>\n\t</li>\n\t<li>\n\t<p>管理界面（Management UI）<br>\n\tRabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</p>\n\t</li>\n\t<li>\n\t<p>跟踪机制（Tracing）<br>\n\t如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p>\n\t</li>\n\t<li>\n\t<p>插件机制（Plugin System）<br>\n\tRabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p>\n\t</li>\n</ol><h1>RabbitMQ 中的概念模型</h1>\n\n<p>消息模型</p>\n\n<p>所有 MQ 产品从模型抽象上来说都是一样的过程：<br>\n消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p>\n\n<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-066ff248d5ff8eed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/401/format/webp"></p>\n\n<p>消息流</p>\n\n<p>RabbitMQ 基本概念</p>\n\n<p>上面只是最简单抽象的描述，具体到 RabbitMQ 则有更详细的概念需要解释。上面介绍过 RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念：</p>\n\n<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp"></p>\n\n<p>RabbitMQ 内部结构</p>\n\n<ol><li>Message<br>\n\t消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</li>\n\t<li>Publisher<br>\n\t消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li>\n\t<li>Exchange<br>\n\t交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li>\n\t<li>Binding<br>\n\t绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li>\n\t<li>Queue<br>\n\t消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>\n\t<li>Connection<br>\n\t网络连接，比如一个TCP连接。</li>\n\t<li>Channel<br>\n\t信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li>\n\t<li>Consumer<br>\n\t消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li>\n\t<li>Virtual Host<br>\n\t虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li>\n\t<li>Broker<br>\n\t表示消息队列服务器实体。</li>\n</ol><p>AMQP 中的消息路由</p>\n\n<p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p>\n\n<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/484/format/webp"></p>\n\n<p>AMQP 的消息路由过程</p>\n\n<p>Exchange 类型</p>\n\n<p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p>\n\n<ol><li>\n\t<p>direct</p>\n\t\xa0\n\n\t<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-13db639d2c22f2aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp"></p>\n\n\t<p>direct 交换器</p>\n\t\xa0\n\n\t<p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p>\n\t</li>\n\t<li>\n\t<p>fanout</p>\n\t\xa0\n\n\t<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-2f509b7f34c47170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/463/format/webp"></p>\n\n\t<p>fanout 交换器</p>\n\t\xa0\n\n\t<p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p>\n\t</li>\n\t<li>topic\n\t<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-275ea009bdf806a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/558/format/webp"></p>\n\n\t<p>topic 交换器</p>\n\t<br>\n\ttopic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“<em>”。#匹配0个或多个单词，</em>匹配不多不少一个单词。</li>\n</ol><h1>RabbitMQ 安装</h1>\n\n<p>一般来说安装 RabbitMQ 之前要安装 Erlang ，可以去<a href="https://link.jianshu.com?t=http://www.erlang.org/downloads" rel="nofollow">Erlang官网</a>下载。接着去<a href="https://link.jianshu.com?t=https://www.rabbitmq.com/download.html" rel="nofollow">RabbitMQ官网</a>下载安装包，之后解压缩即可。根据操作系统不同官网提供了相应的安装说明：<a href="https://link.jianshu.com?t=http://www.rabbitmq.com/install-windows.html" rel="nofollow">Windows</a>、<a href="https://link.jianshu.com?t=http://www.rabbitmq.com/install-debian.html" rel="nofollow">Debian / Ubuntu</a>、<a href="https://link.jianshu.com?t=http://www.rabbitmq.com/install-rpm.html" rel="nofollow">RPM-based Linux</a>、<a href="https://link.jianshu.com?t=http://www.rabbitmq.com/install-standalone-mac.html" rel="nofollow">Mac</a></p>\n\n<p>如果是Mac 用户，个人推荐使用 HomeBrew 来安装，安装前要先更新 brew：</p>\n\n<pre class="has">\n<code>brew update\n</code></pre>\n\n<p>接着安装 rabbitmq 服务器：</p>\n\n<pre class="has">\n<code>brew install rabbitmq\n</code></pre>\n\n<p>这样 RabbitMQ 就安装好了，安装过程中会自动其所依赖的 Erlang 。</p>\n\n<h1>RabbitMQ 运行和管理</h1>\n\n<ol><li>启动<br>\n\t启动很简单，找到安装后的 RabbitMQ 所在目录下的 sbin 目录，可以看到该目录下有6个以 rabbitmq 开头的可执行文件，直接执行 rabbitmq-server 即可，下面将 RabbitMQ 的安装位置以 . 代替，启动命令就是：</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmq-server\n</code></pre>\n\n<p>启动正常的话会看到一些启动过程信息和最后的 completed with 7 plugins，这也说明启动的时候默认加载了7个插件。</p>\n\n<p>\xa0</p>\n\n<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-1392cdc83b0d8341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p>\n\n<p>正常启动</p>\n\n<ol><li>后台启动<br>\n\t如果想让 RabbitMQ 以守护程序的方式在后台运行，可以在启动的时候加上 -detached 参数：</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmq-server -detached\n</code></pre>\n\n<ol><li>查询服务器状态<br>\n\tsbin 目录下有个特别重要的文件叫 rabbitmqctl ，它提供了 RabbitMQ 管理需要的几乎一站式解决方案，绝大部分的运维命令它都可以提供。<br>\n\t查询 RabbitMQ 服务器的状态信息可以用参数 status ：</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl status\n</code></pre>\n\n<p>该命令将输出服务器的很多信息，比如 RabbitMQ 和 Erlang 的版本、OS 名称、内存等等</p>\n\n<ol><li>关闭 RabbitMQ 节点<br>\n\t我们知道 RabbitMQ 是用 Erlang 语言写的，在Erlang 中有两个概念：节点和应用程序。节点就是 Erlang 虚拟机的每个实例，而多个 Erlang 应用程序可以运行在同一个节点之上。节点之间可以进行本地通信（不管他们是不是运行在同一台服务器之上）。比如一个运行在节点A上的应用程序可以调用节点B上应用程序的方法，就好像调用本地函数一样。如果应用程序由于某些原因奔溃，Erlang 节点会自动尝试重启应用程序。<br>\n\t如果要关闭整个 RabbitMQ 节点可以用参数 stop ：</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl stop\n</code></pre>\n\n<p>它会和本地节点通信并指示其干净的关闭，也可以指定关闭不同的节点，包括远程节点，只需要传入参数 -n ：</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl -n rabbit@server.example.com stop \n</code></pre>\n\n<p>-n node 默认 node 名称是 rabbit@server ，如果你的主机名是 <a href="https://link.jianshu.com?t=http://server.example.com" rel="nofollow">server.example.com</a> ，那么 node 名称就是 <a href="https://link.jianshu.com?t=mailto:rabbit@server.example.com" rel="nofollow">rabbit@server.example.com</a> 。</p>\n\n<ol><li>关闭 RabbitMQ 应用程序<br>\n\t如果只想关闭应用程序，同时保持 Erlang 节点运行则可以用 stop_app：</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl stop_app\n</code></pre>\n\n<p>这个命令在后面要讲的集群模式中将会很有用。</p>\n\n<ol><li>启动 RabbitMQ 应用程序</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl start_app\n</code></pre>\n\n<ol><li>重置 RabbitMQ 节点</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl reset\n</code></pre>\n\n<p>该命令将清除所有的队列。</p>\n\n<ol><li>查看已声明的队列</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl list_queues\n</code></pre>\n\n<ol><li>查看交换器</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl list_exchanges\n</code></pre>\n\n<p>该命令还可以附加参数，比如列出交换器的名称、类型、是否持久化、是否自动删除：</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl list_exchanges name type durable auto_delete\n</code></pre>\n\n<ol><li>查看绑定</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmqctl list_bindings\n</code></pre>\n\n<h1>Java 客户端访问</h1>\n\n<p>RabbitMQ 支持多种语言访问，以 Java 为例看下一般使用 RabbitMQ 的步骤。</p>\n\n<ol><li>maven工程的pom文件中添加依赖</li>\n</ol><pre class="has">\n<code>&lt;dependency&gt;\n    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;\n    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;\n    &lt;version&gt;4.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n\n<ol><li>消息生产者</li>\n</ol><pre class="has">\n<code>package org.study.rabbitmq;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\npublic class Producer {\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        //创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setUsername("guest");\n        factory.setPassword("guest");\n        //设置 RabbitMQ 地址\n        factory.setHost("localhost");\n        //建立到代理服务器到连接\n        Connection conn = factory.newConnection();\n        //获得信道\n        Channel channel = conn.createChannel();\n        //声明交换器\n        String exchangeName = "hello-exchange";\n        channel.exchangeDeclare(exchangeName, "direct", true);\n\n        String routingKey = "hola";\n        //发布消息\n        byte[] messageBodyBytes = "quit".getBytes();\n        channel.basicPublish(exchangeName, routingKey, null, messageBodyBytes);\n\n        channel.close();\n        conn.close();\n    }\n}\n</code></pre>\n\n<ol><li>消息消费者</li>\n</ol><pre class="has">\n<code>package org.study.rabbitmq;\nimport com.rabbitmq.client.*;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\npublic class Consumer {\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setUsername("guest");\n        factory.setPassword("guest");\n        factory.setHost("localhost");\n        //建立到代理服务器到连接\n        Connection conn = factory.newConnection();\n        //获得信道\n        final Channel channel = conn.createChannel();\n        //声明交换器\n        String exchangeName = "hello-exchange";\n        channel.exchangeDeclare(exchangeName, "direct", true);\n        //声明队列\n        String queueName = channel.queueDeclare().getQueue();\n        String routingKey = "hola";\n        //绑定队列，通过键 hola 将队列和交换器绑定起来\n        channel.queueBind(queueName, exchangeName, routingKey);\n\n        while(true) {\n            //消费消息\n            boolean autoAck = false;\n            String consumerTag = "";\n            channel.basicConsume(queueName, autoAck, consumerTag, new DefaultConsumer(channel) {\n                @Override\n                public void handleDelivery(String consumerTag,\n                                           Envelope envelope,\n                                           AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    String routingKey = envelope.getRoutingKey();\n                    String contentType = properties.getContentType();\n                    System.out.println("消费的路由键：" + routingKey);\n                    System.out.println("消费的内容类型：" + contentType);\n                    long deliveryTag = envelope.getDeliveryTag();\n                    //确认消息\n                    channel.basicAck(deliveryTag, false);\n                    System.out.println("消费的消息体内容：");\n                    String bodyStr = new String(body, "UTF-8");\n                    System.out.println(bodyStr);\n\n                }\n            });\n        }\n    }\n}\n</code></pre>\n\n<ol><li>启动 RabbitMQ 服务器</li>\n</ol><pre class="has">\n<code>./sbin/rabbitmq-server\n</code></pre>\n\n<ol><li>运行 Consumer<br>\n\t先运行 Consumer ，这样当生产者发送消息的时候能在消费者后端看到消息记录。</li>\n\t<li>\n\t<p>运行 Producer<br>\n\t接着运行 Producer ,发布一条消息，在 Consumer 的控制台能看到接收的消息：</p>\n\t\xa0\n\n\t<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-6f2d0168cfc2878d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p>\n\n\t<p>Consumer 控制台</p>\n\t</li>\n</ol><h1>RabbitMQ 集群</h1>\n\n<p>RabbitMQ 最优秀的功能之一就是内建集群，这个功能设计的目的是允许消费者和生产者在节点崩溃的情况下继续运行，以及通过添加更多的节点来线性扩展消息通信吞吐量。RabbitMQ 内部利用 Erlang 提供的分布式通信框架 OTP 来满足上述需求，使客户端在失去一个 RabbitMQ 节点连接的情况下，还是能够重新连接到集群中的任何其他节点继续生产、消费消息。</p>\n\n<p>RabbitMQ 集群中的一些概念</p>\n\n<p>RabbitMQ 会始终记录以下四种类型的内部元数据：</p>\n\n<ol><li>队列元数据<br>\n\t包括队列名称和它们的属性，比如是否可持久化，是否自动删除</li>\n\t<li>交换器元数据<br>\n\t交换器名称、类型、属性</li>\n\t<li>绑定元数据<br>\n\t内部是一张表格记录如何将消息路由到队列</li>\n\t<li>vhost 元数据<br>\n\t为 vhost 内部的队列、交换器、绑定提供命名空间和安全属性</li>\n</ol><p>在单一节点中，RabbitMQ 会将所有这些信息存储在内存中，同时将标记为可持久化的队列、交换器、绑定存储到硬盘上。存到硬盘上可以确保队列和交换器在节点重启后能够重建。而在集群模式下同样也提供两种选择：存到硬盘上（独立节点的默认设置），存在内存中。</p>\n\n<p>如果在集群中创建队列，集群只会在单个节点而不是所有节点上创建完整的队列信息（元数据、状态、内容）。结果是只有队列的所有者节点知道有关队列的所有信息，因此当集群节点崩溃时，该节点的队列和绑定就消失了，并且任何匹配该队列的绑定的新消息也丢失了。还好RabbitMQ 2.6.0之后提供了镜像队列以避免集群节点故障导致的队列内容不可用。</p>\n\n<p>RabbitMQ 集群中可以共享 user、vhost、exchange等，所有的数据和状态都是必须在所有节点上复制的，例外就是上面所说的消息队列。RabbitMQ 节点可以动态的加入到集群中。</p>\n\n<p>当在集群中声明队列、交换器、绑定的时候，这些操作会直到所有集群节点都成功提交元数据变更后才返回。集群中有内存节点和磁盘节点两种类型，内存节点虽然不写入磁盘，但是它的执行比磁盘节点要好。内存节点可以提供出色的性能，磁盘节点能保障配置信息在节点重启后仍然可用，那集群中如何平衡这两者呢？</p>\n\n<p>RabbitMQ 只要求集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入火离开集群时，它们必须要将该变更通知到至少一个磁盘节点。如果只有一个磁盘节点，刚好又是该节点崩溃了，那么集群可以继续路由消息，但不能创建队列、创建交换器、创建绑定、添加用户、更改权限、添加或删除集群节点。换句话说集群中的唯一磁盘节点崩溃的话，集群仍然可以运行，但知道该节点恢复，否则无法更改任何东西。</p>\n\n<p>RabbitMQ 集群配置和启动</p>\n\n<p>如果是在一台机器上同时启动多个 RabbitMQ 节点来组建集群的话，只用上面介绍的方式启动第二、第三个节点将会因为节点名称和端口冲突导致启动失败。所以在每次调用 rabbitmq-server 命令前，设置环境变量 RABBITMQ_NODENAME 和 RABBITMQ_NODE_PORT 来明确指定唯一的节点名称和端口。下面的例子端口号从5672开始，每个新启动的节点都加1，节点也分别命名为test_rabbit_1、test_rabbit_2、test_rabbit_3。</p>\n\n<p>启动第1个节点：</p>\n\n<pre class="has">\n<code>RABBITMQ_NODENAME=test_rabbit_1 RABBITMQ_NODE_PORT=5672 ./sbin/rabbitmq-server -detached\n</code></pre>\n\n<p>启动第2个节点：</p>\n\n<pre class="has">\n<code>RABBITMQ_NODENAME=test_rabbit_2 RABBITMQ_NODE_PORT=5673 ./sbin/rabbitmq-server -detached\n</code></pre>\n\n<p>启动第2个节点前建议将 RabbitMQ 默认激活的插件关掉，否则会存在使用了某个插件的端口号冲突，导致节点启动不成功。</p>\n\n<p>现在第2个节点和第1个节点都是独立节点，它们并不知道其他节点的存在。集群中除第一个节点外后加入的节点需要获取集群中的元数据，所以要先停止 Erlang 节点上运行的 RabbitMQ 应用程序，并重置该节点元数据，再加入并且获取集群的元数据，最后重新启动 RabbitMQ 应用程序。</p>\n\n<p>停止第2个节点的应用程序：</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl -n test_rabbit_2 stop_app\n</code></pre>\n\n<p>重置第2个节点元数据：</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl -n test_rabbit_2 reset\n</code></pre>\n\n<p>第2节点加入第1个节点组成的集群：</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl -n test_rabbit_2 join_cluster test_rabbit_1@localhost\n</code></pre>\n\n<p>启动第2个节点的应用程序</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl -n test_rabbit_2 start_app\n</code></pre>\n\n<p>第3个节点的配置过程和第2个节点类似：</p>\n\n<pre class="has">\n<code>RABBITMQ_NODENAME=test_rabbit_3 RABBITMQ_NODE_PORT=5674 ./sbin/rabbitmq-server -detached\n\n./sbin/rabbitmqctl -n test_rabbit_3 stop_app\n\n./sbin/rabbitmqctl -n test_rabbit_3 reset\n\n./sbin/rabbitmqctl -n test_rabbit_3 join_cluster test_rabbit_1@localhost\n\n./sbin/rabbitmqctl -n test_rabbit_3 start_app\n</code></pre>\n\n<p>RabbitMQ 集群运维</p>\n\n<p>停止某个指定的节点，比如停止第2个节点：</p>\n\n<pre class="has">\n<code>RABBITMQ_NODENAME=test_rabbit_2 ./sbin/rabbitmqctl stop\n</code></pre>\n\n<p>查看节点3的集群状态：</p>\n\n<pre class="has">\n<code>./sbin/rabbitmqctl -n test_rabbit_3 cluster_status</code></pre>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0（转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>\n\n<p>原文链接：</p>\n\n<p>https://www.jianshu.com/p/79ca08116d57</p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:24 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/88361277', 'title': '真正理解Mysql的四种隔离级别', 'readNum': '9580', 'commentNum': '5', 'publishTime': '2019-04-30 17:10:47', 'content': '<div class="htmledit_views" id="content_views">\n                                            <p><span style="color:#888888;">点击上方</span>“<span style="color:#0052ff;">方志朋</span>”，<span style="color:#888888;">选择“置顶或者星标”</span></p>\n\n<p style="margin-left:16px;"><span style="color:#7f7f7f;">你的关注意义重大！</span></p>\n\n<h2>什么是事务</h2>\n\n<p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>\n\n<p>事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。</p>\n\n<h2>事务的 ACID</h2>\n\n<p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>\n\n<ul><li>\n\t<p><span style="color:#4a4a4a;">原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</span></p>\n\t</li>\n</ul><h2>Mysql的四种隔离级别</h2>\n\n<p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>\n\n<h3>Read Uncommitted（读取未提交内容）</h3>\n\n<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>\n\n<h3>Read Committed（读取提交内容）</h3>\n\n<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>\n\n<h3>Repeatable Read（可重读）</h3>\n\n<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>\n\n<h3>Serializable（可串行化）</h3>\n\n<p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>\n\n<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p>\n\n<ul><li>\n\t<p><span style="color:#4a4a4a;">脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:#4a4a4a;">幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。</span></p>\n\t</li>\n</ul><p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIIdI25ia5ycqI1n1Hhk9VH57v1uGud8SqoXn1es0ZMLbef0iawHuqSMCg/640?wx_fmt=other"></p>\n\n<h2>测试Mysql的隔离级别</h2>\n\n<p>下面，将利用MySQL的客户端程序，我们分别来测试一下这几种隔离级别。</p>\n\n<p>测试数据库为demo，表为test；表结构：</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIqR4xQ4KYrZicWt2lRZstO48sD35Zys0wVFRpeYAneAQiahn3FLiaHWxAw/640?wx_fmt=other"></p>\n\n<p>两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。</p>\n\n<h3>将A的隔离级别设置为read uncommitted(未提交读)</h3>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZI64flb9aGZHRnsVml9cUjDkfbHTO2ljT0rVETjJoicl5I0CvMOOlNHpw/640?wx_fmt=other"></p>\n\n<p>A：启动事务，此时数据为初始状态</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIts8wBwOGaSFkWk1aJOTuG9wRLVZASzQVqskzOic8ibg7PBGZCKtCnQ2g/640?wx_fmt=other"></p>\n\n<p>B：启动事务，更新数据，但不提交</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZI3E4b9ic46DUD6F5VNuU0riaMMvQww9xY96ucsJJAn6v9wVeQFb2gaHaA/640?wx_fmt=other"></p>\n\n<p>A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIGow8fznJngaPic6Ieo3zNoYnDK1o3ictSiaIEsPxQbc8uqLcHpXRwH0ow/640?wx_fmt=other"></p>\n\n<p>B：回滚事务</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIw4jpAicbNpXj8CkAXrcVaOXI1tkqxIISTMo5HWtn02DicH4kesNMKmWw/640?wx_fmt=other"></p>\n\n<p>A：再次读数据，发现数据变回初始状态</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIKnLTNCtL812icYhmicZE9OPgTsteuHvQf0Z7jmz3JwHpzcHAib0x8GFOw/640?wx_fmt=other"></p>\n\n<p>经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。</p>\n\n<h3>将客户端A的事务隔离级别设置为read committed(已提交读)</h3>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZINTsSrC1etnzQtnux7wiaplEMibaicfh434bqxWRoaTDka8Z9N7GDWFlmw/640?wx_fmt=other"></p>\n\n<p>A：启动事务，此时数据为初始状态</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIIHuDBibytlMCkx0UcerCcnvbmUKxHajKJ675GVzG7nJjOA3CQsWmDCA/640?wx_fmt=other"></p>\n\n<p>B：启动事务，更新数据，但不提交</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZI3E4b9ic46DUD6F5VNuU0riaMMvQww9xY96ucsJJAn6v9wVeQFb2gaHaA/640?wx_fmt=other"></p>\n\n<p>A：再次读数据，发现数据未被修改</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIibvyezgtw4DHBRbsVF8ZPr7PYeKgE05P6Hb2LAyu7KHCkjibHGb21NAQ/640?wx_fmt=other"></p>\n\n<p>B：提交事务</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIr20Ndz3ya4yNKuhl41qaxbic5x9Jeku7YY4xPibDaYNTcMUlUzvYiaVpA/640?wx_fmt=other"></p>\n\n<p>A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZItgcxcibzxj4NBejibbwd7to85tf923mI7gesnDAr3vkibmGW2qDrH7DhA/640?wx_fmt=other"></p>\n\n<p>经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。</p>\n\n<h3>将A的隔离级别设置为repeatable read(可重复读)</h3>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIFuFPyib7ibhExyLfLQhlZ3eGicwlFD3UTnkys3qRFUS0P3WXAAoLS0k8w/640?wx_fmt=other"></p>\n\n<p>A：启动事务，此时数据为初始状态</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZICGqiaZtrzGibiauh3VMxGKU0iaBrDyEg30hicWic4icuDUicZ9T59xubbQibChg/640?wx_fmt=other"></p>\n\n<p>B：启动事务，更新数据，但不提交</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZI3E4b9ic46DUD6F5VNuU0riaMMvQww9xY96ucsJJAn6v9wVeQFb2gaHaA/640?wx_fmt=other"></p>\n\n<p>A：再次读取数据，发现数据未被修改</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIibvyezgtw4DHBRbsVF8ZPr7PYeKgE05P6Hb2LAyu7KHCkjibHGb21NAQ/640?wx_fmt=other"></p>\n\n<p>B：提交事务</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIr20Ndz3ya4yNKuhl41qaxbic5x9Jeku7YY4xPibDaYNTcMUlUzvYiaVpA/640?wx_fmt=other"></p>\n\n<p>A：再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIibvyezgtw4DHBRbsVF8ZPr7PYeKgE05P6Hb2LAyu7KHCkjibHGb21NAQ/640?wx_fmt=other"></p>\n\n<p>B：插入一条新的数据，并提交</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZI2jydicoeRELZOorgQ3zCxhibVwBIpfK6unHrLGvuEWUFcIPva41wLiaiaw/640?wx_fmt=other"></p>\n\n<p>A：再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIibvyezgtw4DHBRbsVF8ZPr7PYeKgE05P6Hb2LAyu7KHCkjibHGb21NAQ/640?wx_fmt=other"></p>\n\n<p>A：提交本次事务，再次读取数据，发现读取正常了</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIEmUa4OibSZ1x2nSIylPyynGtjCR5M3BZUsPkYYmD8As7SOmeTGkcOVg/640?wx_fmt=other"></p>\n\n<p>由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题。</p>\n\n<h3>将A的隔离级别设置为可串行化(Serializable)</h3>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIWlBcSV0ZiaraEtQ6FjNc7S16Lsn8A1Zn3hvshNiaj1F7nSpmyNZ0Qgew/640?wx_fmt=other"></p>\n\n<p>A：启动事务，此时数据为初始状态</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIUib5WKRsLU3q5NQcU9BnV1Gg1rJHnlAL7zm7be5dCCoDpSE8oRibSOjQ/640?wx_fmt=other"></p>\n\n<p>B：发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIwZ6qHYPBTu2DQNWF9XicgKwfWxvHbY5YU2Ovgwbg0AnLibibeicJpByDCA/640?wx_fmt=other"></p>\n\n<p>A：提交事务</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIpeAyYczm2lJ9rUW1XMYjxNguhN1fjtqj6ibeFywLfEamLsFQG0FcBjw/640?wx_fmt=other"></p>\n\n<p>B：发现插入成功</p>\n\n<p><img alt="640?wx_fmt=other" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/rtJ5Lhxxzwm1Mk8Ox5XvDSjhcZGicztZIicJial30Ogu6kagul3fqzHTYJXQ1eTUG6L3uRFYcX5HCRhwtNG7dWXhQ/640?wx_fmt=other"></p>\n\n<p>serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。</p>\n\n<h2>原文链接</h2>\n\n<p>https://www.jianshu.com/p/8d735db9c2c0</p>\n\n<p><span style="color:#3da742;">-更多文章-</span></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485223&amp;idx=1&amp;sn=1c59b08d2e4bbf9cdd2dded2b8b156a4&amp;chksm=9bed2655ac9aaf438bcfbc4c8c3e57e08a5abe32ce9843cd6dba8623ec57976f5ee7f935f297&amp;scene=21#wechat_redirect" rel="nofollow">数据库索引原理及优化</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247484551&amp;idx=1&amp;sn=d52692cfa3438e94a77f436c8bf1931d&amp;chksm=9bed25f5ac9aace336437bc590ff3a6672c7c848d0660512c6d615d26212234215df76a11b03&amp;scene=21#wechat_redirect" rel="nofollow">我必须得告诉大家的MySQL优化原理</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485210&amp;idx=1&amp;sn=cf092ad002b617d1bd9da279cad42122&amp;chksm=9bed2668ac9aaf7e7805042cf38fa449d53e4df125652d3a1e0d0e319d30464cf13de80ad2a1&amp;scene=21#wechat_redirect" rel="nofollow">这 10 道 Spring Boot 常见面试题你需要了解下</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485203&amp;idx=1&amp;sn=56a66cc9fe8177749b07c2bb9b7449d0&amp;chksm=9bed2661ac9aaf77ca53fb718bb2c552608f58a4c49cdb34ca653a33fb8099bcdc70dec65373&amp;scene=21#wechat_redirect" rel="nofollow">最详细排序解析，七大排序横评（校正篇）</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485170&amp;idx=1&amp;sn=58f62aa0b9a4c38b8aa9995923ec7ebf&amp;chksm=9bed2780ac9aae9695eaeb4de51b36a28d1f53583e777aae8ef0167c4f6064aef6f70d757ec9&amp;scene=21#wechat_redirect" rel="nofollow">缓存穿透，缓存击穿，缓存雪崩解决方案分析</a></u></p>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-关注我-</span></p>\n\n<p style="text-align:center;"><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png"></p>\n\n<p style="margin-left:8px;"><strong><span style="color:#3da742;">看完了，帮我点个“好看”鸭</span></strong></p>\n\n<p style="margin-left:8px;"><span style="color:#3da742;"><strong>点鸭点鸭</strong></span></p>\n\n<p><span style="color:#3da742;">↓↓↓↓</span></p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:24'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/88414741', 'title': 'Java NIO？看这一篇就够了！', 'readNum': '19786', 'commentNum': '4', 'publishTime': '2019-04-30 17:10:31', 'content': '<div class="htmledit_views" id="content_views">\n                                            <h1>\xa0</h1>\n\n<h1>\xa0</h1>\n\n<p><span style="color:#888888;">点击上方</span>“<span style="color:#0052ff;">方志朋</span>”，<span style="color:#888888;">选择“置顶或者星标”</span></p>\n\n<p style="margin-left:16px;"><span style="color:#7f7f7f;">你的关注意义重大！</span></p>\n\n<p><strong>✎前言</strong></p>\n\n<p><span style="color:#3e3e3e;">现在使用NIO的场景越来越多，很多网上的技术框架或多或少的使用NIO技术，譬如Tomcat，Jetty。学习和掌握NIO技术已经不是一个JAVA攻城狮的加分技能，而是一个必备技能。在前面2篇文章《<a href="http://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483913&amp;idx=1&amp;sn=2da53737b8e8908cf3efdae9621c9698&amp;chksm=fb0be89dcc7c618b0d5a1ba8ac654295454cfc2fa81fbae5a6de49bf0a91a305ca707e9864fc&amp;scene=21#wechat_redirect" rel="nofollow">什么是Zero-Copy?</a>》和《<a href="http://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483907&amp;idx=1&amp;sn=3d5e1384a36bd59f5fd14135067af1c2&amp;chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&amp;scene=21#wechat_redirect" rel="nofollow">NIO相关基础篇</a>》中我们学习了NIO的相关理论知识，而在本篇中我们一起来学习一下Java NIO的实战知识。全文较长，建议先马后看（记得关注不迷路）。</span></p>\n\n<h2><span style="color:inherit;">一、概述</span></h2>\n\n<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>\n\n<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>\n\n<p>IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>\n\n<h3><span style="color:inherit;">Channel</span></h3>\n\n<p>首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>\nNIO中的Channel的主要实现有：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">FileChannel</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">DatagramChannel</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">SocketChannel</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">ServerSocketChannel</span></p>\n\t</li>\n</ul><p>这里看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。下面演示的案例基本上就是围绕这4个类型的Channel进行陈述的。</p>\n\n<h3><span style="color:inherit;">Buffer</span></h3>\n\n<p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p>\n\n<h3><span style="color:inherit;">Selector</span></h3>\n\n<p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p>\n\n<h2><span style="color:inherit;">二、FileChannel</span></h2>\n\n<p>看完上面的陈述，对于第一次接触NIO的同学来说云里雾里，只说了一些概念，也没记住什么，更别说怎么用了。这里开始通过传统IO以及更改后的NIO来做对比，以更形象的突出NIO的用法，进而使你对NIO有一点点的了解。</p>\n\n<h3><span style="color:inherit;">传统IO vs NIO</span></h3>\n\n<p>首先，案例1是采用FileInputStream读取文件内容的：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method2</span>()</span>{\n \xa0 \xa0 \xa0 \xa0InputStream <span style="color:#cb7832;">in</span> = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">in</span> = <span style="color:#cb7832;">new</span> BufferedInputStream(<span style="color:#cb7832;">new</span> FileInputStream(<span style="color:#6a8759;">"src/nomal_io.txt"</span>));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">byte</span> [] buf = <span style="color:#cb7832;">new</span> <span style="color:#cb7832;">byte</span>[<span style="color:#6896ba;">1024</span>];\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> bytesRead = <span style="color:#cb7832;">in</span>.read(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(bytesRead != <span style="color:#6896ba;">-1</span>)\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">for</span>(<span style="color:#cb7832;">int</span> i=<span style="color:#6896ba;">0</span>;i&lt;bytesRead;i++)\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.print((<span style="color:#cb7832;">char</span>)buf[i]);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0bytesRead = <span style="color:#cb7832;">in</span>.read(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span> (IOException e)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(<span style="color:#cb7832;">in</span> != <span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">in</span>.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span> (IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>输出结果：（略）</p>\n\n<p>案例是对应的NIO（这里通过RandomAccessFile进行操作，当然也可以通过FileInputStream.getChannel()进行操作）：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method1</span>()</span>{\n \xa0 \xa0 \xa0 \xa0RandomAccessFile aFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0aFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/nio.txt"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileChannel fileChannel = aFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ByteBuffer buf = ByteBuffer.allocate(<span style="color:#6896ba;">1024</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> bytesRead = fileChannel.read(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(bytesRead);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(bytesRead != <span style="color:#6896ba;">-1</span>)\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buf.hasRemaining())\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.print((<span style="color:#cb7832;">char</span>)buf.<span style="color:#cb7832;">get</span>());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.compact();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0bytesRead = fileChannel.read(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span> (IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(aFile != <span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0aFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span> (IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>输出结果：（略）<br>\n通过仔细对比案例1和案例2，应该能看出个大概，最起码能发现NIO的实现方式比叫复杂。有了一个大概的印象可以进入下一步了。</p>\n\n<h3><span style="color:inherit;">Buffer的使用</span></h3>\n\n<p>从案例2中可以总结出使用Buffer一般遵循下面几个步骤：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">分配空间（ByteBuffer buf = ByteBuffer.allocate(1024); 还有一种allocateDirector后面再陈述）</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">写入数据到Buffer(int bytesRead = fileChannel.read(buf);)</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">调用filp()方法（ buf.flip();）</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">从Buffer中读取数据（System.out.print((char)buf.get());）</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">调用clear()方法或者compact()方法</span></p>\n\t</li>\n</ul><p>Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。如下图：</p>\n\n<p><img alt="640" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkGOwPEf5mVa7pmGeibp8msRSzXYEx3TY3ibDv7AAgd1fb8af6DVY3DBeg/640" style="margin-left:auto;"></p>\n\n<p>向Buffer中写数据：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">从Channel写到Buffer (fileChannel.read(buf))</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">通过Buffer的put()方法 （buf.put(…)）</span></p>\n\t</li>\n</ul><p>从Buffer中读取数据：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">从Buffer读取到Channel (channel.write(buf))</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">使用get()方法从Buffer中读取数据 （buf.get()）</span></p>\n\t</li>\n</ul><p>可以把Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：capacity, position, limit, mark：</p>\n\n<table cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;">\n\t\t\t<p><strong>索引</strong></p>\n\t\t\t</td>\n\t\t\t<td style="vertical-align:top;">\n\t\t\t<p><strong>说明</strong></p>\n\t\t\t</td>\n\t\t</tr><tr><td>\n\t\t\t<p>capacity</p>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t<p>缓冲区数组的总长度</p>\n\t\t\t</td>\n\t\t</tr><tr><td style="vertical-align:top;">\n\t\t\t<p>position</p>\n\t\t\t</td>\n\t\t\t<td style="vertical-align:top;">\n\t\t\t<p>下一个要操作的数据元素的位置</p>\n\t\t\t</td>\n\t\t</tr><tr><td>\n\t\t\t<p>limit</p>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t<p>缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity</p>\n\t\t\t</td>\n\t\t</tr><tr><td style="vertical-align:top;">\n\t\t\t<p>mark</p>\n\t\t\t</td>\n\t\t\t<td style="vertical-align:top;">\n\t\t\t<p>用于记录当前position的前一个位置或者默认是-1</p>\n\t\t\t</td>\n\t\t</tr></tbody></table><p><img alt="640" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swk4IpGBQtmrkZ6yWYwf4EXpVbRd37A9Uv6ia15xsJlyL1ev9xraUE4Fzg/640" style="margin-left:auto;"></p>\n\n<p><br>\n无图无真相，举例：我们通过ByteBuffer.allocate(11)方法创建了一个11个byte的数组的缓冲区，初始状态如上图，position的位置为0，capacity和limit默认都是数组长度。当我们写入5个字节时，变化如下图：<br><img alt="640" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkvBVTX2rNkCkxwrdibDO87QtWrXAcXzcLkUtNBrroLGZNWR5Viaibv2azQ/640" style="margin-left:auto;"></p>\n\n<p>这时我们需要将缓冲区中的5个字节数据写入Channel的通信信道，所以我们调用ByteBuffer.flip()方法，变化如下图所示(position设回0，并将limit设成之前的position的值)：</p>\n\n<p><img alt="640" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/HV4yTI6PjbKgic1MvAjpofibyQwiauK9swkqibxPCibMTibSckicCSobJo9e2ASbgazKdZTAn3Tu3CATicYhtvh6HFRicpw/640" style="margin-left:auto;"></p>\n\n<p>这时底层操作系统就可以从缓冲区中正确读取这个5个字节数据并发送出去了。在下一次写数据之前我们再调用clear()方法，缓冲区的索引位置又回到了初始位置。</p>\n\n<p>调用clear()方法：position将被设回0，limit设置成capacity，换句话说，Buffer被清空了，其实Buffer中的数据并未被清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>\n\n<p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定的position，之后可以通过调用Buffer.reset()方法恢复到这个position。Buffer.rewind()方法将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。</p>\n\n<h2><span style="color:inherit;">三、SocketChannel</span></h2>\n\n<p>说完了FileChannel和Buffer, 大家应该对Buffer的用法比较了解了，这里使用SocketChannel来继续探讨NIO。NIO的强大功能部分来自于Channel的非阻塞特性，套接字的某些操作可能会无限期地阻塞。例如，对accept()方法的调用可能会因为等待一个客户端连接而阻塞；对read()方法的调用可能会因为没有数据可读而阻塞，直到连接的另一端传来新的数据。总的来说，创建/接收连接或读写数据等I/O调用，都可能无限期地阻塞等待，直到底层的网络实现发生了什么。慢速的，有损耗的网络，或仅仅是简单的网络故障都可能导致任意时间的延迟。然而不幸的是，在调用一个方法之前无法知道其是否阻塞。NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel.configureBlocking(<span style="color:#6896ba;">false</span>)\n</code></pre>\n\n<p>在非阻塞式信道上调用一个方法总是会立即返回。这种调用的返回值指示了所请求的操作完成的程度。例如，在一个非阻塞式ServerSocketChannel上调用accept()方法，如果有连接请求来了，则返回客户端SocketChannel，否则返回null。</p>\n\n<p>这里先举一个TCP应用案例，客户端采用NIO实现，而服务端依旧使用BIO实现。<br>\n客户端代码（案例3）：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">client</span>()</span>{\n \xa0 \xa0 \xa0 \xa0ByteBuffer buffer = ByteBuffer.allocate(<span style="color:#6896ba;">1024</span>);\n \xa0 \xa0 \xa0 \xa0SocketChannel socketChannel = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel = SocketChannel.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel.configureBlocking(<span style="color:#6896ba;">false</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel.connect(<span style="color:#cb7832;">new</span> InetSocketAddress(<span style="color:#6a8759;">"10.10.195.115"</span>,<span style="color:#6896ba;">8080</span>));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(socketChannel.finishConnect())\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> i=<span style="color:#6896ba;">0</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(<span style="color:#6896ba;">true</span>)\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0TimeUnit.SECONDS.sleep(<span style="color:#6896ba;">1</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0String info = <span style="color:#6a8759;">"I\'m "</span>+i+++<span style="color:#6a8759;">"-th information from client"</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buffer.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buffer.put(info.getBytes());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buffer.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buffer.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(buffer);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel.write(buffer);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span> (IOException | InterruptedException e)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(socketChannel!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>服务端代码（案例4）：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">server</span>()</span>{\n \xa0 \xa0 \xa0 \xa0ServerSocket serverSocket = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0InputStream <span style="color:#cb7832;">in</span> = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0serverSocket = <span style="color:#cb7832;">new</span> ServerSocket(<span style="color:#6896ba;">8080</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> recvMsgSize = <span style="color:#6896ba;">0</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">byte</span>[] recvBuf = <span style="color:#cb7832;">new</span> <span style="color:#cb7832;">byte</span>[<span style="color:#6896ba;">1024</span>];\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(<span style="color:#6896ba;">true</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Socket clntSocket = serverSocket.accept();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0SocketAddress clientAddress = clntSocket.getRemoteSocketAddress();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"Handling client at "</span>+clientAddress);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">in</span> = clntSocket.getInputStream();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>((recvMsgSize=<span style="color:#cb7832;">in</span>.read(recvBuf))!=<span style="color:#6896ba;">-1</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">byte</span>[] temp = <span style="color:#cb7832;">new</span> <span style="color:#cb7832;">byte</span>[recvMsgSize];\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.arraycopy(recvBuf, <span style="color:#6896ba;">0</span>, temp, <span style="color:#6896ba;">0</span>, recvMsgSize);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#cb7832;">new</span> String(temp));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span> (IOException e)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(serverSocket!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0serverSocket.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(<span style="color:#cb7832;">in</span>!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">in</span>.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>输出结果：（略）</p>\n\n<p>根据案例分析，总结一下SocketChannel的用法。<br>\n打开SocketChannel：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel = SocketChannel.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel.connect(<span style="color:#cb7832;">new</span> InetSocketAddress(<span style="color:#6a8759;">"10.10.195.115"</span>,<span style="color:#6896ba;">8080</span>));\n</code></pre>\n\n<p>关闭：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">socketChannel</span><span style="color:#a6e22e;">.close</span>();\n</code></pre>\n\n<p>读取数据：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0String info = <span style="color:#6a8759;">"I\'m "</span>+i+++<span style="color:#6a8759;">"-th information from client"</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buffer.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buffer.put(info.getBytes());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buffer.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buffer.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(buffer);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0socketChannel.write(buffer);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n</code></pre>\n\n<p>注意SocketChannel.write()方法的调用是在一个while循环中的。write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。<br>\n非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>\n\n<h2><span style="color:inherit;">四、TCP服务端的NIO写法</span></h2>\n\n<p>到目前为止，所举的案例中都没有涉及Selector。不要急，好东西要慢慢来。Selector类可以用于避免使用阻塞式客户端中很浪费资源的“忙等”方法。例如，考虑一个IM服务器。像QQ或者旺旺这样的，可能有几万甚至几千万个客户端同时连接到了服务器，但在任何时刻都只是非常少量的消息。</p>\n\n<p>需要读取和分发。这就需要一种方法阻塞等待，直到至少有一个信道可以进行I/O操作，并指出是哪个信道。NIO的选择器就实现了这样的功能。一个Selector实例可以同时检查一组信道的I/O状态。用专业术语来说，选择器就是一个多路开关选择器，因为一个选择器能够管理多个信道上的I/O操作。然而如果用传统的方式来处理这么多客户端，使用的方法是循环地一个一个地去检查所有的客户端是否有I/O操作，如果当前客户端有I/O操作，则可能把当前客户端扔给一个线程池去处理，如果没有I/O操作则进行下一个轮询，当所有的客户端都轮询过了又接着从头开始轮询；这种方法是非常笨而且也非常浪费资源，因为大部分客户端是没有I/O操作，我们也要去检查；而Selector就不一样了，它在内部可以同时管理多个I/O，当一个信道有I/O操作的时候，他会通知Selector，Selector就是记住这个信道有I/O操作，并且知道是何种I/O操作，是读呢？是写呢？还是接受新的连接；所以如果使用Selector，它返回的结果只有两种结果，一种是0，即在你调用的时刻没有任何客户端需要I/O操作，另一种结果是一组需要I/O操作的客户端，这时你就根本不需要再检查了，因为它返回给你的肯定是你想要的。这样一种通知的方式比那种主动轮询的方式要高效得多！</p>\n\n<p>要使用选择器（Selector），需要创建一个Selector实例（使用静态工厂方法open()）并将其注册（register）到想要监控的信道上（注意，这要通过channel的方法实现，而不是使用selector的方法）。最后，调用选择器的select()方法。该方法会阻塞等待，直到有一个或更多的信道准备好了I/O操作或等待超时。select()方法将返回可进行I/O操作的信道数量。现在，在一个单独的线程中，通过调用select()方法就能检查多个信道是否准备好进行I/O操作。如果经过一段时间后仍然没有信道准备好，select()方法就会返回0，并允许程序继续执行其他任务。</p>\n\n<p>下面将上面的TCP服务端代码改写成NIO的方式（案例5）：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">class</span> <span style="color:inherit;">ServerConnect</span>\n{\n \xa0 \xa0<span style="color:#cb7832;">private</span> <span style="color:#cb7832;">static</span> final <span style="color:#cb7832;">int</span> BUF_SIZE=<span style="color:#6896ba;">1024</span>;\n \xa0 \xa0<span style="color:#cb7832;">private</span> <span style="color:#cb7832;">static</span> final <span style="color:#cb7832;">int</span> PORT = <span style="color:#6896ba;">8080</span>;\n \xa0 \xa0<span style="color:#cb7832;">private</span> <span style="color:#cb7832;">static</span> final <span style="color:#cb7832;">int</span> TIMEOUT = <span style="color:#6896ba;">3000</span>;\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">main</span>(<span style="color:#b9b9b9;">String[] args</span>)\n \xa0 \xa0</span>{\n \xa0 \xa0 \xa0 \xa0selector();\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">handleAccept</span>(<span style="color:#b9b9b9;">SelectionKey key</span>) throws IOException</span>{\n \xa0 \xa0 \xa0 \xa0ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();\n \xa0 \xa0 \xa0 \xa0SocketChannel sc = ssChannel.accept();\n \xa0 \xa0 \xa0 \xa0sc.configureBlocking(<span style="color:#6896ba;">false</span>);\n \xa0 \xa0 \xa0 \xa0sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">handleRead</span>(<span style="color:#b9b9b9;">SelectionKey key</span>) throws IOException</span>{\n \xa0 \xa0 \xa0 \xa0SocketChannel sc = (SocketChannel)key.channel();\n \xa0 \xa0 \xa0 \xa0ByteBuffer buf = (ByteBuffer)key.attachment();\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> bytesRead = sc.read(buf);\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(bytesRead&gt;<span style="color:#6896ba;">0</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buf.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.print((<span style="color:#cb7832;">char</span>)buf.<span style="color:#cb7832;">get</span>());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0bytesRead = sc.read(buf);\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(bytesRead == <span style="color:#6896ba;">-1</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0sc.close();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">handleWrite</span>(<span style="color:#b9b9b9;">SelectionKey key</span>) throws IOException</span>{\n \xa0 \xa0 \xa0 \xa0ByteBuffer buf = (ByteBuffer)key.attachment();\n \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0SocketChannel sc = (SocketChannel) key.channel();\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buf.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0sc.write(buf);\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0buf.compact();\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">selector</span>() </span>{\n \xa0 \xa0 \xa0 \xa0Selector selector = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0ServerSocketChannel ssc = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0selector = Selector.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc= ServerSocketChannel.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.socket().bind(<span style="color:#cb7832;">new</span> InetSocketAddress(PORT));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.configureBlocking(<span style="color:#6896ba;">false</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.register(selector, SelectionKey.OP_ACCEPT);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(<span style="color:#6896ba;">true</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(selector.<span style="color:#cb7832;">select</span>(TIMEOUT) == <span style="color:#6896ba;">0</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"=="</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">continue</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(iter.hasNext()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0SelectionKey key = iter.next();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(key.isAcceptable()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0handleAccept(key);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(key.isReadable()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0handleRead(key);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(key.isWritable() &amp;&amp; key.isValid()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0handleWrite(key);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(key.isConnectable()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"isConnectable = true"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0iter.<span style="color:#cb7832;">remove</span>();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(selector!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0selector.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(ssc!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n}\n</code></pre>\n\n<p>下面来慢慢讲解这段代码。</p>\n\n<h3><span style="color:inherit;">ServerSocketChannel</span></h3>\n\n<p>打开ServerSocketChannel：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">ServerSocketChannel</span> serverSocketChannel = ServerSocketChannel.open();\n</code></pre>\n\n<p>关闭ServerSocketChannel：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">serverSocketChannel</span><span style="color:#a6e22e;">.close</span>();\n</code></pre>\n\n<p>监听新进来的连接：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">while</span>(<span style="color:#6896ba;">true</span>){\n \xa0 \xa0SocketChannel socketChannel = serverSocketChannel.accept();\n}\n</code></pre>\n\n<p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n \xa0 \xa0 \xa0 \xa0serverSocketChannel.socket().bind(<span style="color:#cb7832;">new</span> InetSocketAddress(<span style="color:#6896ba;">9999</span>));\n \xa0 \xa0 \xa0 \xa0serverSocketChannel.configureBlocking(<span style="color:#6896ba;">false</span>);\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span> (<span style="color:#6896ba;">true</span>)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0SocketChannel socketChannel = serverSocketChannel.accept();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span> (socketChannel != <span style="color:#6896ba;">null</span>)\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#6896ba;">//</span> <span style="color:#cb7832;">do</span> something with socketChannel...\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n</code></pre>\n\n<h3><span style="color:inherit;">Selector</span></h3>\n\n<p>Selector的创建：Selector selector = Selector.open();</p>\n\n<p>为了将Channel和Selector配合使用，必须将Channel注册到Selector上，通过SelectableChannel.register()方法来实现，沿用案例5中的部分代码：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc= ServerSocketChannel.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.socket().bind(<span style="color:#cb7832;">new</span> InetSocketAddress(PORT));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.configureBlocking(<span style="color:#6896ba;">false</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ssc.<span style="color:#cb7832;">register</span>(selector, SelectionKey.OP_ACCEPT);\n</code></pre>\n\n<p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>\n\n<p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#6896ba;">1. </span>Connect\n<span style="color:#6896ba;">2. </span>Accept\n<span style="color:#6896ba;">3. </span>Read\n<span style="color:#6896ba;">4. </span>Write\n</code></pre>\n\n<p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p>\n\n<p>这四种事件用SelectionKey的四个常量来表示：</p>\n\n<pre>\n<code style="margin-left:2px;">1. <span style="color:#cb7832;">SelectionKey</span><span style="color:#a6e22e;">.OP_CONNECT</span>\n2. <span style="color:#cb7832;">SelectionKey</span><span style="color:#a6e22e;">.OP_ACCEPT</span>\n3. <span style="color:#cb7832;">SelectionKey</span><span style="color:#a6e22e;">.OP_READ</span>\n4. <span style="color:#cb7832;">SelectionKey</span><span style="color:#a6e22e;">.OP_WRITE</span>\n</code></pre>\n\n<h3><span style="color:inherit;">SelectionKey</span></h3>\n\n<p>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">interest集合</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">ready集合</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">Channel</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">Selector</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">附加的对象（可选）</span></p>\n\t</li>\n</ul><p>interest集合：就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合。</p>\n\n<p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">int</span> readySet = selectionKey.readyOps();\n</code></pre>\n\n<p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">selectionKey</span><span style="color:#a6e22e;">.isAcceptable</span>();\n<span style="color:#cb7832;">selectionKey</span><span style="color:#a6e22e;">.isConnectable</span>();\n<span style="color:#cb7832;">selectionKey</span><span style="color:#a6e22e;">.isReadable</span>();\n<span style="color:#cb7832;">selectionKey</span><span style="color:#a6e22e;">.isWritable</span>();\n</code></pre>\n\n<p>从SelectionKey访问Channel和Selector很简单。如下：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">Channel</span> \xa0channel \xa0= selectionKey.channel();\n<span style="color:#cb7832;">Selector</span> selector = selectionKey.selector();\n</code></pre>\n\n<p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>\n\n<pre>\n<code style="margin-left:2px;">selectionKey.attach(theObject);\n<span style="color:#e0c46c;">Object</span> attachedObj = selectionKey.attachment();\n</code></pre>\n\n<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>\n\n<pre>\n<code style="margin-left:2px;">SelectionKey key = channel.<span style="color:#cb7832;">register</span>(selector, SelectionKey.OP_READ, theObject);\n</code></pre>\n\n<h3><span style="color:inherit;">通过Selector选择通道</span></h3>\n\n<p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>\n\n<p>下面是select()方法：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">int select()</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">int select(long timeout)</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">int selectNow()</span></p>\n\t</li>\n</ul><p>select()阻塞到至少有一个通道在你注册的事件上就绪了。<br>\nselect(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。<br>\nselectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p>\n\n<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>\n\n<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">Set</span> selectedKeys = selector.selectedKeys();\n</code></pre>\n\n<p>当向Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。</p>\n\n<p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>\n\n<p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p>\n\n<p>一个完整的使用Selector和ServerSocketChannel的案例可以参考案例5的selector()方法。</p>\n\n<hr><h2><span style="color:inherit;">五、内存映射文件</span></h2>\n\n<p>JAVA处理大文件，一般用BufferedReader,BufferedInputStream这类带缓冲的IO类，不过如果文件超大的话，更快的方式是采用MappedByteBuffer。</p>\n\n<p>MappedByteBuffer是NIO引入的文件内存映射方案，读写性能极高。NIO最主要的就是实现了对异步操作的支持。其中一种通过把一个套接字通道(SocketChannel)注册到一个选择器(Selector)中,不时调用后者的选择(select)方法就能返回满足的选择键(SelectionKey),键中包含了SOCKET事件信息。这就是select模型。</p>\n\n<p>SocketChannel的读写是通过一个类叫ByteBuffer来操作的.这个类本身的设计是不错的,比直接操作byte[]方便多了. ByteBuffer有两种模式:直接/间接.间接模式最典型(也只有这么一种)的就是HeapByteBuffer,即操作堆内存 (byte[]).但是内存毕竟有限,如果我要发送一个1G的文件怎么办?不可能真的去分配1G的内存.这时就必须使用"直接"模式,即 MappedByteBuffer,文件映射.</p>\n\n<p>先中断一下,谈谈操作系统的内存管理.一般操作系统的内存分两部分:物理内存;虚拟内存.虚拟内存一般使用的是页面映像文件,即硬盘中的某个(某些)特殊的文件.操作系统负责页面文件内容的读写,这个过程叫"页面中断/切换". MappedByteBuffer也是类似的,你可以把整个文件(不管文件有多大)看成是一个ByteBuffer.MappedByteBuffer 只是一种特殊的ByteBuffer，即是ByteBuffer的子类。 MappedByteBuffer 将文件直接映射到内存（这里的内存指的是虚拟内存，并不是物理内存）。通常，可以映射整个文件，如果文件比较大的话可以分段进行映射，只要指定文件的那个部分就可以。</p>\n\n<h3><span style="color:inherit;">概念</span></h3>\n\n<p>FileChannel提供了map方法来把文件影射为内存映像文件： MappedByteBuffer map(int mode,long position,long size); 可以把文件的从position开始的size大小的区域映射为内存映像文件，mode指出了 可访问该内存映像文件的方式：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">READ_ONLY,（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException.(MapMode.READ_ONLY)</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">READ_WRITE（读/写）： 对得到的缓冲区的更改最终将传播到文件；该更改对映射到同一文件的其他程序不一定是可见的。 (MapMode.READ_WRITE)</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">PRIVATE（专用）： 对得到的缓冲区的更改不会传播到文件，并且该更改对映射到同一文件的其他程序也不是可见的；相反，会创建缓冲区已修改部分的专用副本。 (MapMode.PRIVATE)</span></p>\n\t</li>\n</ul><p>MappedByteBuffer是ByteBuffer的子类，其扩充了三个方法：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">force()：缓冲区是READ_WRITE模式下，此方法对缓冲区内容的修改强行写入文件；</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">load()：将缓冲区的内容载入内存，并返回该缓冲区的引用；</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">isLoaded()：如果缓冲区的内容在物理内存中，则返回真，否则返回假；</span></p>\n\t</li>\n</ul><h3><span style="color:inherit;">案例对比</span></h3>\n\n<p>这里通过采用ByteBuffer和MappedByteBuffer分别读取大小约为5M的文件"src/1.ppt"来比较两者之间的区别，method3()是采用MappedByteBuffer读取的，method4()对应的是ByteBuffer。</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method4</span>()</span>{\n \xa0 \xa0 \xa0 \xa0RandomAccessFile aFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0FileChannel fc = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0aFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/1.ppt"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fc = aFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> timeBegin = System.currentTimeMillis();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ByteBuffer buff = ByteBuffer.allocate((<span style="color:#cb7832;">int</span>) aFile.length());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buff.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fc.read(buff);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#7f7f7f;">//System.out.println((char)buff.get((int)(aFile.length()/2-1)));</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#7f7f7f;">//System.out.println((char)buff.get((int)(aFile.length()/2)));</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#7f7f7f;">//System.out.println((char)buff.get((int)(aFile.length()/2)+1));</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> timeEnd = System.currentTimeMillis();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"Read time: "</span>+(timeEnd-timeBegin)+<span style="color:#6a8759;">"ms"</span>);\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(aFile!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0aFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(fc!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fc.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method3</span>()</span>{\n \xa0 \xa0 \xa0 \xa0RandomAccessFile aFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0FileChannel fc = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0aFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/1.ppt"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fc = aFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> timeBegin = System.currentTimeMillis();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_ONLY, <span style="color:#6896ba;">0</span>, aFile.length());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#7f7f7f;">// System.out.println((char)mbb.get((int)(aFile.length()/2-1)));</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#7f7f7f;">// System.out.println((char)mbb.get((int)(aFile.length()/2)));</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#7f7f7f;">//System.out.println((char)mbb.get((int)(aFile.length()/2)+1));</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> timeEnd = System.currentTimeMillis();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"Read time: "</span>+(timeEnd-timeBegin)+<span style="color:#6a8759;">"ms"</span>);\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(aFile!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0aFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(fc!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fc.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>通过在入口函数main()中运行：</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0 \xa0 \xa0method3();\n \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"============="</span>);\n \xa0 \xa0 \xa0 \xa0method4();\n</code></pre>\n\n<p>输出结果（运行在普通PC机上）：</p>\n\n<pre>\n<code style="margin-left:2px;">Read <span style="color:#cb7832;">time</span>: <span style="color:#6896ba;">2</span>ms\n=============\nRead <span style="color:#cb7832;">time</span>: <span style="color:#6896ba;">12</span>ms\n</code></pre>\n\n<p>通过输出结果可以看出彼此的差别，一个例子也许是偶然，那么下面把5M大小的文件替换为200M的文件，输出结果：</p>\n\n<pre>\n<code style="margin-left:2px;">Read <span style="color:#cb7832;">time</span>: <span style="color:#6896ba;">1</span>ms\n=============\nRead <span style="color:#cb7832;">time</span>: <span style="color:#6896ba;">407</span>ms\n</code></pre>\n\n<p>可以看到差距拉大。</p>\n\n<blockquote>\n<p>注：MappedByteBuffer有资源释放的问题：被MappedByteBuffer打开的文件只有在垃圾收集时才会被关闭，而这个点是不确定的。在Javadoc中这里描述：A mapped byte buffer and the file mapping that it represents remian valid until the buffer itself is garbage-collected。详细可以翻阅参考资料5和6.</p>\n</blockquote>\n\n<hr><h2><span style="color:inherit;">六、其余功能介绍</span></h2>\n\n<p>看完以上陈述，详细大家对NIO有了一定的了解，下面主要通过几个案例，来说明NIO的其余功能，下面代码量偏多，功能性讲述偏少。</p>\n\n<h3><span style="color:inherit;">Scatter/Gatter</span></h3>\n\n<p>分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</p>\n\n<p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</p>\n\n<p>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>\n\n<p>案例：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#cb7832;">import</span> java.io.File;\n<span style="color:#cb7832;">import</span> java.io.FileNotFoundException;\n<span style="color:#cb7832;">import</span> java.io.FileOutputStream;\n<span style="color:#cb7832;">import</span> java.io.IOException;\n<span style="color:#cb7832;">import</span> java.io.OutputStream;\n<span style="color:#cb7832;">import</span> java.nio.ByteBuffer;\n<span style="color:#cb7832;">import</span> java.nio.channels.Channel;\n<span style="color:#cb7832;">import</span> java.nio.channels.FileChannel;\n<span style="color:#cb7832;">public</span> <span style="color:inherit;"><span style="color:#cb7832;">class</span> <span style="color:inherit;">ScattingAndGather</span>\n</span>{\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">main</span><span style="color:#b9b9b9;">(String args[])</span></span>{\n \xa0 \xa0 \xa0 \xa0gather();\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">gather</span><span style="color:#b9b9b9;">()</span>\n \xa0 \xa0</span>{\n \xa0 \xa0 \xa0 \xa0ByteBuffer header = ByteBuffer.allocate(<span style="color:#6896ba;">10</span>);\n \xa0 \xa0 \xa0 \xa0ByteBuffer body = ByteBuffer.allocate(<span style="color:#6896ba;">10</span>);\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">byte</span> [] b1 = {<span style="color:#6a8759;">\'0\'</span>, <span style="color:#6a8759;">\'1\'</span>};\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">byte</span> [] b2 = {<span style="color:#6a8759;">\'2\'</span>, <span style="color:#6a8759;">\'3\'</span>};\n \xa0 \xa0 \xa0 \xa0header.put(b1);\n \xa0 \xa0 \xa0 \xa0body.put(b2);\n \xa0 \xa0 \xa0 \xa0ByteBuffer [] buffs = {header, body};\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileOutputStream os = <span style="color:#cb7832;">new</span> FileOutputStream(<span style="color:#6a8759;">"src/scattingAndGather.txt"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileChannel channel = os.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel.write(buffs);\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span> (IOException e)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n}\n</code></pre>\n\n<h3><span style="color:inherit;">transferFrom &amp; transferTo</span></h3>\n\n<p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method1</span>()</span>{\n \xa0 \xa0 \xa0 \xa0RandomAccessFile fromFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0RandomAccessFile toFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fromFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/fromFile.xml"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileChannel fromChannel = fromFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0toFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/toFile.txt"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileChannel toChannel = toFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> position = <span style="color:#6896ba;">0</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> count = fromChannel.size();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(count);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0toChannel.transferFrom(fromChannel, position, count);\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span> (IOException e)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(fromFile != <span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fromFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(toFile != <span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0toFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>\n\n<p>transferTo()方法将数据从FileChannel传输到其他的channel中。</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method2</span>()\n \xa0 \xa0</span>{\n \xa0 \xa0 \xa0 \xa0RandomAccessFile fromFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0RandomAccessFile toFile = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fromFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/fromFile.txt"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileChannel fromChannel = fromFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0toFile = <span style="color:#cb7832;">new</span> RandomAccessFile(<span style="color:#6a8759;">"src/toFile.txt"</span>,<span style="color:#6a8759;">"rw"</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FileChannel toChannel = toFile.getChannel();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> position = <span style="color:#6896ba;">0</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">long</span> count = fromChannel.size();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(count);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fromChannel.transferTo(position, count,toChannel);\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span> (IOException e)\n \xa0 \xa0 \xa0 \xa0{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(fromFile != <span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0fromFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(toFile != <span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0toFile.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>\n\n<h3><span style="color:inherit;">Pipe</span></h3>\n\n<p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">method1</span>()</span>{\n \xa0 \xa0 \xa0 \xa0Pipe pipe = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0ExecutorService exec = Executors.newFixedThreadPool(<span style="color:#6896ba;">2</span>);\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0pipe = Pipe.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0final Pipe pipeTemp = pipe;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0exec.submit(<span style="color:#cb7832;">new</span> Callable&lt;Object&gt;(){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0@<span style="color:inherit;">Override\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">public</span> Object <span style="color:inherit;">call</span>() throws Exception\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Pipe.SinkChannel sinkChannel = pipeTemp.sink();<span style="color:#7f7f7f;">//向通道中写数据</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(<span style="color:#6896ba;">true</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0TimeUnit.SECONDS.sleep(<span style="color:#6896ba;">1</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0String newData = <span style="color:#6a8759;">"Pipe Test At Time "</span>+System.currentTimeMillis();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ByteBuffer buf = ByteBuffer.allocate(<span style="color:#6896ba;">1024</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.put(newData.getBytes());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buf.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0sinkChannel.write(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0});\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0exec.submit(<span style="color:#cb7832;">new</span> Callable&lt;Object&gt;(){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0@<span style="color:inherit;">Override\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">public</span> Object <span style="color:inherit;">call</span>() throws Exception\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Pipe.SourceChannel sourceChannel = pipeTemp.source();<span style="color:#7f7f7f;">//向通道中读数据</span>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(<span style="color:#6896ba;">true</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0TimeUnit.SECONDS.sleep(<span style="color:#6896ba;">1</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ByteBuffer buf = ByteBuffer.allocate(<span style="color:#6896ba;">1024</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> bytesRead = sourceChannel.read(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"bytesRead="</span>+bytesRead);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(bytesRead &gt;<span style="color:#6896ba;">0</span> ){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">byte</span> b[] = <span style="color:#cb7832;">new</span> <span style="color:#cb7832;">byte</span>[bytesRead];\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> i=<span style="color:#6896ba;">0</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buf.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0b[i]=buf.<span style="color:#cb7832;">get</span>();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.printf(<span style="color:#6a8759;">"%X"</span>,b[i]);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0i++;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0String s = <span style="color:#cb7832;">new</span> String(b);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(<span style="color:#6a8759;">"=================||"</span>+s);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0bytesRead = sourceChannel.read(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0});\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0exec.shutdown();\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<h3><span style="color:inherit;">DatagramChannel</span></h3>\n\n<p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>\n\n<pre>\n<code style="margin-left:2px;"> \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> \xa0<span style="color:inherit;">reveive</span>()</span>{\n \xa0 \xa0 \xa0 \xa0DatagramChannel channel = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel = DatagramChannel.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel.socket().bind(<span style="color:#cb7832;">new</span> InetSocketAddress(<span style="color:#6896ba;">8888</span>));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ByteBuffer buf = ByteBuffer.allocate(<span style="color:#6896ba;">1024</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel.receive(buf);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">while</span>(buf.hasRemaining()){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.print((<span style="color:#cb7832;">char</span>)buf.<span style="color:#cb7832;">get</span>());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(channel!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n \xa0 \xa0<span style="color:inherit;"><span style="color:#cb7832;">public</span> <span style="color:#cb7832;">static</span> <span style="color:#cb7832;">void</span> <span style="color:inherit;">send</span>()</span>{\n \xa0 \xa0 \xa0 \xa0DatagramChannel channel = <span style="color:#6896ba;">null</span>;\n \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel = DatagramChannel.open();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0String info = <span style="color:#6a8759;">"I\'m the Sender!"</span>;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0ByteBuffer buf = ByteBuffer.allocate(<span style="color:#6896ba;">1024</span>);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.clear();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.put(info.getBytes());\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0buf.flip();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">int</span> bytesSent = channel.send(buf, <span style="color:#cb7832;">new</span> InetSocketAddress(<span style="color:#6a8759;">"10.10.195.115"</span>,<span style="color:#6896ba;">8888</span>));\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0System.<span style="color:#cb7832;">out</span>.println(bytesSent);\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">finally</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">try</span>{\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<span style="color:#cb7832;">if</span>(channel!=<span style="color:#6896ba;">null</span>){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0channel.close();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}<span style="color:#cb7832;">catch</span>(IOException e){\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0e.printStackTrace();\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0 \xa0 \xa0}\n \xa0 \xa0}\n</code></pre>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-更多文章-</span></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485244&amp;idx=1&amp;sn=decc999c47c0050fc7dc521ad757889f&amp;chksm=9bed264eac9aaf58867fd461ee5676a314133f7427895b49c20f58cb7c7def27687b625d3772&amp;scene=21#wechat_redirect" rel="nofollow">面试季，Java中的static关键字解析</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485240&amp;idx=1&amp;sn=f72ba22a922fda3859890e596c8dd89c&amp;chksm=9bed264aac9aaf5c6127f33351dd2b341ef233e0d418c1a7f7da2de756a6bbfa003cba079c95&amp;scene=21#wechat_redirect" rel="nofollow">面试常问的，Java面向对象设计的六大原则</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485230&amp;idx=1&amp;sn=8b3ec06606d852cee00513efbb050f60&amp;chksm=9bed265cac9aaf4af30489a6b6359cc116929bcdf19bddf8faef173b4df904e77310e28563ba&amp;scene=21#wechat_redirect" rel="nofollow">真正理解Mysql的四种隔离级别</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485223&amp;idx=1&amp;sn=1c59b08d2e4bbf9cdd2dded2b8b156a4&amp;chksm=9bed2655ac9aaf438bcfbc4c8c3e57e08a5abe32ce9843cd6dba8623ec57976f5ee7f935f297&amp;scene=21#wechat_redirect" rel="nofollow">数据库索引原理及优化</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247484551&amp;idx=1&amp;sn=d52692cfa3438e94a77f436c8bf1931d&amp;chksm=9bed25f5ac9aace336437bc590ff3a6672c7c848d0660512c6d615d26212234215df76a11b03&amp;scene=21#wechat_redirect" rel="nofollow">我必须得告诉大家的MySQL优化原理</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485210&amp;idx=1&amp;sn=cf092ad002b617d1bd9da279cad42122&amp;chksm=9bed2668ac9aaf7e7805042cf38fa449d53e4df125652d3a1e0d0e319d30464cf13de80ad2a1&amp;scene=21#wechat_redirect" rel="nofollow">这 10 道 Spring Boot 常见面试题你需要了解下</a></u></p>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-关注我-</span></p>\n\n<p style="text-align:center;"><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png"></p>\n\n<p style="margin-left:8px;"><strong><span style="color:#3da742;">看完了，帮我点个“好看”鸭</span></strong></p>\n\n<p style="margin-left:8px;"><span style="color:#3da742;"><strong>点鸭点鸭</strong></span></p>\n\n<p><span style="color:#3da742;">↓↓↓</span></p>\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/88373743', 'title': '面试常问的，Java面向对象设计的六大原则', 'readNum': '8222', 'commentNum': '1', 'publishTime': '2019-03-09 14:00:44', 'content': '<div class="htmledit_views" id="content_views">\n                                            \n    <div class="rich_media_content" id="js_content">\n                    \n\n                    \n\n                    \n                    \n                    <p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(136,136,136);letter-spacing:.544px;font-size:12px;">点击上方</span><span style="letter-spacing:.544px;font-size:12px;">“<span style="color:rgb(0,82,255);">方志朋</span>”，</span><span style="color:rgb(136,136,136);letter-spacing:.544px;font-size:12px;">选择“置顶或者星标”</span><br></p><p style="margin-left:16px;letter-spacing:.544px;line-height:normal;"><span style="color:rgb(127,127,127);font-size:12px;letter-spacing:.544px;">你的关注意义重大！</span></p><p><br></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这是设计模式系列开篇的第一篇文章。也是我学习设计模式过程中的总结。这篇文章主要讲的是面向对象设计中，我们应该遵循的六大原则。只有掌握了这些原则，我们才能更好的理解设计模式。 我们接下来要介绍以下6个内容。<br></p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;">单一职责原则——SRP</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">开闭原则——OCP</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">里式替换原则——LSP</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">依赖倒置原则——DIP</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">接口隔离原则——ISP</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">迪米特原则——LOD</span></p></li></ul><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">单一职责原则</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">单一职责原则的好处如下：</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多 提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。</p></blockquote><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">开闭原则</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">开闭原则和单一职责原则一样，是非常基础而且一般是常识的原则。开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这个准则和单一职责原则一样，是一个大家都这样去认为但是又没规定具体该如何去做的一种原则。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">开闭原则我们可以用一种方式来确保他，我们用抽象去构建框架，用实现扩展细节。这样当发生修改的时候，我们就直接用抽象了派生一个具体类去实现修改。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">里氏替换原则</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">里氏替换原则是一个非常有用的一个概念。他的定义</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>如果对每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有对象o1都替换成o2的时候，程序P的行为都没有发生变化，那么类型T2是类型T1的子类型。</p></blockquote><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这样说有点复杂，其实有一个简单的定义</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>所有引用基类的地方必须能够透明地使用其子类的对象。</p></blockquote><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;">子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">子类可以增加自己独有的方法。</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。</span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;">当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。</span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">里氏替换原则之所以这样要求是因为继承有很多缺点，他虽然是复用代码的一种方法，但同时继承在一定程度上违反了封装。父类的属性和方法对子类都是透明的，子类可以随意修改父类的成员。这也导致了，如果需求变更，子类对父类的方法进行一些复写的时候，其他的子类无法正常工作。所以里氏替换法则被提出来。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">确保程序遵循里氏替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，然后用实现去扩展细节，这个是不是很耳熟，对，里氏替换原则和开闭原则往往是相互依存的。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">依赖倒置原则</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">依赖倒置原则指的是一种特殊的解耦方式，使得高层次的模块不应该依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。 这也是一个让人难懂的定义，他可以简单来说就是</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象</p></blockquote><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">在Java 中抽象指的是接口或者抽象类，两者皆不能实例化。而细节就是实现类，也就是实现了接口或者继承了抽象类的类。他是可以被实例化的。高层模块指的是调用端，底层模块是具体的实现类。在Java中，依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的。这就是俗称的面向接口编程。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">我们下面有一个例子来讲述这个问题。这个例子是工人用锤子来修理东西。我们的代码如下：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">class</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Hammer</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">String</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> function</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(){</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"用锤子修理东西"</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><br></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">class</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Worker</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">void</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> fix</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Hammer</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> hammer</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">){</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">System</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">out</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">println</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"工人"</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> hammer</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">function</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">());</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><br></p></li><li><p><br></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">static</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">void</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> main</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">String</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[]</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> args</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">new</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Worker</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">().</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">fix</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">new</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Hammer</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">());</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这个是一个很简单的例子，但是如果我们要新增加一个功能，工人用 螺丝刀来修理东西，在这个类，我们发现是很难做的。因为我们Worker类依赖于一个具体的实现类Hammer。所以我们用到面向接口编程的思想，改成如下的代码：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">interface</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Tools</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">String</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> function</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">();</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">然后我们的Worker是通过这个接口来于其他细节类进行依赖。代码如下：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">class</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Worker</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">void</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> fix</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Tools</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> tool</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">){</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">System</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">out</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">println</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"工人"</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> tool</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">function</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">());</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><br></p></li><li><p><br></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">static</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">void</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> main</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">String</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[]</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> args</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">new</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Worker</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">().</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">fix</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">new</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Hammer</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">());</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">new</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Worker</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">().</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">fix</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">new</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Screwdriver</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">());</span></code></span></span></p></li><li><p><br></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">我们的Hammer类与Screwdriver类实现这个接口</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">class</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Hammer</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">implements</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Tools</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">String</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> function</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(){</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"用锤子修理东西"</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><br></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">class</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Screwdriver</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">implements</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">Tools</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">@Override</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">public</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">String</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> function</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">()</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"用螺丝刀修理东西"</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><br></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这样，通过面向接口编程，我们的代码就有了很高的扩展性，降低了代码之间的耦合度，提高了系统的稳定性。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">接口隔离原则</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">接口隔离原则的定义是</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>客户端不应该依赖他不需要的接口</p></blockquote><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">换一种说法就是类间的依赖关系应该建立在最小的接口上。这样说好像更难懂。我们通过一个例子来说明。我们知道在Java中一个具体类实现了一个接口，那必然就要实现接口中的所有方法。如果我们有一个类A和类B通过接口I来依赖，类B是对类A依赖的实现，这个接口I有5个方法。但是类A与类B只通过方法1,2,3依赖，然后类C与类D通过接口I来依赖，类D是对类C依赖的实现但是他们却是通过方法1,4,5依赖。那么是必在实现接口的时候，类B就要有实现他不需要的方法4和方法5 而类D就要实现他不需要的方法2，和方法3。这简直就是一个灾难的设计。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">所以我们需要对接口进行拆分，就是把接口分成满足依赖关系的最小接口，类B与类D不需要去实现与他们无关接口方法。比如在这个例子中，我们可以把接口拆成3个，第一个是仅仅由方法1的接口，第二个接口是包含2,3方法的，第三个接口是包含4,5方法的。 这样，我们的设计就满足了接口隔离原则。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">迪米特原则</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">迪米特原则也被称为最小知识原则，他的定义</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>一个对象应该对其他对象保持最小的了解。</p></blockquote><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。 迪米特法则还有一个更简单的定义</p><blockquote style="color:rgb(129,145,152);border-left-width:6px;border-left-color:rgb(220,230,240);font-size:14px;line-height:18px;background:rgb(242,247,251);font-family:Helvetica, Arial, sans-serif;"><p>只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p></blockquote><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这里我们可以用一个现实生活中的例子来讲解一下。比如我们需要一张CD,我们可能去音像店去问老板有没有我们需要的那张CD，老板说现在没有，等有的时候你们来拿就行了。在这里我们不需要关心老板是从哪里，怎么获得的那张CD，我们只和老板（直接朋友）沟通，至于老板从他的朋友那里通过何种条件得到的CD，我们不关心，我们不和老板的朋友（陌生人）进行通信，这个就是迪米特的一个应用。说白了，就是一种中介的方式。我们通过老板这个中介来和真正提供CD的人发生联系。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">总结</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">到这里，面向对象的六大原则，就写完了。我们看出来，这些原则其实都是应对不断改变的需求。每当需求变化的时候，我们利用这些原则来使我们的代码改动量最小，而且所造成的影响也是最小的。但是我们在看这些原则的时候，我们会发现很多原则并没有提供一种公式化的结论，而即使提供了公式化的结论的原则也只是建议去这样做。这是因为，这些设计原则本来就是从很多实际的代码中提取出来的，他是一个经验化的结论。怎么去用它，用好他，就要依靠设计者的经验。否则一味者去使用设计原则可能会使代码出现过度设计的情况。大多数的原则都是通过提取出抽象和接口来实现，如果发生过度的设计，就会出现很多抽象类和接口，增加了系统的复杂度。让本来很小的项目变得很庞大，当然这也是Java的特性（任何的小项目都会做成中型的项目）。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">原文链接</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">https://blog.csdn.net/Jin_Kwok/article/details/80348936</p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;">-更多文章-</span><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485230&amp;idx=1&amp;sn=8b3ec06606d852cee00513efbb050f60&amp;chksm=9bed265cac9aaf4af30489a6b6359cc116929bcdf19bddf8faef173b4df904e77310e28563ba&amp;scene=21#wechat_redirect" rel="nofollow">真正理解Mysql的四种隔离级别</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485223&amp;idx=1&amp;sn=1c59b08d2e4bbf9cdd2dded2b8b156a4&amp;chksm=9bed2655ac9aaf438bcfbc4c8c3e57e08a5abe32ce9843cd6dba8623ec57976f5ee7f935f297&amp;scene=21#wechat_redirect" rel="nofollow">数据库索引原理及优化</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247484551&amp;idx=1&amp;sn=d52692cfa3438e94a77f436c8bf1931d&amp;chksm=9bed25f5ac9aace336437bc590ff3a6672c7c848d0660512c6d615d26212234215df76a11b03&amp;scene=21#wechat_redirect" rel="nofollow">我必须得告诉大家的MySQL优化原理</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485210&amp;idx=1&amp;sn=cf092ad002b617d1bd9da279cad42122&amp;chksm=9bed2668ac9aaf7e7805042cf38fa449d53e4df125652d3a1e0d0e319d30464cf13de80ad2a1&amp;scene=21#wechat_redirect" rel="nofollow">这 10 道 Spring Boot 常见面试题你需要了解下</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485203&amp;idx=1&amp;sn=56a66cc9fe8177749b07c2bb9b7449d0&amp;chksm=9bed2661ac9aaf77ca53fb718bb2c552608f58a4c49cdb34ca653a33fb8099bcdc70dec65373&amp;scene=21#wechat_redirect" rel="nofollow">最详细排序解析，七大排序横评（校正篇）</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);letter-spacing:.544px;font-size:13px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485170&amp;idx=1&amp;sn=58f62aa0b9a4c38b8aa9995923ec7ebf&amp;chksm=9bed2780ac9aae9695eaeb4de51b36a28d1f53583e777aae8ef0167c4f6064aef6f70d757ec9&amp;scene=21#wechat_redirect" rel="nofollow">缓存穿透，缓存击穿，缓存雪崩解决方案分析</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-关注我-</span></p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="font-size:14px;letter-spacing:1px;"><strong style="letter-spacing:.544px;"><span style="letter-spacing:1px;color:rgb(61,167,66);">看完了，帮我点个“好看”鸭</span></strong></span></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:1px;"><strong>点鸭点鸭</strong></span></p><p style="letter-spacing:.544px;font-size:13px;line-height:normal;text-align:right;"><span style="color:rgb(61,167,66);">↓↓↓↓</span></p>\n                </div>\n                                      </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/88325144', 'title': '数据库索引原理及优化', 'readNum': '8159', 'commentNum': '0', 'publishTime': '2019-03-07 09:20:00', 'content': '<div class="htmledit_views" id="content_views">\n                                            \n    <div class="rich_media_content" id="js_content">\n                    \n\n                    \n\n                    \n                    \n                    <p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(136,136,136);letter-spacing:.544px;font-size:12px;">点击上方</span><span style="letter-spacing:.544px;font-size:12px;">“<span style="color:rgb(0,82,255);">方志朋</span>”，</span><span style="color:rgb(136,136,136);letter-spacing:.544px;font-size:12px;">选择“置顶或者星标”</span><br></p><p style="margin-left:16px;letter-spacing:.544px;line-height:normal;"><span style="color:rgb(127,127,127);font-size:12px;letter-spacing:.544px;">你的关注意义重大！</span></p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;"><br></h2><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">摘要<br></h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">常见的查询算法及数据结构</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">为什么这里要讲查询算法和数据结构呢？因为之所以要建立索引，其实就是为了构建一种数据结构，可以在上面应用一种高效的查询算法，最终提高数据的查询速度。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">索引的本质</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">常见的查询算法</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。那么有哪些查询算法可以使查询速度变得更快呢？</p><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">顺序查找（linear search ）</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>数据结构：有序或无序队列</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>复杂度：O(n)</span></span></p></li></ul><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="com" style="color:rgb(156,148,145);line-height:20px;font-size:13px;">//顺序查找</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">SequenceSearch</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[],</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> n</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">for</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">0</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">&lt;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">n</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">++)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]==</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">            </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">-</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li></ol><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">二分查找（binary search）</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">比顺序查找更快的查询方法应该就是二分查找了，二分查找的原理是查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>数据结构：有序数组</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>复杂度：O(logn)</span></span></p></li></ul><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="com" style="color:rgb(156,148,145);line-height:20px;font-size:13px;">//二分查找，递归版本</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BinarySearch2</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[],</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> low</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> high</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">int</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> mid </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> low</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">high</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">-</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">low</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)/</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">mid</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]==</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> mid</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">mid</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]&gt;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BinarySearch2</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> low</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> mid</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">-</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">);</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">    </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">mid</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]&lt;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">        </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BinarySearch2</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> value</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> mid</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> high</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">);</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li></ol><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">二叉排序树查找</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">二叉排序树的特点是：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>它的左、右子树也分别为二叉排序树。</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">搜索的原理：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>若b是空树，则搜索失败，否则：</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>若x等于b的根节点的数据域之值，则查找成功；否则：</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>若x小于b的根节点的数据域之值，则搜索左子树；否则：查找右子树</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>数据结构：二叉排序树</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>时间复杂度： O(log2N)</span></span></p></li></ul><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">哈希散列法(哈希表)</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>数据结构：哈希表</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>时间复杂度：几乎是O(1)，取决于产生冲突的多少。</span></span></p></li></ul><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">分块查找</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。 \u3000\u3000 算法流程：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>先选取各块中的最大关键字构成一个索引表；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这种搜索算法每一次比较都使搜索范围缩小一半。它们的查询速度就有了很大的提升。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">平衡多路搜索树B树（B-tree）</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">上面讲到了二叉树，它的搜索时间复杂度为O(log2N)，所以它的搜索效率和树的深度有关，如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">B Tree</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，它就是一种平衡路查找树。下图就是一个典型的B树：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3MerYeJ7kN8kefvCJVibqWG4O5iaYN22xdMDbV1oRgvrEKMJBWK4mtAXIHA/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">从上图中我们可以大致看到B树的一些特点，为了更好的描述B树，我们定义记录为一个二元组[key, data]，key为记录的键值，data表示其它数据（上图中只有key，没有画出data数据 ）。下面是对B树的一个详细定</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>有一个根节点，根节点只有一个记录和两个孩子或者根节点为空；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>每个节点记录中的key和指针相互间隔，指针指向孩子节点；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>d是表示树的宽度，除叶子节点之外，其它每个节点有[d/2,d-1]条记录，并且些记录中的key都是从左到右按大小排列的，有[d/2+1,d]个孩子；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>在一个节点中，第n个子树中的所有key，小于这个节点中第n个key，大于第n-1个key，比如上图中B节点的第2个子节点E中的所有key都小于B中的第2个key 9，大于第1个key 3;</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>所有的叶子节点必须在同一层次，也就是它们具有相同的深度；</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BTree_Search</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">{</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">     </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">==</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">null</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">null</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">;</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">     foreach</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">){</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">          </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">==</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">data</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">];</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">          </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">if</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">.</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">&gt;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">)</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BTree_Search</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">point</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]-&gt;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">);</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">      </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">     </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">return</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BTree_Search</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">point</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">[</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">i</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">]-&gt;</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">node</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">);</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">  </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">}</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="java language-java" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">data </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">BTree_Search</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">root</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">,</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> my_key</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">);</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以查阅其它文献进行详细研究。</p><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">B+Tree</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。B-Tree相比，B+Tree有以下不同点：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>每个节点的指针上限为2d而不是2d+1；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>内节点不存储data，只存储key；</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>叶子节点不存储指针；</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">下面是一个简单的B+Tree示意</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3MefnIgBvav6TKZb5GjyCU5HYvULfoiclDDTToelJqJwhwne3tpgHnEJ2Q/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">带有顺序访问指针的B+Tree</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3Me2zSzkdKvOTI2f1g8bGZuDibfC7YbJn9LxAbWwo58xiaCuKgltXcZGL8w/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">索引数据结构设相关的计算机原理</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">上文说过，二叉树、红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">两种类型的存储</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">在计算机系统中一般包含两种类型的存储，计算机主存（RAM）和外部存储器（如硬盘、CD、SSD等）。在设计索引算法和存储结构时，我们必须要考虑到这两种类型的存储特点。主存的读取速度快，相对于主存，外部磁盘的数据读取速率要比主从慢好几个数量级，具体它们之间的差别后面会详细介绍。 上面讲的所有查询算法都是假设数据存储在计算机主存中的，计算机主存一般比较小，实际数据库中数据都是存储到外部存储器的。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面详细介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">存存取原理</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3MeN1CFI4q34hAvDZplY3Qdvf8jicAaoGcdLW9dMNNm4bD20edhRv0PqkQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">主存的存取过程如下：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">磁盘存取原理</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">磁盘读取数据靠的是机械运动，当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间，最后便是对读取数据的传输。 所以每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。其中：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>寻道时间是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">局部性原理与磁盘预读</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">数据库索引所采用的数据结构B-/+Tree及其性能分析</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">到这里终于可以分析为何数据库索引采用B-/+Tree存储结构了。上文说过数据库索引是存储到磁盘的而我们又一般以使用磁盘I/O次数来评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h-1个节点（根节点常驻内存）。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">综上所述，如果我们采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，所以用B-Tree作为索引结构效率是非常高的。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">B+树性能分析</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">从上面介绍我们知道，B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">dmax</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">floor</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">pagesize</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">/(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">keysize</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">datasize</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">+</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">pointsize</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">))</span><span class="com" style="color:rgb(156,148,145);line-height:20px;font-size:13px;">//floor表示向下取整</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">B+树查找过程</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3Me66oibJFFsEL1OlXL00wN635ckwzYxzohLw1EvtERiaMHu1UqicovKJK0A/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">B-树和B+树查找过程基本一致。如上图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">MySQL索引实现</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">MyISAM索引实现</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3MeWYTfATbl5xaqcibVXHNNgJGyKrrWPVAgyibgic3Ol5s6Z1CjFtAPibtJbA/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3Me3ZbLfnhmxtc8EqX5mqbg0XvzrbISDEevhWFq6NuMMwvTQjxtjxz0DA/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">InnoDB索引实现</h3><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3MeRqoc5dWqaib0nGzAZ6oBnqVL8wM73Vhj8ibbxSs3QkuTiamXwUq8CL7Qg/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;"><img style="border-width:2px;border-style:solid;border-color:rgb(238,238,238);" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5Lhxxzwkyf2aoltRTNRibSA7NyN3MelRltxT2ZrymMU7YXHyACMwDUmvlKeIpwz20SeIFcSbQYnTCc4Bx8cA/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">下一章将具体讨论这些与索引有关的优化策略。</p><h2 style="color:rgb(21,153,87);line-height:1.35;font-size:22px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">索引使用策略及优化</h2><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">联合索引及最左前缀原理</h3><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">联合索引（复合索引）</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>第一个字段一定是有序的</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的</span></span></p></li></ul><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> A </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> B </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> C </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">3</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">4</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">4</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">3</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">5</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">4</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">4</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">4</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">6</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">5</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">5</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">|</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。</p><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">最左前缀原理</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">我们再来详细介绍一下联合索引的查询。还是上面例子，我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">以下的查询方式都可以用到索引</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> b</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> b</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> c</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">3</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">上面三个查询按照 （a ）, （a，b ）,（a，b，c ）的顺序都可以利用到索引，这就是最左前缀匹配。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">如果查询语句是：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> c</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">3</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">那么只会用到索引</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">。</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">如果查询语句是：</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> b</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> c</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">3</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">因为没有用到最左前缀</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">，所以这个查询是用户到索引的。</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">如果用到了最左前缀，但是顺序颠倒会用到索引码？</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="text language-text" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> b</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="text language-text" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">select</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">from</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> table </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">where</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> b</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">2</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="kwd" style="color:rgb(102,102,234);line-height:20px;font-size:13px;">and</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> c</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">3</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">；</span></code></span></span></p></li></ol><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。</p><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">前缀索引</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">除了联合索引之外，对mysql来说其实还有一种前缀索引。前缀索引就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">一般来说以下情况可以使用前缀索引：</p><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">一些文章中也提到：</p><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。</p><h3 style="color:rgb(21,153,87);line-height:1.35;font-size:18px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">索引优化策略</h3><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>最左前缀匹配原则，上面讲到了</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>主键外检一定要建索引</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>对 where,on,group by,order by 中出现的列使用索引</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>索引列不能参与计算，保持列“干净”，比如from<span>unixtime(create</span>time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create<span>time = unix</span>timestamp(’2014-05-29’);</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>为较长的字符串使用前缀索引</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建</span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>对于like查询，”%”不要放在前面。</span></span></p></li></ul><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="text language-text" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">SELECT </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">FROMhoudunwangWHEREunameLIKE</span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">\'后盾%\'</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">--</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">走索引</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code class="text language-text" style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">SELECT </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">FROMhoudunwangWHEREunameLIKE</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"%后盾%"</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">--</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">不走索引</span></code></span></span></p></li></ol><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>查询where条件数据类型不匹配也无法使用索引</span></span></p></li></ul><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">字符串与数字比较不使用索引;</p><pre class="prettyprint linenums prettyprinted" style="background:rgb(241,239,238);color:rgb(80,97,109);font-size:10px;line-height:12px;font-family:consolas, menlo, courier, monospace, \'Microsoft Yahei\';border-width:1px;border-style:solid;border-color:rgb(226,226,226);"></pre><ol class="linenums list-paddingleft-2" style="list-style-type:none;"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">CREATE </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">TABLEa</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">achar</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">(</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">10</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">));</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">EXPLAIN SELECT </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="typ" style="color:rgb(64,126,231);line-height:20px;font-size:13px;">FROMaWHEREa</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="str" style="color:rgb(123,151,38);line-height:20px;font-size:13px;">"1"</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">–</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">走索引</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span><code style="margin-left:-20px;line-height:12px;border-width:0px;font-size:10px;font-family:inherit;"><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">EXPLAIN SELECT </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">*</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> FROM a WHERE a</span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">=</span><span class="lit" style="color:rgb(223,83,32);line-height:20px;font-size:13px;">1</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">–</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span><span class="pun" style="color:rgb(27,25,24);line-height:20px;font-size:13px;">不走索引</span><span class="pln" style="color:rgb(27,25,24);line-height:20px;font-size:13px;"> </span></code></span></span></p></li></ol><ul style="list-style-type:square;" class="list-paddingleft-2"><li><p><span style="color:rgb(74,74,74);font-size:14px;"><span>正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因</span></span></p><p><span style="color:rgb(74,74,74);font-size:14px;"><span></span></span></p></li></ul><h4 style="color:rgb(21,153,87);line-height:1.35;font-size:14px;font-family:Menlo, Monaco, \'Source Code Pro\', Consolas, Inconsolata, \'Ubuntu Mono\', \'DejaVu Sans Mono\', \'Courier New\', \'Droid Sans Mono\', \'Hiragino Sans GB\', \'微软雅黑\', monospace;">原文链接</h4><p style="color:rgb(80,97,109);font-family:Helvetica, Arial, sans-serif;font-size:15px;">https://blog.csdn.net/suifeng3051/article/details/52669644</p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;">-更多文章-</span><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247484551&amp;idx=1&amp;sn=d52692cfa3438e94a77f436c8bf1931d&amp;chksm=9bed25f5ac9aace336437bc590ff3a6672c7c848d0660512c6d615d26212234215df76a11b03&amp;scene=21#wechat_redirect" rel="nofollow">我必须得告诉大家的MySQL优化原理</a></span><em><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247484551&amp;idx=1&amp;sn=d52692cfa3438e94a77f436c8bf1931d&amp;chksm=9bed25f5ac9aace336437bc590ff3a6672c7c848d0660512c6d615d26212234215df76a11b03&amp;scene=21#wechat_redirect" rel="nofollow"></a><br></span></em></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485210&amp;idx=1&amp;sn=cf092ad002b617d1bd9da279cad42122&amp;chksm=9bed2668ac9aaf7e7805042cf38fa449d53e4df125652d3a1e0d0e319d30464cf13de80ad2a1&amp;scene=21#wechat_redirect" rel="nofollow">这 10 道 Spring Boot 常见面试题你需要了解下</a></span><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;"><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485203&amp;idx=1&amp;sn=56a66cc9fe8177749b07c2bb9b7449d0&amp;chksm=9bed2661ac9aaf77ca53fb718bb2c552608f58a4c49cdb34ca653a33fb8099bcdc70dec65373&amp;scene=21#wechat_redirect" rel="nofollow">最详细排序解析，七大排序横评（校正篇）</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);letter-spacing:.544px;font-size:13px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485170&amp;idx=1&amp;sn=58f62aa0b9a4c38b8aa9995923ec7ebf&amp;chksm=9bed2780ac9aae9695eaeb4de51b36a28d1f53583e777aae8ef0167c4f6064aef6f70d757ec9&amp;scene=21#wechat_redirect" rel="nofollow">缓存穿透，缓存击穿，缓存雪崩解决方案分析</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-关注我-</span></p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="font-size:14px;letter-spacing:1px;"><strong style="letter-spacing:.544px;"><span style="letter-spacing:1px;color:rgb(61,167,66);">看完了，帮我点个“好看”鸭</span></strong></span></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:1px;"><strong>点鸭点鸭</strong></span></p><p style="letter-spacing:.544px;font-size:13px;line-height:normal;text-align:right;"><span style="color:rgb(61,167,66);">↓↓↓↓</span></p>\n                </div>\n                                      </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83476131', 'title': '拨开云雾见天日：剖析单机事务原理', 'readNum': '14423', 'commentNum': '4', 'publishTime': '2019-02-27 14:54:08', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章<br>\n作者：CHEN川<br>\n链接：<a href="https://www.jianshu.com/p/2af078f4cc5d" rel="nofollow">https://www.jianshu.com/p/2af078f4cc5d</a></p>\n</blockquote>\n<p>江湖传说：不了解数据库事务的程序员不是一个好的DBA。阅遍网上无数关于数据库事务的文章，都感觉云里雾里，不知所云。于是乎拍案而起，麻蛋，还是自己写吧。最后便有了这篇文章，它试图用通俗的文字来说明单机事务的ACID特性及其大致的实现原理。</p>\n<h2><a id="_6"></a>一、什么是事务？</h2>\n<blockquote>\n<p>数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。—— 维基百科</p>\n</blockquote>\n<p>好吧，你没怎么看明白？对于应用程序来说，事务就是一系列对数据库的数据进行读或写的操作，在本文中，把一个读或者写操作称为事务单元。同一时刻，可能有多个应用程序同时向数据库发送读写请求，所以对于数据库管理系统（如：MySQL、Oracle等）来说，一个事务包含一系列事务单元。</p>\n<p>举个栗子，Bob向Smith转账100块这样一个动作，包含多个对数据库的读写操作，我们把这一系列操作称为一个事务，具体操作如下表所示。</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-c291c8f43d82d7b3.png?imageMogr2/auto-orient/" alt=""></p>\n<p>只要是对数据库的一个操作就是一个事务单元，事务单元也并非只有读写操作，建立索引、删除表等等都是事务单元，例如下面对数据库的操作都是事务单元。</p>\n<ul>\n<li>商品表要建立一个基于某列的索引</li>\n<li>从数据库读取一行记录</li>\n<li>想数据库中写入一行记录，同时更新这行记录</li>\n<li>删除整张表</li>\n<li>…</li>\n</ul>\n<h2><a id="Atomicity_25"></a>二、事务的原子性（Atomicity）</h2>\n<p>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p>\n<p>还是以Bob向Smith转账100块钱为例，整个事务包含如下操作：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-f9f00be4636d7879.png?imageMogr2/auto-orient/" alt=""></p>\n<p>A，B，C 3个操作，要么全部成功，要么全部失败。可以看到，如果能够保证这点，那么对于上层的应用程序就不再需要去做各种中间状态的维持工作，而只要关注业务逻辑即可。比如在C操作开始之前，发现Smith的账户被锁定了无法进行加款操作，那么数据库能够自动的将A和B两个操作进行回滚，从让上层的应用程序只关注具体的业务流程实现，而不需要关注事务本身的实现流程。</p>\n<h3><a id="21_36"></a>2.1、数据库如何实现原子性？</h3>\n<p>实现原子性的核心是要记录下每一个变更的中间状态或者是记录变更的具体过程。这样我们就可以在发现问题时，直接把老数据替换回去，从而实现回滚操作，保证原子性。</p>\n<p>以转账的实例进行细节分析，在执行A之前，数据库中的数据大概是这样（version1）：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-be7aefd2d13682e6.png?imageMogr2/auto-orient/" alt=""></p>\n<p>执行A操作：检查Bob账户是否有100块，执行的SQL：select money from T where pk=1，一个简单的查询操作并不涉及对数据的修改，因此不会记录变更数据。</p>\n<p>执行B操作：Bob账户减去100块，执行SQL：update T set money=money-100 where pk=1，执行完这个操作，数据库应该是这样（version2）</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-975917e0a13da4a4.png?imageMogr2/auto-orient/" alt=""></p>\n<p>注：除了当前运行事务的这个进程，其他的进程只要不是在读未提交状态，完全看不见这些中间状态</p>\n<p>接着执行C操作，突然发现Smith的账户出现未知异常，导致加款的操作无法进行，那么整个事务单元执行失败，需要回滚前面的操作，由于A操作不涉及数据的修改，因此只需要回滚B操作。要回滚B操作，就需要知道PK=1这一行在version1版本时的数据：money=100，在回滚时用version1版本的记录替换当前版本（version2）据即可。</p>\n<h3><a id="22_53"></a>2.2、那数据库是如何实现回滚的呢？</h3>\n<p>首先要明确的是回滚必须按照顺序进行，否则会出现不符合预期的情况。</p>\n<p>这个很容易理解，如果两条update语句按照不同的顺序执行，那么其结果肯定不一致，同理，如果回滚时，不按照执行顺序的反序执行，那么回滚的结果也肯定不一致。所以我们必须让回滚本身按照执行顺序的反序执行。一般而言，实现方式就是把数据按照顺序记录到文件里，然后将这个文件按照FILO（先入后出）的方式读取出来，这样可以保证按照执行序列的反序来回滚了。</p>\n<p>除了记录中间状态的数据外，回滚还要考虑的一个重要因素：并发。</p>\n<p>如果数据库系统将所有针对他的读写请求都按照顺序执行，那么完全不用考虑并发因素，回滚也可以很简单的实现。但系统需要更高效的利用CPU和各种物理资源，且很多数据在物理上就是需要被共享的。所以，处理并发和同步就成了一个数据库系统必须面对的实际问题。</p>\n<p>如果进行不恰当的并发处理，那么多线程执行回滚操作会导致最终数据出现错乱，比如A进程优先进行了两个操作并记录了回滚段，B进程紧接着进行了一个操作并记录了回滚段，这时候A进程要回滚，那么他用自己记录的回滚中间状态恢复了数据，然而B也要进行回滚，就会发现数据本身已经无法回滚到最初的状态去了。</p>\n<p>如果要切实的解决这个问题，我们只能把每个事务所影响的数据全部都加上锁，这样，在这个事务没有完成之前，其他进程不能进入到这些加锁的数据中对这个数据进行修改。从而保证了尽可能细颗粒度的并发控制，同时也解决了回滚中会出现的回滚时序冲突问题。</p>\n<p>当然这种方式的代价就是回滚隐含了对事务锁的要求，而事务只要加锁，就存在对加锁数据的读写请求，就需要等待，进而降低并发性能。</p>\n<h2><a id="Consistency_70"></a>三、事务的一致性(Consistency)</h2>\n<p>事务应确保数据库的状态从一个一致状态转变为另一个一致状态。</p>\n<p>怎么理解这句话？还是以转账的示例来说明，在整个转账的事务单元中，数据库中的数据有3个版本：<br>\nA操作(查询)后得到version1：Bob=100，Smith=0<br>\nundo日志：无</p>\n<p>B操作(减款)后得到version2：Bob=0，Smith=0<br>\nundo日志：Bob=100，Smith=0</p>\n<p>C操作(加款)后得到version3：Bob=0，Smith=100<br>\nundo日志：Bob=0，Smith=0</p>\n<p>其中version1是初始的一致状态，version3是最终的一致状态，version2为中间状态，一致性要保证的是应用程序只能看到初始的一致状态或者最终的一致状态，而不能看见中间状态。</p>\n<p>这里我们需要注意一致性和原子性的区别。</p>\n<p>原子性的语义只保证数据库记录了回滚段，如上面的undo日志，它可以保证在事务单元执行出现异常时，可根据回滚段(undo日志)回滚到之前的版本。</p>\n<p>而一致性则保证上层应用程序不看到中间状态，虽然原子性和一致性经常一起出现，但它们没有任何必然的联系。原子性只保证整个事务单元那么全部执行成功，要么全部执行失败。它不保证你看不到中间状态。我举个简单的栗子说明。</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-d46349d83a0bc315.png?imageMogr2/auto-orient/" alt=""></p>\n<p>现在请只考虑原子性的语义，线程1执行Bob向Smith转账100块，线程2执行向Smith账户加款200块。线程1和线程2同时执行到向Smith转账，线程2执行成功后，Smith账户有200块，这时如果线程1执行成功，那么Smith账户应该有300块，但遗憾的时，线程1的操作失败，那么线程1的事务必须回滚，根据上文的分析，这时候线程1的undo日志一定是Bob=100，Smith=0，回滚结束后，你会发现线程2给Smith加款的200块钱莫名其妙的消失了。出现这种情况是肯定不能接受，所以一致性就是为了防止这种情况。一致性保证线程2只能看到两种状态，即Bob=100,Smith=0或者Bob=0,Smith=100，而不会看到Bob=0,Smith=0这种状态，更不会在中间状态时就向Smith账户加款。</p>\n<p>那数据库是如何实现一致性呢？答案很简单，就是锁。</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-6f54d60e8dd321a9.png?imageMogr2/auto-orient/" alt=""></p>\n<p>线程1在执行Bob向Smith转账，同时线程2执行向Smith加款时，发现Smith账户已经被锁定，那么线程2等待，直到Smith账户解除锁定为止。</p>\n<h2><a id="Isolation_103"></a>四、事务的隔离性（Isolation）</h2>\n<p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>\n<p>简单的理解就是一个事务内部的操作以及正在操作的数据必须封锁起来，不被其他企图修改这些数据的事务看到。那么如何保证事物的隔离性？就如同上面保持一致性所讲的那样，只需要在每个事务执行之前加一把排他锁，事务执行结束后释放锁，然后再执行下一个事务，直到执行完成所有的事务单元即可，就如同这样：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-85b2687023fc6265.png?imageMogr2/auto-orient/" alt=""></p>\n<p>将所有的事务排队，利用排他锁的方式，将事务锁住，单位时间内，只有一个事务进来，这就是事务隔离级别中的可序列化（Serializable）级别。</p>\n<p>可序列化级别是事务的最高隔离级别，它强制事务排序，使事务间不可能相互冲突。但很明显的，这种方式有一个很严重的问题：并行度太低，导致性能非常差。性能太差就意味着大多数情况下不可用，就需要想办法提高性能。</p>\n<p>通过仔细分析，我们可以发现最核心的问题就是一把大锁堵住了所有的请求。一种行之有效的方法就是利用锁分离 + 读写锁来提升并行度。</p>\n<p>锁分离是指使用多个锁来控制没有冲突的事务，每个事务都有自己的锁，这样就可以让没有冲突的事务并行的执行。请看下面的小例子：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-7e27c7ca67ad4ddb.png?imageMogr2/auto-orient/" alt=""></p>\n<p>有三个事务，事务1为Bob向Smith转账，涉及3个数据库操作、事务2为查询Joe账户余额，只有一个读操作、事务3为Jack向LILei转账。如果事务的隔离级别为可序列化级别，那么事务的执行顺序应该是这样的：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-1c7fdaa32f6d95fb.png?imageMogr2/auto-orient/" alt=""></p>\n<p>但很明显，三个事务之间完全没有冲突，使用锁分离技术后，他们的执行顺序就变成了这样：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-72858ee03be74c2a.png?imageMogr2/auto-orient/" alt=""></p>\n<p>采用锁分离技术可以提高并行度，但我还想要再提高速度呢？我们可以把控制事务的锁拆分成读写锁。使用读写锁后，事务内部的所有读操作都可以并行，就如同这样：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-1c8a00fc8dcc5c61.png?imageMogr2/auto-orient/" alt=""></p>\n<p>这就是事务隔离级别中的可重复读（Repeatable Read）级别。可重复读级别在序列化级别上的基础上，让两个读操作可以并行执行，提高并行度。可重复读保证了同一个事务里，所有读操作的结果都是事务开始时的状态（一致性）。但是，由于当前的事务（A事务）对已经存在的行加读或写锁，不能阻止另一个事务（B事务）插入新数据，所以当A事务再次查询时可能会查出更多的结果，这就是幻读现象。</p>\n<p>举一个非常简单的例子，在工资表中，事务A第一次查询所有工资为2000的用户，结果有10人，但同一时刻事务B新增了若干条工资数据，导致事务A再次查询工资为2000的用户时，结果变成了15人，这就是幻读。</p>\n<p>可重复读只能做到读读并行，并不能完美的提升性能，这个时候就产生了另外一个事务隔离级别读已提交（Read Commited）。”读已提交“与”可重复读“的区别就在于读锁能不能被写锁升级。</p>\n<p>怎样理解这句话？</p>\n<p>数据库对当前的读操作加锁，这时来了一个写操作，我们要不要放写操作进来呢？如果不放，那么只能读读并行，就是可重复读的隔离级别。如果放进来，新的写请求会将原来的读锁升级为写锁，这样除了读读可并行，读写也可并行，进一步提升了并行度，原来的读读并行就变成了这个样子：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-d7223a907926c724.png?imageMogr2/auto-orient/" alt=""></p>\n<p>当然性能的提高，肯定是要付出代价的，读已提交的事务隔离级别除了可能会出现“幻读”的情况，还会出现“不可重复读”。</p>\n<p>一个事务执行一个查询，读取了大量的数据行。由于读锁可以被写锁升级，所以在它结束读取之前，另一个事务可能完成了对数据行的更改。当第一个事务试图再次执行同一个查询，服务器就会返回不同的结果，这就是“不可重复读”。</p>\n<p>还是举一个非常简单的例子，比如事务A是Bob向Smith转账100块，事务B是向Bob收取管理费10块。事务A在检查Bob是否有100块时，查询后发现有100，同一时刻，事务B发起扣手续费的操作，当事务B达到时，发现数据被事务A的读锁锁住的，由于事务的隔离级别是“读已提交”，读锁直接被升级，B事务顺利扣款10块，Bob账户还剩90块，B事务结束后，A事务再进行转账操作时就会发现余额已经不够100了。</p>\n<p>既然读锁可以被写锁升级，那如果干脆不要读锁呢？这样的话读读、读写、写读都可以并行，只有写写还是串行，这样又可以更进一步提升并行度，就如同这样：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-c90d7f6d8af91634.png?imageMogr2/auto-orient/" alt=""></p>\n<p>这就是4种事务隔离级别的最后一种：读未提交（Read Uncommitted），隔离级别最低，同时也是并行度最高、性能最好的隔离级别。当然也存在很大的问题，就是“脏读”。所谓“脏读”就是事务A修改了一行，另一个事务B也可以读到该行。如果第一个事务A执行了回滚，那么事务B读取的就是从来没有正式出现过的值，也就是前面提到的读取到中间状态数据，这肯定是不能够接受的，所以大部分情况都不应该使用这个隔离级别。</p>\n<p>最后做个小结，回顾这4种隔离级别，我们可以看到隔离级别越高，性能越差，越能保持一致性；隔离级别越低，性能越好，对一致性的破坏也就更彻底，出现的问题也就越多。所以我们可以用一句话来总结：事务的隔离性就是以性能为理由，对强一致性的破坏。</p>\n<p>大多数数据库的默认事务隔离级别是“读已提交”，MySQL的默认事务隔离级别是“可重复读”。像“可重复读”这种事务隔离级别并发性能是非常低的，那MySQL又是如何在“可重复读”的隔离级别下达到很高的性能的？答案请参考第六部分。</p>\n<h2><a id="Durability_161"></a>五、事务的持久性（Durability）</h2>\n<p>终于说到ACID的最后一个字母了，所谓事务的持久性就是指：</p>\n<p>已被提交的事务对数据库的修改应该永久保存在数据库中</p>\n<p>也就是说：如果一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p>\n<p>其实在很多数据库系统中，由于性能的原因，事务操作时，并不是数据每次被修改后立即被写入磁盘，而是采用异步刷盘的模式。持久性就是为了保证这些在缓存中的数据，在故障（硬件损坏或者断电等）恢复后，仍然能够正确的写入磁盘。</p>\n<p>这里就存在两种情况，如果在事务提交之前发生故障，那么缓存的数据丢失，修改的信息也就丢失了，数据库只能根据日志做回滚。如果在事务提交之后发生故障，即使缓存中的数据丢失，仍然可以根据日志将事务单元继续提交，整个事务仍然是成功的，不会导致任何数据丢失。当然这里日志的持久化又是另外一个话题了，简单的说，就是在对数据库更新时，一定要保证日志已经写入磁盘，如果日志没有写入磁盘，故障发生后，数据只能丢失。</p>\n<p>所以持久化的语义更多的体现在数据库发生故障时，确保提交的事务不丢失。</p>\n<h2><a id="MVCC_176"></a>六、MVCC</h2>\n<p>在前文已经说到，读未提交级别下会出现脏读，而在可序列化隔离级别下，事务只能串行执行，性能太低。大多数情况下，这两个事务隔离级别都是不能接受的，一般情况下会在可重复读与读已提交两个隔离级别下对系统性能进行优化。</p>\n<p>其中可重复读可以做到读读并行，读已提交写锁可以将读锁升级。在这两个事务隔离级别下，如果当前事务正在写，那么其他所有的读都将被阻塞（这里的读写事务是针对相同的资源，或者说是针对数据库的同一行数据），所以优化的点也在这里，有没有办法让写不阻塞读呢？这样的话，可以大大提升数据库读的性能，尤其是在读多写少的场景下，这样的性能优化尤其重要。</p>\n<p>MVCC（多版本并发控制）模型为解决这个问题提供了思路。数据库为了支持事务，在每个写事务（更新数据）时，都会记录undo log以便在事务执行出现异常时可以回滚到事务初始的状态，就如同这样：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-ba4e96bc9fc82722.png?imageMogr2/auto-orient/" alt=""></p>\n<p>事务A为Bob向Smith转账的操作，假设目前数据正在进行事务A，这时候正好来了一个读事务B，传统情况下，读事务B是需要在此等待的，直到事务A执行完成，就如同这样：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-75c794f7d57e81c9.png?imageMogr2/auto-orient/" alt=""></p>\n<p>在MVCC模型下，每行数据具有多个版本，假设事务A下数据的当前版本为版本1，那么这一时刻其回滚段中对应的数据版本为版本0，当事务B到达时，发现事务A为写事务，且数据当前版本为版本1，那么事务B自动到回滚段中读取版本为版本0的数据，版本0的数据也称为快照数据，就如同下图这样。</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-0c340e3fd0651479.png?imageMogr2/auto-orient/" alt=""></p>\n<p>如上示例，事务A正在转账，整个转账的过账中Bob和Smith账户数据有3个版本，其对应回滚段中的数据有两个版本，所以事务B读到的数据始终是初始状态的值，也就是回滚段中version2的数据，其对应的是事务A中version1的数据。</p>\n<p>这里请大家考虑一个问题，假如现在有两个同样的A事务：A1、A2，还有一个事务B，这3个事务几乎同时达到，那么B事务是应该读取A1之前的数据，还是读取A2之前的数据呢？这里引申出来的问题就是：一个读请求应该读哪一个写之后的数据？</p>\n<p>不同的数据库有不同的实现方式，但是大致的原理都是在系统内部维护一个逻辑时间戳，比如：根据时间先后顺序在内部维持一个全局的自增号，每来一个请求加1，利用这个自增号来维持先后顺序，比如Oracle中的SCN，Innodb中的Trx_id（事务ID）。这样就可以确定读事务应该读取那个版本的快照数据。</p>\n<p>不同的数据库，实现MVCC的方式不同，甚至是同一数据库，不同隔离级别下的实现方式也不同。比如MySQL的InnoDB存储引擎下，在读已提交（READ COMMITTED）事务隔离级别下，总是读取被锁定行的最新一份快照数据。而在可重复读（REPEATABLE READ）事务隔离级别下，总是读取事务开始时的行数据版本。这两者之间的不同，请看下图：</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-fa6ea42eff981451.png?imageMogr2/auto-orient/" alt=""></p>\n<p>数据表Table在事务AB开始之前查询id=1的这行数据的结果是amount=1</p>\n<blockquote>\n<p>时刻1：开始AB事务<br>\n时刻2：事务B更新amount的值为3，同一时刻A事务并未结束<br>\n时刻3：事务A再次查询，读取事务B开始之前的数据，在两种隔离级别下amount均为1<br>\n时刻4：事务B提交，同一时刻A事务并未结束<br>\n时刻5：事务A再次查询，在读已提交事务隔离级别下，读取被锁定行的最新一份快照数据即amount=3，在可重复读事务隔离级别下，总是读取事务开始时的行数据即amout=1</p>\n</blockquote>\n<p>还有一点需要说明的是在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>\n<p>那哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p>\n<p>快照读：简单的select操作，属于快照读，不加锁：</p>\n<pre><code>select * from table where A=?;\n</code></pre>\n<p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p>\n<pre><code>select * from table where A=? lock in share mode;\nselect * from table where A=? for update;\ninsert into table values (…);\nupdate table set A=? where B=?;\ndelete from table where A=?;\n</code></pre>\n<p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p>\n<p>说明：关于MVCC，我想写的也就这么多，也就一些最基本的原理，其实网上关于MVCC的介绍不是很多，而已有的大多数文章分析也不是很透彻，总感觉云里雾里的，也希望可以看到更多深入浅出介绍MVCC的文章或者书籍，大家也可以留言推荐给我。</p>\n<h2><a id="_237"></a>七、反思</h2>\n<p>写了这么多，总结起来，什么是事务？</p>\n<p>事务的核心是锁和并发</p>\n<p>怎么优化事务？</p>\n<p>在锁和并发之间找到一个平衡值</p>\n<p>你觉得这句话太抽象了？那换种方式，在优化事务时，你可以尽量减少锁的覆盖范围，比如：MyISAM使用表锁，它的锁范围就大于Innodb的行锁，所以如果写多读少且需要支持事务的话，请使用Innodb存储引擎，如果读多写少的话，可以使用MyISAM存储引擎。当然现在大部分数据库都参考MVCC模型来实现以提高并发性能，但是仍然需要设置合理的事务隔离级别。</p>\n<p>除了这个你还可以增加锁上可并行的线程数，将读写锁分离，并行读取数据。具体实现也就是尽量把大事务拆分成小事务，这样在缩小锁范围同时，可以将读写锁分离开，何乐而不为呢？最后还要使用正确的锁类型，比如：悲观锁就适合并发争抢比较严重场景，而乐观锁则适合并发争抢不太严重场景。</p>\n<p>还有就是MVCC实现的核心思路就是：无锁编程 + copy on write，本质就是能够做到写不阻塞读。</p>\n<p>最后一句话：容易理解的模型性，实现简单，但性能都不好，性能好的模型都不容易理解，且实现困难。</p>\n<h3><a id="_256"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<p>作者：CHEN川<br>\n链接：<a href="https://www.jianshu.com/p/2af078f4cc5d" rel="nofollow">https://www.jianshu.com/p/2af078f4cc5d</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83896098', 'title': 'FeignClient源码深度解析', 'readNum': '19142', 'commentNum': '0', 'publishTime': '2019-02-27 14:53:49', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文转载于微信公众号：吉姆餐厅ak</p>\n\n<p>学习更多源码知识，欢迎关注。 全文共16984字左右。</p>\n</blockquote>\n\n<hr><h2>概述</h2>\n\n<blockquote>\n<p>springCloud feign主要对netflix feign进行了增强和包装，本篇从源码角度带你过一遍装配流程，揭开feign底层的神秘面纱。 主要包括feign整合ribbon，hystrix，sleuth，以及生成的代理类最终注入到spring容器的过程。篇幅略长，耐心读完，相信你会有所收获。</p>\n</blockquote>\n\n<hr><h2>Feign架构图</h2>\n\n<p>一些核心类及大致流程：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/201811131034307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p><strong>大体步骤：</strong>\xa0<strong>一、注册FeignClient配置类和FeignClient BeanDefinition 二、实例化Feign上下文对象FeignContext 三、创建 Feign.builder 对象 四、生成负载均衡代理类 五、生成默认代理类 六、注入到spring容器</strong></p>\n\n<hr><h2>源码分析</h2>\n\n<p>主要围绕上面6个步骤详细分析。</p>\n\n<hr><h3>一、注册FeignClient配置类和FeignClient BeanDefinition</h3>\n\n<p>从启动类注解开始，来看下\xa0<code>@EnableFeignClients</code>注解：</p>\n\n<ol><li>\n\t<p><code>@EnableFeignClients</code></p>\n\t</li>\n\t<li>\n\t<p><code>public class MyApplication {</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p>这是在启动类开启feign装配的注解，跟进该注解，看看做了什么：</p>\n\n<ol><li>\n\t<p><code>@Import(FeignClientsRegistrar.class)</code></p>\n\t</li>\n\t<li>\n\t<p><code>public class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ResourceLoaderAware, BeanClassLoaderAware {</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0// patterned after Spring Integration IntegrationComponentScanRegistrar</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0// and RibbonClientsConfigurationRegistgrar</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private final Logger logger = LoggerFactory.getLogger(FeignClientsRegistrar.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private ResourceLoader resourceLoader;</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private ClassLoader classLoader;</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public FeignClientsRegistrar() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public void setResourceLoader(ResourceLoader resourceLoader) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0this.resourceLoader = resourceLoader;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public void setBeanClassLoader(ClassLoader classLoader) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0this.classLoader = classLoader;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public void registerBeanDefinitions(AnnotationMetadata metadata,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0BeanDefinitionRegistry registry) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//1、先注册默认配置</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0registerDefaultConfiguration(metadata, registry);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//2、注册所有的feignClient beanDefinition</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0registerFeignClients(metadata, registry);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0//...</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p><strong>我们分别来看一下上面\xa0<code>registerBeanDefinitions</code>中的两个方法：</strong>\xa01） 注册默认配置方法：\xa0<code>registerDefaultConfiguration</code></p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0private void registerDefaultConfiguration(AnnotationMetadata metadata,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0BeanDefinitionRegistry registry) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Map&lt;String, Object&gt; defaultAttrs = metadata</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.getAnnotationAttributes(EnableFeignClients.class.getName(), true);</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (defaultAttrs != null &amp;&amp; defaultAttrs.containsKey("defaultConfiguration")) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0String name;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (metadata.hasEnclosingClass()) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0name = "default." + metadata.getEnclosingClassName();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0else {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0name = "default." + metadata.getClassName();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0// name 默认以 default 开头，后续会根据名称选择配置</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0registerClientConfiguration(registry, name,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0defaultAttrs.get("defaultConfiguration"));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>上述方法为读取启动类上面\xa0<code>@EnableFeignClients</code>注解中声明feign相关配置类，默认name为default，一般情况下无需配置。用默认的\xa0<code>FeignAutoConfiguration</code>即可。 上面有个比较重要的方法：注册配置\xa0<code>registerClientConfiguration</code>，启动流程一共有两处读取feign的配置类，这是第一处。根据该方法看一下</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0Object configuration) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0BeanDefinitionBuilder builder = BeanDefinitionBuilder</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.genericBeanDefinition(FeignClientSpecification.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0builder.addConstructorArgValue(name);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0builder.addConstructorArgValue(configuration);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0registry.registerBeanDefinition(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0name + "." + FeignClientSpecification.class.getSimpleName(),</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.getBeanDefinition());</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>上面将bean配置类包装成\xa0<code>FeignClientSpecification</code>，注入到容器。该对象非常重要，包含FeignClient需要的重试策略，超时策略，日志等配置，如果某个服务没有设置，则读取默认的配置。</p>\n\n<p>2、扫描FeignClient</p>\n\n<p>该方法主要是扫描类路径，对所有的FeignClient生成对应的\xa0<code>BeanDefinitio</code></p>\n\n<ol><li>\n\t<p><code>public void registerFeignClients(AnnotationMetadata metadata,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0BeanDefinitionRegistry registry) {</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//...</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//获取扫描目录下面所有的bean deanDefinition</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0for (String basePackage : basePackages) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0Set&lt;BeanDefinition&gt; candidateComponents = scanner</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.findCandidateComponents(basePackage);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0for (BeanDefinition candidateComponent : candidateComponents) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (candidateComponent instanceof AnnotatedBeanDefinition) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// verify annotated class is an interface</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Assert.isTrue(annotationMetadata.isInterface(),</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0"@FeignClient can only be specified on an interface");</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Map&lt;String, Object&gt; attributes = annotationMetadata</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.getAnnotationAttributes(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FeignClient.class.getCanonicalName());</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0String name = getClientName(attributes);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0//这里是第二处</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0registerClientConfiguration(registry, name,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0attributes.get("configuration"));</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0//注册feignClient</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0registerFeignClient(registry, annotationMetadata, attributes);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p><strong>可以看到上面又调用了\xa0<code>registerClientConfiguration</code>注册配置的方法，这里是第二处调用。这里主要是将扫描的目录下，每个项目的配置类加载的容器当中。</strong>\xa0注册到容器中，什么时候会用到呢？具体又如何使用呢？别着急，后面会有介绍。</p>\n\n<p>我们先会回到继续主流程，继续看注册feignClient的方法，跟进\xa0<code>registerFeignClient</code>：</p>\n\n<ol><li>\n\t<p><code>private void registerFeignClient(BeanDefinitionRegistry registry,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0String className = annotationMetadata.getClassName();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//声明代理类名称</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0BeanDefinitionBuilder definition = BeanDefinitionBuilder</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.genericBeanDefinition(FeignClientFactoryBean.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//logger.info("TEX do some replacement");</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0//attributes.put("value", ((String)attributes.get("value")).replace(\'_\',\'-\'));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0validate(attributes);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.addPropertyValue("url", getUrl(attributes));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.addPropertyValue("path", getPath(attributes));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0String name = getName(attributes);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.addPropertyValue("name", name);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.addPropertyValue("type", className);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.addPropertyValue("decode404", attributes.get("decode404"));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.addPropertyValue("fallback", attributes.get("fallback"));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0String alias = name + "FeignClient";</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0beanDefinition.setPrimary(true);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0new String[] { alias });</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//将bean definition加入到spring容器</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>划重点，上面出现了一行相当关键代码</p>\n\n<ol><li>\n\t<p><code>BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class);</code></p>\n\t</li>\n</ol><p>springCloud FeignClient其实是利用了spring的代理工厂来生成代理类，所以这里将所有的\xa0<code>feignClient</code>的描述信息\xa0<code>BeanDefinition</code>设定为\xa0<code>FeignClientFactoryBean</code>类型，该类又继承\xa0<code>FactoryBean</code>,很明显，这是一个代理类。 在spring中，\xa0<code>FactoryBean</code>是一个工厂bean，用作创建代理bean，所以得出结论，feign将所有的feignClient bean包装成\xa0<code>FeignClientFactoryBean</code>。扫描方法到此结束。</p>\n\n<p><strong>代理类什么时候会触发生成呢？ 在spring刷新容器时，当实例化我们的业务service时，如果发现注册了FeignClient，spring就会去实例化该FeignClient，同时会进行判断是否是代理bean，如果为代理bean，则调用\xa0<code>FeignClientFactoryBean</code>的\xa0<code>T getObject() throws Exception;</code>方法生成代理bean。</strong></p>\n\n<hr><h3>先来隆重介绍一下\xa0<code>FeignClientFactoryBean</code>，后面四步都基于此类。</h3>\n\n<p>先看一下代理feignClient代理生成入口：\xa0<code>getObject</code>方法</p>\n\n<ol><li>\n\t<p><code>@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public Object getObject() throws Exception {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0// 二、实例化Feign上下文对象FeignContext</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0FeignContext context = applicationContext.getBean(FeignContext.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0// 三、生成builder对象，用来生成feign</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Feign.Builder builder = feign(context);</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0// 判断生成的代理对象类型，如果url为空，则走负载均衡，生成有负载均衡功能的代理类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (!StringUtils.hasText(this.url)) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0String url;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (!this.name.startsWith("http")) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0url = "http://" + this.name;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0else {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0url = this.name;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0url += cleanPath();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0// 四、生成负载均衡代理类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0return loadBalance(builder, context, new HardCodedTarget&lt;&gt;(this.type,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.name, url));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//如果指定了url，则生成默认的代理类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (StringUtils.hasText(this.url) &amp;&amp; !this.url.startsWith("http")) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.url = "http://" + this.url;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0String url = this.url + cleanPath();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0// 五、生成默认代理类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return targeter.target(this, builder, context, new HardCodedTarget&lt;&gt;(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.type, this.name, url));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p><code>getObject()</code>逻辑比较多，每一行都会做一些初始化配置，来逐步分析。</p>\n\n<h3>二、实例化Feign上下文对象FeignContext</h3>\n\n<p>上述方法中第一行便是实例化\xa0<code>FeignContext</code>：</p>\n\n<ol><li>\n\t<p><code>FeignContext context = applicationContext.getBean(FeignContext.class);</code></p>\n\t</li>\n</ol><p>获取\xa0<code>FeignContext</code>对象，如果没有实例化，则主动实例化，如下：</p>\n\n<ol><li>\n\t<p><code>@Configuration</code></p>\n\t</li>\n\t<li>\n\t<p><code>@ConditionalOnClass(Feign.class)</code></p>\n\t</li>\n\t<li>\n\t<p><code>public class FeignAutoConfiguration {</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Autowired(required = false)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private List&lt;FeignClientSpecification&gt; configurations = new ArrayList&lt;&gt;();</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Bean</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public HasFeatures feignFeature() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return HasFeatures.namedFeature("Feign", Feign.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Bean</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public FeignContext feignContext() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0FeignContext context = new FeignContext();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//将feign的配置类设置到feign的容器当中</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0context.setConfigurations(this.configurations);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return context;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p>可以看到feign的配置类设置到feign的容器当中，而集合中的元素 正是上面我们提到的两处调用\xa0<code>registerClientConfiguration</code>方法添加进去的，前后呼应。</p>\n\n<p>然而，当我们引入了\xa0<code>sleuth</code>之后，获取的\xa0<code>feignContext</code>确是\xa0<code>TraceFeignClientAutoConfiguration</code>中配置的实例\xa0<code>sleuthFeignContext</code>:</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113103526330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>可以看到上面创建了一个\xa0<code>TraceFeignContext</code>实例，因为该对象继承\xa0<code>FeignContext</code>，同时又加了\xa0<code>@Primary</code>注解，所以在上面第2步中通过类型获取:\xa0<code>applicationContext.getBean(FeignContext.class);</code>，最终拿到的是\xa0<code>TraceFeignContext</code>。</p>\n\n<hr><h3>三、构造\xa0<code>FeignBuilder</code></h3>\n\n<p>继续跟进该方法：</p>\n\n<p><code>Feign.Builder builder = feign(context);</code></p>\n\n<ol><li>\n\t<p><code>protected Feign.Builder feign(FeignContext context) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Logger logger = getOptional(context, Logger.class);</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (logger == null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0logger = new Slf4jLogger(this.type);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0// 1、构造 Feign.Builder</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Feign.Builder builder = get(context, Feign.Builder.class)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// required values</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.logger(logger)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.encoder(get(context, Encoder.class))</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.decoder(get(context, Decoder.class))</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.contract(get(context, Contract.class));</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0// 2、设置重试策略，log等组件</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 //设置log级别</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Logger.Level level = getOptional(context, Logger.Level.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (level != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.logLevel(level);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//设置重试策略</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Retryer retryer = getOptional(context, Retryer.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (retryer != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.retryer(retryer);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//feign的错误code解析接口</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (errorDecoder != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.errorDecoder(errorDecoder);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//超时时间设置，连接超时时间：connectTimeout默认10s，请求请求超时时间：readTimeout默认60s</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Request.Options options = getOptional(context, Request.Options.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (options != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.options(options);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//拦截器设置，可以看出拦截器也是可以针对单独的feignClient设置</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Map&lt;String, RequestInterceptor&gt; requestInterceptors = context.getInstances(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.name, RequestInterceptor.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (requestInterceptors != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.requestInterceptors(requestInterceptors.values());</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (decode404) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.decode404();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return builder;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>上述代码有两处逻辑，分别来看：</p>\n\n<p>1、\xa0<code>Feign.Builder builder = get(context, Feign.Builder.class)</code>\xa0，又会有以下三种情况：</p>\n\n<p>1）单独使用Feign，没有引入\xa0<code>sleuth</code>、\xa0<code>hystrix</code>： 通过加载FeignClientsConfiguration的配置创建\xa0<code>Feign</code>的静态内部类：\xa0<code>Feign.Builder</code></p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0@Bean</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Scope("prototype")</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@ConditionalOnMissingBean</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public Feign.Builder feignBuilder(Retryer retryer) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return Feign.builder().retryer(retryer);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>2）引入了\xa0<code>hystrix</code>,没有引入\xa0<code>sleuth</code>: 通过加载\xa0<code>FeignClientsConfiguration</code>的配置创建\xa0<code>HystrixFeign</code>的静态内部类：\xa0<code>HystrixFeign.Builder</code></p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0@Configuration</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@ConditionalOnClass({ HystrixCommand.class, HystrixFeign.class })</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0protected static class HystrixFeignConfiguration {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0@Bean</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0@Scope("prototype")</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0@ConditionalOnMissingBean</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0@ConditionalOnProperty(name = "feign.hystrix.enabled", matchIfMissing = false)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0public Feign.Builder feignHystrixBuilder() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0return HystrixFeign.builder();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>3）同时引入\xa0<code>hystrix</code>\xa0和\xa0<code>sleuth</code>: 加载\xa0<code>TraceFeignClientAutoConfiguration</code>的配置创建：\xa0<code>HystrixFeign.Builder</code>：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113103550293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>注意：</p>\n\n<ul><li>\n\t<p><code>TraceFeignClientAutoConfiguration</code>的配置类加载一定是在\xa0<code>FeignClientsConfiguration</code>之前（先加载先生效），而\xa0<code>FeignClientsConfiguration</code>加载是通过\xa0<code>FeignAutoConfiguration</code>完成的，所以上图中引入了条件注解：</p>\n\n\t<ol><li>\n\t\t<p><code>@AutoConfigureBefore({FeignAutoConfiguration.class})</code></p>\n\t\t</li>\n\t</ol></li>\n\t<li>\n\t<p>创建创建的\xa0<code>builder</code>对象和第二种情况一下，只是做了一层包装</p>\n\t</li>\n</ul><ol><li>\n\t<p><code>final class SleuthFeignBuilder {</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private SleuthFeignBuilder() {}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0static Feign.Builder builder(Tracer tracer, HttpTraceKeysInjector keysInjector) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return HystrixFeign.builder()</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0//各组件`client，retryer，decoder`进行增强，装饰器模式。</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.client(new TraceFeignClient(tracer, keysInjector))</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.retryer(new TraceFeignRetryer(tracer))</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.decoder(new TraceFeignDecoder(tracer))</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.errorDecoder(new TraceFeignErrorDecoder(tracer));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p>2、设置重试策略，log等组件 Feign.builder在获取之后又分别指定了重试策略，日志级别，错误代码code等，在上一步中调用\xa0<code>SleuthFeignBuilder.build()</code>时已经设置过默认值了，这里为什么要重复设置呢？</p>\n\n<p>我们跟进去get()方法，一探究竟：</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0protected &lt;T&gt; T get(FeignContext context, Class&lt;T&gt; type) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//根据name，也就是服务名称来生成builder</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0T instance = context.getInstance(this.name, type);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (instance == null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0throw new IllegalStateException("No bean found of type " + type + " for "</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0+ this.name);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return instance;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public &lt;T&gt; T getInstance(String name, Class&lt;T&gt; type) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//这里获取AnnotationConfigApplicationContext容器</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0AnnotationConfigApplicationContext context = getContext(name);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0type).length &gt; 0) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0return context.getBean(type);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return null;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = new ConcurrentHashMap&lt;&gt;();</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0protected AnnotationConfigApplicationContext getContext(String name) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (!this.contexts.containsKey(name)) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0synchronized (this.contexts) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (!this.contexts.containsKey(name)) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0//这里创建容器createContext(name)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.contexts.put(name, createContext(name));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return this.contexts.get(name);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>重点来了，上述代码将FeignContext做了缓存，每个服务对应一个FeignContext，服务名作为key。 继续跟进\xa0<code>createContext(name)</code>方法：</p>\n\n<ol><li>\n\t<p><code>protected AnnotationConfigApplicationContext createContext(String name) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//注意：这里的容器并不是spring的容器，而是每次都重新创建一个</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//加载每个服务对应的配置类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (this.configurations.containsKey(name)) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0for (Class&lt;?&gt; configuration : this.configurations.get(name)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0.getConfiguration()) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0context.register(configuration);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//加载启动类@EnableFeignClients注解指定的配置类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0for (Map.Entry&lt;String, C&gt; entry : this.configurations.entrySet()) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (entry.getKey().startsWith("default.")) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0for (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0context.register(configuration);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//注册默认的配置类：FeignClientsConfiguration</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0context.register(PropertyPlaceholderAutoConfiguration.class,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.defaultConfigType);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0context.getEnvironment().getPropertySources().addFirst(new MapPropertySource(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.propertySourceName,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Collections.&lt;String, Object&gt; singletonMap(this.propertyName, name)));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (this.parent != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0// Uses Environment from parent as well as beans</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0context.setParent(this.parent);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//刷新容器</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0context.refresh();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return context;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>可以看到上述AnnotationConfigApplicationContext容器并非spring容器，只是利用了spring刷新容器的方法来实例化配置类，以服务名作为key，配置隔离。</p>\n\n<p><strong>重点来了，上面加载配置的顺序为：先加载每个服务的配置类，然后加载启动类注解上的配置类，最后加载默认的配置类。这样做有什么好处？ spring刷新容器的方法也是对所有的bean进行了缓存，如果已经创建，则不再实例化。所以优先选取每个FeignClient的配置类，最后默认的配置类兜底。</strong></p>\n\n<p>所以这也证明了\xa0<code>sleuth</code>的配置一定在\xa0<code>feign</code>的配置类之前加载。 至此，\xa0<code>FeignBuilder</code>构造流程结束。</p>\n\n<hr><h3>四、生成负载均衡代理类</h3>\n\n<p>再贴一下生成代理类的入口：</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//判断url是否为空 </code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (!StringUtils.hasText(this.url)) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0//......</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0return loadBalance(builder, context, new HardCodedTarget&lt;&gt;(this.type,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.name, url));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//......</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return targeter.target(this, builder, context, new HardCodedTarget&lt;&gt;(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.type, this.name, url));</code></p>\n\t</li>\n</ol><p>这里有个重要判断：判断FeignClient声明的url是否为空，来判断具体要生成的代理类。如下： 这么做有什么意义？ 1）如果为空，则默认走Ribbon代理，也就是这个入口，会有加载ribbon的处理。\xa0<code>@FeignClient("MyFeignClient")</code>\xa02）如果不为空，指定url，则走默认生成代理类的方式，也就是所谓的硬编码。\xa0<code>@FeignClient(value = "MyFeignClient",url = "http://localhost:8081")</code>\xa0这样处理方便开发人员进行测试，无需关注注册中心，直接http调用，是个不错的开发小技巧。</p>\n\n<blockquote>\n<p>生产环境也可以用上述第二种方式，指定域名的方式。</p>\n</blockquote>\n\n<p>我们跟进\xa0<code>loadBalance</code>方法：</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0HardCodedTarget&lt;T&gt; target) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//获得FeignClient</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Client client = getOptional(context, Client.class);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (client != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0builder.client(client);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0return targeter.target(this, builder, context, target);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0throw new IllegalStateException(</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-ribbon?");</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p><code>Client client = getOptional(context, Client.class);</code>这里会从\xa0<code>FeignContext</code>上下文中获取\xa0<code>Client</code>对象，该对象有三种实例，具体是哪个实现呢？\xa0</p>\n\n<p><img alt="" class="has" height="127" src="https://img-blog.csdnimg.cn/20181113103717327.png" width="701"></p>\n\n<p>\xa0</p>\n\n<p>这里又会有三种情况： 1）没有整合\xa0<code>ribbon</code>、\xa0<code>sleuth</code>： 获取默认的\xa0<code>Client</code>：\xa0<code>Default</code>实例。</p>\n\n<p>2）整合了\xa0<code>ribbon</code>,没有整合\xa0<code>sleuth</code>: 获取\xa0<code>LoadBalanceFeignClient</code>实例。</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113103729803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>3）整合了\xa0<code>ribbon</code>\xa0和\xa0<code>sleuth</code>: 会获取\xa0<code>TraceFeignClient</code>实例，该实例是对\xa0<code>LoadBalanceFeignClient</code>的一种包装，实现方式通过\xa0<code>BeanPostProcessor</code>实现：\xa0<code>FeignBeanPostProcessor</code>中定义了包装逻辑：</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public Object postProcessBeforeInitialization(Object bean, String beanName)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0throws BeansException {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return this.traceFeignObjectWrapper.wrap(bean);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>通过\xa0<code>wrap</code>方法最终返回\xa0<code>TraceFeignClient</code>实例。</p>\n\n<p>继续回到主流程，先来看下\xa0<code>Targeter</code>接口：</p>\n\n<ol><li>\n\t<p><code>interface Targeter {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0&lt;T&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0HardCodedTarget&lt;T&gt; target);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>该对象定义在\xa0<code>FeignClientFactoryBean</code>静静态代码块中：</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0private static final Targeter targeter;</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0static {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Targeter targeterToUse;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0//判断类路径是否引入了hystrixFeign</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (ClassUtils.isPresent("feign.hystrix.HystrixFeign",</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FeignClientFactoryBean.class.getClassLoader())) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0targeterToUse = new HystrixTargeter();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0else {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0targeterToUse = new DefaultTargeter();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0targeter = targeterToUse;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>这里会初始化\xa0<code>Targeter</code>，该类是生成feign代理类的工具类，有两种实现，正是上面的\xa0<code>HystrixTargeter</code>,\xa0<code>DefaultTargeter</code>。 因为我们引入了\xa0<code>hystrix</code>，所以\xa0<code>Targeter</code>实现类为\xa0<code>HystrixTargeter</code>。我们继续跟进\xa0<code>targeter.target</code>方法：</p>\n\n<ol><li>\n\t<p><code>\xa0public &lt;T&gt; T target(Target&lt;T&gt; target) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0return build().newInstance(target);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>上面通过\xa0<code>build()</code>方法获取生成代理类的工具类\xa0<code>ReflectiveFeign</code>，再通过\xa0<code>newInstance</code>正式创建代理类。 继续跟进</p>\n\n<ol><li>\n\t<p><code>\xa0 \xa0public Feign build() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 logLevel, decode404);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0ParseHandlersByName handlersByName =</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0new ParseHandlersByName(contract, options, encoder, decoder,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0errorDecoder, synchronousMethodHandlerFactory);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0return new ReflectiveFeign(handlersByName, invocationHandlerFactory);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>这里会创建Feign的方法工厂\xa0<code>synchronousMethodHandlerFactory</code>,\xa0<code>Feign</code>通过该工厂为每个方法创建一个\xa0<code>methodHandler</code>，每个\xa0<code>methodHandler</code>中包含Feign对应的配置：\xa0<code>retryer</code>、\xa0<code>requestInterceptors</code>等。</p>\n\n<p>继续跟进\xa0<code>newInstance</code>方法：</p>\n\n<ol><li>\n\t<p><code>public &lt;T&gt; T newInstance(Target&lt;T&gt; target) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 //创建所有的 MethodHandler</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0Map&lt;Method, MethodHandler&gt; methodToHandler = new LinkedHashMap&lt;Method, MethodHandler&gt;();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = new LinkedList&lt;DefaultMethodHandler&gt;();</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0for (Method method : target.type().getMethods()) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0if (method.getDeclaringClass() == Object.class) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0continue;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 //判断是否启用默认handler</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0} else if(Util.isDefault(method)) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0DefaultMethodHandler handler = new DefaultMethodHandler(method);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0defaultMethodHandlers.add(handler);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0methodToHandler.put(method, handler);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0} else {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0//创建InvocationHandler，接收请求，转发到methodHandler</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0InvocationHandler handler = factory.create(target, methodToHandler);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0//生成代理类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]{target.type()}, handler);</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 //将默认方法绑定到代理类</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0for(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0defaultMethodHandler.bindTo(proxy);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0return proxy;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0}</code></p>\n\t</li>\n</ol><p><code>InvocationHandler</code>最终创建的实例为\xa0<code>HystrixInvocationHandler</code>，核心方法如下：</p>\n\n<ol><li>\n\t<p><code>HystrixCommand&lt;Object&gt; hystrixCommand = new HystrixCommand&lt;Object&gt;(setter) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0protected Object run() throws Exception {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0try {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0return HystrixInvocationHandler.this.dispatch.get(method).invoke(args);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0} catch (Exception e) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0throw e;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0} catch (Throwable t) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0throw (Error) t;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0protected Object getFallback() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0//......</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0};</code></p>\n\t</li>\n</ol><p>整个流程：Feign调用方发起请求，发送至hystrix的HystrixInvocationHandler，通过服务名称，找到对应方法的methodHandler，methodHandler中封装了loadBalanceClient、retryer、RequestInterceptor等组件，如果引入了sleuth,这几个组件均是sleuth的包装类。然后通过以上组件构造\xa0<code>http</code>请求完成整个过程。</p>\n\n<hr><h3>五、生成默认代理类</h3>\n\n<p>理解了第四步的逻辑，生成默认代理类就很容易理解了，唯一不同点就是\xa0<code>client</code>的实现类为\xa0<code>loadBalanceClient</code>。</p>\n\n<blockquote>\n<p>注意：不管是哪种代理类，最终发起请求还是由\xa0<code>Feign.Default</code>中的\xa0<code>execute</code>方法完成，默认使用\xa0<code>HttpUrlConnection</code>实现。</p>\n</blockquote>\n\n<hr><h3>六、注入spring容器</h3>\n\n<p>总结：通过\xa0<code>spring refresh()</code>方法，触发\xa0<code>FeignClientFactoryBean.getObject()</code>方法获得了代理类，然后完成注入\xa0<code>spring</code>容器的过程。该实现方式同\xa0<code>Dubbo</code>的实现方式类似，有兴趣的可以自行研究噢。</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0（转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83896180', 'title': '分布式架构的套路No.74', 'readNum': '14211', 'commentNum': '0', 'publishTime': '2019-02-27 14:53:42', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>&gt;转载于公众号：一个叫大蕉的程序员<br>\n&gt;\xa0</p>\n\n<p>今天小蕉跟大伙一起聊聊分布式系统的架构的套路。在开始说套路之前，大家先思考一个问题，为什么要进行分布式架构？</p>\n\n<p>大多数的开发者大多数的系统可能从来没接触过分布式系统，也根本没必要进行分布式系统架构，为什么？因为在访问量或者QPS没有达到单台机器的性能瓶颈的时候，根本没必要进行分布式架构。那如果业务量上来了，一般会怎么解决呢？</p>\n\n<p>首先考虑的就是机器升级。机器配置的垂直扩展，首先要找到当前性能的瓶颈点，是CPU，是内存，是硬盘，还是带宽。砸钱加CPU，砸钱换SSD硬盘，砸钱换1T内存，这通常是解决问题最直接也最高效的方法。带宽不够？加带宽，1G不够用100G。CPU 8核不够？搞32核96核。这是绝大多数公司能思考到的第一个方案，也是最高效最快最安全的方法，立竿见影。</p>\n\n<p>其次就是系统拆分，将所提供服务的主流程以及支线流程梳理出来，按照流程进行系统拆分。如同一棵树，核心业务作为主干流程，其他系统按照需要进行拆分，如同树的开枝散叶。所采取的方式有这么一些，按前后端进行拆分，按照领域拆分，按团队拆分，当然通常来说这些拆分基本都要跟着组织架构走。</p>\n\n<p>再不行就进行技术升级，更换更加高效或者场景适合的技术。比如从 Oracle 更换到HBase。从A数据库连接池更换到B数据库连接池。技术的变革对于业务量的支持也是非常巨大的，同一台机器不同的技术，效能发挥的程度可以说有天壤之别。</p>\n\n<p>最后的最后手段才会考虑分布式架构，实在是砸不出这么多钱了，实在是没办法了。因为分布式架构肯定会带来非常多非常多的一致性问题，原本只需要访问一台机器，现在需要访问N台，那么这N台机器的一致性怎么保证，以前撑死搞个主从备份就算完了，定时同步一下数据就好，现在N台设备的数据怎么管理，甚至这个集群本身怎么管理，都会成为一个致命的问题。</p>\n\n<p>所以只有等业务量到达一定程度了，单台机器扛不住了，才会开始堆钱升级机器，系统拆分，换技术，继续堆钱升级机器，系统拆分...周而复始，发现成本太高或者技术已经到达上线了。最后没办法，就选择分布式架构了。</p>\n\n<p>但是分布式架构的优势也是明显的，用一群低廉的设备，来提供一个高性能高吞吐量的稳定的系统，下面开始说说常见的分布式集群的架构。</p>\n\n<p><strong>1、纯负载均衡形式</strong></p>\n\n<p>在集群前面，前置一个流量分发的组件进行流量分发，整个集群的机器提供无差别的服务，这在常见的 web 服务器中是最最常见的。目前比较主流的方式就是整个集群机器上云，根据实时的调用量进行云服务器弹性伸缩。常见的负载均衡有硬件层面的 F5、软件层面的 nginx 等。</p>\n\n<p><img alt="zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7DjicM0kiaFNMtdXbOBibH8YFBrWdeNRdYMYegBLk7bdThKuxcZ8uyf7jog" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7DjicM0kiaFNMtdXbOBibH8YFBrWdeNRdYMYegBLk7bdThKuxcZ8uyf7jog/"></p>\n\n<p><strong>2、领导选举型</strong></p>\n\n<p>整个集群的消息都会转发到集群的领导这里，是一种 master-slavers，区别只是这个 master 是被临时选举出来的，一旦 master 宕机，集群会立刻选举出一个新的领导，继续对外提供服务。使用领导选举型架构的典型的应用有 ElasticSearch，zookeeper。</p>\n\n<p><img alt="zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7DOibUztSekj9L5n5uXBicQia1cTbiagUyHu41IbhBEQLCaRwiaeXCUlms5Pw" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7DOibUztSekj9L5n5uXBicQia1cTbiagUyHu41IbhBEQLCaRwiaeXCUlms5Pw/"></p>\n\n<p><strong>3、区块链型</strong></p>\n\n<p>整个集群的每一个节点都可以进行记录，但是记录的内容要得到整个集群 N 个机器的认可才是合法的。典型的应用有 Bit Coin，以及 Hyperledger。</p>\n\n<p><img alt="zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7DbqdXAgUGYRZgMFA4LkkVZjMu6icDcIiaqXiaYHG4gNgia7cC1iatK4lCP9A" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7DbqdXAgUGYRZgMFA4LkkVZjMu6icDcIiaqXiaYHG4gNgia7cC1iatK4lCP9A/"></p>\n\n<p><strong>4、master-slaver型</strong></p>\n\n<p>整个集群以某台 master 为中枢，进行集群的调度。交互是这样，一般会把所有的管理类型的数据放到 master 上，而把具体的数据放到 slaver 上，实际进行调用的时候，client 先调用 master 获取数据所存放的 server 的 信息，再自行跟 slave 进行交互。典型的系统有 Hadoop。集群，HBase 集群，Redis 集群等。</p>\n\n<p><img alt="zPECv5G0LTzibvRkHcpv5CunYb6IegBgszTxITRiajDHS4oejia7tic6qrnf6Bt2kdAhF7pKBcO6ZCIk6BpINVtcrA" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/zPECv5G0LTzibvRkHcpv5CunYb6IegBgszTxITRiajDHS4oejia7tic6qrnf6Bt2kdAhF7pKBcO6ZCIk6BpINVtcrA/"></p>\n\n<p><strong>5、规则型一致性Hash</strong></p>\n\n<p>这种架构类型一般出现在数据库分库分表的设计中。按照规则进行分库分表，在查询之前使用规则引擎进行库和表的确认，再对具体的应用进行访问。为什么要用一致性 Hash ？其实用什么都可以，只是对于这类应用来说一致性 Hash 比较常见而已。</p>\n\n<p><img alt="zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7D4MG3Sic3treq8If7ianIfh9sOv5SD6rcwRhqZxFVFdwCKWbgZrZ0ceLQ" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/zPECv5G0LTzNLdH7Pg0a7HJ5Fn0lPF7D4MG3Sic3treq8If7ianIfh9sOv5SD6rcwRhqZxFVFdwCKWbgZrZ0ceLQ/"></p>\n\n<p>好了，至此，已经把我所知道的大部分分布式集群的套路说完了，总结一下。</p>\n\n<p>1、升级机器配置是最直接的升级方式。不到万不得已不会使用分布式</p>\n\n<p>2、分布式的核心就是业务拆分以及流量分发</p>\n</blockquote>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0（转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-0_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83896145', 'title': '优雅的使用 ThreadLocal', 'readNum': '14572', 'commentNum': '0', 'publishTime': '2019-02-27 14:53:36', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>转载于公众号 码匠笔记</p>\n</blockquote>\n\n<h2>\xa0</h2>\n\n<h2>前言</h2>\n\n<p>在我们日常 <code>Web</code> 开发中难免遇到需要把一个参数层层的传递到最内层，然后中间层根本不需要使用这个参数，或者是仅仅在特定的工具类中使用，这样我们完全没有必要在每一个方法里面都传递这样一个 <code>通用</code>的参数。如果有一个办法能够在任何一个类里面想用的时候直接拿来使用就太好了。 <code>Java</code>的 <code>Web</code>项目大部分都是基于 <code>Tomcat</code>，每次访问都是一个新的线程，这样让我们联想到了 <code>ThreadLocal</code>，每一个线程都独享一个 <code>ThreadLocal</code>，在接收请求的时候 <code>set</code>特定内容，在需要的时候 <code>get</code>这个值。下面我们就进入主题。</p>\n\n<h2>ThreadLocal</h2>\n\n<p>维持线程封闭性的一种更规范的方法就是使用 <code>ThreadLocal</code>，这个类能使线程中的某个值与保存的值的对象关联起来。 <code>ThreadLocal</code>提供 <code>get</code>和 <code>set</code>等接口或方法，这些方法为每一个使用这个变量的线程都存有一份独立的副本，因此 <code>get</code>总是返回由当前线程在调用 <code>set</code>时设置的最新值。 <code>ThreadLocal</code>有如下方法</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public T get() { }</code></p>\n\t</li>\n\t<li>\n\t<p><code>public void set(T value) { }</code></p>\n\t</li>\n\t<li>\n\t<p><code>public void remove() { }</code></p>\n\t</li>\n\t<li>\n\t<p><code>protected T initialValue() { }</code></p>\n\t</li>\n</ol><p><code>get()</code>方法是用来获取 <code>ThreadLocal</code>在当前线程中保存的变量副本<br><code>set()</code>用来设置当前线程中变量的副本<br><code>remove()</code>用来移除当前线程中变量的副本<br><code>initialValue()</code>是一个 <code>protected</code>方法，一般是用来在使用时进行重写的，如果在没有set的时候就调用 <code>get</code>，会调用 <code>initialValue</code>方法初始化内容。 为了使用的更放心，我们简单的看一下具体的实现:</p>\n\n<h3><code>set</code>方法</h3>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public void set(T value) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Thread t = Thread.currentThread();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ThreadLocalMap map = getMap(t);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (map != null)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0map.set(this, value);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0else</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0createMap(t, value);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p><code>set</code>方法会获取当前的线程，通过当前线程获取 <code>ThreadLocalMap</code>对象。然后把需要存储的值放到这个 <code>map</code>里面。如果没有就调用 <code>createMap</code>创建对象。</p>\n\n<h3><code>getMap</code>方法</h3>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>ThreadLocalMap getMap(Thread t) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return t.threadLocals;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p><code>getMap</code>方法直接返回当前 <code>Thread</code>的 <code>threadLocals</code>变量，这样说明了之所以说 <code>ThreadLocal</code>是 <code>线程局部变量</code>就是因为它只是通过 <code>ThreadLocal</code>把 <code>变量</code>存在了 <code>Thread</code>本身而已。</p>\n\n<h3><code>createMap</code>方法</h3>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>void createMap(Thread t, T firstValue) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0t.threadLocals = new ThreadLocalMap(this, firstValue);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>在 <code>set</code>的时候如果不存在 <code>threadLocals</code>，直接创建对象。由上看出，放入 <code>map</code>的 <code>key</code>是当前的 <code>ThreadLocal</code>， <code>value</code>是需要存放的内容，所以我们设置属性的时候需要注意存放和获取的是一个 <code>ThreadLocal</code>。</p>\n\n<h3><code>get</code>方法</h3>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public T get() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0Thread t = Thread.currentThread();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ThreadLocalMap map = getMap(t);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (map != null) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0ThreadLocalMap.Entry e = map.getEntry(this);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (e != null)</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0return (T)e.value;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return setInitialValue();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p><code>get</code>方法就比较简单，获取当前线程，尝试获取当前线程里面的 <code>threadLocals</code>，如果没有获取到就调用 <code>setInitialValue</code>方法， <code>setInitialValue</code>基本和 <code>set</code>是一样的，就不累累述了。</p>\n\n<h2>场景</h2>\n\n<p>本文应用 <code>ThreadLocal</code>的场景：在调用API接口的时候传递了一些公共参数，这些公共参数携带了一些设备信息，服务端接口根据不同的信息组装不同的格式数据返回给客户端。假定服务器端需要通过设备类型(device)来下发下载地址，当然接口也有同样的其他逻辑，我们只要在返回数据的时候判断好是什么类型的客户端就好了。如下:</p>\n\n<p>场景一</p>\n\n<p>请求</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>GET api/users?device=android</code></p>\n\t</li>\n</ol><p>返回</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>\xa0 \xa0{</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0user : { \xa0 \xa0 \xa0 \xa0</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0},</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0link : "https://play.google.com/store/apps/details?id=***"</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><p>场景二</p>\n\n<p>请求</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>GET api/users?device=ios</code></p>\n\t</li>\n</ol><p>返回</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>\xa0 \xa0{</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0user : { \xa0 \xa0</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0},</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0link : "https://itunes.apple.com/us/app/**"</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><h2>实现</h2>\n\n<p>首先准备一个 <code>BaseSigntureRequest</code>类用来存放公共参数</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public class BaseSignatureRequest {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0private String device;</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public String getDevice() {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return device;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public void setDevice(String device) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0this.device = device;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p>然后准备一个 <code>static</code>的 <code>ThreadLocal</code>类用来存放 <code>ThreadLocal</code>，以便存储和获取时候的 <code>ThreadLocal</code>一致。</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public class ThreadLocalCache {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public static ThreadLocal&lt;BaseSignatureRequest&gt; </code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0baseSignatureRequestThreadLocal = new ThreadLocal&lt;&gt;();</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p>然后编写一个 <code>Interceptor</code>，在请求的时候获取 <code>device</code>参数，存入当前线程的 <code>ThreadLocal</code>中。这里需要注意的是，重写了 <code>afterCompletion</code>方法，当请求结束的时候把 <code>ThreadLocal</code> <code>remove</code>，移除不必须要键值对。</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public class ParameterInterceptor implements HandlerInterceptor {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public boolean preHandle(HttpServletRequest request, HttpServletResponse response,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 Object handler) throws Exception {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0String device = request.getParameter("device");</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0BaseSignatureRequest baseSignatureRequest = new BaseSignatureRequest();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0baseSignatureRequest.setDevice(device);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ThreadLocalCache.baseSignatureRequestThreadLocal.set(baseSignatureRequest);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return true;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public void afterCompletion(HttpServletRequest request, HttpServletResponse response,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0Object handler, Exception ex) throws Exception {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ThreadLocalCache.baseSignatureRequestThreadLocal.remove();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0@Override</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public void postHandle(HttpServletRequest httpServletRequest,</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 HttpServletResponse httpServletResponse, </code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 Object o, ModelAndView modelAndView) throws Exception {</code></p>\n\t</li>\n\t<li>\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>}</code></p>\n\t</li>\n</ol><p>当然需要在 <code>spring</code>里面配置 <code>interceptor</code></p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>\xa0 \xa0&lt;mvc:interceptors&gt;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0&lt;mvc:interceptor&gt;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0&lt;mvc:mapping path="/api/**"/&gt;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0&lt;bean class="life.majiang.ParameterInterceptor"&gt;&lt;/bean&gt;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0&lt;/mvc:interceptor&gt;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0&lt;/mvc:interceptors&gt;</code></p>\n\t</li>\n</ol><p>最后在 <code>Converter</code>里面转换实体的时候直接使用即可，这样就大功告成了。</p>\n\n<pre class="has">\n\n<code class="language-html">\xa0</code></pre>\n\n<ol><li>\n\t<p><code>public class UserConverter {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0public static ResultDO toDO(User user) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0ResultDO resultDO = new ResultDO();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0resultDO.setUser(user);</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0BaseSignatureRequest baseSignatureRequest = ThreadLocalCache.baseSignatureRequestThreadLocal.get();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0String device = baseSignatureRequest.getDevice();</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0if (StringUtils.equals(device, "ios")) {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0resultDO.setLink("https://itunes.apple.com/us/app/**");</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0} else {</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0resultDO.setLink("https://play.google.com/store/apps/details?id=***");</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0}</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0 \xa0 \xa0return resultDO;</code></p>\n\t</li>\n\t<li>\n\t<p><code>\xa0 \xa0}</code></p>\n\t</li>\n</ol><h2>总结</h2>\n\n<p>这种机制很方便，因为他避免了在调用每一个方法时都要传递执行上下文信息，合理的使用 <code>ThreadLocal</code>可以起到事倍功半的效果，但是需要避免滥用，例如将所有的全局变量作为 <code>ThreadLocal</code>对象， <code>ThreadLocal</code>类似全局变量，他能降低代码的可重用性，并在类之间引入隐含的耦合性，所以再使用前需要格外小心。</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0（转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:25'}
2020-02-05 20:12:25 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:41] - MainThread - INFO - 翻页：2 nextUrl：https://blog.csdn.net/forezp/article/list/2
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83896120', 'title': '谈谈 API 网关', 'readNum': '14057', 'commentNum': '0', 'publishTime': '2019-02-27 14:53:29', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>作者：预流<br>\n链接：https://www.jianshu.com/p/b52a2773e75f</p>\n</blockquote>\n\n<h1>背景</h1>\n\n<p>理论上，客户端可以直接向微服务发送请求，每个微服务都有一个公开的URL，该URL将映射到微服务的负载均衡器，由它负责在可用实例之间分发请求。但这种方式存在如下缺陷：</p>\n\n<p>1. 客户端需求和微服务暴露的细粒度 API 不匹配</p>\n\n<p>经常有一个业务调用很多个服务，假如客户端发送许多请求，这在公网上可能会很低效，而且会使客户端代码变得更复杂。</p>\n\n<p>2. 服务使用的协议不是 Web 友好的</p>\n\n<p>有的服务可能使用二进制 RPC（比如 thrift），有的服务可能使用 AMQP 消息传递协议。不管哪种协议都不是浏览器友好或防火墙友好的，最好是内部使用。在防火墙之外，应用程序应该使用诸如 HTTP 和 WebSocket 之类的协议。</p>\n\n<p>3. 难重构</p>\n\n<p>随着时间推移可能想要更改系统划分成服务的方式。例如，合并两个服务或者将一个服务拆分成两个或更多服务。如果客户端与微服务直接通信，那么执行这类重构就很困难。</p>\n\n<p>由于以上问题，客户端与微服务直接通信很少是合理的，更好的方法是使用\xa0<strong>API 网关，</strong>由 API 网关作为后端服务系统的唯一入口。它封装了系统内部架构，为每个客户端提供一个定制的 API 。由它负责服务请求路由、组合及协议转换。有的 API 网关还有其它职责，如身份验证、监控、负载均衡、缓存等。</p>\n\n<hr><h1>整体架构</h1>\n\n<p>完备的服务网关应该包括三大部分：API 网关、网关控制台、度量数据采集分析。实际形态各异，可以按需搭建，但肯定少不了 API 网关，网关控制台的功能职责可能会放到服务注册等地方而没有单独抽取出来，至于度量数据采集可能会在整个微服务架构中存一个通用的度量数据采集应用以监控所有类型应用。</p>\n\n<p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/5015984-6c2cae80d43d12ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p>\n\n<p>API服务网关整体架构</p>\n\n<p>API 网关的优缺点</p>\n\n<p>1. 优点</p>\n\n<p>封装了应用程序的内部结构。客户端只需要同网关交互，而不必调用特定的服务。API 网关为每一类客户端提供了特定的 API ，从而减少客户端与应用程序间的交互次数，简化客户端代码的处理。</p>\n\n<p>2. 缺点</p>\n\n<p>增加了一个必须开发、部署和维护的高可用组件。还有一个风险是 API 网关变成了开发瓶颈。为了暴露每个微服务，开发人员必须更新 API 网关。API 网关的更新过程要尽可能地简单，否则为了更新网关，开发人员将不得不排队等待。不过，虽然有这些不足，但对于大多数现实世界的应用程序而言使用 API 网关是合理的。</p>\n\n<h1>\xa0</h1>\n\n<hr><h1>实现技术</h1>\n\n<p>1. 开发语言</p>\n\n<p>对于大多数应用程序而言，API 网关的性能和可扩展性通常都非常重要。因此，API 网关将构建在一个支持异步、I/O 非阻塞的平台上。Java系可以使用一种基于 NIO 的框架，比如Netty、Vertx、Spring Reactor ，还可以使用 Node.js、NGINX Plus。</p>\n\n<p>2. 响应式编程</p>\n\n<p>API 网关通过简单地将请求路由给合适的后端服务来处理部分请求，而通过调用多个后端服务并合并结果来处理其它请求。对于没有依赖关系的请求，API 网关应该并发执行以最小化响应时间。使用传统的异步回调方法编写 API 组合代码会陷入回调地狱。代码会变得混乱、难以理解、容易出错。可以使用响应式编程以一种声明式样式编写代码。比如 Scala 中的Future 、Java 8 中的 CompletableFuture 和 JavaScript 中的 Promise ，还有最初是微软为 .NET 平台开发的 Reactive Extensions（RX）。Netflix 创建了 RxJava for JVM ，专门用于他们的 API 网关。</p>\n\n<p>3. 进程通信模型</p>\n\n<p>微服务的应用程序必定是一个分布式系统，所以必须使用进程间的通信机制。有两种类型的进程间通信机制可供选择。一种是使用异步的、基于消息传递的机制。有些实现使用诸如JMS 或 AMQP 那样的消息代理，而其它的实现（如 Zeromq ）则没有代理，服务间直接通信。另一种是诸如 HTTP 或 Thrift 那样的同步机制。通常，一个系统会同时使用异步和同步两种类型。它甚至还可能使用同一类型的多种实现。总之，API 网关需要支持多种通信机制。</p>\n\n<p>4. 服务发现</p>\n\n<p>API 网关需要知道它与之通信的每个微服务的位置（IP 地址和端口）。应用程序服务的位置是动态分配的。而且，单个服务的一组实例也会随着自动扩展或升级而动态变化。API 网关需要使用系统的服务发现机制，可以是服务器端发现，也可以是客户端发现。如果系统使用客户端发现，那么 API 网关必须能够查询服务注册中心，这是一个包含所有微服务实例及其位置的数据库。</p>\n\n<p>Spring cloud 提供了服务注册和发现功能，如果需要自己实现，可以考虑用 Zookeeper 作为注册表，客户端用 Curator 。</p>\n\n<p>5. 局部失败</p>\n\n<p>在实现 API 网关时，还有一个问题需要处理，就是局部失败的问题。该问题在所有的分布式系统中都会出现，无论什么时候，当一个服务调用另一个响应慢或不可用的服务，就会出现这个问题。API 网关永远不能因为无限期地等待下游服务而阻塞。不过，如何处理失败取决于特定的场景以及哪个服务失败。如果缓存数据可用，那么 API 网关还可以返回缓存数据。数据可以由API网关自己缓存，也可以存储在像 Redis 或 Memcached 那样的外部缓存中。通过返回默认数据或者缓存数据，API 网关可以确保系统故障不影响用户的体验。</p>\n\n<p>在编写代码调用远程服务方面，Netflix Hystrix 是一个异常有用的库。Hystrix 会将超出设定阀值的调用超时。它实现了一个“断路器（circuit breaker）”模式，可以防止客户端对无响应的服务进行不必要的等待。如果服务的错误率超出了设定的阀值，那么 Hystrix 会切断断路器，在一个指定的时间范围内，所有请求都会立即失败。Hystrix 允许用户定义一个请求失败后的后援操作，比如从缓存读取数据，或者返回一个默认值。如果你正在使用 JVM，那么你绝对应该考虑使用 Hystrix 。而如果你正在使用一个非 JVM 环境，那么你应该使用一个等效的库。</p>\n\n<p>6.参考实现方案</p>\n\n<p>以上列出在 DIY 这个 API 网关时需要考虑的点，以及参考的技术实现。下面是几种目前比较流行的 API 网关搭建的技术方案供参考，后续文章将给出这些方案搭建的例子</p>\n\n<p>1）Nginx + Lua实现负载均衡、限流、服务发现等功能</p>\n\n<p>2）使用 spring cloud 技术栈，其中 zuul 就是用作 API 网关的</p>\n\n<p>3）Mashape 的开源 API 网关 Kong</p>\n\n<p>7.网关控制台</p>\n\n<p>提供 domain 管理、应用管理、服务授权、服务监控、统计和度量数据展示、查看服务全局视图等功能。服务消费者和服务提供者都要在网关控制台进行应用注册，控制台为每个应用分配应用id(appId唯一)和应用密钥(appSecret)。注册时需要提供的信息：应用名称、应用描述、应用负责人相关信息。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0（转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83999882', 'title': '拜托！面试请不要再问我Spring Cloud底层原理', 'readNum': '39775', 'commentNum': '58', 'publishTime': '2019-02-27 14:53:23', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>&gt;转载请标明出处：\xa0<br>\n&gt;https://www.fangzhipeng.com<br>\n&gt; 本文出自[方志朋的博客](http://blog.csdn.net/forezp)<br>\n&gt;\xa0<br>\n&gt;</p>\n\n<p>本文为转载文章，作者：中华石杉，十余年BAT架构经验，倾囊相授。作者微信公众号：石杉的架构笔记（ID:shishan100）</p>\n</blockquote>\n\n<p><strong>概述</strong></p>\n\n<p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。<strong>因此本文将通过大量的手绘图</strong>，给大家谈谈Spring Cloud微服务架构的底层原理。<br><br>\n实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。<strong>也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件</strong><strong>。</strong></p>\n\n<p>\xa0</p>\n\n<h1><strong>一、业务场景介绍</strong></h1>\n\n<p>\xa0</p>\n\n<p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>创建一个订单之后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”</p>\n\t</li>\n\t<li>\n\t<p>扣减相应的商品库存</p>\n\t</li>\n\t<li>\n\t<p>通知仓储中心，进行发货</p>\n\t</li>\n\t<li>\n\t<p>给用户的这次购物增加相应的积分</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>针对上述流程，<strong>我们需要有订单服务、库存服务、仓储服务、积分服务</strong>。整个流程的大体思路如下：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态</p>\n\t</li>\n\t<li>\n\t<p>订单服务调用库存服务，完成相应功能</p>\n\t</li>\n\t<li>\n\t<p>订单服务调用仓储服务，完成相应功能</p>\n\t</li>\n\t<li>\n\t<p>订单服务调用积分服务，完成相应功能</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>至此，整个支付订单的业务流程结束</strong></p>\n\n<p>\xa0</p>\n\n<p>下图这张图，清晰表明了各服务间的调用过程：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100305737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>好！有了业务场景之后，咱们就一起来看看Spring\xa0Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。</p>\n\n<p>\xa0</p>\n\n<p><strong>二、Spring Cloud核心组件：Eureka</strong></p>\n\n<p>\xa0</p>\n\n<p><strong>咱们来考虑第一个问题</strong>：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</p>\n\t</li>\n\t<li>\n\t<p>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>\xa0咱们来看看下面的这张图，结合图来仔细剖析一下整个流程：\xa0</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100343563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</p>\n\n<p>\xa0</p>\n\n<p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p>\n\n<p>\xa0</p>\n\n<p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p>\n\n<p>\xa0</p>\n\n<p>总结一下：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p><strong>Eureka</strong><strong>\xa0</strong><strong>Client：</strong>负责将这个服务的信息注册到Eureka Server中</p>\n\t</li>\n\t<li>\n\t<p><strong>Eureka Server：</strong>注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<h1><strong>三、Spring Cloud核心组件：Feign</strong></h1>\n\n<p>\xa0</p>\n\n<p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。<strong>但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</strong></p>\n\n<p>\xa0</p>\n\n<p>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！</p>\n\n<p>\xa0</p>\n\n<p><strong>友情提示，前方高能：</strong></p>\n\n<p>\xa0</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100406582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事儿压根儿就不是地球人能干的。</p>\n\n<p>\xa0\xa0</p>\n\n<p>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？</p>\n\n<p>\xa0</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100422118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p>\n\n<p>\xa0</p>\n\n<p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</p>\n\t</li>\n\t<li>\n\t<p>接着你要是调用那个接口，本质就是会调用\xa0Feign创建的动态代理，这是核心中的核心</p>\n\t</li>\n\t<li>\n\t<p>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</p>\n\t</li>\n\t<li>\n\t<p>最后针对这个地址，发起请求、解析响应</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100436705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<h1><strong>四、Spring Cloud核心组件：</strong><strong>Ribbon</strong></h1>\n\n<p>\xa0</p>\n\n<p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>192.168.169:9000</p>\n\t</li>\n\t<li>\n\t<p>192.168.170:9000</p>\n\t</li>\n\t<li>\n\t<p>192.168.171:9000</p>\n\t</li>\n\t<li>\n\t<p>192.168.172:9000</p>\n\t</li>\n\t<li>\n\t<p>192.168.173:9000</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p><strong>这下麻烦了！</strong><strong>人家Feign怎么知道该请求哪台机器呢？</strong></p>\n\n<p>\xa0</p>\n\n<p>这时Spring Cloud\xa0Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>Ribbon的负载均衡默认使用的最经典的Round\xa0Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</p>\n\n<p>\xa0</p>\n\n<p>\xa0<strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>首先Ribbon会从\xa0Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</p>\n\t</li>\n\t<li>\n\t<p>然后Ribbon就可以使用默认的Round\xa0Robin算法，从中选择一台机器</p>\n\t</li>\n\t<li>\n\t<p>Feign就会针对这台机器，构造并发起请求。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>对上述整个过程，再来一张图，帮助大家更深刻的理解：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100455861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p><strong>五、Spring Cloud核心组件：Hystrix</strong></p>\n\n<p>\xa0</p>\n\n<p>在微服务架构里，一个系统会有很多的服务。以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p>\n\n<p>\xa0</p>\n\n<p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求</p>\n\t</li>\n\t<li>\n\t<p>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>上面这个，就是<strong>微服务架构中恐怖的服务雪崩问题</strong>，如下图所示：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100521214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p>\n\n<p>\xa0</p>\n\n<p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！</strong><strong>为什么？</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了</p>\n\t</li>\n\t<li>\n\t<p>如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</p>\n\n\t<p>\xa0</p>\n\t</li>\n</ul><p><strong>现在问题分析完了，如何解决？</strong></p>\n\n<p>\xa0</p>\n\n<p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p>\n\n<p>\xa0</p>\n\n<p><strong>打个比方：现在很不幸，积分服务挂了，会咋样？</strong></p>\n\n<p>\xa0</p>\n\n<p>当然会导致订单服务里的那个用来调用积分服务的线程都卡死不能工作了啊！但是由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p>\n\n<p>\xa0</p>\n\n<p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？</strong><strong>有意义吗？当然没有！</strong>所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！</p>\n\n<p>\xa0</p>\n\n<p><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？</strong>没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。</p>\n\n<p>\xa0</p>\n\n<p>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100536909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<h1><strong>六、Spring Cloud核心组件：</strong><strong>Zuul</strong></h1>\n\n<p>\xa0</p>\n\n<p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。这个组件是负责网络路由的。不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p>\n\n<p>\xa0</p>\n\n<p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方</strong>：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</p>\n\n<p>\xa0</p>\n\n<p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p>\n\n<p>\xa0</p>\n\n<p>而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。</p>\n\n<p>\xa0</p>\n\n<p><strong>七、总结：</strong></p>\n\n<p>\xa0</p>\n\n<p>最后再来总结一下，上述几个Spring\xa0Cloud核心组件，在微服务架构中，分别扮演的角色：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p><strong>Eureka</strong>：各个服务启动时，Eureka\xa0Client都会将服务注册到Eureka\xa0Server，并且Eureka\xa0Client还可以反过来从Eureka\xa0Server拉取注册表，从而知道其他服务在哪里</p>\n\t</li>\n\t<li>\n\t<p><strong>Ribbon</strong>：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p>\n\t</li>\n\t<li>\n\t<p><strong>Feign</strong>：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p>\n\t</li>\n\t<li>\n\t<p><strong>Hystrix</strong>：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p>\n\t</li>\n\t<li>\n\t<p><strong>Zuul</strong>：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>以上就是我们通过一个电商业务场景，阐述了Spring\xa0Cloud微服务架构几个核心组件的底层原理。</p>\n\n<p>\xa0</p>\n\n<p><strong>文字总结还不够直观？没问题！</strong>我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100554824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</p>\n\n<p>作者：中华石杉，十余年BAT架构经验，倾囊相授。个人微信公众号：石杉的架构笔记（ID:shishan100）</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 （转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83999947', 'title': '【双11狂欢的背后】微服务注册中心如何承载大型系统的千万级访问？', 'readNum': '19764', 'commentNum': '4', 'publishTime': '2019-02-27 14:53:16', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文为转载文章，作者：中华石杉，十余年BAT架构经验，倾囊相授。作者微信公众号：石杉的架构笔记（ID:shishan100）</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p><strong>目录：</strong></p>\n\n<p><strong>一、问题起源</strong></p>\n\n<p><strong>二、Eureka\xa0Server设计精妙的注册表存储结构</strong></p>\n\n<p><strong>三、Eureka\xa0Server端优秀的多级缓存机制</strong></p>\n\n<p><strong>四、总结</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>一、问题起源</strong></p>\n\n<p>\xa0</p>\n\n<p>Spring Cloud架构体系中，Eureka是一个至关重要的组件，它扮演着微服务注册中心的角色，所有的服务注册与服务发现，都是依赖Eureka的。</p>\n\n<p><br>\n不少初学Spring Cloud的朋友在落地公司生产环境部署时，经常会问：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>Eureka Server到底要部署几台机器？</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>我们的系统那么多服务，到底会对Eureka Server产生多大的访问压力？</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>Eureka Server能不能抗住一个大型系统的访问压力？</p>\n\t</li>\n</ul><p><br>\n如果你也有这些疑问，别着急！咱们这就一起去看看，Eureka作为微服务注册中心的核心原理</p>\n\n<p>\xa0</p>\n\n<p>下面这些问题，大家先看看，有个大概印象。带着这些问题，来看后面的内容，效果更佳</p>\n\n<p>\xa0</p>\n\n<ol><li>\n\t<p>Eureka注册中心使用什么样的方式来储存各个服务注册时发送过来的机器地址和端口号？</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>各个服务找Eureka Server拉取注册表的时候，是什么样的频率？</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>各个服务是如何拉取注册表的？</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>一个几百服务，部署上千台机器的大型分布式系统，会对Eureka Server造成多大的访问压力？</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>Eureka Server从技术层面是如何抗住日千万级访问量的？</p>\n\t</li>\n</ol><p>\xa0</p>\n\n<p>先给大家说一个基本的知识点，各个服务内的Eureka Client组件，默认情况下，每隔30秒会发送一个请求到Eureka Server，来拉取最近有变化的服务信息</p>\n\n<p>\xa0</p>\n\n<p><strong>举个例子</strong>：</p>\n\n<ul><li>\n\t<p>库存服务原本部署在1台机器上，现在扩容了，部署到了3台机器，并且均注册到了Eureka Server上。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>然后订单服务的Eureka Client会每隔30秒去找Eureka Server拉取最近注册表的变化，看看其他服务的地址有没有变化。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>除此之外，Eureka还有一个心跳机制，各个Eureka Client每隔30秒会发送一次心跳到Eureka Server，通知人家说，哥们，我这个服务实例还活着！</p>\n\n<p>\xa0</p>\n\n<p>如果某个Eureka Client很长时间没有发送心跳给Eureka Server，那么就说明这个服务实例已经挂了。</p>\n\n<p>\xa0</p>\n\n<p>光看上面的文字，大家可能没什么印象。老规矩！咱们还是来一张图，一起来直观的感受一下这个过程。</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113101321724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>二、Eureka Server设计精妙的注册表存储结构</strong></p>\n\n<p>\xa0</p>\n\n<p>现在咱们假设手头有一套大型的分布式系统，一共100个服务，每个服务部署在20台机器上，机器是4核8G的标准配置。</p>\n\n<p>\xa0</p>\n\n<p>也就是说，相当于你一共部署了100 * 20 = 2000个服务实例，有2000台机器。</p>\n\n<p>\xa0</p>\n\n<p>每台机器上的服务实例内部都有一个Eureka Client组件，它会每隔30秒请求一次Eureka Server，拉取变化的注册表。</p>\n\n<p>\xa0</p>\n\n<p>此外，每个服务实例上的Eureka Client都会每隔30秒发送一次心跳请求给Eureka Server。</p>\n\n<p>\xa0</p>\n\n<p>那么大家算算，Eureka Server作为一个微服务注册中心，<strong>每秒钟要被请求多少次？一天要被请求多少次？</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>按标准的算法，每个服务实例每分钟请求2次拉取注册表，每分钟请求2次发送心跳</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>这样一个服务实例每分钟会请求4次，2000个服务实例每分钟请求8000次</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>换算到每秒，则是8000 / 60 = 133次左右，我们就大概估算为Eureka Server每秒会被请求150次</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>那一天的话，就是8000 * 60 * 24 = 1152万，也就是<strong>每天千万级访问量</strong></p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p><strong>好！经过这么一个测算，大家是否发现这里的奥秘了？</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>首先，对于微服务注册中心这种组件，在一开始设计它的拉取频率以及心跳发送频率时，就已经考虑到了一个大型系统的各个服务请求时的压力，每秒会承载多大的请求量。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>所以各服务实例<strong>每隔30秒</strong>发起请求拉取变化的注册表，以及<strong>每隔30秒</strong>发送心跳给Eureka Server，其实这个时间安排是有其用意的。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>按照我们的测算，一个上百个服务，几千台机器的系统，按照这样的频率请求Eureka Server，日请求量在千万级，每秒的访问量在150次左右。</p>\n\n<p>\xa0</p>\n\n<p>即使算上其他一些额外操作，我们姑且就算每秒钟请求Eureka Server在200次~300次吧。</p>\n\n<p>\xa0</p>\n\n<p>所以通过设置一个适当的拉取注册表以及发送心跳的频率，可以保证大规模系统里对Eureka Server的请求压力不会太大。</p>\n\n<p>\xa0</p>\n\n<p><strong>关键问题来了</strong><strong>，Eureka Server是如何保证轻松抗住这每秒数百次请求，每天千万级请求的呢？</strong></p>\n\n<p>\xa0</p>\n\n<p>要搞清楚这个，首先得清楚Eureka\xa0Server到底是用什么来存储注册表的？三个字，<strong>看源码</strong></p>\n\n<p>\xa0</p>\n\n<p><strong>接下来咱们就一起进入Eureka源码里一探究竟：</strong></p>\n\n<p>\xa0</p>\n\n<p><img alt="" class="has" height="151" src="https://img-blog.csdnimg.cn/20181113101336386.png" width="711"></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>如上图所示，图中的这个名字叫做<strong>registry</strong>的<strong>CocurrentHashMap</strong>，就是注册表的核心结构。看完之后忍不住先赞叹一下，精妙的设计！</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>从代码中可以看到，Eureka\xa0Server的注册表直接基于<strong>纯内存</strong>，即在内存里维护了一个数据结构。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>各个服务的注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>各个服务每隔30秒拉取注册表的时候，Eureka\xa0Server就是直接提供内存里存储的有变化的注册表数据给他们就可以了。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>同样，每隔30秒发起心跳时，也是在这个纯内存的Map数据结构里更新心跳时间。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p><strong>一句话概括</strong>：维护注册表、拉取注册表、更新心跳时间，全部发生在内存里！这是Eureka Server非常核心的一个点。</p>\n\n<p>\xa0</p>\n\n<p>搞清楚了这个，咱们再来分析一下registry这个东西的数据结构，大家千万别被它复杂的外表唬住了，沉下心来，一层层的分析！</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>首先，这个ConcurrentHashMap的key就是服务名称，比如“inventory-service”，就是一个服务名称。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>value则代表了一个服务的多个服务实例。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>举例：比如“inventory-service”是可以有3个服务实例的，每个服务实例部署在一台机器上。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>再来看看作为value的这个Map：</p>\n\n<p>\xa0\xa0\xa0\xa0<strong>Map&lt;String, Lease&lt;InstanceInfo</strong><strong>&gt;</strong>&gt;</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>这个Map的key就是<strong>服务实例的id</strong></p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>value是一个叫做<strong>Lease</strong>的类，它的泛型是一个叫做<strong>InstanceInfo</strong>的东东，你可能会问，这俩又是什么鬼？</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>首先说下InstanceInfo，其实啊，我们见名知义，这个InstanceInfo就代表了<strong>服务实例的具体信息</strong>，比如机器的ip地址、hostname以及端口号。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>而这个Lease，里面则会维护每个服务<strong>最近一次发送心跳的时间</strong></p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>三、Eureka Server端优秀的多级缓存机制</strong></p>\n\n<p>\xa0</p>\n\n<p>假设Eureka Server部署在4核8G的普通机器上，那么<strong>基于内存来承载各个服务的请求，每秒钟最多可以处理多少请求呢？</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>根据之前的测试，单台4核8G的机器，处理纯内存操作，哪怕加上一些网络的开销，每秒处理几百请求也是轻松加愉快的。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>而且Eureka Server为了避免同时读写内存数据结构造成的并发冲突问题，还采用了<strong>多级缓存机制</strong>来进一步提升服务请求的响应速度。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>在拉取注册表的时候：</p>\n\n\t<ul><li>\n\t\t<p>首先从<strong>ReadOnlyCacheMap</strong>里查缓存的注册表。</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<ul><li>\n\t\t<p>若没有，就找<strong>ReadWriteCacheMap</strong>里缓存的注册表。</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<ul><li>\n\t\t<p>如果还没有，就从<strong>内存中获取实际的注册表数据。</strong></p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>在注册表发生变更的时候：</p>\n\n\t<ul><li>\n\t\t<p>会在内存中更新变更的注册表数据，同时<strong>过期掉ReadWriteCacheMap</strong>。</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<ul><li>\n\t\t<p>此过程不会影响ReadOnlyCacheMap提供人家查询注册表。</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<ul><li>\n\t\t<p>一段时间内（默认30秒），各服务拉取注册表会直接读ReadOnlyCacheMap</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<ul><li>\n\t\t<p>30秒过后，Eureka Server的后台线程发现ReadWriteCacheMap已经清空了，也会清空ReadOnlyCacheMap中的缓存</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<ul><li>\n\t\t<p>下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。</p>\n\t\t</li>\n\t</ul></li>\n</ul><p>\xa0</p>\n\n<p><strong>多级缓存机制的优点是什么？</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>为方便大家更好的理解，同样来一张图，大家跟着图再来回顾一下这整个过程：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113101356247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>四、总结</strong></p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>通过上面的分析可以看到，Eureka通过设置适当的请求频率<strong>（拉取注册表30秒间隔，发送心跳30秒间隔）</strong>，可以保证一个大规模的系统每秒请求Eureka Server的次数在几百次。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>同时通过纯内存的注册表，保证了所有的请求都可以在内存处理，确保了极高的性能</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>另外,多级缓存机制，确保了不会针对内存数据结构发生频繁的读写并发冲突操作，进一步提升性能。</p>\n\t</li>\n</ul><p>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</p>\n\n<p>作者：中华石杉，十余年BAT架构经验，倾囊相授。个人微信公众号：石杉的架构笔记（ID:shishan100）</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 （转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>上述就是Spring Cloud架构中，Eureka作为微服务注册中心可以承载大规模系统每天千万级访问量的原理。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83999975', 'title': '性能优化之道】每秒上万并发下的Spring Cloud参数优化实战', 'readNum': '23137', 'commentNum': '6', 'publishTime': '2019-02-27 14:53:09', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文为转载文章，作者：中华石杉，十余年BAT架构经验，倾囊相授。作者微信公众号：石杉的架构笔记（ID:shishan100）</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p><strong>一、写在前面</strong></p>\n\n<p>\xa0</p>\n\n<p>相信不少朋友都在自己公司使用Spring Cloud框架来构建微服务架构，毕竟现在这是非常火的一门技术。</p>\n\n<p>\xa0</p>\n\n<p>如果只是用户量很少的传统IT系统，使用Spring Cloud可能还暴露不出什么问题。</p>\n\n<p>\xa0</p>\n\n<p>如果是较多用户量，高峰每秒高达上万并发请求的互联网公司的系统，使用Spring Cloud技术就有一些问题需要注意了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>二、场景引入，问题初现</strong></p>\n\n<p>\xa0</p>\n\n<p>先不空聊原理、理论，来讲一个<strong>真实的例子</strong>，这是我的一个朋友在创业互联网公司发生过的真实案例。</p>\n\n<p><br>\n\xa0</p>\n\n<blockquote>\n<p>朋友A的公司做互联网类的创业，组建了一个小型研发团队，上来就用了Spring Cloud技术栈来构建微服务架构的系统。</p>\n\n<p>\xa0</p>\n\n<p>一段时间没日没夜的加班，好不容易核心业务系统给做出来了，平时正常QA测试没发现什么大毛病，感觉性能还不错，一切都很完美。</p>\n</blockquote>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>然后系统就这么上线了，一开始用户规模很小，注册用户量小几十万，日活几千用户。</p>\n\n<p>\xa0</p>\n\n<p>每天都有新的数据进入数据库的表中，就这么日积月累的，没想到数据规模居然慢慢吞吞增长到了单表几百万。</p>\n\n<p>\xa0</p>\n\n<p>这个时候呢，看起来也没太大的毛病，就是有用户反映，系统有些操作，会感觉卡顿几秒钟，会刷不出来页面。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这是为啥呢？</p>\n\n<ul><li>\n\t<p>核心原因是单表数据量大了一些，达到了几百万。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>有个别服务，跑的SQL比较复杂，一大堆的多表关联</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<ul><li>\n\t<p>并且还没有设计好索引，或者是设计了索引，但无奈一些小弟写了上百行的大SQL，SQL实在太复杂了，那么一个SQL跑出来好几秒肯定是正常的。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如果大家对微服务框架有点了解的话，应该知道，比如Feign + Ribbon组成的服务调用框架，是有接口调用超时这一说的，有一些参数可以设置接口调用的超时时间。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如果你调用一个接口，好几秒刷不出来，人家就超时异常返回，用户就刷不出来页面了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>三、扬汤止沸，饮鸩止渴</strong></p>\n\n<p>\xa0</p>\n\n<p>一般碰到这种事情，一大坨屎一样的SQL摆在那儿，写SQL的人过一个月自己都看不懂了，80%的工程师看着都不愿意去花时间重写和优化。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>一是修改的人力成本太高，二是谁敢负担这责任呢？</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>系统跑的好好的，就是慢了点而已，结果你硬是乱改一通，重构，把系统核心业务流程搞挂了怎么办？</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>所以，那些兄弟第一反应是：增加超时时间啊！接口慢点可以，但是别超时不响应啊！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>咱们让接口执行个几秒把结果返回，用户不就可以刷出来页面了！不用重构系统了啊！轻松+愉快！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如何增加呢？很简单，看下面的参数就知道了：</p>\n\n<p>\xa0</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113100947173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>大家如果看过之前的文章，应该知道，Spring Cloud里一般会用hystrix的线程池来执行接口调用的请求。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如果忘了这一点的，可以回头看看<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247483712&amp;idx=1&amp;sn=4cd88761830428a2e485ac4c2cf120f9&amp;chksm=fba6e943ccd16055344222ce9c794358e1a4a84fdf4263eaa7c91e9756597bd06e49f9b390cb&amp;scene=21#wechat_redirect" rel="nofollow">《拜托，面试请不要再问我Spring Cloud底层原理！》</a>。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>所以设置超时一般设置两个地方，feign和ribbon那块的超时，还有hystrix那块的超时。其中后者那块的超时一般必须大于前者。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>Spring Cloud玩儿的好的兄弟，可千万别看着这些配置发笑，因为我确实见过不少Spring Cloud玩儿的没那么溜的哥们，真的就这么干了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>好了，日子在继续。。。</strong></p>\n\n<p>\xa0</p>\n\n<p>优化了参数后，看上去效果不错，用户虽然觉得有的页面慢是慢点，但是起码过几秒能刷出来。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这个时候，日活几千的用户量，压根儿没什么并发可言，高峰期每秒最多一二十并发请求罢了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>大家看看下面这张图，感受一下现场氛围：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113101001735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>四、问题爆发，洪水猛兽</strong></p>\n\n<p>\xa0</p>\n\n<p><strong>随着时间的推移，公司业务高速发展……</strong></p>\n\n<p>\xa0</p>\n\n<p>那位兄弟的公司，在系统打磨成熟，几万用户试点都ok之后，老板立马拿到一轮几千万的融资。</p>\n\n<p>\xa0</p>\n\n<p>公司上上下下意气风发啊！紧接着就是组建运营团队，地推团队，全国大范围的推广。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>总之就是三个字</strong>：<strong>推！</strong><strong>推！</strong><strong>推！</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这一推不打紧！研发人员在后台系统发现，自己的用户量蹭蹭蹭的直线增长。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>注册用户增长了几十倍，突破了千万级别，日活用户也翻了几十倍，在活动之类的高峰期，居然达到了上百万的日活用户量！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>幸福的烦恼。。。</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>为什么这么说？因为用户量上来后，悲剧的事情就发生了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>高峰期每秒的并发请求居然达到了近万的程度，</strong>研发团队的兄弟们哪里敢怠慢！在这个过程中，先是紧张的各种扩容服务，一台变两台，两台变四台。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>然后数据库主从架构挂上去，读写分离是必须的，否则单个数据库服务器哪能承载那么大的请求！多搞几个从库，扛一下大量的读请求，这样基本就扛住了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>正准备坐下来喝口茶、松口气，更加悲剧的事情就发生了。</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>在这个过程中，那些兄弟经常会发现高峰期，系统的某个功能页面，突然就整个hang死了，就是没法再响应任何请求！所有用户刷新这个页面全部都是无法响应！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这是为什么呢？原因很简单啊！一个服务A的实例里，专门调用服务B的那个线程池里的线程，总共可能就几十个。每个线程调用服务B都会卡住5秒钟。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>那如果每秒钟过来几百个请求这个服务实例呢？一下子那个线程池里的线程就全部hang死了，没法再响应任何请求了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>大家来看看下面这张图，再直观的感受一下这个无助的过程！</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113101016495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>这个时候咋办？兄弟们只能祭出程序员最古老的法宝，重启机器！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>遇到页面刷不出来，只能重启机器，相当于短暂的初始化了一下机器内的资源。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>然后接着运行一段时间，又卡死，再次重启！真是令人崩溃啊！用户们的体验是极差的，老板的心情是愤怒的！</p>\n\n<p><br>\n\xa0</p>\n\n<p><strong>画外音：</strong></p>\n\n<p>其实这个问题本身不大，但如果对Spring Cloud没有高并发场景的真实经验，确实可能会跟这帮兄弟一样，搞出些莫名其妙的问题。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>比如这个公司，明明应该去优化服务接口性能，结果硬是调大了超时时间。结果导致并发量高了，对那个服务的调用直接hang死，系统的核心页面刷不出来，影响用户体验了，这怪谁呢？</p>\n\n<p><br>\n\xa0</p>\n\n<p><strong>五、追本溯源，治标治本</strong></p>\n\n<p>\xa0</p>\n\n<p>没法子了，那帮兄弟们只能找人求助。<strong>下面</strong><strong>就是作者全程指导他们完成系统优化的过程。</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>第一步</strong></p>\n\n<p>\xa0</p>\n\n<p><strong>关键点，优化图中核心服务B的性能</strong>。互联网公司，核心业务逻辑，面向C端用户高并发的请求，不要用上百行的大SQL，多表关联，那样单表几百万行数据量的话，会导致一下执行好几秒。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>其实最佳的方式，就是对数据库就执行简单的单表查询和更新，然后复杂的业务逻辑全部放在java系统中来执行，比如一些关联，或者是计算之类的工作。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这一步干完了之后，那个核心服务B的响应速度就已经优化成几十毫秒了，是不是很开心？从几秒变成了几十毫秒！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>第二步</strong></p>\n\n<p>\xa0</p>\n\n<p>那个超时的时间，也就是上面那段ribbon和hystrix的超时时间设置。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>奉劝各位同学，不要因为系统接口的性能过差而懒惰，搞成几秒甚至几十秒的超时，<strong>一般</strong><strong>超时定义在1秒以内，是比较通用以及合理的。</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>为什么这么说？</p>\n\n<p>\xa0</p>\n\n<p>因为一个接口，理论的最佳响应速度应该在200ms以内，或者慢点的接口就几百毫秒。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如果一个接口响应时间达到1秒+，建议考虑用缓存、索引、NoSQL等各种你能想到的技术手段，优化一下性能。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>否则你要是胡乱设置超时时间是几秒，甚至几十秒，万一下游服务偶然出了点问题响应时间长了点呢？那你这个线程池里的线程立马全部卡死！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>具体hystrix的线程池以及超时时间的最佳生产实践，请见下一篇文章：《微服务架构如何保障双11狂欢下的99.99%高可用》</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这两步解决之后，其实系统表现就正常了，核心服务B响应速度很快，而且超时时间也在1秒以内，不会出现hystrix线程池频繁卡死的情况了。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>第三步</strong></p>\n\n<p>\xa0</p>\n\n<p>事儿还没完，你要真觉得两步就搞定了，那还是经验不足。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>如果你要是超时时间设置成了1秒，如果就是因为偶然发生的网络抖动，导致接口某次调用就是在1.5秒呢？这个是经常发生的，因为网络的问题，接口调用偶然超时。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>所以此时配合着超时时间，一般都会设置一个合理的重试，如下所示：</p>\n\n<p>\xa0</p>\n\n<p><img alt="" class="has" height="182" src="https://img-blog.csdnimg.cn/20181113101032394.png" width="417"></p>\n\n<p>\xa0</p>\n\n<p>设置这段重试之后，Spring Cloud中的Feign + Ribbon的组合，在进行服务调用的时候，如果发现某台机器超时请求失败，会自动重试这台机器，如果还是不行会换另外一台机器重试。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>这样由于偶尔的网络请求造成的超时，不也可以通过自动重试避免了？</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>第四步</strong></p>\n\n<p>\xa0</p>\n\n<p>其实事儿还没完，如果把重试参数配置了，结果你居然就放手了，那还是没对人家负责任啊！</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>你的系统架构中，<strong>只要涉及到了重试，那么必须上接口的幂等性保障机制</strong>。</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>否则的话，试想一下，你要是对一个接口重试了好几次，结果人家重复插入了多条数据，该怎么办呢？</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>其实幂等性保证本身并不复杂，根据业务来，常见的方案：</p>\n\n<p>\xa0</p>\n\n<ul><li>\n\t<p>可以在数据库里建一个唯一索引，插入数据的时候如果唯一索引冲突了就不会插入重复数据</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>或者是通过redis里放一个唯一id值，然后每次要插入数据，都通过redis判断一下，那个值如果已经存在了，那么就不要插入重复数据了。</p>\n\t</li>\n</ul><p>\xa0</p>\n\n<p>类似这样的方案还有一些。总之，<strong>要</strong><strong>保证一个接口被多次调用的时候，不能插入重复的数据。</strong><br>\n\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>六、总结全文，回眸再看</strong></p>\n\n<p>\xa0</p>\n\n<p>有图有真相！老规矩，最后给大家上一张图，最终优化后的系统表现大概是长下面这样子的。</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181113101044347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！</strong></p>\n\n<p>\xa0</p>\n\n<p>作者：中华石杉，十余年BAT架构经验，倾囊相授。个人微信公众号：石杉的架构笔记（ID:shishan100）</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持下作者吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 （转载本站文章请注明作者和出处\xa0<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a>）</strong></p>\n\n<p>\xa0</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84313907', 'title': '条件注解 @ConditionalOnBean 的正确使用姿势', 'readNum': '22729', 'commentNum': '1', 'publishTime': '2019-02-27 14:53:01', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文转载于公众号“吉姆餐厅ak”</p>\n</blockquote>\n\n<p>条件注解是<code>Spring4</code>提供的一种bean加载特性，主要用于控制配置类和bean初始化条件。在<code>springBoot，springCloud</code>一系列框架底层源码中，条件注解的使用到处可见。</p>\n\n<p>不少人在使用\xa0@ConditionalOnBean\xa0注解时会遇到不生效的情况，依赖的 bean 明明已经配置了，但就是不生效。是不是<code>@ConditionalOnBean</code>和\xa0Bean加载的顺序有没有关系呢？</p>\n\n<p><strong>本篇文章就针对这个问题，跟着源码，一探究竟。</strong></p>\n\n<hr><p>问题演示：</p>\n\n<pre class="has">\n<code>@Configuration\npublic\xa0class\xa0Configuration1\xa0{\n\n\xa0\xa0\xa0\xa0@Bean\n\xa0\xa0\xa0\xa0@ConditionalOnBean(Bean2.class)\n\xa0\xa0\xa0\xa0public\xa0Bean1\xa0bean1()\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0new\xa0Bean1();\n\xa0\xa0\xa0\xa0}\n}\n\n</code></pre>\n\n<pre class="has">\n<code>@Configuration\npublic\xa0class\xa0Configuration2\xa0{\n\n\xa0\xa0\xa0\xa0@Bean\n\xa0\xa0\xa0\xa0public\xa0Bean2\xa0bean2(){\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0new\xa0Bean2();\n\xa0\xa0\xa0\xa0}\n}\n</code></pre>\n\n<p>运行结果：<br><code>@ConditionalOnBean(Bean2.class)</code>返回false。明明定义的有bean2，<code>bean1</code>却未加载。</p>\n\n<hr><p>源码分析</p>\n\n<p>首先要明确一点，条件注解的解析一定发生在spring ioc的<code>bean definition</code>阶段，因为 spring bean初始化的前提条件就是有对应的<code>bean definition</code>，条件注解正是通过判断<code>bean definition</code>来控制bean能否被解析。</p>\n\n<p>对上述示例进行源码调试。</p>\n\n<p>从 bean definition解析的入口开始：<code>ConfigurationClassPostProcessor</code></p>\n\n<pre class="has">\n<code>\xa0\xa0\xa0\xa0@Override\n\xa0\xa0\xa0\xa0public\xa0void\xa0postProcessBeanDefinitionRegistry(BeanDefinitionRegistry\xa0registry)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0int\xa0registryId\xa0=\xa0System.identityHashCode(registry);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(this.registriesPostProcessed.contains(registryId))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0throw\xa0new\xa0IllegalStateException(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"postProcessBeanDefinitionRegistry\xa0already\xa0called\xa0on\xa0this\xa0post-processor\xa0against\xa0"\xa0+\xa0registry);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(this.factoriesPostProcessed.contains(registryId))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0throw\xa0new\xa0IllegalStateException(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"postProcessBeanFactory\xa0already\xa0called\xa0on\xa0this\xa0post-processor\xa0against\xa0"\xa0+\xa0registry);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.registriesPostProcessed.add(registryId);\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//\xa0解析bean\xa0definition入口\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0processConfigBeanDefinitions(registry);\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>跟进<code>processConfigBeanDefinitions</code>方法：</p>\n\n<pre class="has">\n<code>public\xa0void\xa0processConfigBeanDefinitions(BeanDefinitionRegistry\xa0registry)\xa0{\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//省略不必要的代码...\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//解析候选bean，先获取所有的配置类，也就是@Configuration标注的类\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0parser.parse(candidates);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0parser.validate();\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//配置类存入集合\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Set&lt;ConfigurationClass&gt;\xa0configClasses\xa0=\xa0new\xa0LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0configClasses.removeAll(alreadyParsed);\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//\xa0Read\xa0the\xa0model\xa0and\xa0create\xa0bean\xa0definitions\xa0based\xa0on\xa0its\xa0content\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(this.reader\xa0==\xa0null)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.reader\xa0=\xa0new\xa0ConfigurationClassBeanDefinitionReader(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0registry,\xa0this.sourceExtractor,\xa0this.resourceLoader,\xa0this.environment,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.importBeanNameGenerator,\xa0parser.getImportRegistry());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//开始解析配置类，也就是条件注解解析的入口\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.reader.loadBeanDefinitions(configClasses);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0alreadyParsed.addAll(configClasses);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//...\n\n}\n</code></pre>\n\n<p>跟进条件注解解析入口<code>loadBeanDefinitions</code>，开始循环解析所有的配置类。这里是所有自定义的配置类和自动装配的配置类，如下：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181121095055112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>上述代码开始解析配置类。如果配置类中有@Bean标注的方法，则会调用<code>loadBeanDefinitionsForBeanMethod()</code>来获得所有方法。然后循环解析，解析时会执行如下校验方法，也正是条件注解的入口：</p>\n\n<pre class="has">\n<code>public\xa0boolean\xa0shouldSkip(@Nullable\xa0AnnotatedTypeMetadata\xa0metadata,\xa0@Nullable\xa0ConfigurationPhase\xa0phase)\xa0{\n\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//判断是否有条件注解，否则直接返回\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(metadata\xa0==\xa0null\xa0||\xa0!metadata.isAnnotated(Conditional.class.getName()))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0false;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(phase\xa0==\xa0null)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(metadata\xa0instanceof\xa0AnnotationMetadata\xa0&amp;&amp;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata)\xa0metadata))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0shouldSkip(metadata,\xa0ConfigurationPhase.PARSE_CONFIGURATION);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0shouldSkip(metadata,\xa0ConfigurationPhase.REGISTER_BEAN);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//获取当前定义bean的方法上，所有的条件注解\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0List&lt;Condition&gt;\xa0conditions\xa0=\xa0new\xa0ArrayList&lt;&gt;();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for\xa0(String[]\xa0conditionClasses\xa0:\xa0getConditionClasses(metadata))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for\xa0(String\xa0conditionClass\xa0:\xa0conditionClasses)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Condition\xa0condition\xa0=\xa0getCondition(conditionClass,\xa0this.context.getClassLoader());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0conditions.add(condition);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//根据Order来进行排序\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0AnnotationAwareOrderComparator.sort(conditions);\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//遍历条件注解，开始执行条件注解的流程\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for\xa0(Condition\xa0condition\xa0:\xa0conditions)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurationPhase\xa0requiredPhase\xa0=\xa0null;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(condition\xa0instanceof\xa0ConfigurationCondition)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0requiredPhase\xa0=\xa0((ConfigurationCondition)\xa0condition).getConfigurationPhase();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//这里执行条件注解的\xa0condition.matches\xa0方法来进行匹配，返回布尔值\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0((requiredPhase\xa0==\xa0null\xa0||\xa0requiredPhase\xa0==\xa0phase)\xa0&amp;&amp;\xa0!condition.matches(this.context,\xa0metadata))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0true;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0false;\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>继续跟进条件注解的匹配方法，开始解析示例代码中<code>bean1</code>的配置：</p>\n\n<pre class="has">\n<code>\xa0\xa0\xa0@Bean\n\xa0\xa0\xa0\xa0@ConditionalOnBean(Bean2.class)\n\xa0\xa0\xa0\xa0public\xa0Bean1\xa0bean1()\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0new\xa0Bean1();\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p><code><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181121095036499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></code></p>\n\n<p><code>在getMatchOutcome</code>方法中，参数<code>metadata</code>是要解析的目标bean，也就是<code>bean1</code>。条件注解依赖的<code>bean</code>被封装成了<code>BeanSearchSpec</code>，从名字可以看出是要寻找的对象，这是一个静态内部类，构造方法如下：</p>\n\n<pre class="has">\n<code>BeanSearchSpec(ConditionContext\xa0context,\xa0AnnotatedTypeMetadata\xa0metadata,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Class&lt;?&gt;\xa0annotationType)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.annotationType\xa0=\xa0annotationType;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//读取\xa0metadata中的设置的value\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0MultiValueMap&lt;String,\xa0Object&gt;\xa0attributes\xa0=\xa0metadata\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.getAllAnnotationAttributes(annotationType.getName(),\xa0true);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//设置各参数，根据这些参数进行寻找目标类\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0collect(attributes,\xa0"name",\xa0this.names);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0collect(attributes,\xa0"value",\xa0this.types);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0collect(attributes,\xa0"type",\xa0this.types);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0collect(attributes,\xa0"annotation",\xa0this.annotations);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0collect(attributes,\xa0"ignored",\xa0this.ignoredTypes);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0collect(attributes,\xa0"ignoredType",\xa0this.ignoredTypes);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.strategy\xa0=\xa0(SearchStrategy)\xa0metadata\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.getAnnotationAttributes(annotationType.getName()).get("search");\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0BeanTypeDeductionException\xa0deductionException\xa0=\xa0null;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0try\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(this.types.isEmpty()\xa0&amp;&amp;\xa0this.names.isEmpty())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0addDeducedBeanType(context,\xa0metadata,\xa0this.types);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0catch\xa0(BeanTypeDeductionException\xa0ex)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0deductionException\xa0=\xa0ex;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0validate(deductionException);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>继续跟进搜索bean的方法：</p>\n\n<pre class="has">\n<code>MatchResult\xa0matchResult\xa0=\xa0getMatchingBeans(context,\xa0spec);\n</code></pre>\n\n<pre class="has">\n<code>private\xa0MatchResult\xa0getMatchingBeans(ConditionContext\xa0context,\xa0BeanSearchSpec\xa0beans)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurableListableBeanFactory\xa0beanFactory\xa0=\xa0context.getBeanFactory();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(beans.getStrategy()\xa0==\xa0SearchStrategy.ANCESTORS)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0BeanFactory\xa0parent\xa0=\xa0beanFactory.getParentBeanFactory();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Assert.isInstanceOf(ConfigurableListableBeanFactory.class,\xa0parent,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0"Unable\xa0to\xa0use\xa0SearchStrategy.PARENTS");\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0beanFactory\xa0=\xa0(ConfigurableListableBeanFactory)\xa0parent;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0MatchResult\xa0matchResult\xa0=\xa0new\xa0MatchResult();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0boolean\xa0considerHierarchy\xa0=\xa0beans.getStrategy()\xa0!=\xa0SearchStrategy.CURRENT;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0List&lt;String&gt;\xa0beansIgnoredByType\xa0=\xa0getNamesOfBeansIgnoredByType(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0beans.getIgnoredTypes(),\xa0beanFactory,\xa0context,\xa0considerHierarchy);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//因为实例代码中设置的是类型，所以这里会遍历类型，根据type获取目标bean是否存在\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for\xa0(String\xa0type\xa0:\xa0beans.getTypes())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Collection&lt;String&gt;\xa0typeMatches\xa0=\xa0getBeanNamesForType(beanFactory,\xa0type,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.getClassLoader(),\xa0considerHierarchy);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0typeMatches.removeAll(beansIgnoredByType);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(typeMatches.isEmpty())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0matchResult.recordUnmatchedType(type);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0matchResult.recordMatchedType(type,\xa0typeMatches);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//根据注解寻找\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for\xa0(String\xa0annotation\xa0:\xa0beans.getAnnotations())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0List&lt;String&gt;\xa0annotationMatches\xa0=\xa0Arrays\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.asList(getBeanNamesForAnnotation(beanFactory,\xa0annotation,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.getClassLoader(),\xa0considerHierarchy));\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0annotationMatches.removeAll(beansIgnoredByType);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(annotationMatches.isEmpty())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0matchResult.recordUnmatchedAnnotation(annotation);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0matchResult.recordMatchedAnnotation(annotation,\xa0annotationMatches);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//根据设置的name进行寻找\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0for\xa0(String\xa0beanName\xa0:\xa0beans.getNames())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(!beansIgnoredByType.contains(beanName)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&amp;&amp;\xa0containsBean(beanFactory,\xa0beanName,\xa0considerHierarchy))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0matchResult.recordMatchedName(beanName);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0matchResult.recordUnmatchedName(beanName);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0matchResult;\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p><code>getBeanNamesForType()</code>方法最终会委托给<code>BeanTypeRegistry</code>类的<code>getNamesForType</code>方法来获取对应的指定类型的bean name：</p>\n\n<pre class="has">\n<code>\xa0\xa0\xa0\xa0Set&lt;String&gt;\xa0getNamesForType(Class&lt;?&gt;\xa0type)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//同步spring容器中的bean\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0updateTypesIfNecessary();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//返回指定类型的bean\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0this.beanTypes.entrySet().stream()\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.filter((entry)\xa0-&gt;\xa0entry.getValue()\xa0!=\xa0null\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&amp;&amp;\xa0type.isAssignableFrom(entry.getValue()))\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.map(Map.Entry::getKey)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.collect(Collectors.toCollection(LinkedHashSet::new));\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>重点来了。<br>\n上述方法中的第一步便是同步bean，也就是获取此时 spring 容器中的所有 beanDifinition。只有这样，条件注解的判断才有意义。</p>\n\n<p>我们跟进<code>updateTypesIfNecessary()</code>：</p>\n\n<pre class="has">\n<code>\xa0\xa0\xa0\xa0private\xa0void\xa0updateTypesIfNecessary()\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//这里lastBeanDefinitionCount\xa0代表已经同步的数量，如果和容器中的数量不相等，才开始同步。\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//否则，获取beanFactory迭代器，开始同步。\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(this.lastBeanDefinitionCount\xa0!=\xa0this.beanFactory.getBeanDefinitionCount())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Iterator&lt;String&gt;\xa0names\xa0=\xa0this.beanFactory.getBeanNamesIterator();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0while\xa0(names.hasNext())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0String\xa0name\xa0=\xa0names.next();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(!this.beanTypes.containsKey(name))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0addBeanType(name);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0//同步完之后，更新已同步的beanDefinition数量。\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.lastBeanDefinitionCount\xa0=\xa0this.beanFactory.getBeanDefinitionCount();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>离答案只差一步了，就是看一下从<code>beanFactory</code>中迭代的是哪些<code>beanDefinition</code>？</p>\n\n<p><code>继续跟进getBeanNamesIterator()</code>：</p>\n\n<pre class="has">\n<code>@Override\n\xa0\xa0\xa0\xa0public\xa0Iterator&lt;String&gt;\xa0getBeanNamesIterator()\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0CompositeIterator&lt;String&gt;\xa0iterator\xa0=\xa0new\xa0CompositeIterator&lt;&gt;();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0iterator.add(this.beanDefinitionNames.iterator());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0iterator.add(this.manualSingletonNames.iterator());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0iterator;\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>分别来看：</p>\n\n<ul><li>\n\t<p><code>beanDefinitionNames</code>就是存储一些自动解析和装配的bean，我们的启动类、配置类、<code>controller、service</code>等。</p>\n\t</li>\n\t<li>\n\t<p><code>manualSingletonNames</code>，从名字可以看出，手工单例名称。什么意思呢？在\xa0<code>spring ioc</code>的过程中，会手动触发一些bean的注册。比如在<code>springboot</code>启动过程中，会显示的注册一些配置 bean，如:<br><code>springBootBanner,systemEnvironment,systemProperties</code>等。</p>\n\t</li>\n</ul><p>我们来分析一下上面示例<code>bean1</code>为何没有实例化？</p>\n\n<p><strong>在<code>spring ioc</code>的过程中，优先解析<code>@Component，@Service，@Controller</code>注解的类。其次解析配置类，也就是<code>@Configuration</code>标注的类。最后开始解析配置类中定义的<code>bean</code>。\xa0</strong></p>\n\n<p><strong>示例代码中<code>bean1</code>是定义在配置类中的，当执行到配置类解析的时候，<code>@Component，@Service，@Controller ,@Configuration</code>标注的类已经全部扫描，所以这些<code>BeanDifinition</code>已经被同步。 但是<code>bean1</code>的条件注解依赖的是<code>bean2</code>，<code>bean2</code>是被定义的配置类中的，所以此时配置类的解析无法保证先后顺序，就会出现不生效的情况。</strong></p>\n\n<p><strong>同样的道理，如果依赖的是<code>FeignClient</code>，可以设想一下结果？<code>FeignClient</code>最终还是由配置类触发的，解析的先后顺序同样也不能保证。</strong></p>\n\n<hr><p>解决</p>\n\n<p>以下两种方式：</p>\n\n<ul><li>\n\t<p>项目中条件注解依赖的类，大多会交给<code>spring</code>容器管理，所以如果要在配置中<code>Bean</code>通过<code>@ConditionalOnBean</code>依赖配置中的<code>Bean</code>时，完全可以用<code>@ConditionalOnClass(Bean2.class)</code>来代替。</p>\n\n\t<p>\xa0</p>\n\t</li>\n\t<li>\n\t<p>如果一定要区分两个配置类的先后顺序，可以将这两个类交与<code>EnableAutoConfiguration</code>管理和触发。也就是定义在<code>META-INF\\spring.factories</code>中声明是配置类，然后通过<code>@AutoConfigureBefore、AutoConfigureAfter\xa0 AutoConfigureOrder</code>控制先后顺序。之所以这么做是因为这三个注解只对自动配置类的先后顺序生效。</p>\n\n\t<p>\xa0</p>\n\n\t<p>这里推荐第一种。</p>\n\t</li>\n</ul><hr><p>总结</p>\n\n<p><strong>在配置类中定义<code>Bean</code>，如果使用<code>@ConditionalOnBean</code>注解依赖的<code>Bean</code>是通过配置类触发解析的，则执行结果依赖配置类加载顺序</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p><strong>### 更多阅读</strong></p>\n\n<p><strong>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</strong></p>\n\n<p><strong>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</strong></p>\n\n<p><strong>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</strong></p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持博主吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0</strong></p>\n\n<p>\xa0</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84503386', 'title': '分布式事务的实现原理', 'readNum': '14450', 'commentNum': '1', 'publishTime': '2019-02-27 14:52:50', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章，原文出处： <a href="https://draveness.me/distributed-transaction-principle" rel="nofollow">https://draveness.me/distributed-transaction-principle</a></p>\n</blockquote>\n<p>事务是数据库系统中非常有趣也非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全不执行；在 SOA 与微服务架构大行其道的今天，在分布式的多个服务中保证业务的一致性就需要我们实现分布式事务。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0a747e74d0c90269.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>在这篇文章中，我们将介绍 事务的实现原理、分布式事务的理论基础以及实现原理。</p>\n<h2><a id="_10"></a>事务</h2>\n<p>在文章的开头，我们已经说过事务是数据库管理系统执行过程中的一个逻辑单位，它能保证一组数据库操作要么全部执行，要么全不执行，我们能够通过事务将数据库从一个状态迁移到另一个状态，在每一个状态中，数据库中的数据都保持一致性。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-f89f81d0e302d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>数据库事务拥有四个特性，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）：</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-1b7534deb56dc904.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>我们经常将这上述的四大特性简写为 ACID，而数据库事务的实现原理其实也就是实现这四大特性的原理。</p>\n<h2><a id="_22"></a>实现原理</h2>\n<p>在之前的文章 『浅入深出』MySQL 中事务的实现 中其实已经对如何实现事务的 ACID 这几个基本属性给出了比较详细的介绍和分析，在这里就简单介绍几个比较重要的实现细节，关于展开的内容，可以阅读上述文章。</p>\n<h3><a id="_26"></a>事务日志</h3>\n<p>为了实现确保事务能在执行的任意过程中回滚（原子性）并且提交的事务会永久保存在数据库中，我们会使用事务日志来存储事务执行过程中的数据库的变动，每一条事务日志中都包含事务的 ID、当前被修改的元素、变动前以及变动后的值。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-5e80af5d0f743a07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>当我们有以上的事务日志之后，一旦需要对事务进行回滚就非常容易了，数据库会根据上述日志生成一个相反的操作恢复事务发生之前的状态；事务日志除了能够对事务进行回滚保证原子性之外，还能够实现持久性，当一个事务常食对数据库进行修改时，它其实会先生成一条日志并刷新到磁盘上，写日志的操作由于是追加的所以非常快，在这之后才会向数据库中写入或者更新对应的记录。</p>\n<p>在 MySQL 最常见的存储引擎 InnoDB 中，事务日志其实有两种，一种是回滚日志（undo log），另一种是重做日志（redo log），其中前者保证事务的原子性，后者保证事务的持久性，两者可以统称为事务日志。</p>\n<h3><a id="_37"></a>并发控制</h3>\n<p>数据库作为最关键的后端服务，很难想象只能串行执行每一个数据库操作带来的性能影响，然而在并发执行 SQL 的过程中就可能无法保证数据库对于隔离性的要求，归根结底这就是一致性、隔离性与性能之间的权衡。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-f007924028c7cce0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>为了避免并发带来的一致性问题、满足数据库对于隔离性要求，数据库系统往往都会使用并发控制机制尽可能地充分利用机器的效率，最常见的几种并发控制机制就是锁、时间戳和 MVCC：</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-5444e35bf710cd35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>作为悲观并发控制机制，锁使用在更新资源之前对资源进行锁定的方式保证多个数据库的会话同时修改某一行记录时不会出现脱离预期的行为，而时间戳这种方式在每次提交时对资源是否被改变进行检查。</p>\n<blockquote>\n<p>在 浅谈数据库并发控制 - 锁和 MVCC 中，作者介绍过几种不同的并发控制机制的实现原理，想要了解更多相关的内容的可以阅读这篇文章。</p>\n</blockquote>\n<h2><a id="_57"></a>分布式事务</h2>\n<p>从广义上来看，分布式事务其实也是事务，只是由于业务上的定义以及微服务架构设计的问题，所以需要在多个服务之间保证业务的事务性，也就是 ACID 四个特性；从单机的数据库事务变成分布式事务时，原有单机中相对可靠的方法调用以及进程间通信方式已经没有办法使用，同时由于网络通信经常是不稳定的，所以服务之间信息的传递会出现障碍。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-f8bd2dadae4dc75f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>模块（或服务）之间通信方式的改变是造成分布式事务复杂的最主要原因，在同一个事务之间的执行多段代码会因为网络的不稳定造成各种奇怪的问题，当我们通过网络请求其他服务的接口时，往往会得到三种结果：正确、失败和超时，无论是成功还是失败，我们都能得到唯一确定的结果，超时代表请求的发起者不能确定接受者是否成功处理了请求，这也是造成诸多问题的诱因。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-5e41e0aea21dcd9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>系统之间的通信可靠性从单一系统中的可靠变成了微服务架构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。无论是事务还是分布式事务实现原子性都无法避免对持久存储的依赖，事务使用磁盘上的日志记录执行的过程以及上下文，这样无论是需要回滚还是补偿都可以通过日志追溯，而分布式事务也会依赖数据库、Zookeeper 或者 ETCD 等服务追踪事务的执行过程，总而言之，各种形式的日志是保证事务几大特性的重要手段。</p>\n<h3><a id="2PC__3PC_70"></a>2PC 与 3PC</h3>\n<p>两阶段提交是一种使分布式系统中所有节点在进行事务提交时保持一致性而设计的一种协议；在一个分布式系统中，所有的节点虽然都可以知道自己执行操作后的状态，但是无法知道其他节点执行操作的状态，在一个事务跨越多个系统时，就需要引入一个作为协调者的组件来统一掌控全部的节点并指示这些节点是否把操作结果进行真正的提交，想要在分布式系统中实现一致性的其他协议都是在两阶段提交的基础上做的改进。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a04500c4b5de033a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>两阶段提交的执行过程就跟它的名字一样分为两个阶段，投票阶段和提交阶段，在投票阶段中，协调者（Coordinator）会向事务的参与者（Cohort）询问是否可以执行操作的请求，并等待其他参与者的响应，参与者会执行相对应的事务操作并记录重做和回滚日志，所有执行成功的参与者会向协调者发送 AGREEMENT 或者 ABORT 表示执行操作的结果。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8e55b62e5d271d55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>当所有的参与者都返回了确定的结果（同意或者终止）时，两阶段提交就进入了提交阶段，协调者会根据投票阶段的返回情况向所有的参与者发送提交或者回滚的指令。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-478a43c97c4d214f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>当事务的所有参与者都决定提交事务时，协调者会向参与者发送 COMMIT 请求，参与者在完成操作并释放资源之后向协调者返回完成消息，协调者在收到所有参与者的完成消息时会结束整个事务；与之相反，当有参与者决定 ABORT 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会根据之前执行操作时的回滚日志对操作进行回滚并向协调者发送完成的消息，在提交阶段，无论当前事务被提交还是回滚，所有的资源都会被释放并且事务也一定会结束。</p>\n<p>两阶段提交协议是一个阻塞协议，也就是说在两阶段提交的执行过程中，除此之外，如果事务的执行过程中协调者永久宕机，事务的一部分参与者将永远无法完成事务，它们会等待协调者发送 COMMIT 或者 ROLLBACK 消息，甚至会出现多个参与者状态不一致的问题。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ffdde4986ee1ea48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<h3><a id="3PC_92"></a>3PC</h3>\n<p>为了解决两阶段提交在协议的一些问题，三阶段提交引入了超时机制和准备阶段，如果协调者或者参与者在规定的之间内没有接受到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务，准备阶段的引入其实让事务的参与者有了除回滚之外的其他选择。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6872e238a602e36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>当参与者向协调者发送 ACK 后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交中被阻塞住；上述的图片非常清楚地说明了在不同阶段，协调者或者参与者的超时会造成什么样的行为。</p>\n<h3><a id="XA__101"></a>XA 事务</h3>\n<p>MySQL 的 InnoDB 引擎其实能够支持分布式事务，也就是我们经常说的 XA 事务；XA 事务就是用了我们在上一节中提到的两阶段提交协议实现分布式事务，其中事务管理器为协调者，而资源管理器就是分布式事务的参与者。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6680b8d5cedbf7f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>到这里，其实我们已经能够清晰地知道 MySQL 中的 XA 事务是如何实现的：</p>\n<ul>\n<li>资源管理器提供了访问事务资源的能力，数据库就是一种常见的资源管理器，它能够提交或者回滚其管理的事务；</li>\n<li>事务管理器协调整个分布式事务的各个部分，它与多个资源管理器通信，分别处理他们管理的事务，这些事务都是整体事务的一个分支。</li>\n</ul>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8681f67209b3e756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>正如两阶段提交协议中定义的，MySQL 提供的 XA 接口可以非常方便地实现协议中的投票和提交阶段，我们可以通过一下的流程图简单理解一下 MySQL XA 的接口是如何使用的：</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8d9a7aa9d603e554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>XA 确实能够保证较强的一致性，但是在 MySQL XA 的执行过程中会对相应的资源加锁，阻塞其他事务对该资源的访问，如果事务长时间没有 COMMIT 或者 ROLLBACK，其实会对数据库造成比较严重的影响。</p>\n<h3><a id="Saga_125"></a>Saga</h3>\n<p>两阶段提交其实可以保证事务的强一致性，但是在很多业务场景下，我们其实只需要保证业务的最终一致性，在一定的时间窗口内，多个系统中的数据不一致是可以接受的，在过了时间窗口之后，所有系统都会返回一致的结果。</p>\n<p>Saga 其实就一种简化的分布式事务解决方案，它将一系列的分布式操作转化成了一系列的本地事务，在每一个本地事务中我们都会更新数据库并且向集群中的其他服务发送一条的新的消息来触发下一个本地的事务；一旦本地的事务因为违反了业务逻辑而失败，那么就会立刻触发一系列的回滚操作来撤回之前本地事务造成的副作用。</p>\n<h3><a id="LLT_133"></a>LLT</h3>\n<p>相比于本地的数据库事务来说，长事务（Long Lived Transaction）会对一些数据库资源持有相对较长的一段时间，这会严重地影响其他正常数据库事务的执行，为了解决这一问题，Hector Garcia-Molina 和 Kenneth Salem 在 1987 发布了论文 Sagas 用于解决这一问题。</p>\n<p>如果一个 LLT 能够被改写成一系列的相互交错重叠的多个数据库事务，那么这个 LLT 就是一个 Saga；数据库系统能够保证 Saga 中一系列的事务要么全部成功执行、要么它们的补偿事务能够回滚全部的副作用，保证整个分布式事务的最终一致性。Saga 的概念和它的实现都是非常简单的，但是它却能够有很大的潜力增加整个系统的处理能力。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-e61fbcac74416c33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>事务越长并且越复杂，那么这个事务由于异常而被回滚以及死锁的可能性就会逐渐增加，Saga 会将一个 LLT 分解成多个短事务，能够非常明显地降低事务被回滚的风险。</p>\n<h3><a id="_145"></a>协同与编排</h3>\n<p>当我们使用 Saga 模式开发分布式事务时，有两种协调不同服务的方式，一种是协同（Choreography），另一种是编排（Orchestration）：</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-008be219a377e15f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>如果对于一个分布式事务，我们采用协同的方式进行开发，每一个本地的事务都会触发一个其他服务中的本地事务的执行，也就是说事务的执行过程是一个流的形式进行的：</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a136e02d6630b51c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>当我们选择使用协同的方式处理事务时，服务之间的通信其实就是通过事件进行的，每一个本的事务最终都会向服务的下游发送一个新的事件，既可以是消息队列中的消息，也可以是 RPC 的请求，只是下游提供的接口需要保证幂等和重入。</p>\n<p>除此之外，通过协同方式创建的分布式事务其实并没有明显的中心化节点，多个服务参与者之间的交互协议要从全局来定义，每个服务能够处理以及发送的事件和接口都需要进行比较严谨的设计，尽可能提供抽象程度高的事件或者接口，这样各个服务才能实现自治并重用已有的代码和逻辑。</p>\n<p>如果我们不想使用协同的方式对分布式事务进行处理，那么也可以选择编排的方式实现分布式事务，编排的方式引入了中心化的协调器节点，我们通过一个 Saga 对象来追踪所有的子任务的调用情况，根据任务的调用情况决定是否需要调用对应的补偿方案，并在网络请求出现超时时进行重试:</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-f954d5288886a9d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>在这里我们就引入了一个中心化的『协调器』，它会保存当前分布式事务进行到底的状态，并根据情况对事务进行回滚或者提交操作，在服务编排的过程中，我们是从协调者本身触发考虑整个事务的执行过程的，相对于协同的方式，编排实现的过程相对来说更为简单。</p>\n<p>协同与编排其实是两种思路截然相反的模式，前者强调各个服务的自治与去中心化，后者需要一个中心化的组件对事务执行的过程进行统一的管理，两者的优缺点其实就是中心化与去中心化的优缺点，中心化的方案往往都会造就一个『上帝服务』，其中包含了非常多组织与集成其他节点的工作，也会有单点故障的问题，而去中心化的方案就会带来管理以及调试上的不便，当我们需要追踪一个业务的执行过程时就需要跨越多个服务进行，增加了维护的成本。</p>\n<h3><a id="_167"></a>下游约束</h3>\n<p>当我们选择使用 Saga 对分布式事务进行开发时，会对分布式事务的参与者有一定的约束，每一个事务的参与者都需要保证：</p>\n<p>提供接口和补偿副作用的接口；<br>\n接口支持重入并通过全局唯一的 ID 保证幂等；<br>\n这样我们就能够保证一个长事务能够在网络通信发生超时时进行重试，同时在需要对事务进行回滚时调用回滚接口达到我们的目的。</p>\n<h3><a id="_176"></a>小结</h3>\n<p>Saga 这种模式其实完全放弃了同时满足事务四大基本特性 ACID 的想法，而是选择降低实现分布式事务的难度并减少资源同步以及锁定带来的问题，选择实现 BASE(Basic Availability, Soft, Eventual consistency) 事务，达到业务上的基本可用以及最终一致性，在绝大多数的业务场景中，实现最终一致性就能够基本满足业务的全部需求，极端场景下还是应该选择两阶段提交或者干脆放弃分布式事务这种易错的实现方式，转而使用单机中的数据库事务来解决。</p>\n<h2><a id="_180"></a>消息服务</h2>\n<p>分布式事务带来复杂度的原因其实就是由于各个模块之间的通信不稳定，当我们发出一个网络请求时，可能的返回结果是成功、失败或者超时。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-97893112bee0ed1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>网络无论是返回成功还是失败其实都是一个确定的结果，当网络请求超时的时候其实非常不好处理，在这时调用方并不能确定这一次请求是否送达而且不会知道请求的结果，但是消息服务可以保证某条信息一定会送达到调用方；大多数消息服务都会提供两种不同的 QoS，也就是服务的等级。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-53feb6caac2e3b97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>\n<p>最常见的两种服务等级就是 At-Most-Once 和 At-Least-Once，前者能够保证发送方不对接收方是否能收到消息作保证，消息要么会被投递一次，要么不会被投递，这其实跟一次普通的网络请求没有太多的区别；At-Least-Once 能够解决消息投递失败的问题，它要求发送者检查投递的结果，并在失败或者超时时重新对消息进行投递，发送者会持续对消息进行推送，直到接受者确认消息已经被收到，相比于 At-Most-Once，At-Least-Once 因为能够确保消息的投递会被更多人使用。</p>\n<p>除了这两种常见的服务等级之外，还有另一种服务等级，也就是 Exactly-Once，这种服务等级不仅对发送者提出了要求，还对消费者提出了要求，它需要接受者对接收到的所有消息进行去重，发送者和接受者一方对消息进行重试，另一方对消息进行去重，两者分别部署在不同的节点上，这样对于各个节点上的服务来说，它们之间的通信就是 Exactly-Once 的，但是需要注意的是，Exacly-Once 一定需要接收方的参与。</p>\n<p>我们可以通过实现 AMQP 协议的消息队列来实现分布式事务，在协议的标准中定义了 tx_select、tx_commit 和 tx_rollback 三个事务相关的接口，其中 tx_select 能够开启事务，tx_commit 和 tx_rollback 分别能够提交或者回滚事务。</p>\n<p>使用消息服务实现分布式事务在底层的原理上与其他的方法没有太多的差别，只是消息服务能够帮助我们实现的消息的持久化以及重试等功能，能够为我们提供一个比较合理的 API 接口，方便开发者使用。</p>\n<h2><a id="_198"></a>总结</h2>\n<p>分布式事务的实现方式是分布式系统中非常重要的一个问题，在微服务架构和 SOA 大行其道的今天，掌握分布式事务的原理和使用方式已经是作为后端开发者理所应当掌握的技能，从实现 ACID 事务的 2PC 与 3PC 到实现 BASE 补偿式事务的 Saga，再到最后通过事务消息的方式异步地保证消息最终一定会被消费成功，我们为了增加系统的吞吐量以及可用性逐渐降低了系统对一致性的要求。</p>\n<p>在业务没有对一致性有那么强的需求时，作者一般会使用 Saga 协议对分布式事务进行设计和开发，而在实际工作中，需要强一致性事务的业务场景几乎没有，我们都可以实现最终一致性，在发生脑裂或者不一致问题时通过补偿的方式进行解决，这就能解决几乎全部的问题。</p>\n<h3><a id="_204"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<p>原文链接</p>\n<p><a href="https://draveness.me/distributed-transaction-principle" rel="nofollow">https://draveness.me/distributed-transaction-principle</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84503495', 'title': '详解JVM内存管理与垃圾回收机制1 - 内存管理', 'readNum': '14407', 'commentNum': '0', 'publishTime': '2019-02-27 14:52:33', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章，原文链接：<a href="https://www.jianshu.com/p/f8d71e1e8821" rel="nofollow">https://www.jianshu.com/p/f8d71e1e8821</a></p>\n</blockquote>\n<p>Java应用程序是运行在JVM上的，得益于JVM的内存管理和垃圾收集机制，开发人员的效率得到了显著提升，也不容易出现内存溢出和泄漏问题。但正是因为开发人员把内存的控制权交给了JVM，一旦出现内存方面的问题，如果不了解JVM的工作原理，将很难排查错误。本文将从理论角度介绍虚拟机的内存管理和垃圾回收机制，算是入门级的文章，希望对大家的日常开发有所助益。</p>\n<h2><a id="_5"></a>一、内存管理</h2>\n<p>也许大家都有过这样的经历，在启动时通过-Xmx或者-XX:MaxPermSize这样的参数来显式的设置应用的堆(Heap)和永久代(Permgen)的内存大小，但为什么不直接设置JVM所占内存的大小，而要分别去设置不同的区域？JVM所管理的内存被分成多少区域？每个区域有什么作用？如何来管理这些区域？</p>\n<h3><a id="11__9"></a>1.1 运行时数据区</h3>\n<p>JVM在执行Java程序时会把其所管理的内存划分成多个不同的数据区域，每个区域的创建时间、销毁时间以及用途都各不相同。比如有的内存区域是所有线程共享的，而有的内存区域是线程隔离的。线程隔离的区域就会随着线程的启动和结束而创建和销毁。JVM所管理的内存将会包含以下几个运行时数据区域，如下图的上半部分所示。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190618205235795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="Method_Area__15"></a>Method Area (方法区)</h3>\n<p>方法区是所有线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。在Java虚拟机规范中，方法区属于堆的一个逻辑部分，但很多情况下，都把方法区与堆区分开来说。大家平时开发中通过反射获取到的类名、方法名、字段名称、访问修饰符等信息都是从这块区域获取的。</p>\n<p>对于HotSpot虚拟机，方法区对应为永久代(Permanent Generation)，但本质上，两者并不等价，仅仅是因为HotSpot虚拟机的设计团队是用永久代来实现方法区而已，对于其他的虚拟机(JRockit、J9)来说，是不存在永久代这一概念的。</p>\n<p>但现在看来，使用永久代来实现方法区并不是一个好注意，由于方法区会存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，在某些场景下非常容易出现永久代内存溢出。如Spring、Hibernate等框架在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。在JSP页面较多的情况下，也会出现同样的问题。可以通过如下代码来测试：</p>\n<pre><code>/**\n * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M(JDK6.0)\n * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M(JDK8.0)\n */\npublic class CGlibProxy {\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(ProxyObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                @Override\n                public Object intercept(Object o, Method method, Object[] os, MethodProxy proxy) throws Throwable {\n                    System.out.println("I am proxy");\n                    return proxy.invokeSuper(o,os);\n                }\n            });\n            ProxyObject proxy = (ProxyObject) enhancer.create();\n            proxy.greet();\n        }\n    }\n    static class ProxyObject {\n        public String greet() {\n            return "Thanks for you";\n        }\n    }\n}\n\n</code></pre>\n<p>在JDK1.8中运行一小会儿出现内存溢出错误：</p>\n<pre><code>Exception in thread "main" I am proxy\njava.lang.OutOfMemoryError: Metaspace\n    at org.mockito.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:238)\n    at org.mockito.cglib.proxy.Enhancer.createHelper(Enhancer.java:378)\n    at org.mockito.cglib.proxy.Enhancer.create(Enhancer.java:286)\n    at com.lwork.mdo.CGlibProxy.main(CGlibProxy.java:23)\n\n\n</code></pre>\n<p>在JDK1.8下并没有出现我们期望的永久代内存溢出错误，而是Metaspace内存溢出错误。这是因为Java团队从JDK1.7开始就逐渐移除了永久代，到JDK1.8时，永久代已经被Metaspace取代，因此在JDK1.8并没有出现我们期望的永久代内存溢出错误。在JDK1.8中，JVM参数-XX:PermSize和-XX:MaxPermSize已经失效，取而代之的是-XX:MetaspaceSize和XX:MaxMetaspaceSize。注意：Metaspace已经不再使用堆空间，转而使用Native Memory。关于Native Memory，下文会详细说明。</p>\n<p>还有一点需要说明的是，在JDK1.6中，方法区虽然被称为永久代，但并不意味着这些对象真的能够永久存在了，JVM的内存回收机制，仍然会对这一块区域进行扫描，即使回收这部分内存的条件相当苛刻。</p>\n<h3><a id="Runtime_Constant_Pool__71"></a>Runtime Constant Pool (运行时常量池)</h3>\n<p>回过头来看下图1的下半部分，方法区主要包含：</p>\n<p>运行时常量池(Runtime Constant Pool)<br>\n类信息(Class &amp; Field &amp; Method data)<br>\n编译器编译后的代码(Code)等等<br>\n后面两项都比较好理解，但运行时常量池有何作用，其意义何在？抛开运行时3个字，首先了解下何为常量池。<br>\nJava源文件经编译后得到存储字节码的Class文件，Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中。也就是说，哪个字节代表什么含义，长度多少，先后顺序如何都是被严格限定的，是不允许改变的。比如：开头的4个字节存放在魔数，用于确定这个文件是否能够被JVM接受，接下来的4个字节用于存放版本号，再接着存放的就是常量池，常量池的长度是不固定的，所以，在常量池的入口存放着常量池容量的计数值。</p>\n<p>常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，比如：字符串常量、声明为final的常量等等。符号引用是用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。理解不了？举个例子，有如下代码：</p>\n<pre><code>\npublic class M {\n    private int m;\n    private String mstring = "chen";\n    public void f() {\n    }\n}\n\n</code></pre>\n<p>使用javap工具输出M.class文件字节码的部分内容如下：</p>\n<pre><code>\n⇒ javap -verbose M\n  ......\nConstant pool:\n   #1 = Methodref          #5.#20         // java/lang/Object."&lt;init&gt;":()V\n   #2 = String             #21            // chen\n   #3 = Fieldref           #4.#22         // com/lwork/mdo/M.mstring:Ljava/lang/String;\n   #4 = Class              #23            // com/lwork/mdo/M\n   #5 = Class              #24            // java/lang/Object\n   #6 = Utf8               m\n   #7 = Utf8               I\n   #8 = Utf8               mstring\n   #9 = Utf8               Ljava/lang/String;\n  #10 = Utf8               &lt;init&gt;\n  #11 = Utf8               ()V\n  #12 = Utf8               Code\n  #13 = Utf8               LineNumberTable\n  #14 = Utf8               LocalVariableTable\n  #15 = Utf8               this\n  #16 = Utf8               Lcom/lwork/mdo/M;\n// 方法名称\n  #17 = Utf8               f\n  #18 = Utf8               SourceFile\n// 类名称\n  #19 = Utf8               M.java\n  #20 = NameAndType        #10:#11        // "&lt;init&gt;":()V\n  #21 = Utf8               chen\n  #22 = NameAndType        #8:#9          // mstring:Ljava/lang/String;\n// 类的完整路径，注意class文件中是用"/"来代替"."\n  #23 = Utf8               com/lwork/mdo/M\n  #24 = Utf8               java/lang/Object\n......\n\n</code></pre>\n<p>这里只保留了常量池的部分，从中可以看到M.class文件的常量池总共24项，其中包含类的完整名称、字段名称和描述符、方法名称和描述符等等。当然其中还包含I、V、、LineNumberTable、LocalVariableTable等代码中没有出现过的常量，其实这些常量是用来描述如下信息：方法的返回值是什么？有多少个参数？每个参数的类型是什么…… 这个示例非常直观的向大家展示了常量池中存储的内容。</p>\n<p>接下来就比较好理解运行时常量池了。我们都知道：Class文件中存储的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。运行时常量池就可以理解为常量池被加载到内存之后的版本，但并非只有Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能产生新的常量，它们也可以放入运行时常量池中。</p>\n<h3><a id="Heap_Space_Java_136"></a>Heap Space (Java堆)</h3>\n<p>Java堆是JVM所管理的最大一块内存，所有线程共享这块内存区域，几乎所有的对象实例都在这里分配内存，因此，它也是垃圾收集器管理的主要区域。从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间，如图1所示。有一点需要注意：Java堆空间只是在逻辑上是连续的，在物理上并不一定是连续的内存空间。</p>\n<p>默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，注意不要被示意图误导，可以使用参数-XX:SurvivorRatio对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。</p>\n<p>何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同</p>\n<p>Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。关于JVM内存分配更直观的介绍，请阅读参考资料3。</p>\n<h3><a id="VM_Stack___Native_Method_Stack__146"></a>VM Stack (虚拟机栈) &amp; Native Method Stack (本地方法栈)</h3>\n<p>虚拟机栈与本地方法栈都属于线程私有，它们的生命周期与线程相同。虚拟机栈用于描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>\n<p>其中局部变量表用于存储方法参数和方法内部定义的局部变量，它只在当前函数调用中有效，当函数调用结束，随着函数栈帧的销毁，局部变量表也随之消失；操作数栈是一个后入先出栈，用于存放方法运行过程中的各种中间变量和字节码指令 (在学习栈的时候，有一个经典的例子就是用栈来实现4则运算，其实方法执行过程中操作数栈的变化过程，与4则预算中栈中数字与符号的变化类似)；动态连接其实是指一个过程，即在程序运行过程中将符号引用解析为直接引用的过程。</p>\n<p>如何理解动态连接？我们知道Class文件的常量池中存有大量的符号引用，在加载过程中会被原样的拷贝到内存里先放着，到真正使用的时候就会被解析为直接引用 (直接引用包含：直接指向目标的指针、相对偏移量、能间接定位到目标的句柄等)。有些符号引用会在类的加载阶段或者第一次使用的时候转化为直接引用，这种转化称为静态解析，而有的将在运行期间转化为直接引用，这部分称为动态连接。</p>\n<p>全部静态解析不是更好，为何会存在动态连接？Java多态的实现会导致一个引用变量到底指向哪个类的实例对象，或者说该引用变量发出的方法调用到底是调用哪个类中实现方法都需要在运行期间才能确定。因此有些符号引用在类加载阶段是不知道它对应的直接引用的</p>\n<p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，下面通过一个非常简单的图例来描述这一过程，有如下的代码片段：</p>\n<pre><code>public void sayHello(String name) {\n    System.out.println("hello " + name);\n    greet(name);\n    bye();\n}\n\n</code></pre>\n<p>其调用过程中虚拟机栈的大致示意图如下图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190618205316120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>调用sayHello方法时，在栈中分配有一块内存用来保存该方法的局部变量等信息，①当函数执行到greet()方法时，栈中同样有一块内存用来保存greet方法的相关信息，当然第二个内存块位于第一个内存块上面，②接着从greet方法返回，③现在栈顶的内存块就是sayHello方法的，这表示你已经返回到sayHello方法，④接着继续调用bye方法，在栈顶添加了bye方法的内存块，⑤接着再从bye方法返回到sayHello方法中，由于没有别的事了，现在就从sayHello方法返回。</p>\n<p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法 (也就是字节码) 服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>\n<h3><a id="Program_Counter_Register__176"></a>Program Counter Register (程序计数器)</h3>\n<p>程序计数器(Program Counter Register)，很多地方也被称为PC寄存器，但寄存器是CPU的一个部件，用于存储CPU内部重要的数据资源，比如在汇编语言中，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。</p>\n<p>类似的，JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。</p>\n<p>Java虚拟机可以支持多条线程同时执行，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，JVM中的程序计数器是每个线程私有的。</p>\n<h3><a id="12__184"></a>1.2 堆外内存</h3>\n<p>堆外内存又被称为直接内存(Direct Memory)，它并不是虚拟机运行时数据区的一部分，Java虚拟机规范中也没有定义这部分内存区域，使用时由Java程序直接向系统申请，访问直接内存的速度要优于Java堆，因此，读写频繁的场景下使用直接内存，性能会有提升，比如Java NIO库，就是使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBytedBuffer对象作为这块内存的引用进行操作。</p>\n<p>由于直接内存在Java堆外，其大小不会直接受限于Xmx指定的堆大小，但它肯定会受到本机总内存大小以及处理器寻址空间的限制，因此我们在配置JVM参数时，特别是有大量网络通讯场景下，要特别注意，防止各个内存区域的总内存大于物理内存限制 (包括物理的和OS的限制)。</p>\n<h3><a id="13__190"></a>1.3 小结</h3>\n<p>花了很大篇幅来介绍Java虚拟机的内存结构，其中在讲解Java堆时，还简单的介绍了JVM的内存分配机制；在介绍虚拟机栈的同时，也对方法调用过程中栈的数据变化作了形象的说明。当然这样的篇幅肯定不足以完全理清整个内存结构以及其内存分配机制，你尽可以把它当做简单的入门，带你更好的学习。接下来会以此为背景介绍一些常用的JVM参数。</p>\n<h2><a id="JVM_195"></a>二、常用JVM参数</h2>\n<h3><a id="21_JVM_197"></a>2.1 关于JVM参数必须知道的小知识</h3>\n<p>JVM参数分为标准参数和非标准参数，所有以-X和-XX开头的参数都是非标准参数，标准参数可以通过java -help命令查看，比如：-server就是一个标准参数。</p>\n<p>非标准参数中，以-XX开头的都是不稳定的且不推荐在生成环境中使用。但现在的情况已经有所改变，很多-XX开头的参数也已经非常稳定了，但不管什么参数在使用前都应该了解它可能产生的影响。</p>\n<p>布尔型参数，-XX:+表示激活选项，-XX:-表示关闭此选项。<br>\n部分参数可以使用jinfo工具动态设置，比如：jinfo -flag +PrintGCDetails 12278，能够动态设置的参数很少，所以用处有限，至于哪些参数可以动态设置，可以参考jinfo工具的使用方法。</p>\n<h3><a id="22_GC_206"></a>2.2 GC日志</h3>\n<p>GC日志是一个非常重要的工具，它准确的记录了每一次GC的执行时间和结果，通过分析GC日志可以帮助我们优化内存设置，也可以帮助改进应用的对象分配方式。如何阅读GC日志不在本文的范畴内，大家可以参考网上相关文章。</p>\n<p>下面几个关于GC日志的参数应该加入到应用启动参数列表中：</p>\n<p>-XX:+PrintGCDetails 开启详细GC日志模式<br>\n-XX:+PrintGCTimeStamps在每行GC日志头部加上GC发生的时间，这个时间是指相对于JVM的启动时间，单位是秒<br>\n-XX:+PrintGCDateStamps在GC日志的每一行加上绝对日期和时间，推荐同时使用这两个参数，这样在关联不同来源的GC日志时很有帮助<br>\n-XX:+PrintHeapAtGC输出GC回收前和回收后的堆信息，使用这个参数可以更好的观察GC对堆空间的影响<br>\n-Xloggc设置GC日志目录<br>\n设置这几个参数后，发生GC时输出的日志就类似于下面的格式 (不同的垃圾收集器格式可能略有差异)：</p>\n<pre><code>2018-01-07T19:45:08.627+0800: 0.794: [GC (Allocation Failure) [PSYoungGen: 153600K-&gt;4564K(179200K)] 153600K-&gt;4580K(384000K), 0.0051736 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]\n......\n\n</code></pre>\n<p>简单的说明：</p>\n<p>2018-01-07T19:45:08.627+0800 - GC开始时间<br>\n0.794 - GC开始时间相对于JVM启动时间<br>\nGC - 用来区分是Minor GC 还是 Full GC，这里是Minor GC<br>\nAllocation Failure - GC原因，这里是因为年轻代中没有任何足够空间，也就是分配失败<br>\nPSYoungGen - 垃圾收集算法，这里是Parallel Scavenge<br>\n153600K-&gt;4564K(179200K) - 本次垃圾回收前后年轻代内存使用情况，括号内表示年轻代总大小<br>\n153600K-&gt;4580K(384000K) - 在本次垃圾回收前后整个堆内存的使用情况，括号内表示总的可用堆内存<br>\n0.0051736 secs - GC持续时间<br>\n[Times: user=0.01 sys=0.00, real=0.01 secs] - 多个维度衡量GC持续时间</p>\n<h3><a id="23__237"></a>2.3 内存优化</h3>\n<p>我们的程序可能会经常出现性能问题，但如何分析和定位？知道一些常用的JVM内存管理参数，对我们开发人员有莫大的帮助。</p>\n<h3><a id="_241"></a>堆空间设置</h3>\n<p>使用-Xms和-Xmx来指定JVM堆空间的初始值和最大值，比如：</p>\n<p>java -Xms128m -Xmx2g app</p>\n<p>虽然JVM可以在运行时动态的调整堆内存大小，但很多时候我们都直接将-Xms和-Xmx设置相等的值，这样可以减少程序运行时进行垃圾回收的次数。</p>\n<h3><a id="_248"></a>新生代设置</h3>\n<p>参数-Xmn用于设置新生代大小，设置一个较大的新生代会减少老年代的大小，这个参数堆GC行为影响很大。一般情况下不需要使用这个参数，在分析GC日志后，发现确实是因为新生代设置过小导致频繁的Full GC，可以配置这个参数，一般情况下，新生代设置为堆空间的1/3 - 1/4左右。</p>\n<p>还可以通过-XX:SurviorRatio设置新生代中eden区和Survivor from/to区空间的比例关系，也可使用-XX:NewRatio设置新生代和老年代的比例。</p>\n<p>配置这3个参数的基本策略是：尽可能将对象预留在新生代，减少老年代GC的次数，所以需要更谨慎的对其进行修改，不要太随意。</p>\n<h3><a id="_256"></a>生成快照文件</h3>\n<p>我们可能没有办法给最大堆内存设置一个合适的值，因为我们时常面临内存溢出的状况，当然我们可以在内存溢出情况出现后，再监控程序，dump出内存快照来定位，但这种方法的前提条件是内存溢出问题要再次发生。更好方法是通过设置-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出时自动的生成堆内存快照。有了这个参数，当我们在面对内存溢出异常的时候会节约大量的时间，-XX:HeapDumpPath则可以设置快照的生成路径。堆内存快照文件可能很庞大，要注意存储的磁盘空间。</p>\n<h3><a id="_260"></a>方法区设置</h3>\n<p>方法区中存放中JVM加载的类信息，如果JVM加载的类过多，就需要合理设置永久大的大小，在JDK1.6和JDK1.7中，可以使用 -XX:PermSize和-XX:MaxPermSize来达到这个目的，前者用于设置永久代的初始大小，后者用于设置永久代的最大值。前面我们知道，方法区并不在堆内存中，所以要注意所有JVM参数设置的内存总大小。</p>\n<p>在JDK1.8中已经使用元空间代替永久代，同样的目的，需要使用-XX:MetaspaceSize和-XX:MaxMetaspaceSize来代替。</p>\n<h3><a id="_266"></a>直接内存</h3>\n<p>参数-XX:MaxDirectMemorySize用于配置直接内存大小 ，如果不设置，默认值为最大堆空间，即-Xmx，当直接内存使用量达到设置的值时，就会触发垃圾回收，如果垃圾回收不能有效释放足够空间，仍然会引起OOM。如果堆外内存发生OOM，请检查此参数是否配置过小。</p>\n<h3><a id="24__270"></a>2.4 小结</h3>\n<p>这部分主要介绍一些常用的JVM参数，理解这些JVM参数的前提是需要理解JVM的内存结构以及各个内存区域的作用，希望通过这些参数的介绍，能够加深大家对JVM内存结构的理解，也希望在平时的工作中能够注意这些参数的运用。下篇文章将着重介绍常用的垃圾回收算法与垃圾收集器。</p>\n<p>###b参考资料</p>\n<p>周志明 著; 深入理解Java虚拟机(第2版); 机械工业出版社,2013<br>\nJava8内存模型—永久代(PermGen)和元空间(Metaspace)<br>\njava虚拟机：运行时常量池<br>\n最简单例子图解JVM内存分配和回收<br>\nJVM的内存区域划分<br>\nJVM实用参数（八）GC日志<br>\nJVM实用参数（四）内存调优</p>\n<p>作者：<br>\nCHEN川<br>\n链接：<br>\n<a href="https://www.jianshu.com/p/f8d71e1e8821" rel="nofollow">https://www.jianshu.com/p/f8d71e1e8821</a></p>\n<h3><a id="_289"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:26 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84503413', 'title': '那些年让人迷惑的同步、异步、阻塞、非阻塞', 'readNum': '17143', 'commentNum': '3', 'publishTime': '2019-02-27 14:52:42', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章，原文链接：<a href="https://www.jianshu.com/p/3d603166f54d" rel="nofollow">https://www.jianshu.com/p/3d603166f54d</a></p>\n</blockquote>\n<blockquote>\n<p>在IT圈混饭吃，不管你用什么编程语言、从事前端还是后端，阻塞、非阻塞、异步、同步这些概念，都需要清晰地掌握，否则，怎么与面试官谈笑风生（chui niu pi）？但是，掌握这些概念又不是非常容易，尤其对非科班出身的，更加困难。本文试图给出一个清晰简明但不失深刻的介绍，希望对大家有所帮助。</p>\n</blockquote>\n<h2><a id="1IO_5"></a>1、从I/O说起</h2>\n<p>这些概念之所以容易令人迷惑，在于很多人对I/O就没有清晰准确的理解，后面的理解自然不可能正确。我想用一个具体的例子来说明一下I/O。</p>\n<p>设想自己是一个进程，就叫小进吧。小进需要接收一个输入，我们不管这个输入是从网络套接字来，还是键盘，鼠标来，输入的来源可以千千万万。但是，都必须由内核来帮小进完成，为啥内核这么霸道？因为计算机上运行的可不只是咱小进一个进程，还有很多进程。这些进程兄弟也可能需要从这些输入设备接收输入，没有内核居中协调，岂不是乱套。</p>\n<p>从小进的角度看，内核帮助它完成输入，其实包括三个步骤：</p>\n<ul>\n<li>1、内核替小进接收好数据，这些数据暂时存在内核的内存空间</li>\n<li>2、内核将数据从自己的内存空间复制到小进的内存空间</li>\n<li>3、告诉小进，输入数据来了，赶快读吧</li>\n</ul>\n<p>这三步看似挺简单，其实在具体实现时，有很多地方需要考虑：</p>\n<ul>\n<li>0、小进如何告诉内核自己要接收一个输入？</li>\n<li>1、内核接到小进的请求，替小进接收好数据这段时间， 小进咋办？</li>\n<li>2、内核在将数据复制到小进的内存空间这段时间，小进咋办？</li>\n<li>3、到底什么时候告诉小进数据准备好了，是在内核接收好数据之后就告诉小进，还是在将数据复制到小进的内存空间之后再告诉他？</li>\n<li>4、内核以什么样的方式告诉小进，数据准备好了？</li>\n</ul>\n<h2><a id="2IO_25"></a>2、阻塞式I/O模型</h2>\n<p>对上面5个问题，最简单的解决方案就是阻塞式I/O模型，它的过程是这样的：</p>\n<p>小进：内核内核，我要接收一个键盘输入，快点帮我完成！</p>\n<p>内核：好咧！biubiu！一个阻塞丢给小进，小进顿时石化，就像被孙悟空点了定一样。</p>\n<p>就这样，小进在石化中，时间一点点流逝。终于，内核收到了数据。</p>\n<p>内核：数据终于来了，我要开干了！duang duang duang，先把数据存在自己的内核空间，然后又复制到小进的用户空间。</p>\n<p>内核：biubiu！一个解除阻塞丢给小进，小进瞬间复活，小进的记忆还是停留在让内核帮他接收输入时。</p>\n<p>小进：哇！内核真靠谱，数据已经有了！干活去！</p>\n<p>我们可以看到，小进发出接收输入的请求给内核开始，就处于阻塞状态，直到内核将数据复制到小进的用户空间，小进才解除阻塞。</p>\n<h2><a id="3IO_43"></a>3、非阻塞式I/O</h2>\n<p>小进发现，阻塞式I/O中，自己总要被阻塞好久，好不爽啊，于是小进改用了非阻塞式I/O，其过程是这样的：</p>\n<p>小进：内核内核，我要接收一个输入，赶紧帮我看看，数据到了没有，先说好，不要阻塞我。</p>\n<p>内核：查看了一下自己的内核空间，没有发现数据，于是迅速告诉小进，没有呢！并继续帮小进等着数据。</p>\n<p>如此这样，小进不断地问内核，终于，过了一段时间，小进再一次询问时，内核往自己的空间中一查，呦！数据来了，不胜其烦的内核迅速告诉小进，数据好了！</p>\n<p>小进：快给我！</p>\n<p>内核：biu！一个阻塞丢给小进，悲催的小进还是石化了！</p>\n<p>内核赶紧将自己空间的输入数据复制到小进的用户空间，复制好后。</p>\n<p>内核：biu！一个非阻塞丢给小进，小进立马复活</p>\n<p>小进：哇！数据来了，啥也不说，干活！</p>\n<p>我们看到，所谓的非阻塞I/O，其实在内核将数据从内核空间复制到小进的用户空间时，小进还是被阻塞的。</p>\n<h2><a id="4IO_65"></a>4、信号驱动式I/O</h2>\n<p>非阻塞I/O中，小进不停地问内核，数据好了没有啊，内核感觉太烦了，于是想出一个好办法。</p>\n<p>内核告诉小进，本内核升级了，如果想要我替你接收输入，请先注册一个信号处理函数，等数据准备好时，我会发信号给你。于是，现在的流程是这样的：</p>\n<p>小进：注册信号处理函数，告诉内核，自己要接收一个输入，然后继续干活！</p>\n<p>内核：收到函数，开始执行数据接收</p>\n<p>接收完成时，给小进发送信号，信号处理函数收到信号，开始向内核发送读数据请求</p>\n<p>内核：biu！阻塞了小进，并把数据从内核空间复制到小进的用户空间。</p>\n<p>内核：biu！解除了阻塞</p>\n<p>小进：哇！数据来了！啥也不说，干活去！</p>\n<h2><a id="5IO_83"></a>5、异步I/O</h2>\n<p>上面的三种I/O解决方案中，小进都被阻塞了，只不过是阻塞时间长短不一样，第一种方案中小进被阻塞的时间长一些，在内核接收数据以及将数据复制到小进的用户空间时，都被阻塞。</p>\n<p>第二、第三种方案中，只在内核将数据从内核空间复制到小进的用户空间时，小进才被阻塞。</p>\n<p>我们现在说的异步I/O，目的就是让小进绝对不被阻塞。其过程是这样的：</p>\n<p>小进：内核内核，我要接收一个输入，弄好了告诉我。同时将一个信号和信号处理函数告诉内核，然后继续干自己的活了。</p>\n<p>内核：得了您嘞，您先忙。</p>\n<p>一直到内核接收到数据并将数据从内核空间复制到小进的用户空间后，内核才给小进发送信号。小进在信号处理函数中可以直接处理数据。</p>\n<h2><a id="6_97"></a>6、那啥是同步呢？</h2>\n<p>一句话，凡是让小进阻塞（不管长短）的I/O方案都是同步I/O。也就是说，阻塞、非阻塞、信号驱动式都是同步I/O。</p>\n<h2><a id="7_101"></a>7、无总结，不进步</h2>\n<p>上面，我们从完成输入时，进程与内核的交互方式的角度分析了不同的I/O解决方案，在这个过程中，解释清楚了阻塞、非阻塞、同步、异步的概念。</p>\n<p>作者：milter<br>\n链接：<br>\n<a href="https://www.jianshu.com/p/3d603166f54d" rel="nofollow">https://www.jianshu.com/p/3d603166f54d</a></p>\n<h3><a id="_109"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:26'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84503504', 'title': '详解JVM内存管理与垃圾回收机制2 - 何为垃圾', 'readNum': '13915', 'commentNum': '0', 'publishTime': '2019-02-27 14:52:20', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章，原文链接：<a href="https://www.jianshu.com/p/d9840ebdea25" rel="nofollow">https://www.jianshu.com/p/d9840ebdea25</a></p>\n</blockquote>\n<p>随着编程语言的发展，GC的功能不断增强，性能也不断提高，作为语言背后的无名英雄，GC离我们的工作似乎越来越远。作为Java程序员，对这一点也许会有更深的体会，我们不需要了解太多与GC相关的知识，就能很好的完成工作。那还有必要深入了解GC吗？学习GC的意义在哪儿？</p>\n<p>不管性能提高到何种程度，GC都需要花费一定的时间，对于实时性要求较高的场景，就必须尽量压低GC导致的最大暂停时间 (GC会导致应用线程处于暂停状态)，举两个例子：</p>\n<ul>\n<li>实时对战游戏：如果因为GC导致玩家频繁卡顿，任谁都会想摔手机吧。</li>\n<li>金融交易：在某些对价格非常敏感的交易场景下(比如，外汇交易中价格的变动非常频繁)，如果因为GC导致没有按照交易者指定的价格进行交易，相信我，这些交易者非生吃了你。</li>\n</ul>\n<p>但也有许多场景，GC的最大暂停时间没那么重要，比如，离线分析、视频网站等等。因此，知道这个GC算法有这样的特征，所以它适合这个场景，对程序员来说非常有价值，这就是我们学习GC最重要的意义。接下来，我们将一步步走进GC的世界。</p>\n<p>从诞生之初，人们就在思考GC需要完成的3件事情：何为垃圾？何时回收？如何回收？垃圾收集器在对内存进行回收前，第一件事就是要确定这些对象之中哪些还”活着“，哪些已经”死去“，而这些”死去“的对象，也就是我们所说的垃圾。</p>\n<h3><a id="_14"></a>引用计数法</h3>\n<p>判断对象是否存活，其中一种方法是给对象添加一个引用计数器，每当有一个地方引用它，计数器的值就加1，当引用失效时，计数器的值减1，任一时刻，如果对象的计数器值为0，那么这个对象就不会再被使用，这种方法被称为引用计数法。在整个回收过程中，引用计数器的值会以极快的速度更新，因而计数值的更新任务变得繁重，而且需要给计数器预留足够大的内存空间，以确保它不会溢出。因此，引用计数法的算法很简单，但在实际运用中要考虑非常多的因素，所以它的实现往往比较复杂，更为重要的是它不能解决对象之间的循环引用问题。</p>\n<p>举个栗子，下面的代码片段展示了为什么引用计数法无法解决循环引用的问题。</p>\n<pre><code>public class GcDemo {\n    public static void main(String[] args) {\n        // 在栈中分配内存空间给obj1，然后在堆中创建GcObject对象A\n        // 将obj1指向A实例，这时A的引用计数值 = 1\n        GcObject obj1 = new GcObject();\n        // 同理，GcObject实例B的引用计数值 = 1\n        GcObject obj2 = new GcObject();\n        // GcObject实例2被引用，所以B引用计数值 = 2\n        obj1.instance = obj2;\n        // 同理A的引用计数值 = 2\n        obj2.instance = obj1;\n        // 栈中的obj1不再指向堆中A，这时A的计数值减1，变成1\n        obj1 = null;\n        // 栈中的obj2不再指向堆中B，这时B的计数值减1，变成1\n        obj2 = null;\n    }\n}\n\nclass GcObject {\n    public Object instance = null;\n}\n\n</code></pre>\n<p>仔细阅读代码中的注释，并结合下面的内存结构示意图，应该可以很好的理解其中的原因：如果JVM垃圾收集器采用引用计数法，当obj1和obj2不再指向堆中的实例A、B时，虽然A、B已经不可能再被访问，但彼此间相互引用导致计数器的值不为0，最终导致无法回收A和B。</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-a6684e48125e7bc2.jpg" alt=""></p>\n<h3><a id="_50"></a>可达性分析</h3>\n<p>引用计数法有一个致命的问题，即无法释放有循环引用的垃圾，因此，主流的Java虚拟机都没有选用引用计数法来管理内存，而是通过可达性分析 (Reachability Analysis)来判定对象是否存活。<br>\n可达性分析的基本思路是找到一系列被称为”GC Roots“的对象引用 (Reference) 作为起始节点，通过引用关系向下搜索，能被遍历到的 (可到达的) 对象就被判定为存活，其余对象 (也就是没有被遍历到的) 自然被判定为死亡。这里需要着重理解的是：可达性分析本质是找出活的对象来把其余空间判定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间，简略的示意图如下所示。</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/175724-d0731494f9cc0bec.jpg" alt=""></p>\n<p>从图中可以看出，经过可达性分析后，有不少对象没有在GC Roots的引用链条上，其中还包含一些相互引用的对象，这些对象在不久以后都会被垃圾收集器回收，因此，可达性分析算法可以有效解决引用计数法存在的致命问题。</p>\n<p>但是，首次被标记的对象并一定会被回收，它还有自救的机会。一个对象真正的死亡至少需要经历两次标记过程：</p>\n<p>标记所有不可达对象，并进行筛选，筛选的标准是该对象覆盖了finalize()方法且finalize()方法没有被虚拟机调用过，选出的对象将被放置在一个“即将被回收”的队列中。稍后虚拟机会创建一个低优先级的Finalizer线程去遍历队列中的所有对象并执行finalize()方法<br>\n对队列中的对象进行第二次标记，如果对象在finalize()方法中重新与引用链上的任何一个对象建立关联，那么这个对象将被移除队列，而还留在队列中的对象，就会被回收了。</p>\n<p>要正确的实现可达性分析算法，就必须完整地枚举出所有的GC Roots，否则就有可能会漏掉本应存活的对象，如果垃圾收集器错误的回收了这些被漏掉的活对象，将会造成严重的bug。GC Roots作为垃圾回收的起点，必须是一些列活的引用 (Reference) 集合，那这个集合中究竟包含哪些引用？为什么这些引用可以作为GC Roots？要回答好这两个问题，需要对Java对象在内存中布局有一些初步的了解，所以，在下节会对相关知识进行补充。</p>\n<h3><a id="_67"></a>参考资料</h3>\n<p>周志明 著; 深入理解Java虚拟机(第2版); 机械工业出版社,2013<br>\n知乎上关于GC ROOTS的问题</p>\n<p>作者：CHEN川<br>\n链接：<a href="https://www.jianshu.com/p/d9840ebdea25" rel="nofollow">https://www.jianshu.com/p/d9840ebdea25</a></p>\n<h3><a id="_75"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84724673', 'title': 'Alibaba之Nacos', 'readNum': '16627', 'commentNum': '3', 'publishTime': '2019-02-27 14:52:10', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章，原文链接： <a href="https://windmt.com/2018/11/09/intro-to-spring-cloud-alibaba-nacos/" rel="nofollow">https://windmt.com/2018/11/09/intro-to-spring-cloud-alibaba-nacos/</a></p>\n</blockquote>\n<p>上个月最后一天的凌晨，Spring Cloud Alibaba 正式入驻了 Spring Cloud 官方孵化器，并在 maven 中央库发布了第一个版本。</p>\n<p>目前 Spring Cloud Alibaba 还只能算是预览版吧，里边的坑肯定不少，不过我还是决定试试，看看 Alibaba 到底靠谱不靠谱。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130602873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="Spring_Cloud_Alibaba_8"></a>Spring Cloud Alibaba</h2>\n<p>目前 Spring Cloud Alibaba 项目还处于 Spring Cloud 官方孵化器中，打开它 Github 的就能看到 “亲切” 的中文文档。</p>\n<p>它目前只有三个组件：</p>\n<ul>\n<li>\n<p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>\n</li>\n<li>\n<p>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>\n</li>\n<li>\n<p>AliCloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>\n</li>\n</ul>\n<p>看官方路线图上讲后边还会增加</p>\n<ul>\n<li>\n<p>Dubbo：Apache Dubbo™ (incubating) 是一款高性能 Java RPC 框架。</p>\n</li>\n<li>\n<p>RocketMQ：Apache RocketMQ™ 基于 Java 的高性能、高吞吐量的分布式消息和流计算平台。</p>\n</li>\n<li>\n<p>Schedulerx：阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</p>\n</li>\n<li>\n<p>AliCloud SLS：针对日志类数据的一站式服务，在阿里巴巴集团经历大量大数据场景锤炼而成。您无需开发就能快捷完成日志数据采集、消费、投递以及查询分析等功能，提升运维、运营效率，建立 DT 时代海量日志处理能力。</p>\n</li>\n</ul>\n<p>从数量上来看，Alibaba 的组件数量和目前 Netflix 的相比少了一多半，但是仔细看看各组件的功能描述，也就明白了。在没真正上手之前，我个人先大胆猜测一下：</p>\n<ul>\n<li>Nacos = Eureka/Consule + Config + Admin</li>\n<li>Sentinel = Hystrix + Dashboard + Turbine</li>\n<li>Dubbo = Ribbon + Feign</li>\n<li>RocketMQ = RabbitMQ</li>\n<li>Schedulerx = Quartz</li>\n<li>AliCloud OSS、AliCloud SLS 这三个应该是独有的<br>\n链路跟踪（Sleuth、Zipkin）不知道会不会在 Sentinel 里<br>\n以上只是猜测，待我从坑里爬出来之后再回来更新。也欢迎大家一起交流探讨~</li>\n</ul>\n<p>这里我就先试试 Nacos。</p>\n<h2><a id="Nacos_44"></a>Nacos</h2>\n<p><img src="https://img-blog.csdnimg.cn/20190814130621764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>这是 Nacos 的架构图，可以看到它确实是融合了服务注册发现中心、配置中心、服务管理等功能，和我之前猜想的它是 Eureka/Consule + Config + Admin 的合体差不多。</p>\n<p>另外通过官方文档发现，Nacos 除了可以和 Spring Cloud 集成，还可以和 Spring、SpringBoot 进行集成。</p>\n<p>不过我们只关注于 Spring Cloud，别的就略过了，直接上手吧~</p>\n<p>工程的目录结构如下：</p>\n<pre><code class="prism language-text">\nalibaba\n├── nacos-config\n│   ├── pom.xml\n│   └── src\n├── nacos-consumer\n│   ├── pom.xml\n│   └── src\n├── nacos-provider\n│   ├── pom.xml\n│   └── src\n└── pom.xml\n\n</code></pre>\n<p>首先引入 Spring Cloud Alibaba 的 BOM</p>\n<pre><code class="prism language-java">\n<span class="token generics function"><span class="token punctuation">&lt;</span>parent<span class="token punctuation">&gt;</span></span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>parent<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.0</span><span class="token number">.4</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>relativePath<span class="token operator">/</span><span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>parent<span class="token operator">&gt;</span>\n<span class="token generics function"><span class="token punctuation">&lt;</span>properties<span class="token punctuation">&gt;</span></span>\n    <span class="token operator">&lt;</span>spring<span class="token operator">-</span>cloud<span class="token punctuation">.</span>version<span class="token operator">&gt;</span>Finchley<span class="token punctuation">.</span>SR2<span class="token operator">&lt;</span><span class="token operator">/</span>spring<span class="token operator">-</span>cloud<span class="token punctuation">.</span>version<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>alibaba<span class="token punctuation">.</span>version<span class="token operator">&gt;</span><span class="token number">0.2</span><span class="token number">.0</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>alibaba<span class="token punctuation">.</span>version<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>properties<span class="token operator">&gt;</span>\n<span class="token generics function"><span class="token punctuation">&lt;</span>dependencyManagement<span class="token punctuation">&gt;</span></span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>dependencies<span class="token punctuation">&gt;</span></span>\n        <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>alibaba<span class="token operator">-</span>dependencies<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span>$<span class="token punctuation">{</span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>alibaba<span class="token punctuation">.</span>version<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>type<span class="token punctuation">&gt;</span></span>pom<span class="token operator">&lt;</span><span class="token operator">/</span>type<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">&gt;</span></span><span class="token keyword">import</span><span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">&gt;</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>\n        <span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>dependencies<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span>$<span class="token punctuation">{</span>spring<span class="token operator">-</span>cloud<span class="token punctuation">.</span>version<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>type<span class="token punctuation">&gt;</span></span>pom<span class="token operator">&lt;</span><span class="token operator">/</span>type<span class="token operator">&gt;</span>\n            <span class="token generics function"><span class="token punctuation">&lt;</span>scope<span class="token punctuation">&gt;</span></span><span class="token keyword">import</span><span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">&gt;</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>dependencyManagement<span class="token operator">&gt;</span>\n\n</code></pre>\n<p>这里版本号有坑，文档上说和 Spring Boot 2.0.x 版本兼容，但是实测 2.0.6.RELEASE 报错</p>\n<pre><code class="prism language-text">\njava.lang.NoClassDefFoundError: org/springframework/core/env/EnvironmentCapable\n\n</code></pre>\n<h2><a id="Nacos_Server_117"></a>Nacos Server</h2>\n<p>在使用 Nacos 之前，需要先下载 Nacos 并启动 Nacos Server。</p>\n<p>Nacos Server 有两种运行模式：</p>\n<ul>\n<li>standalone</li>\n<li>cluster</li>\n</ul>\n<p>不论哪种方式吧，都需要先去 <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a> 下载最新的 release 包，然后解压，以 nacos-server-0.4.0.zip 为例</p>\n<pre><code class="prism language-text">unzip nacos-server-0.4.0.zip\ncd nacos\n\n</code></pre>\n<h3><a id="standalone__135"></a>standalone 模式</h3>\n<p>此模式一般用于 demo 和测试，不用改任何配置，直接敲以下命令执行</p>\n<pre><code class="prism language-text">sh bin/startup.sh -m standalone\n\n</code></pre>\n<p>Windows 的话就是</p>\n<pre><code class="prism language-text">cmd bin/startup.cmd -m standalone\n</code></pre>\n<p>然后从 <a href="http://localhost:8848/nacos/index.html" rel="nofollow">http://localhost:8848/nacos/index.html</a> 进入控制台就能看到如下界面了</p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130640587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="cluster__155"></a>cluster 模式</h3>\n<p>集群模式需要依赖 MySQL，然后改两个配置文件：</p>\n<pre><code class="prism language-text">conf/cluster.conf\nconf/application.properties\n\n</code></pre>\n<p>具体怎么改，在这里就先不展开了。我们先用 standalone 模式撸起来，享受 coding 的快感，然后再慢慢转到 cluster 上边。</p>\n<h2><a id="_169"></a>配置管理</h2>\n<p>在 nacos/pom.xml 里添加依赖</p>\n<pre><code class="prism language-text">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n</code></pre>\n<p>启动类不用修改</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NacosApplication</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>NacosApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>修改 bootstrap.yml</p>\n<pre><code class="prism language-text">spring:\n  application:\n    name: nacos\n  cloud:\n    nacos:\n      config:\n        server-addr: 127.0.0.1:8848\n</code></pre>\n<p>注意：必须是写在 bootstrap.yml 中，配置在 application.yml 中不行，启动报错</p>\n<pre><code class="prism language-text">java.lang.IllegalArgumentException: Could not resolve placeholder \'spring.application.name\' in value "${spring.application.name}"\n\n</code></pre>\n<p>至于 bootstrap.yml 和 application.yml 的区别，之前讲过这里就不赘述了。</p>\n<p>添加一个 Endpoint 便于观察</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/config"</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@RefreshScope</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${useLocalCache:false}"</span><span class="token punctuation">)</span>\n    <span class="token keyword">private</span> <span class="token keyword">boolean</span> useLocalCache<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/get"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> useLocalCache<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>注意一定要加@RefreshScope注解</p>\n<p>小心！此处有坑！</p>\n<p>这时候先别急着启动 NacosConfigApplication 的，需要需要通过调用 Nacos Open API 往 Nacos Server 里发布一个配置。dataId 为 nacos.properties，内容为useLocalCache=true</p>\n<pre><code class="prism language-text">curl -X "POST" "http://127.0.0.1:8848/nacos/v1/cs/configs" \\\n     -H \'Content-Type: application/x-www-form-urlencoded; charset=utf-8\' \\\n     --data-urlencode "dataId=nacos.properties" \\\n     --data-urlencode "group=DEFAULT_GROUP" \\\n     --data-urlencode "content=useLocalCache=true\n     \n</code></pre>\n<blockquote>\n<p>dataId 的完整格式如下：</p>\n</blockquote>\n<blockquote>\n<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi></mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">{prefix}-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit">x</span></span><span class="mord">−</span></span></span></span></span>{spring.profile.active}.${file-extension}</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>prefix 默认为 <a href="http://spring.application.name" rel="nofollow">spring.application.name</a> 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。</li>\n<li>spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring &gt;Boot 文档。 注意：当 spring.profile.active 为空时，对应的连接符 - &gt;也将不存在，dataId 的拼接格式变成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">{prefix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit">x</span></span><span class="mord">.</span></span></span></span></span>{file-extension}</li>\n<li>file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</li>\n</ul>\n</blockquote>\n<p>然后启动 NacosConfigApplication，从启动日志里能看到</p>\n<pre><code class="prism language-text">Located property source: CompositePropertySource {name=\'NACOS\', propertySources=[NacosPropertySource {name=\'nacos.properties\'}]}\n\n</code></pre>\n<p>如果 propertySources 里边是空的，那抱歉，你掉到坑里边了。 如果你能看到之前发布的 dataId，那恭喜，请求 <a href="http://localhost:8080/config/get" rel="nofollow">http://localhost:8080/config/get</a> 就可以看到返回内容 true 了。</p>\n<p>再次调用 Nacos Open API 修改内容为useLocalCache=false</p>\n<p>再次访问 <a href="http://localhost:8080/config/get" rel="nofollow">http://localhost:8080/config/get</a> ，此时返回内容为false，说明程序中的useLocalCache值已经被动态更新了。</p>\n<p>当然，以上手动调用 Nacos Open API 的方式也可以通过 Nacos Console 的可视化界面来操作</p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130704679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>另外我们可以查询配置的历史记录并能快速回滚</p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130720468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>还能查询到某个配置当前的被监听状态（这里的分页有些 bug）</p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130733809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_297"></a>数据源</h3>\n<p>经过了上边的一些简单操作，我们已经可以正常使用 Nacos 配置中心了。<br>\n但是不知道你有没有想过：配置数据是存在哪里呢？</p>\n<p>我们没有对 Nacos Server 做任何配置，那么数据只有两个位置可以存储：</p>\n<ul>\n<li>内存</li>\n<li>本地数据库</li>\n</ul>\n<p>如果我们现在重启刚刚在运行的 Nacos Server，会发现刚才加的 nacos.properties 配置还在，说明不是内存存储的。</p>\n<p>这时候我们打开NACOS_PATH/data，会发现里边有个derby-data目录，Derby 是 Java 编写的数据库，属于 Apache 的一个开源项目。我们的配置数据现在就存储在这个库中。</p>\n<p>Derby 我并不是很熟悉，那能不能将数据源改为我们熟悉的 MySQL 呢？当然可以了。</p>\n<blockquote>\n<p>注意：不支持 MySQL 8.0 版本</p>\n</blockquote>\n<p>这里我以本地运行的 MySQL 为例：</p>\n<p>创建一个名为nacos_config的 database</p>\n<p>将NACOS_PATH/conf/nacos-mysql.sql中的表结构导入刚才创建的库中，这几张表的用途就自己研究吧</p>\n<p>修改NACOS_PATH/conf/application.properties，加入 MySQL 配置</p>\n<pre><code class="prism language-text">\ndb.num=1\ndb.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true\ndb.user=root\ndb.password=root\n\n</code></pre>\n<p>创建cluster.conf，填入要运行 Nacos Server 机器的 ip</p>\n<pre><code class="prism language-text">\n192.168.100.155\n192.168.100.156\n\n</code></pre>\n<p>我就是运行个 demo，没有多余机器来组建集群怎么办呢？</p>\n<p>其实不用虚拟机，直接只填一个本地地址也是可以的（仅限于配置管理，服务发现不行）。</p>\n<p>这里有两个坑：</p>\n<p>Nacos Server 的数据源是用 Derby 还是 MySQL 完全是由其运行模式决定的：</p>\n<ul>\n<li>standalone 的话仅会使用 Derby，即使在 application.properties 里边配置 MySQL 也照样无视；</li>\n<li>cluster 模式会自动使用 MySQL，这时候如果没有 MySQL 的配置，是会报错的。<br>\n官方提供的 cluster.conf 示例如下</li>\n</ul>\n<pre><code class="prism language-text">\n#it is ip\n#example\n10.10.109.214\n11.16.128.34\n11.16.128.36\n\n</code></pre>\n<p>从习惯来看，这个#号后边的应该就是注释的，但是抱歉哦，必须删掉，否则下面的异常就扑面而来</p>\n<pre><code class="prism language-text">Caused by: java.lang.NumberFormatException: For input string: "it is ip:0"\n  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n  at java.lang.Long.parseLong(Long.java:589)\n  at java.lang.Long.parseLong(Long.java:631)\n  at com.alibaba.nacos.naming.core.DistroMapper.onServerStatusUpdate(DistroMapper.java:125)\n  at com.alibaba.nacos.naming.core.DistroMapper.init(DistroMapper.java:100)\n  at com.alibaba.nacos.naming.core.DistroMapper.&lt;clinit&gt;(DistroMapper.java:65)\n  ... 79 common frames omitted\n</code></pre>\n<p>以上配置结束后，运行 Nacos Server 就能看到效果了。</p>\n<p>除了 MySQL 的数据表发生了变化，我们会发现NACOS_PATH/data下的目录结构也发生了变化，多了config-data/DEFAULT_GROUP/nacos_config这么一个文件，里边的内容就是我们的配置</p>\n<pre><code class="prism language-text">useLocalCache=true\n\n</code></pre>\n<p>这是容错呢？还是缓存呢？只有等看过源码才知道了。</p>\n<h2><a id="_389"></a>服务发现</h2>\n<p>服务注册中心和服务发现的服务端都是由 Nacos Server 来提供的，我们只需要提供 Service 向其注册就好了。</p>\n<p>首先我们先将 Nacos Server 由伪分布式改为 standalone 模式，原因后边再说吧。</p>\n<p>这里模拟提供两个 service：provider 和 consumer</p>\n<pre><code class="prism language-text">alibaba\n├── nacos-provider\n│   ├── pom.xml\n│   └── src\n└── nacos-consumer\n│   ├── pom.xml\n│   └── src\n└── pom.xml\n\n</code></pre>\n<p>首先在 provider 和 consumer 的 pom 添加依赖</p>\n<pre><code class="prism language-java"><span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>\n<span class="token generics function"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>\n    <span class="token generics function"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>cloud<span class="token operator">-</span>starter<span class="token operator">-</span>alibaba<span class="token operator">-</span>nacos<span class="token operator">-</span>discovery<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>\n\n</code></pre>\n<p>在两者的 bootstrap.yml 中添加配置</p>\n<h3><a id="provider_426"></a>provider</h3>\n<pre><code class="prism language-text">\nspring:\n  application:\n    name: nacos-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\nserver:\n  port: 18080\nconsumer\n\nspring:\n  application:\n    name: nacos-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\nserver:\n  port: 18081\n  \n</code></pre>\n<p>使用 Spring Cloud 的原生注解 @EnableDiscoveryClient 开启服务发现</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableDiscoveryClient</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NacosProviderApplication</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>NacosProviderApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>提供 Endpoint 以供访问</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/echo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EchoController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/{string}"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">echo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"Hello Nacos Discovery "</span> <span class="token operator">+</span> string<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="Consumer_486"></a>Consumer</h3>\n<p>在 NacosConsumerApplication 中集成 RestTemplate 和 Ribbon</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@LoadBalanced</span>\n<span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>提供 Controller</p>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/echo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">final</span> RestTemplate restTemplate<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token keyword">public</span> <span class="token function">TestController</span><span class="token punctuation">(</span>RestTemplate restTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>restTemplate <span class="token operator">=</span> restTemplate<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/{str}"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>\n    <span class="token keyword">public</span> String <span class="token function">echo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://nacos-provider/echo/"</span> <span class="token operator">+</span> str<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>分别启动 NacosProviderApplication 和 NacosConsumerApplication ，调用 <a href="http://localhost:18080/echo/windmt" rel="nofollow">http://localhost:18080/echo/windmt</a> 和 <a href="http://localhost:18081/echo/windmt" rel="nofollow">http://localhost:18081/echo/windmt</a> ，返回内容均为 Hello Nacos Discovery windmt，说明服务发现成功了。</p>\n<p>这时候查看 Nacos Console 也能看到已注册的服务列表及其详情</p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130804988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190814130819791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>现在来讲一下为什么前边要将 Nacos Server 由伪分布式再改为 standalone 模式。</p>\n<p>单个节点的 Nacos Server 伪分布式在配置管理运行的好好的，但是到了服务发现，它就失效了。</p>\n<p>通过 log 可以发现一些端倪，单节点的在选主的时候，无法正确选出 leader</p>\n<pre><code class="prism language-text">\n==&gt; logs/naming-raft.log &lt;==\n2018-11-13 16:38:56,424 INFO leader timeout, start voting,leader: null, term: 1\n\n</code></pre>\n<p>从而导致 Client 无法正常注册</p>\n<pre><code class="prism language-text">\njava.lang.IllegalStateException: failed to req API:/nacos/v1/ns/instance after all servers([127.0.0.1:8848]) tried\n    at com.alibaba.nacos.client.naming.net.NamingProxy.reqAPI(NamingProxy.java:339) ~[nacos-client-0.3.0.jar:na]\n    at com.alibaba.nacos.client.naming.net.NamingProxy.reqAPI(NamingProxy.java:272) ~[nacos-client-0.3.0.jar:na]\n    at com.alibaba.nacos.client.naming.net.NamingProxy.registerService(NamingProxy.java:171) ~[nacos-client-0.3.0.jar:na]\n    at com.alibaba.nacos.client.naming.NacosNamingService.registerInstance(NacosNamingService.java:161) ~[nacos-client-0.3.0.jar:na]\n    ... ...\n    \n</code></pre>\n<h3><a id="_557"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_565"></a>小结</h2>\n<p>当今年年初 Dubbo 进入 Apache 孵化器的时候，就有预感阿里要与 Spring Cloud 结缘。只是没想到这么快。</p>\n<p>如今 Spring Cloud Alibaba 已经进入了 Spring Cloud 官方孵化器，相信等不了多久也就能正式发布了。虽然大家在生产环境必然还不会这么快速地接入，但是总归是多了一种选择。</p>\n<p>而 Nacos 作为微服务核心的服务注册与发现中心，让大家在 Eureka 和 Consule 之外有了新的选择，开箱即用，上手简洁，暂时也没发现有太大的坑。但将配置中心融合也融合进来是好是坏，这个我先按下不表。</p>\n<p>总而言之，Spring Cloud Alibaba 的入驻对于 Spring Cloud 生态总归是好的~</p>\n<p>本文示例代码：<a href="https://github.com/zhaoyibo/spring-cloud-study/tree/master/alibaba">https://github.com/zhaoyibo/spring-cloud-study/tree/master/alibaba</a></p>\n<h2><a id="_577"></a>参考</h2>\n<p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba">https://github.com/spring-cloud-incubator/spring-cloud-alibaba</a></p>\n<p><a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a></p>\n<p><a href="https://nacos.io/en-us/docs/quick-start-spring-cloud.html" rel="nofollow">https://nacos.io/en-us/docs/quick-start-spring-cloud.html</a></p>\n<h2><a id="_585"></a>原文链接</h2>\n<p><a href="https://windmt.com/2018/11/09/intro-to-spring-cloud-alibaba-nacos/" rel="nofollow">https://windmt.com/2018/11/09/intro-to-spring-cloud-alibaba-nacos/</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84927048', 'title': 'Spring 面试问题 TOP 50', 'readNum': '15846', 'commentNum': '0', 'publishTime': '2019-02-27 14:51:57', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>本文为转载文章，原文链接：<a href="https://www.cnblogs.com/jingmoxukong/p/9408037.html" rel="nofollow">https://www.cnblogs.com/jingmoxukong/p/9408037.html</a></p>\n</blockquote>\n<p>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。</p>\n<p>本文内容主要翻译自 Top 50 Spring Interview Questions You Must Prepare In 2018</p>\n<h2><a id="1__7"></a>1. 一般问题</h2>\n<h3><a id="11__Spring_Framework__9"></a>1.1. 不同版本的 Spring Framework 有哪些主要功能？</h3>\n\n<table>\n<thead>\n<tr>\n<th>Version</th>\n<th>Feature</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Spring 2.5</td>\n<td>发布于 2007 年。这是第一个支持注解的版本。</td>\n</tr>\n<tr>\n<td>Spring 3.0</td>\n<td>发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td>\n</tr>\n<tr>\n<td>Spring 4.0</td>\n<td>发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td>\n</tr>\n</tbody>\n</table><h3><a id="12__Spring_Framework_18"></a>1.2. 什么是 Spring Framework？</h3>\n<ul>\n<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>\n<li>它是轻量级、松散耦合的。</li>\n<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>\n<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>\n</ul>\n<h3><a id="13__Spring_Framework__26"></a>1.3. 列举 Spring Framework 的优点。</h3>\n<ul>\n<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>\n<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>\n<li>由于依赖注入和控制反转，JDBC 得以简化。</li>\n<li>它是开源免费的。</li>\n</ul>\n<h3><a id="14_Spring_Framework__33"></a>1.4. Spring Framework 有哪些不同的功能？</h3>\n<ul>\n<li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li>\n<li>IOC - 控制反转</li>\n<li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>\n<li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>\n<li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>\n<li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>\n<li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>\n</ul>\n<h3><a id="15_Spring_Framework__43"></a>1.5. Spring Framework 中有多少个模块，它们分别是什么？</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190804193644516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<ul>\n<li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：\n<ul>\n<li>Spring Core</li>\n<li>Spring Bean</li>\n<li>SpEL (Spring Expression Language)</li>\n<li>Spring Context</li>\n</ul>\n</li>\n<li>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：\n<ul>\n<li>JDBC (Java DataBase Connectivity)</li>\n<li>ORM (Object Relational Mapping)</li>\n<li>OXM (Object XML Mappers)</li>\n<li>JMS (Java Messaging Service)</li>\n<li>Transaction</li>\n</ul>\n</li>\n<li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：\n<ul>\n<li>Web</li>\n<li>Web – Servlet</li>\n<li>Web – Socket</li>\n<li>Web – Portlet</li>\n</ul>\n</li>\n<li>AOP – 该层支持面向切面编程</li>\n<li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li>\n<li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。<br>\n几个杂项模块:</li>\n<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>\n<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>\n<li>几个杂项模块:\n<ul>\n<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>\n<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>\n</ul>\n</li>\n</ul>\n<h3><a id="16__Spring__74"></a>1.6. 什么是 Spring 配置文件？</h3>\n<p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>\n<h3><a id="17_Spring__78"></a>1.7. Spring 应用程序有哪些不同组件？</h3>\n<p>Spring 应用一般有以下组件：</p>\n<ul>\n<li>接口 - 定义功能。</li>\n<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>\n<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li>\n<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>\n<li>用户程序 - 它使用接口。</li>\n</ul>\n<h3><a id="18__Spring__88"></a>1.8. 使用 Spring 有哪些方式？</h3>\n<p>使用 Spring 有以下方式：</p>\n<ul>\n<li>作为一个成熟的 Spring Web 应用程序。</li>\n<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>\n<li>用于远程使用。</li>\n<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>\n</ul>\n<h2><a id="2_Ioc_98"></a>2. 依赖注入（Ioc）</h2>\n<h3><a id="21__Spring_IOC__101"></a>2.1. 什么是 Spring IOC 容器？</h3>\n<p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190804193749449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="22__107"></a>2.2. 什么是依赖注入？</h3>\n<p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>\n<h3><a id="23__110"></a>2.3. 可以通过多少种方式完成依赖注入？</h3>\n<p>通常，依赖注入可以通过三种方式完成，即：</p>\n<ul>\n<li>构造函数注入</li>\n<li>setter 注入</li>\n<li>接口注入</li>\n<li>在 Spring Framework 中，仅使用构造函数和 setter 注入。</li>\n</ul>\n<h3><a id="24__setter__118"></a>2.4. 区分构造函数注入和 setter 注入。</h3>\n\n<table>\n<thead>\n<tr>\n<th>构造函数注入</th>\n<th>setter 注入</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>没有部分注入</td>\n<td>有部分注入</td>\n</tr>\n<tr>\n<td>不会覆盖 setter 属性</td>\n<td>会覆盖 setter 属性</td>\n</tr>\n<tr>\n<td>任意修改都会创建一个新实例</td>\n<td>任意修改不会创建一个新实例</td>\n</tr>\n<tr>\n<td>适用于设置很多属性</td>\n<td>适用于设置少量属性</td>\n</tr>\n</tbody>\n</table><h3><a id="25_spring__IOC__128"></a>2.5. spring 中有多少种 IOC 容器？</h3>\n<ul>\n<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>\n<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>\n</ul>\n<h3><a id="26__BeanFactory__ApplicationContext_133"></a>2.6. 区分 BeanFactory 和 ApplicationContext。</h3>\n\n<table>\n<thead>\n<tr>\n<th>BeanFactory</th>\n<th>ApplicationContext</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>它使用懒加载</td>\n<td>它使用即时加载</td>\n</tr>\n<tr>\n<td>它使用语法显式提供资源对象</td>\n<td>它自己创建和管理资源对象</td>\n</tr>\n<tr>\n<td>不支持国际化</td>\n<td>支持国际化</td>\n</tr>\n<tr>\n<td>不支持基于依赖的注解</td>\n<td>支持基于依赖的注解</td>\n</tr>\n</tbody>\n</table><h3><a id="27__IoC__143"></a>2.7. 列举 IoC 的一些好处。</h3>\n<p>IoC 的一些好处是：</p>\n<ul>\n<li>它将最小化应用程序中的代码量。</li>\n<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>\n<li>它以最小的影响和最少的侵入机制促进松耦合。</li>\n<li>它支持即时的实例化和延迟加载服务。</li>\n</ul>\n<h3><a id="28_Spring_IoC__152"></a>2.8. Spring IoC 的实现机制。</h3>\n<p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>\n<pre><code class="prism language-java">\n<span class="token keyword">interface</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span>\n     <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> Fruit <span class="token function">getInstance</span><span class="token punctuation">(</span>String ClassName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        Fruit f<span class="token operator">=</span>null<span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            f<span class="token operator">=</span><span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>ClassName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> f<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        Fruit f<span class="token operator">=</span>Factory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"io.github.dunwu.spring.Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>\n            f<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h2><a id="3_Beans_194"></a>3. Beans</h2>\n<h3><a id="31__spring_bean_196"></a>3.1. 什么是 spring bean？</h3>\n<ul>\n<li>它们是构成用户应用程序主干的对象。</li>\n<li>Bean 由 Spring IoC 容器管理。</li>\n<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>\n<li>Bean 是基于用户提供给容器的配置元数据创建。</li>\n</ul>\n<h3><a id="32_spring__204"></a>3.2. spring 提供了哪些配置方式？</h3>\n<ul>\n<li>基于 xml 配置<br>\nbean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</li>\n</ul>\n<pre><code>&lt;bean id="studentbean" class="org.edureka.firstSpring.StudentBean"&gt;\n &lt;property name="name" value="Edureka"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n</code></pre>\n<ul>\n<li>基于注解配置<br>\n您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</li>\n</ul>\n<pre><code>&lt;beans&gt;\n&lt;context:annotation-config/&gt;\n&lt;!-- bean definitions go here --&gt;\n&lt;/beans&gt;\n\n</code></pre>\n<ul>\n<li>基于 Java API 配置<br>\nSpring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</li>\n</ul>\n<p>@Bean 注解扮演与  元素相同的角色。<br>\n@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>\n例如：</p>\n<pre><code>@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n\n</code></pre>\n<h3><a id="33_spring__bean_scope_245"></a>3.3. spring 支持集中 bean scope？</h3>\n<p>Spring bean 支持 5 种 scope：</p>\n<ul>\n<li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li>\n<li>Prototype - 每次请求都会产生一个新的实例。</li>\n<li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>\n<li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>\n<li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。<br>\n仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li>\n</ul>\n<h3><a id="34_spring_bean__256"></a>3.4. spring bean 容器的生命周期是什么样的？</h3>\n<p>spring bean 容器的生命周期流程如下：</p>\n<ul>\n<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>\n<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>\n<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>\n<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>\n<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>\n<li>如果为 bean 指定了 init 方法（ 的 init-method 属性），那么将调用它。</li>\n<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>\n<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>\n<li>如果为 bean 指定了 destroy 方法（ 的 destroy-method 属性），那么将调用它。</li>\n</ul>\n<p><img src="https://img-blog.csdnimg.cn/20190804193840470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="35__spring__bean_274"></a>3.5. 什么是 spring 的内部 bean？</h3>\n<p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在  或  中提供了  元素的使用。内部 bean 总是匿名的，它们总是作为原型。</p>\n<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p>\n<pre><code class="prism language-java">\nStudent<span class="token punctuation">.</span>java\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> Person person<span class="token punctuation">;</span>\n    <span class="token comment">//Setters and Getters</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>\n    <span class="token comment">//Setters and Getters</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>bean.xml</p>\n<pre><code>&lt;bean id=“StudentBean" class="com.edureka.Student"&gt;\n    &lt;property name="person"&gt;\n        &lt;!--This is inner bean --&gt;\n        &lt;bean class="com.edureka.Person"&gt;\n            &lt;property name="name" value=“Scott"&gt;&lt;/property&gt;\n            &lt;property name="address" value=“Bangalore"&gt;&lt;/property&gt;\n        &lt;/bean&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n</code></pre>\n<h3><a id="36__spring__314"></a>3.6. 什么是 spring 装配</h3>\n<p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>\n<h3><a id="37__318"></a>3.7. 自动装配有哪些方式？</h3>\n<p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>\n<p>自动装配的不同模式：</p>\n<ul>\n<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>\n<li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>\n<li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>\n<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>\n<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>\n</ul>\n<h3><a id="38__329"></a>3.8. 自动装配有什么局限？</h3>\n<ul>\n<li>覆盖的可能性 - 您始终可以使用  和  设置指定依赖项，这将覆盖自动装配。</li>\n<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>\n<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>\n</ul>\n<h2><a id="4__335"></a>4. 注解</h2>\n<h3><a id="41__337"></a>4.1. 什么是基于注解的容器配置</h3>\n<p>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>\n<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>\n<ul>\n<li>@Bean 注解扮演与 元素相同的角色。</li>\n<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>\n例如：</li>\n</ul>\n<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentConfig</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> StudentBean <span class="token function">myStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StudentBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3><a id="42__spring__357"></a>4.2. 如何在 spring 中启动注解装配？</h3>\n<p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>\n<h3><a id="43_Component_Controller_Repository_Service__361"></a>4.3. @Component, @Controller, @Repository, @Service 有何区别？</h3>\n<ul>\n<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>\n<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>\n<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>\n<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>\n</ul>\n<h3><a id="44_Required__368"></a>4.4. @Required 注解有什么用？</h3>\n<p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p>\n<p>示例：</p>\n<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@Required</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="45_Autowired__388"></a>4.5. @Autowired 注解有什么用？</h3>\n<p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>\n<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="46_Qualifier__406"></a>4.6. @Qualifier 注解有什么用？</h3>\n<p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<p>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p>\n<p>Employee.java</p>\n<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>EmpAccount.java</p>\n<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmpAccount</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> Employee emp<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>emp1<span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“Employee name <span class="token operator">:</span> ”<span class="token operator">+</span>emp<span class="token punctuation">.</span>getName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3><a id="47_RequestMapping__443"></a>4.7. @RequestMapping 注解有什么用？</h3>\n<p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>\n<ul>\n<li>类级别：映射请求的 URL</li>\n<li>方法级别：映射 URL 以及 HTTP 请求方法</li>\n</ul>\n<h2><a id="5__450"></a>5. 数据访问</h2>\n<h3><a id="51_spring_DAO__452"></a>5.1. spring DAO 有什么用？</h3>\n<p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>\n<h3><a id="52__Spring_DAO__455"></a>5.2. 列举 Spring DAO 抛出的异常。</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190804193915634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="53_spring_JDBC_API__459"></a>5.3. spring JDBC API 中存在哪些类？</h3>\n<ul>\n<li>JdbcTemplate</li>\n<li>SimpleJdbcTemplate</li>\n<li>NamedParameterJdbcTemplate</li>\n<li>SimpleJdbcInsert</li>\n<li>SimpleJdbcCall</li>\n</ul>\n<h3><a id="54__Spring__Hibernate__467"></a>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</h3>\n<p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>\n<ul>\n<li>\n<p>使用 Hibernate 模板和回调进行控制反转</p>\n</li>\n<li>\n<p>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</p>\n</li>\n<li>\n<p>5.5. 列举 spring 支持的事务管理类型</p>\n</li>\n<li>\n<p>Spring 支持两种类型的事务管理：</p>\n</li>\n<li>\n<p>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</p>\n</li>\n<li>\n<p>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</p>\n</li>\n</ul>\n<h3><a id="56_spring__ORM__479"></a>5.6. spring 支持哪些 ORM 框架</h3>\n<ul>\n<li>Hibernate</li>\n<li>iBatis</li>\n<li>JPA</li>\n<li>JDO</li>\n<li>OJB</li>\n</ul>\n<h2><a id="6_AOP_486"></a>6. AOP</h2>\n<h3><a id="61__AOP_487"></a>6.1. 什么是 AOP？</h3>\n<p>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>\n在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p>\n<h3><a id="62__Aspect_491"></a>6.2. 什么是 Aspect？</h3>\n<p>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>\nAOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>\n<ul>\n<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>\n<li>如何在 advice 中编写切面代码.</li>\n<li>可以简单地认为, 使用 @Aspect 注解的类就是切面.</li>\n</ul>\n<p><img src="https://img-blog.csdnimg.cn/20190804193931366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="63_JoinPoint_502"></a>6.3. 什么是切点（JoinPoint）</h3>\n<p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.</p>\n<p>在 Spring AOP 中, join point 总是方法的执行点。</p>\n<h3><a id="64_Advice_507"></a>6.4. 什么是通知（Advice）？</h3>\n<p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>\n<h3><a id="65_Advice_510"></a>6.5. 有哪些类型的通知（Advice）？</h3>\n<ul>\n<li>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>\n<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>\n<li>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>\n<li>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>\n<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>\n</ul>\n<h3><a id="66__spring_aop__concern__crosscutting_concern__518"></a>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h3>\n<p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p>\n<p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>\n<h3><a id="67_AOP__524"></a>6.7. AOP 有哪些实现方式？</h3>\n<p>实现 AOP 的技术，主要分为两大类：</p>\n<ul>\n<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；\n<ul>\n<li>编译时编织（特殊编译器实现）</li>\n<li>类加载时编织（特殊的类加载器实现）。</li>\n</ul>\n</li>\n<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。\n<ul>\n<li>JDK 动态代理</li>\n<li>CGLIB</li>\n</ul>\n</li>\n</ul>\n<h3><a id="68_Spring_AOP_and_AspectJ_AOP__534"></a>6.8. Spring AOP and AspectJ AOP 有什么区别？</h3>\n<ul>\n<li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li>\n<li>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li>\n</ul>\n<h3><a id="69__Spring__539"></a>6.9. 如何理解 Spring 中的代理？</h3>\n<p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>\n<pre><code class="prism language-java">Advice <span class="token operator">+</span> Target Object <span class="token operator">=</span> Proxy\n</code></pre>\n<h3><a id="610_Weaving_547"></a>6.10. 什么是编织（Weaving）？</h3>\n<p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190804194002754.png" alt="在这里插入图片描述"></p>\n<h2><a id="7_MVC_552"></a>7. MVC</h2>\n<h3><a id="71_Spring_MVC__554"></a>7.1. Spring MVC 框架有什么用？</h3>\n<p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>\n<h3><a id="72__DispatcherServlet__557"></a>7.2. 描述一下 DispatcherServlet 的工作流程</h3>\n<p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190804194038351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<ul>\n<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>\n<li>DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>\n<li>DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>\n<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n<ul>\n<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>\n<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li>\n<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>\n<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li>\n</ul>\n</li>\n<li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</li>\n<li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li>\n<li>ViewResolver 结合Model和View，来渲染视图。</li>\n<li>视图负责将渲染结果返回给客户端。</li>\n</ul>\n<h3><a id="73__WebApplicationContext_576"></a>7.3. 介绍一下 WebApplicationContext</h3>\n<p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>\n<p>（完）</p>\n<h3><a id="_581"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="8__589"></a>8. 原文链接</h2>\n<p>Top 50 Spring Interview Questions You Must Prepare In 2018</p>\n<p>英文原文链接：<br>\n<a href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/" rel="nofollow">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></p>\n<p>原文链接：<br>\n<a href="https://www.cnblogs.com/jingmoxukong/p/9408037.html" rel="nofollow">https://www.cnblogs.com/jingmoxukong/p/9408037.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫一扫，支持下博主吧\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/85215042', 'title': '一个故事讲清楚NIO', 'readNum': '11663', 'commentNum': '0', 'publishTime': '2019-02-27 10:25:06', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文为转载文章，原文链接：<a href="http://www.cnblogs.com/LBSer/p/4622749.html" rel="nofollow">http://www.cnblogs.com/LBSer/p/4622749.html</a></p>\n</blockquote>\n\n<p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p>\n\n<p>1） 顾客填申请表（5分钟）；</p>\n\n<p>2） 职员审核（1分钟）；</p>\n\n<p>3） 职员叫保安去金库取钱（3分钟）；</p>\n\n<p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p>\n\n<p>\u3000\u3000我们看看银行不同的工作方式对其工作效率到底有何影响。</p>\n\n<h1>1 BIO方式</h1>\n\n<p>\u3000\u3000每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p>\n\n<p>\u3000\u3000我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p>\n\n<p>\u3000\u3000可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p>\n\n<p>\u3000\u3000这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p>\n\n<h1>2 NIO方式</h1>\n\n<p>\u3000\u3000如何提高银行的吞吐量呢？</p>\n\n<p>\u3000\u3000思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。</p>\n\n<p>\u3000\u3000具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p>\n\n<p>\u3000\u3000我们计算下这种工作方式下银行一个小时到底能处理多少顾客？</p>\n\n<p>\u3000\u3000假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60/5）=108。</p>\n\n<p>\u3000\u3000可见工作方式的转变能带来效率的极大提升。</p>\n\n<p>\xa0 \xa0 \xa0 这种工作方式其实就NIO的思路。下图是非常经典的NIO说明图，mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。</p>\n\n<p>\u3000\u3000可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181222181456790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==,size_16,color_FFFFFF,t_70"></p>\n\n<p>\xa0</p>\n\n<h1>3 异步方式</h1>\n\n<p>\u3000\u3000第二种工作方式有没有什么可以提高的地方呢？</p>\n\n<p>\u3000\u3000仔细查看可发现第3步骤这3分钟柜台职员是在等待中度过的，那怎么能让柜台职员保持满负荷呢？</p>\n\n<p>\u3000\u3000还是分而治之的思路，指派1个职员B来专门负责第3步骤。每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。当职员B拿到钱之后，他会怎么办呢？他会通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p>\n\n<p>\u3000\u3000我们可以算算通过这种方法，银行的吞吐量能提高到多少。</p>\n\n<p>\u3000\u3000假设职员B的工作非常饱和，柜台一个职员现在2分钟能处理完一个顾客，一个小时8名职员能处理：8*（60/2）=240。</p>\n\n<p>\u3000\u3000在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p>\n\n<p>\u3000\u3000jetty Continuations 就实现了上述异步方式，有兴趣的同学可以去尝试下（<a href="http://wiki.eclipse.org/Jetty/Feature/Continuations" rel="nofollow">http://wiki.eclipse.org/Jetty/Feature/Continuations</a>）。</p>\n\n<p>\u3000\u3000NIO+异步的方式能让少量的线程（资源）做大量的事情，这适用于很多应用场景，比如代理服务、api服务、长连接服务等等，这些应用如果用同步方式将耗费大量机器资源。尽管NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p>\n\n<h1>\xa04 小结</h1>\n\n<p>\u3000\u3000总结就一句：“分而治之，将任务拆分开来，由专门的人负责专门的任务”，这不仅在计算机领域生效，在整个社会领域都生效。</p>\n\n<p>更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<h3>\xa0</h3>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 扫一扫，支持博主吧</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>\n\n<p>\xa0</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/85215110', 'title': 'JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解', 'readNum': '11854', 'commentNum': '1', 'publishTime': '2019-02-27 10:24:55', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文为转载文章，原文链接：<a href="https://my.oschina.net/feichexia/blog/196575" rel="nofollow">https://my.oschina.net/feichexia/blog/196575</a></p>\n</blockquote>\n\n<p>现实企业级Java应用开发、维护中，有时候我们会碰到下面这些问题：</p>\n\n<ul><li>\n\t<p>OutOfMemoryError，内存不足</p>\n\t</li>\n\t<li>\n\t<p>内存泄露</p>\n\t</li>\n\t<li>\n\t<p>线程死锁</p>\n\t</li>\n\t<li>\n\t<p>锁争用（Lock Contention）</p>\n\t</li>\n\t<li>\n\t<p>Java进程消耗CPU过高</p>\n\t</li>\n\t<li>\n\t<p>......</p>\n\t</li>\n</ul><p>\xa0 \xa0 这些问题在日常开发、维护中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是Java程序员进阶的必备要求。本文将对一些常用的JVM性能调优监控工具进行介绍，希望能起抛砖引玉之用。</p>\n\n<p><strong>而且这些监控、调优工具的使用，无论你是运维、开发、测试，都是必须掌握的。</strong></p>\n\n<p>A、\xa0jps(Java Virtual Machine Process Status Tool) \xa0 \xa0 \xa0</p>\n\n<p>\xa0 \xa0 jps主要用来输出JVM中运行的进程状态信息。语法格式如下：</p>\n\n<pre class="has">\n<code>jps\xa0[options]\xa0[hostid]</code></pre>\n\n<p>\xa0 \xa0 如果不指定hostid就默认为当前主机或服务器。</p>\n\n<p>\xa0 \xa0 命令行参数选项说明如下：</p>\n\n<pre class="has">\n<code>-q\xa0不输出类名、Jar名和传入main方法的参数\n\n-m\xa0输出传入main方法的参数\n\n-l\xa0输出main类或Jar的全限名\n\n-v\xa0输出传入JVM的参数</code></pre>\n\n<p>\xa0 \xa0比如下面：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jps\xa0-m\xa0-l\n2458\xa0org.artifactory.standalone.main.Main\xa0/usr/local/artifactory-2.2.5/etc/jetty.xml\n29920\xa0com.sun.tools.hat.Main\xa0-port\xa09998\xa0/tmp/dump.dat\n3149\xa0org.apache.catalina.startup.Bootstrap\xa0start\n30972\xa0sun.tools.jps.Jps\xa0-m\xa0-l\n8247\xa0org.apache.catalina.startup.Bootstrap\xa0start\n25687\xa0com.sun.tools.hat.Main\xa0-port\xa09999\xa0dump.dat\n21711\xa0mrf-center.jar\n</code></pre>\n\n<p>B、\xa0jstack</p>\n\n<p>\xa0 \xa0 jstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：</p>\n\n<pre class="has">\n<code>jstack\xa0[option]\xa0pid\njstack\xa0[option]\xa0executable\xa0core\njstack\xa0[option]\xa0[server-id@]remote-hostname-or-ip</code></pre>\n\n<p>\xa0 \xa0 命令行参数选项说明如下：</p>\n\n<pre class="has">\n<code>-l\xa0long\xa0listings，会打印出额外的锁信息，在发生死锁时可以用jstack\xa0-l\xa0pid来观察锁持有情况-m\xa0mixed\xa0mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</code></pre>\n\n<p>\xa0 \xa0 jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。</p>\n\n<p>\xa0 \xa0 第一步先找出Java进程ID，我部署在服务器上的Java应用名称为mrf-center：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0ps\xa0-ef\xa0|\xa0grep\xa0mrf-center\xa0|\xa0grep\xa0-v\xa0grep\nroot\xa0\xa0\xa0\xa0\xa021711\xa0\xa0\xa0\xa0\xa01\xa0\xa01\xa014:47\xa0pts/3\xa0\xa0\xa0\xa000:02:10\xa0java\xa0-jar\xa0mrf-center.jar</code></pre>\n\n<p>\xa0 \xa0 得到进程ID为21711，第二步找出该进程内最耗费CPU的线程，可以使用ps -Lfp pid或者ps -mp pid -o THREAD, tid, time或者top -Hp pid，我这里用第三个，输出如下：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/2018122218290196"></p>\n\n<p>\xa0 TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为21742的线程，用</p>\n\n<pre class="has">\n<code>printf\xa0"%x\\n"\xa021742</code></pre>\n\n<p>\xa0 \xa0 得到21742的十六进制值为54ee，下面会用到。 \xa0 \xa0</p>\n\n<p>\xa0 \xa0 OK，下一步终于轮到jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jstack\xa021711\xa0|\xa0grep\xa054ee\n"PollIntervalRetrySchedulerThread"\xa0prio=10\xa0tid=0x00007f950043e000\xa0nid=0x54ee\xa0in\xa0Object.wait()\xa0[0x00007f94c6eda000]</code></pre>\n\n<p>\xa0 \xa0 可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，我找了下我的代码，定位到下面的代码：</p>\n\n<pre class="has">\n<code>//\xa0Idle\xa0wait\ngetLog().info("Thread\xa0["\xa0+\xa0getName()\xa0+\xa0"]\xa0is\xa0idle\xa0waiting...");\nschedulerThreadState\xa0=\xa0PollTaskSchedulerThreadState.IdleWaiting;\nlong\xa0now\xa0=\xa0System.currentTimeMillis();\nlong\xa0waitTime\xa0=\xa0now\xa0+\xa0getIdleWaitTime();\nlong\xa0timeUntilContinue\xa0=\xa0waitTime\xa0-\xa0now;\nsynchronized(sigLock)\xa0{\ttry\xa0{\n\xa0\xa0\xa0\xa0\tif(!halted.get())\xa0{\n\xa0\xa0\xa0\xa0\t\tsigLock.wait(timeUntilContinue);\n\xa0\xa0\xa0\xa0\t}\n\xa0\xa0\xa0\xa0}\xa0\tcatch\xa0(InterruptedException\xa0ignore)\xa0{\n\xa0\xa0\xa0\xa0}\n}</code></pre>\n\n<p>\xa0 \xa0 它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。</p>\n\n<p>\xa0</p>\n\n<p>C、\xa0jmap（Memory Map）和jhat（Java Heap Analysis Tool）</p>\n\n<p>\xa0 \xa0 jmap用来查看堆内存使用状况，一般结合jhat使用。</p>\n\n<p>\xa0 \xa0 jmap语法格式如下：</p>\n\n<pre class="has">\n<code>jmap\xa0[option]\xa0pid\njmap\xa0[option]\xa0executable\xa0core\njmap\xa0[option]\xa0[server-id@]remote-hostname-or-ip</code></pre>\n\n<p>\xa0 \xa0 如果运行在64位JVM上，可能需要指定-J-d64命令选项参数。</p>\n\n<pre class="has">\n<code>jmap\xa0-permstat\xa0pid</code></pre>\n\n<p>\xa0 \xa0 打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息，如下图：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181222182901171"></p>\n\n<p>使用jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。比如下面的例子：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jmap\xa0-heap\xa021711\nAttaching\xa0to\xa0process\xa0ID\xa021711,\xa0please\xa0wait...\nDebugger\xa0attached\xa0successfully.\nServer\xa0compiler\xa0detected.\nJVM\xa0version\xa0is\xa020.10-b01\n\nusing\xa0thread-local\xa0object\xa0allocation.\nParallel\xa0GC\xa0with\xa04\xa0thread(s)\n\nHeap\xa0Configuration:\nMinHeapFreeRatio\xa0=\xa040\xa0\xa0\xa0\nMaxHeapFreeRatio\xa0=\xa070\xa0\xa0\xa0\nMaxHeapSize\xa0\xa0\xa0\xa0\xa0\xa0=\xa02067791872\xa0(1972.0MB)\nNewSize\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0=\xa01310720\xa0(1.25MB)\nMaxNewSize\xa0\xa0\xa0\xa0\xa0\xa0\xa0=\xa017592186044415\xa0MB\nOldSize\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0=\xa05439488\xa0(5.1875MB)\nNewRatio\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0=\xa02\xa0\xa0\xa0\nSurvivorRatio\xa0\xa0\xa0\xa0=\xa08\xa0\xa0\xa0\nPermSize\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0=\xa021757952\xa0(20.75MB)\nMaxPermSize\xa0\xa0\xa0\xa0\xa0\xa0=\xa085983232\xa0(82.0MB)\n\nHeap\xa0Usage:\nPS\xa0Young\xa0Generation\nEden\xa0Space:\n\xa0\xa0\xa0capacity\xa0=\xa06422528\xa0(6.125MB)\n\xa0\xa0\xa0used\xa0\xa0\xa0\xa0\xa0=\xa05445552\xa0(5.1932830810546875MB)\n\xa0\xa0\xa0free\xa0\xa0\xa0\xa0\xa0=\xa0976976\xa0(0.9317169189453125MB)\n\xa0\xa0\xa084.78829520089286%\xa0used\nFrom\xa0Space:\n\xa0\xa0\xa0capacity\xa0=\xa0131072\xa0(0.125MB)\n\xa0\xa0\xa0used\xa0\xa0\xa0\xa0\xa0=\xa098304\xa0(0.09375MB)\n\xa0\xa0\xa0free\xa0\xa0\xa0\xa0\xa0=\xa032768\xa0(0.03125MB)\n\xa0\xa0\xa075.0%\xa0used\nTo\xa0Space:\n\xa0\xa0\xa0capacity\xa0=\xa0131072\xa0(0.125MB)\n\xa0\xa0\xa0used\xa0\xa0\xa0\xa0\xa0=\xa00\xa0(0.0MB)\n\xa0\xa0\xa0free\xa0\xa0\xa0\xa0\xa0=\xa0131072\xa0(0.125MB)\n\xa0\xa0\xa00.0%\xa0used\nPS\xa0Old\xa0Generation\n\xa0\xa0\xa0capacity\xa0=\xa035258368\xa0(33.625MB)\n\xa0\xa0\xa0used\xa0\xa0\xa0\xa0\xa0=\xa04119544\xa0(3.9287033081054688MB)\n\xa0\xa0\xa0free\xa0\xa0\xa0\xa0\xa0=\xa031138824\xa0(29.69629669189453MB)\n\xa0\xa0\xa011.683876009235595%\xa0used\nPS\xa0Perm\xa0Generation\n\xa0\xa0\xa0capacity\xa0=\xa052428800\xa0(50.0MB)\n\xa0\xa0\xa0used\xa0\xa0\xa0\xa0\xa0=\xa026075168\xa0(24.867218017578125MB)\n\xa0\xa0\xa0free\xa0\xa0\xa0\xa0\xa0=\xa026353632\xa0(25.132781982421875MB)\n\xa0\xa0\xa049.73443603515625%\xa0used\n\xa0\xa0\xa0....</code></pre>\n\n<p>\xa0 \xa0 使用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象，如下：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jmap\xa0-histo:live\xa021711\xa0|\xa0more\xa0\nnum\xa0\xa0\xa0\xa0\xa0#instances\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0#bytes\xa0\xa0class\xa0name----------------------------------------------\n\xa0\xa0\xa01:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa038445\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa05597736\xa0\xa0&lt;constMethodKlass&gt;\n\xa0\xa0\xa02:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa038445\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa05237288\xa0\xa0&lt;methodKlass&gt;\n\xa0\xa0\xa03:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03500\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03749504\xa0\xa0&lt;constantPoolKlass&gt;\n\xa0\xa0\xa04:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa060858\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03242600\xa0\xa0&lt;symbolKlass&gt;\n\xa0\xa0\xa05:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03500\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02715264\xa0\xa0&lt;instanceKlassKlass&gt;\n\xa0\xa0\xa06:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02796\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02131424\xa0\xa0&lt;constantPoolCacheKlass&gt;\n\xa0\xa0\xa07:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa05543\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01317400\xa0\xa0[I\n\xa0\xa0\xa08:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa013714\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01010768\xa0\xa0[C\n\xa0\xa0\xa09:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa04752\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01003344\xa0\xa0[B\n\xa0\xa010:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01225\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0639656\xa0\xa0&lt;methodDataKlass&gt;\n\xa0\xa011:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa014194\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0454208\xa0\xa0java.lang.String\n\xa0\xa012:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03809\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0396136\xa0\xa0java.lang.Class\n\xa0\xa013:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa04979\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0311952\xa0\xa0[S\n\xa0\xa014:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa05598\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0287064\xa0\xa0[[I\n\xa0\xa015:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03028\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0266464\xa0\xa0java.lang.reflect.Method\n\xa0\xa016:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0280\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0163520\xa0\xa0&lt;objArrayKlassKlass&gt;\n\xa0\xa017:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa04355\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0139360\xa0\xa0java.util.HashMap$Entry\n\xa0\xa018:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01869\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0138568\xa0\xa0[Ljava.util.HashMap$Entry;\n\xa0\xa019:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02443\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa097720\xa0\xa0java.util.LinkedHashMap$Entry\n\xa0\xa020:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02072\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa082880\xa0\xa0java.lang.ref.SoftReference\n\xa0\xa021:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01807\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa071528\xa0\xa0[Ljava.lang.Object;\n\xa0\xa022:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02206\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa070592\xa0\xa0java.lang.ref.WeakReference\n\xa0\xa023:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0934\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa052304\xa0\xa0java.util.LinkedHashMap\n\xa0\xa024:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0871\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa048776\xa0\xa0java.beans.MethodDescriptor\n\xa0\xa025:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01442\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa046144\xa0\xa0java.util.concurrent.ConcurrentHashMap$HashEntry\n\xa0\xa026:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0804\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa038592\xa0\xa0java.util.HashMap\n\xa0\xa027:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0948\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa037920\xa0\xa0java.util.concurrent.ConcurrentHashMap$Segment\n\xa0\xa028:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01621\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa035696\xa0\xa0[Ljava.lang.Class;\n\xa0\xa029:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01313\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa034880\xa0\xa0[Ljava.lang.String;\n\xa0\xa030:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01396\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa033504\xa0\xa0java.util.LinkedList$Entry\n\xa0\xa031:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0462\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa033264\xa0\xa0java.lang.reflect.Field\n\xa0\xa032:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01024\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa032768\xa0\xa0java.util.Hashtable$Entry\n\xa0\xa033:\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0948\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa031440\xa0\xa0[Ljava.util.concurrent.ConcurrentHashMap$HashEntry;</code></pre>\n\n<p>\xa0 \xa0 class name是对象类型，说明如下：</p>\n\n<pre class="has">\n<code>B\xa0\xa0byte\nC\xa0\xa0char\nD\xa0\xa0double\nF\xa0\xa0float\nI\xa0\xa0int\nJ\xa0\xa0long\nZ\xa0\xa0boolean\n[\xa0\xa0数组，如[I表示int[]\n[L+类名\xa0其他对象</code></pre>\n\n<p>\xa0 \xa0 还有一个很常用的情况是：用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。jmap进行dump命令格式如下：</p>\n\n<pre class="has">\n<code>jmap\xa0-dump:format=b,file=dumpFileName pid</code></pre>\n\n<p>\xa0 \xa0 我一样地对上面进程ID为21711进行Dump：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jmap\xa0-dump:format=b,file=/tmp/dump.dat\xa021711\xa0\xa0\xa0\xa0\xa0\nDumping\xa0heap\xa0to\xa0/tmp/dump.dat\xa0...\nHeap\xa0dump\xa0file\xa0created</code></pre>\n\n<p>\xa0 \xa0dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jhat\xa0-port\xa09998\xa0/tmp/dump.dat\nReading\xa0from\xa0/tmp/dump.dat...\nDump\xa0file\xa0created\xa0Tue\xa0Jan\xa028\xa017:46:14\xa0CST\xa02014Snapshot\xa0read,\xa0resolving...\nResolving\xa0132207\xa0objects...\nChasing\xa0references,\xa0expect\xa026\xa0dots..........................\nEliminating\xa0duplicate\xa0references..........................\nSnapshot\xa0resolved.\nStarted\xa0HTTP\xa0server\xa0on\xa0port\xa09998Server\xa0is\xa0ready.</code></pre>\n\n<p>\xa0 \xa0 \xa0注意如果Dump文件太大，可能需要加上-J-Xmx512m这种参数指定最大堆内存，即jhat -J-Xmx512m -port 9998 /tmp/dump.dat。然后就可以在浏览器中输入主机地址:9998查看了：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181222182901308"></p>\n\n<p>\xa0</p>\n\n<p>D、jstat（JVM统计监测工具）</p>\n\n<p>\xa0 \xa0 语法格式如下：</p>\n\n<pre class="has">\n<code>jstat\xa0[\xa0generalOption\xa0|\xa0outputOptions\xa0vmid\xa0[interval[s|ms]\xa0[count]]\xa0]</code></pre>\n\n<p>\xa0 \xa0 vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。比如下面输出的是GC信息，采样时间间隔为250ms，采样数为4：</p>\n\n<pre class="has">\n<code>root@ubuntu:/#\xa0jstat\xa0-gc\xa021711\xa0250\xa04\xa0\nS0C\xa0\xa0\xa0\xa0S1C\xa0\xa0\xa0\xa0S0U\xa0\xa0\xa0\xa0S1U\xa0\xa0\xa0\xa0\xa0\xa0EC\xa0\xa0\xa0\xa0\xa0\xa0\xa0EU\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0OC\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0OU\xa0\xa0\xa0\xa0\xa0\xa0\xa0PC\xa0\xa0\xa0\xa0\xa0PU\xa0\xa0\xa0\xa0YGC\xa0\xa0\xa0\xa0\xa0YGCT\xa0\xa0\xa0\xa0FGC\xa0\xa0\xa0\xa0FGCT\xa0\xa0\xa0\xa0\xa0GCT\xa0\xa0\xa0\n192.0\xa0\xa0192.0\xa0\xa0\xa064.0\xa0\xa0\xa00.0\xa0\xa0\xa0\xa06144.0\xa0\xa0\xa01854.9\xa0\xa0\xa032000.0\xa0\xa0\xa0\xa0\xa04111.6\xa0\xa0\xa055296.0\xa025472.7\xa0\xa0\xa0\xa0702\xa0\xa0\xa0\xa00.431\xa0\xa0\xa03\xa0\xa0\xa0\xa0\xa0\xa00.218\xa0\xa0\xa0\xa00.649\n192.0\xa0\xa0192.0\xa0\xa0\xa064.0\xa0\xa0\xa00.0\xa0\xa0\xa0\xa06144.0\xa0\xa0\xa01972.2\xa0\xa0\xa032000.0\xa0\xa0\xa0\xa0\xa04111.6\xa0\xa0\xa055296.0\xa025472.7\xa0\xa0\xa0\xa0702\xa0\xa0\xa0\xa00.431\xa0\xa0\xa03\xa0\xa0\xa0\xa0\xa0\xa00.218\xa0\xa0\xa0\xa00.649\n192.0\xa0\xa0192.0\xa0\xa0\xa064.0\xa0\xa0\xa00.0\xa0\xa0\xa0\xa06144.0\xa0\xa0\xa01972.2\xa0\xa0\xa032000.0\xa0\xa0\xa0\xa0\xa04111.6\xa0\xa0\xa055296.0\xa025472.7\xa0\xa0\xa0\xa0702\xa0\xa0\xa0\xa00.431\xa0\xa0\xa03\xa0\xa0\xa0\xa0\xa0\xa00.218\xa0\xa0\xa0\xa00.649\n192.0\xa0\xa0192.0\xa0\xa0\xa064.0\xa0\xa0\xa00.0\xa0\xa0\xa0\xa06144.0\xa0\xa0\xa02109.7\xa0\xa0\xa032000.0\xa0\xa0\xa0\xa0\xa04111.6\xa0\xa0\xa055296.0\xa025472.7\xa0\xa0\xa0\xa0702\xa0\xa0\xa0\xa00.431\xa0\xa0\xa03\xa0\xa0\xa0\xa0\xa0\xa00.218\xa0\xa0\xa0\xa00.649\n</code></pre>\n\n<p>\xa0 \xa0 要明白上面各列的意义，先看JVM堆内存布局：</p>\n\n<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181222182901363"></p>\n\n<p>\xa0</p>\n\n<p>可以看出：</p>\n\n<pre class="has">\n<code>堆内存\xa0=\xa0年轻代\xa0+\xa0年老代\xa0+\xa0永久代\n年轻代\xa0=\xa0Eden区\xa0+\xa0两个Survivor区（From和To）</code></pre>\n\n<p>\xa0 \xa0 现在来解释各列含义：</p>\n\n<pre class="has">\n<code>S0C、S1C、S0U、S1U：Survivor\xa00/1区容量（Capacity）和使用量（Used）\nEC、EU：Eden区容量和使用量\nOC、OU：年老代容量和使用量\nPC、PU：永久代容量和使用量\nYGC、YGT：年轻代GC次数和GC耗时\nFGC、FGCT：Full\xa0GC次数和Full\xa0GC耗时\nGCT：GC总耗时</code></pre>\n\n<p>\xa0</p>\n\n<p>E、hprof（Heap/CPU Profiling Tool）</p>\n\n<p>\xa0 \xa0 hprof能够展现CPU使用率，统计堆内存使用情况。</p>\n\n<p>\xa0 \xa0 语法格式如下：</p>\n\n<pre class="has">\n<code>java\xa0-agentlib:hprof[=options]\xa0ToBeProfiledClass\njava\xa0-Xrunprof[:options]\xa0ToBeProfiledClass\njavac\xa0-J-agentlib:hprof[=options]\xa0ToBeProfiledClass</code></pre>\n\n<p>\xa0 \xa0 完整的命令选项如下：</p>\n\n<pre class="has">\n<code>Option\xa0Name\xa0and\xa0Value\xa0\xa0Description\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Default\n---------------------\xa0\xa0-----------\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0-------\nheap=dump|sites|all\xa0\xa0\xa0\xa0heap\xa0profiling\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0all\ncpu=samples|times|old\xa0\xa0CPU\xa0usage\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0off\nmonitor=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0monitor\xa0contention\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0n\nformat=a|b\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0text(txt)\xa0or\xa0binary\xa0output\xa0\xa0\xa0\xa0\xa0a\nfile=&lt;file&gt;\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0write\xa0data\xa0to\xa0file\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0java.hprof[.txt]\nnet=&lt;host&gt;:&lt;port&gt;\xa0\xa0\xa0\xa0\xa0\xa0send\xa0data\xa0over\xa0a\xa0socket\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0off\ndepth=&lt;size&gt;\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0stack\xa0trace\xa0depth\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa04\ninterval=&lt;ms&gt;\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0sample\xa0interval\xa0in\xa0ms\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa010\ncutoff=&lt;value&gt;\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0output\xa0cutoff\xa0point\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa00.0001\nlineno=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0line\xa0number\xa0in\xa0traces?\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0y\nthread=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0thread\xa0in\xa0traces?\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0n\ndoe=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0dump\xa0on\xa0exit?\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0y\nmsa=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Solaris\xa0micro\xa0state\xa0accounting\xa0n\nforce=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0force\xa0output\xa0to\xa0&lt;file&gt;\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0y\nverbose=y|n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0print\xa0messages\xa0about\xa0dumps\xa0\xa0\xa0\xa0\xa0y</code></pre>\n\n<p>\xa0 \xa0 来几个官方指南上的实例。</p>\n\n<p>\xa0 \xa0 CPU Usage Sampling Profiling(cpu=samples)的例子：</p>\n\n<pre class="has">\n<code>java\xa0-agentlib:hprof=cpu=samples,interval=20,depth=3\xa0Hello</code></pre>\n\n<p>\xa0 \xa0 上面每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，在当前目录。\xa0</p>\n\n<p>\xa0 \xa0 CPU Usage Times Profiling(cpu=times)的例子，它相对于CPU Usage Sampling Profile能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）：</p>\n\n<pre class="has">\n<code>javac\xa0-J-agentlib:hprof=cpu=times\xa0Hello.java</code></pre>\n\n<p>\xa0 \xa0 Heap Allocation Profiling(heap=sites)的例子：</p>\n\n<pre class="has">\n<code>javac\xa0-J-agentlib:hprof=heap=sites\xa0Hello.java</code></pre>\n\n<p>\xa0 \xa0 Heap Dump(heap=dump)的例子，它比上面的Heap Allocation Profiling能生成更详细的Heap Dump信息：</p>\n\n<pre class="has">\n<code>javac\xa0-J-agentlib:hprof=heap=dump\xa0Hello.java</code></pre>\n\n<p>\xa0 \xa0\xa0虽然在JVM启动参数中加入-Xrunprof:heap=sites参数可以生成CPU/Heap Profile文件，但对JVM性能影响非常大，不建议在线上服务器环境使用。</p>\n\n<p>\xa0</p>\n\n<p>### 更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258"></p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0扫一扫，支持下博主吧</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0</strong></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84927180', 'title': 'Spring AOP 原理源码深度剖析', 'readNum': '14854', 'commentNum': '2', 'publishTime': '2019-02-27 10:24:37', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p>本文转载于公众号：吉姆餐厅ak</p>\n</blockquote>\n\n<p>概述<br>\nAOP(Aspect-Oriented Programming) 面向切面编程。Spring Aop 在 Spring框架中的地位举足轻重，主要用于实现事务、缓存、安全等功能。本篇主要是对源码进行深度分析。</p>\n\n<p>主要介绍以下三个方面：</p>\n\n<p>Spring AOP 多种代理机制相关核心类介绍。<br>\nSpring Boot 中AOP注解方式源码分析。<br>\nSpring Boot 1.x 版本和 2.x版本 AOP 默认配置的变动。<br>\nSpring AOP 多种代理机制相关核心类介绍<br>\n先介绍一些Spring Aop中一些核心类，大致分为三类：</p>\n\n<p>advisorCreator，继承 spring ioc的扩展接口 beanPostProcessor，主要用来扫描获取 advisor。<br>\nadvisor：顾问的意思，封装了spring aop中的切点和通知。<br>\nadvice：通知，也就是aop中增强的方法。<br>\n对以上三类核心类对应的 UML 分别来看。</p>\n\n<p>advisorCreator：</p>\n\n<p><br>\nAbstractAutoProxyCreator：Spring 为Spring AOP 模块暴露的可扩展抽象类，也是 AOP 中最核心的抽象类。Nepxion Matrix 框架便是基于此类对AOP进行扩展和增强。</p>\n\n<p>BeanNameAutoProxyCreator：根据指定名称创建代理对象（阿里大名鼎鼎的连接池框架druid也基于此类做了扩展）。通过设置 advisor，可以对指定的 beanName 进行代理。支持模糊匹配。</p>\n\n<p>AbstractAdvisorAutoProxyCreator：功能比较强大，默认扫描所有Advisor的实现类。相对于根据Bean名称匹配，该类更加灵活。动态的匹配每一个类，判断是否可以被代理，并寻找合适的增强类，以及生成代理类。</p>\n\n<p>DefaultAdvisorAutoProxyCreator：AbstractAdvisorAutoProxyCreator的默认实现类。可以单独使用，在框架中使用AOP，尽量不要手动创建此对象。</p>\n\n<p>AspectJAwareAdvisorAutoProxyCreator：Aspectj的实现方式，也是Spring Aop中最常用的实现方式，如果用注解方式，则用其子类AnnotationAwareAspectJAutoProxyCreator。</p>\n\n<p>AnnotationAwareAspectJAutoProxyCreator：目前最常用的AOP使用方式。spring aop 开启注解方式之后，该类会扫描所有@Aspect()注释的类，生成对应的adviosr。目前SpringBoot框架中默认支持的方式，自动配置。</p>\n\n<p>advisor：</p>\n\n<p><br>\nStaticMethodMatcherPointcut：静态方法切面，抽象类。定义了一个classFilter，通过重写getClassFilter()方法来指定切面规则。另外实现了StaticMethodMatcher接口，通过重写matches来指定方法匹配规则。</p>\n\n<p>StaticMethodMatcherPointcutAdvisor：静态方法匹配切面顾问，同未抽象类，扩展了切面排序方法。</p>\n\n<p>NameMatchMethodPointcut：名称匹配切面，通过指定方法集合变量mappedNames，模糊匹配。</p>\n\n<p>NameMatchMethodPointcutAdvisor：方法名称切面顾问，内部封装了<br>\nNameMatchMethodPointcut，通过设置方法名称模糊匹配规则和通知来实现切面功能。</p>\n\n<p>RegexpMethodPointcutAdvisor：正则表达式切面顾问，可设置多个正则表达式规则，通过内部封装的<br>\nJdkRegexpMethodPointcut解析正则表达式。</p>\n\n<p>DefaultPointcutAdvisor：默认切面顾问，比较灵活。可自由组合切面和通知。</p>\n\n<p>InstantiationModelAwarePointcutAdvisorImpl：springboot自动装配的顾问类型，也是最常用的一种顾问实现。在注解实现的切面中，所有@Aspect类，都会被解析成该对象。</p>\n\n<p>advice：</p>\n\n<p><br>\nAspectJMethodBeforeAdvice：前置通知，AspectJ中 before 属性对应的通知（@Before标注的方法会被解析成该通知），，在切面方法执行之前执行。<br>\nAspectJAfterReturningAdvice：后置通知，AspectJ中 afterReturning 属性对应的通知（@AfterReturning 标注的方法会被解析成该通知），在切面方法执行之后执行，如果有异常，则不执行。<br>\n注意：该通知与AspectJMethodBeforeAdvice对应。<br>\nAspectJAroundAdvice：环绕通知，AspectJ中 around 属性对应的通知（@Around标注的方法会被解析成该通知），在切面方法执行前后执行。<br>\nAspectJAfterAdvice：返回通知，AspectJ中 after 属性对应的通知（@After 标注的方法会被解析成该通知），不论是否异常都会执行。<br>\n可以看出 Spring AOP 提供的实现方式很多，但是殊途同归。</p>\n\n<p>具体使用方式已上传至 github：<br>\nhttps://github.com/admin801122/springboot2-spring5-studying</p>\n\n<p><br>\nSpring Boot 中AOP注解方式源码分析<br>\nSpring Aop使用方式很多，从上面的 API 也可以看出。本篇就基于最常用的注解实现方式，对源码深入分析。</p>\n\n<p>@Aspect<br>\n@Component<br>\npublic class LogableAspect {</p>\n\n<p>\xa0 \xa0 @Pointcut("@annotation(com.springboot2.spring5.springAop.aspect.Logable)")<br>\n\xa0 \xa0 public void aspect() {<br>\n\xa0 \xa0 }<br>\n\xa0 \xa0\xa0<br>\n\xa0 \xa0 @Around("aspect()")<br>\n\xa0 \xa0 public Object doAround(ProceedingJoinPoint point) throws Throwable {<br>\n\xa0 \xa0 \xa0 \xa0 //...<br>\n\xa0 \xa0 \xa0 \xa0 Object returnValue = \xa0point.proceed(point.getArgs());<br>\n\xa0 \xa0 \xa0 \xa0 //...<br>\n\xa0 \xa0 \xa0 \xa0 return returnValue;<br>\n\xa0 \xa0 }<br>\n}<br><br>\n这是实际项目中，使用AOP最常见的形式，基于注解实现。如今springboot大行其道，我们就从springboot中的EnableAspectJAutoProxy自动配置开始。</p>\n\n<p>大致流程主要分为三个步骤：<br>\n1： 创建AnnotationAwareAspectJAutoProxyCreator对象<br>\n2： 扫描容器中的切面，创建PointcutAdvisor对象<br>\n3： 生成代理类</p>\n\n<p>分别来分析以上三个步骤。</p>\n\n<p>1： 创建AnnotationAwareAspectJAutoProxyCreator对象<br>\n首先来看AnnotationAwareAspectJAutoProxyCreator对象初始化的过程。springboot中，aop同样以自动装配的方式，所以还是要从spring.factories开始：</p>\n\n<p># Auto Configure<br>\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\<br><br>\n@Configuration<br>\n@ConditionalOnClass({ EnableAspectJAutoProxy.class, Aspect.class, Advice.class,<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0AnnotatedElement.class })<br>\n@ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)<br>\npublic class AopAutoConfiguration {</p>\n\n<p>\xa0\xa0 \xa0@Configuration<br>\n\xa0\xa0 \xa0@EnableAspectJAutoProxy(proxyTargetClass = false)<br>\n\xa0\xa0 \xa0@ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "false", matchIfMissing = false)<br>\n\xa0\xa0 \xa0public static class JdkDynamicAutoProxyConfiguration {</p>\n\n<p>\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0@Configuration<br>\n\xa0\xa0 \xa0@EnableAspectJAutoProxy(proxyTargetClass = true)<br>\n\xa0\xa0 \xa0@ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true", matchIfMissing = true)<br>\n\xa0\xa0 \xa0public static class CglibAutoProxyConfiguration {</p>\n\n<p>\xa0\xa0 \xa0}</p>\n\n<p>}<br><br>\n具体来看：<br>\n（1）该配置类的加载前提是什么？</p>\n\n<p>@ConditionalOnClass({ EnableAspectJAutoProxy.class, Aspect.class, Advice.class,<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0AnnotatedElement.class })<br><br>\n条件注解依赖的配置类均被引入到spring-boot-starter-aop中，只需引入该依赖即可自动装配。<br>\n而且可以看到spring.aop.auto默认为true，并不需要手动开启。<br>\n所以很多同学在springboot项目中使用 aop 的时候，习惯在启动类上引入@EnableAspectJAutoProxy，其实完全不必要。保证项目中有spring-boot-starter-aop依赖即可。</p>\n\n<p>（2）上述代码通过spring.aop.proxy-target-class变量来控制proxyTargetClass的变量，最终都会加载@EnableAspectJAutoProxy配置。<br>\nspring.aop.proxy-target-class默认为true，该变量相当关键，控制 spring aop 代理类的生成方式，具体后面详细介绍。</p>\n\n<p>继续跟进EnableAspectJAutoProxy：</p>\n\n<p>class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {</p>\n\n<p>\xa0\xa0 \xa0@Override<br>\n\xa0\xa0 \xa0public void registerBeanDefinitions(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0//注册 AnnotationAwareAspectJAutoProxyCreator<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0AnnotationAttributes enableAspectJAutoProxy =<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//将 aop 代理方式相关的变量设置到 AopConfigUtils，创建代理类时会读取变量<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (enableAspectJAutoProxy != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0}<br>\n}<br><br>\n\xa0\xa0 \xa0@Nullable<br>\n\xa0\xa0 \xa0public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry,<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0@Nullable Object source) {</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);<br>\n\xa0\xa0 \xa0}<br><br>\n上述代码可以看到注册了一个切面相关BeanDefinition，正是上面提到的类：<br>\nAnnotationAwareAspectJAutoProxyCreator，并设置了代理方式配置变量： proxyTargetClass，默认为true。</p>\n\n<p>这里只是创建BeanDefinition，并没有实例化和初始化该对象。那什么时候会触发呢？<br>\n上面的 uml 图可以看到，该类继承的顶层接口为 BeanPostProcessor。我们知道BeanPostProcessor实现类会提前初始化，由PostProcessorRegistrationDelegate触发，具体细节之前博客有提到：<br>\nSpringBoot2 | @SpringBootApplication注解 自动化配置流程源码分析（三）</p>\n\n<p>该类又继承BeanFactoryAware，所以在其在实例化 bean 后，会触发setBeanFactory()方法，最终会触发<br>\ninitBeanFactory方法：</p>\n\n<p>\xa0\xa0 \xa0@Override<br>\n\xa0\xa0 \xa0protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0super.initBeanFactory(beanFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (this.aspectJAdvisorFactory == null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//advisor 工厂类<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//用于创建 advisor<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0this.aspectJAdvisorsBuilder =<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0new BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory);<br>\n\xa0\xa0 \xa0}<br><br>\n至此，AnnotationAwareAspectJAutoProxyCreator BeanDefinition创建完毕。</p>\n\n<p>2： 扫描容器中的切面，创建PointcutAdvisor对象<br>\n在spring ioc流程加载的过程中，会触发 beanPostProcessor 扩展接口，<br>\n而AnnotationAwareAspectJAutoProxyCreator又是SmartInstantiationAwareBeanPostProcessor的子类，所以该扩展接口正是 aop 实现的入口。</p>\n\n<p>该接口的触发在实例化 bean 之后，初始化 bean之前，具体来看：</p>\n\n<p>@Override<br>\n\xa0\xa0 \xa0public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0Object cacheKey = getCacheKey(beanClass, beanName);</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//advisedBeans用于存储不可代理的bean，如果包含直接返回<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (this.advisedBeans.containsKey(cacheKey)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return null;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//判断当前bean是否可以被代理，然后存入advisedBeans<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.advisedBeans.put(cacheKey, Boolean.FALSE);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return null;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0// Create proxy here if we have a custom TargetSource.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0// Suppresses unnecessary default instantiation of the target bean:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0// The TargetSource will handle target instances in a custom fashion.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//到这里说明该bean可以被代理，所以去获取自定义目标类，如果没有定义，则跳过。<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0TargetSource targetSource = getCustomTargetSource(beanClass, beanName);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (targetSource != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (StringUtils.hasLength(beanName)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.targetSourcedBeans.add(beanName);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.proxyTypes.put(cacheKey, proxy.getClass());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//如果最终可以获得代理类，则返回代理类，直接执行实例化后置通知方法<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return proxy;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0return null;<br>\n\xa0\xa0 \xa0}<br><br>\n来看一下判定 bean 是否被代理的方法依据：</p>\n\n<p>\xa0\xa0 \xa0@Override<br>\n\xa0\xa0 \xa0protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return (super.isInfrastructureClass(beanClass) ||<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0(this.aspectJAdvisorFactory != null &amp;&amp; this.aspectJAdvisorFactory.isAspect(beanClass)));<br>\n\xa0\xa0 \xa0}<br><br>\n\xa0\xa0 \xa0private boolean hasAspectAnnotation(Class&lt;?&gt; clazz) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//判定当前类是否有 Aspect 注解，如果有，则不能被代理<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);<br>\n\xa0\xa0 \xa0}<br><br>\n\xa0\xa0 \xa0protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//判定当前bean是否是 Advice、Pointcut、Advisor、AopInfrastructureBean等子类或实现类，如果是，则不能被代理<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0boolean retVal = Advice.class.isAssignableFrom(beanClass) ||<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Pointcut.class.isAssignableFrom(beanClass) ||<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Advisor.class.isAssignableFrom(beanClass) ||<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AopInfrastructureBean.class.isAssignableFrom(beanClass);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (retVal &amp;&amp; logger.isTraceEnabled()) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0logger.trace("Did not attempt to auto-proxy infrastructure class [" + beanClass.getName() + "]");<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return retVal;<br>\n\xa0\xa0 \xa0}<br><br>\n重点来看 shouldSkip方法：</p>\n\n<p>\xa0\xa0 \xa0@Override<br>\n\xa0\xa0 \xa0protected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0// TODO: Consider optimization by caching the list of the aspect names<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//获取所有的候选顾问类 Advisor<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0for (Advisor advisor : candidateAdvisors) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (advisor instanceof AspectJPointcutAdvisor &amp;&amp;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return true;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return super.shouldSkip(beanClass, beanName);<br>\n\xa0\xa0 \xa0}<br><br>\n上述代码通过findCandidateAdvisors()方法来获取所有的候选 advisor：</p>\n\n<p>@Override<br>\n\xa0\xa0 \xa0protected List&lt;Advisor&gt; findCandidateAdvisors() {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0// Add all the Spring advisors found according to superclass rules.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//获得 Advisor 实现类<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0// Build Advisors for all AspectJ aspects in the bean factory.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//将@Aspect注解类， 解析成Advisor\xa0<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (this.aspectJAdvisorsBuilder != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return advisors;<br>\n\xa0\xa0 \xa0}<br><br>\n继续跟进buildAspectJAdvisors方法，会触发<br>\nReflectiveAspectJAdvisorFactory中的getAdvisors方法：</p>\n\n<p>@Override<br>\n\xa0\xa0 \xa0public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//从 aspectMetadata 中获取 Aspect()标注的类 class对象<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//获取Aspect()标注的类名<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0validate(aspectClass);</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0// so that it will only instantiate once.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0List&lt;Advisor&gt; advisors = new LinkedList&lt;&gt;();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//遍历该类所有方法，根据方法判断是否能获取到对应 pointCut，如果有，则生成 advisor 对象<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0for (Method method : getAdvisorMethods(aspectClass)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (advisor != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0advisors.add(advisor);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0// If it\'s a per target aspect, emit the dummy instantiating aspect.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0advisors.add(0, instantiationAdvisor);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0// Find introduction fields.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//获取 @DeclareParents 注解修饰的属性（并不常用）<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0for (Field field : aspectClass.getDeclaredFields()) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Advisor advisor = getDeclareParentsAdvisor(field);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (advisor != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0advisors.add(advisor);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0return advisors;<br>\n\xa0\xa0 \xa0}<br><br>\n继续来看getAdvisor方法：</p>\n\n<p>\xa0\xa0 \xa0@Override<br>\n\xa0\xa0 \xa0@Nullable<br>\n\xa0\xa0 \xa0public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0int declarationOrderInAspect, String aspectName) {</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//根据候选方法名，来获取对应的 pointCut<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0AspectJExpressionPointcut expressionPointcut = getPointcut(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (expressionPointcut == null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return null;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//如果能获取到 pointCut，则将切点表达式 expressionPointcut、当前<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0对象ReflectiveAspectJAdvisorFactory、 方法名等包装成 advisor 对象<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this, aspectInstanceFactory, declarationOrderInAspect, aspectName);<br>\n\xa0\xa0 \xa0}<br><br>\n\xa0\xa0 \xa0protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//定义class对象数组，如果方法中有以下注解中任何一种，则返回该注解<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0Class&lt;?&gt;[] classesToLookFor = new Class&lt;?&gt;[] {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0for (Class&lt;?&gt; c : classesToLookFor) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (foundAnnotation != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return foundAnnotation;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return null;<br>\n\xa0\xa0 \xa0}<br><br>\nInstantiationModelAwarePointcutAdvisorImpl的构造方法会触发构造通知对象：</p>\n\n<p>public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//......<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//根据注解类型，匹配对应的通知类型<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0switch (aspectJAnnotation.getAnnotationType()) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//前置通知<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0case AtBefore:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice = new AspectJMethodBeforeAdvice(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0break;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//最终通知<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0case AtAfter:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice = new AspectJAfterAdvice(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0break;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//后置通知<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0case AtAfterReturning:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice = new AspectJAfterReturningAdvice(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (StringUtils.hasText(afterReturningAnnotation.returning())) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice.setReturningName(afterReturningAnnotation.returning());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0break;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//异常通知<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0case AtAfterThrowing:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice = new AspectJAfterThrowingAdvice(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice.setThrowingName(afterThrowingAnnotation.throwing());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0break;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//环绕通知<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0case AtAround:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0springAdvice = new AspectJAroundAdvice(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0break;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//切面<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0case AtPointcut:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (logger.isDebugEnabled()) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0logger.debug("Processing pointcut \'" + candidateAdviceMethod.getName() + "\'");<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return null;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0default:<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0throw new UnsupportedOperationException(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0"Unsupported advice type on method: " + candidateAdviceMethod);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0//......<br>\n\xa0\xa0 \xa0}<br><br>\n可以看到，根据@Aspect类中方法的注解类型，生成对应的advice，并通过通知的构造方法，将通知增强方法，切面表达式传入到通知当中。</p>\n\n<p>到这里InstantiationModelAwarePointcutAdvisorImpl对象构造完毕。</p>\n\n<p>3： 生成代理类<br>\n上面创建advisor的逻辑发生在扩展接口中的postProcessBeforeInstantiation，实例化之前执行，如果有自定义的TargetSource指定类，则则直接生成代理类，并直接执行初始化之后的方法postProcessAfterInitialization。这种情况使用不多，常规代理类还是在postProcessAfterInitialization中创建，也就是 IOC 最后一个扩展方法。</p>\n\n<p>\xa0\xa0 \xa0@Override<br>\n\xa0\xa0 \xa0public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) throws BeansException {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (bean != null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//处理循环依赖的判断<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (!this.earlyProxyReferences.contains(cacheKey)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return wrapIfNecessary(bean, beanName, cacheKey);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return bean;<br>\n\xa0\xa0 \xa0}<br><br>\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return bean;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return bean;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.advisedBeans.put(cacheKey, Boolean.FALSE);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return bean;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0// Create proxy if we have advice.<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//获取到合适的advisor，如果为空。如果不为空，则生成代理类。<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (specificInterceptors != DO_NOT_PROXY) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.advisedBeans.put(cacheKey, Boolean.TRUE);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Object proxy = createProxy(<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0this.proxyTypes.put(cacheKey, proxy.getClass());<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return proxy;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}</p>\n\n<p>\xa0\xa0 \xa0\xa0\xa0 \xa0this.advisedBeans.put(cacheKey, Boolean.FALSE);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return bean;<br>\n\xa0\xa0 \xa0}<br><br><br>\n上述方法通过调用getAdvicesAndAdvisorsForBean()方法来获取advisor，该方法最终会调用findEligibleAdvisors()，Eligible意为有资格的，合适的。具体来看下：</p>\n\n<p>protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//这里会对获取的advisor进行筛选<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//添加一个默认的advisor，执行时用到。<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0extendAdvisors(eligibleAdvisors);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (!eligibleAdvisors.isEmpty()) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0eligibleAdvisors = sortAdvisors(eligibleAdvisors);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return eligibleAdvisors;<br>\n\xa0\xa0 \xa0}<br><br>\n最终的筛选规则在AopUtils中：</p>\n\n<p>public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//......<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0for (Advisor candidate : candidateAdvisors) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (candidate instanceof IntroductionAdvisor) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0// already processed<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0continue;<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}\xa0<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//调用 canApply 方法，遍历所有的方法进行匹配<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (canApply(candidate, clazz, hasIntroductions)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0eligibleAdvisors.add(candidate);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0//......<br>\n\xa0\xa0 \xa0}<br><br>\n调用canApply方法，遍历被代理类的所有的方法，跟进切面表达式进行匹配，如果有一个方法匹配到，也就意味着该类会被代理。<br>\n匹配方法是借助org.aspectj.weaver.internal.tools实现，也就是AspectJ框架中的工具类，有兴趣的可以自行查看。</p>\n\n<p>重点来看一下代理生成方式：</p>\n\n<p>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0Class&lt;?&gt; targetClass = config.getTargetClass();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (targetClass == null) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0throw new AopConfigException("TargetSource cannot determine target class: " +<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0"Either an interface or a target is required for proxy creation.");<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0//如果代理目标是接口或者Proxy类型，则走jdk类型<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return new JdkDynamicAopProxy(config);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return new ObjenesisCglibAopProxy(config);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0else {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0return new JdkDynamicAopProxy(config);<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0}<br>\n\xa0\xa0 \xa0}<br><br>\n上述方法通过三个变量来进行筛选代理方法：</p>\n\n<p>optimize：官方文档翻译为设置代理是否应执行积极的优化，默认为false。<br>\nproxyTargetClass：这个在上面已经提到了，AopAutoConfiguration中指定，默认为true，也就是选择使用 cglib 代理。可以看到该变量和optimize意义一样，之所以这么做，个人理解是为了可以在不同的场景中使用。<br>\nhasNoUserSuppliedProxyInterfaces：是否设置了实现接口。<br>\nhasNoUserSuppliedProxyInterfaces方法如下：</p>\n\n<p>private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();<br>\n\xa0\xa0 \xa0\xa0\xa0 \xa0return (ifcs.length == 0 || (ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0])));<br>\n\xa0\xa0 \xa0}<br><br>\n主要就是判断AdvisedSupport中interfaces变量中是否设置了接口，</p>\n\n<p>意思是如果一个类实现了接口，把接口设置到该方法的变量中，但是不是一定会设置到该变量中，具体设置接口的代码如下：</p>\n\n<p>可以看到如果用默认配置也就是proxyTargetClass为true时，只有一种情况会走jdk代理方法，就是代理类为接口类型（注意：代理类是接口类型，并不是指接口类是否实现了接口）或者代理类是Proxy类型，否则全部走cglib代理。所以，平时使用中，代理类大部分还是用cglib的方式来生成。</p>\n\n<p>Spring Boot 1.x 版本和 2.x版本 AOP 默认配置的变动<br>\n配置类AopAutoConfiguration：</p>\n\n<p>1.5x版本：</p>\n\n<p>\xa0 \xa0 @Configuration<br>\n\xa0 \xa0 @EnableAspectJAutoProxy(proxyTargetClass = true)<br>\n\xa0 \xa0 @ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true", matchIfMissing = false)<br>\n\xa0 \xa0 public static class CglibAutoProxyConfiguration {</p>\n\n<p>\xa0 \xa0 }<br><br>\n2.x版本：</p>\n\n<p>\xa0 \xa0 @Configuration<br>\n\xa0 \xa0 @EnableAspectJAutoProxy(proxyTargetClass = true)<br>\n\xa0 \xa0 @ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true", matchIfMissing = true)<br>\n\xa0 \xa0 public static class CglibAutoProxyConfiguration {</p>\n\n<p>\xa0 \xa0 }<br><br>\n可以看到，在SpringBoot2.x中最主要的变化就是proxy-target-class默认为true，意味着类代理的时候全部走cglib代理方式，只有为接口代理时才走jdk代理(注意：这里为接口代理，不是指代理目标类是否实现了接口)。所以，在使用springboot2.x的版本中，除了代理目标类是接口外，其余的代理方式全部采用cglib类型。</p>\n\n<p>总结<br>\nSpringboot通过自动装配AopAutoConfiguration配置类，默认自动开启 AOP 功能。通过注册<br>\nAnnotationAwareAspectJAutoProxyCreator类，来扫描创建所有的Advisor，再通过 Advisor在 Spring IOC的扩展接口中来创建代理类。</p>\n\n<p>更多阅读</p>\n\n<p>[史上最简单的 SpringCloud 教程汇总](https://blog.csdn.net/forezp/article/details/70148833)</p>\n\n<p>[SpringBoot教程汇总](https://blog.csdn.net/forezp/article/details/70341818)</p>\n\n<p>[Java面试题系列汇总](https://blog.csdn.net/forezp/article/details/85163411)</p>\n\n<p>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<img alt="" class="has" height="258" src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258">\xa0<br>\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0扫码关注有惊喜</p>\n\n<p><strong>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0</strong></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87910226', 'title': '聊聊 SpringCloud 中的父子容器', 'readNum': '9108', 'commentNum': '0', 'publishTime': '2019-02-24 18:16:59', 'content': '<div class="htmledit_views" id="content_views">\n                                            <blockquote>\n<p><span style="color:#7f7f7f;">来源公号：吉姆餐厅ak</span></p>\n</blockquote>\n\n<p style="margin-left:16px;">\xa0</p>\n\n<h2><strong>概述</strong></h2>\n\n<p>在引入 SpringCloud 的项目中会多次创建 Spring 容器，本篇从源码角度深入分析具体哪些点会创建 Spring 容器，以及这些容器之间的区别与联系。</p>\n\n<blockquote>\n<p>本文介绍的Spring相关容器是基于 SpringCloud Finchley.RELEASE 版本。</p>\n</blockquote>\n\n<hr><p>\xa0</p>\n\n<p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7iaUeydzEAF5VmlDZAgjjmrO43e0G3Viad3lAEGEh5Dq25xfic2qwcqPt8W7Tpic0cwUicruOW30IGIIkw/640?wx_fmt=png" style="margin-left:auto;"></p>\n\n<p>\xa0</p>\n\n<p>容器大致分为三层，分别对应上面的三类：</p>\n\n<ul><li>\n\t<p><span style="color:inherit;">BootStrap上下文：由SpringCloud 监听器创建，用来初始化 SpringCloud 上下文，也是祖先容器。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">SpringBoot 上下文：由SpringBoot创建，也是项目中常用的Spring容器。</span></p>\n\t</li>\n\t<li>\n\t<p><span style="color:inherit;">微服务配置上下文：Feign和Ribbon配置类对应的上下文，由配置容器抽象工厂\xa0NamedContextFactory 创建，用于容器隔离。</span></p>\n\t</li>\n</ul><p>分别来看。</p>\n\n<hr><h2><strong>BootStrap 上下文</strong></h2>\n\n<p>在之前的博客《<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTk1MTE5NQ==&amp;mid=2247483664&amp;idx=1&amp;sn=4c384c9f1f49c9a3e4a481bceeba012b&amp;chksm=f90b2ca4ce7ca5b2c1762e526c8bd0f34fd387552e182f3fa480386ad57e1cf3980d189e8b3d&amp;token=302932053&amp;lang=zh_CN&amp;scene=21#wechat_redirect" rel="nofollow">SpringBoot | 第一篇：启动流程源码分析（上）</a>》中，提到了 SpringBoot 在启动时，会触发相关一系列监听器，监听器各司其职，做一些初始化预处理操作。SpringCloud 实现了自己的监听器：<code style="margin-left:2px;">BootstrapApplicationListener</code>，来初始化SpringCloud上下文环境。</p>\n\n<p>来看一下该监听器被触发后的处理逻辑：</p>\n\n<pre>\n<code style="margin-left:2px;">@<span style="color:inherit;">Override\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">public</span>\xa0<span style="color:#fcc28c;">void</span>\xa0<span style="color:#ffffaa;">onApplicationEvent</span>(<span style="color:inherit;">ApplicationEnvironmentPreparedEvent\xa0<span style="color:#fcc28c;">event</span></span>)\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurableEnvironment\xa0environment\xa0=\xa0<span style="color:#fcc28c;">event</span>.getEnvironment();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//如果未开启SpringCloud，直接返回</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(!environment.getProperty(<span style="color:#a2fca2;">"spring.cloud.bootstrap.enabled"</span>,\xa0Boolean.class,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">true</span>))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">return</span>;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//\xa0don\'t\xa0listen\xa0to\xa0events\xa0in\xa0a\xa0bootstrap\xa0context</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//判断该监听器是否已经执行过，如果执行过，直接返回</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">return</span>;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//这里返回了一个\xa0Spring\xa0容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurableApplicationContext\xa0context\xa0=\xa0bootstrapServiceContext(environment,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">event</span>.getSpringApplication());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0apply(context,\xa0<span style="color:#fcc28c;">event</span>.getSpringApplication(),\xa0environment);\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p><code style="margin-left:2px;">bootstrapServiceContext</code>方法创建了一个 Spring 容器：</p>\n\n<pre>\n<code style="margin-left:2px;">private\xa0ConfigurableApplicationContext\xa0bootstrapServiceContext(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurableEnvironment\xa0environment,\xa0<span style="color:#fcc28c;">final</span>\xa0SpringApplication\xa0application)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0StandardEnvironment\xa0bootstrapEnvironment\xa0=\xa0<span style="color:#fcc28c;">new</span>\xa0StandardEnvironment();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0MutablePropertySources\xa0bootstrapProperties\xa0=\xa0bootstrapEnvironment\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.getPropertySources();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(PropertySource&lt;?&gt;\xa0source\xa0:\xa0bootstrapProperties)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0bootstrapProperties.remove(source.getName());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//设置读取\xa0bootstrap\xa0文件</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">String</span>\xa0configName\xa0=\xa0environment\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.resolvePlaceholders(<span style="color:#a2fca2;">"<span style="color:inherit;">${spring.cloud.bootstrap.name:bootstrap}</span>"</span>);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//设置\xa0bootstrap\xa0文件路径</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">String</span>\xa0configLocation\xa0=\xa0environment\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.resolvePlaceholders(<span style="color:#a2fca2;">"<span style="color:inherit;">${spring.cloud.bootstrap.location:}</span>"</span>);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">Map</span>&lt;<span style="color:#ffffaa;">String</span>,\xa0<span style="color:#ffffaa;">Object</span>&gt;\xa0bootstrapMap\xa0=\xa0<span style="color:#fcc28c;">new</span>\xa0HashMap&lt;&gt;();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0bootstrapMap.put(<span style="color:#a2fca2;">"spring.config.name"</span>,\xa0configName);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(StringUtils.hasText(configLocation))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0bootstrapMap.put(<span style="color:#a2fca2;">"spring.config.location"</span>,\xa0configLocation);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//设置是否已经初始化BootStrap环境</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0bootstrapProperties.addFirst(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">new</span>\xa0MapPropertySource(BOOTSTRAP_PROPERTY_SOURCE_NAME,\xa0bootstrapMap));\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(PropertySource&lt;?&gt;\xa0source\xa0:\xa0environment.getPropertySources())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0bootstrapProperties.addLast(source);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//......</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//加载BootstrapConfiguration\xa0配置类</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">List</span>&lt;<span style="color:#ffffaa;">String</span>&gt;\xa0names\xa0=\xa0SpringFactoriesLoader\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.loadFactoryNames(BootstrapConfiguration.<span style="color:#fcc28c;">class</span>,\xa0classLoader);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(<span style="color:#ffffaa;">String</span>\xa0name\xa0:\xa0StringUtils.commaDelimitedListToStringArray(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0environment.getProperty(<span style="color:#a2fca2;">"spring.cloud.bootstrap.sources"</span>,\xa0<span style="color:#a2fca2;">""</span>)))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0names.add(name);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//创建\xa0Spring\xa0容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0SpringApplicationBuilder\xa0builder\xa0=\xa0<span style="color:#fcc28c;">new</span>\xa0SpringApplicationBuilder()\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.environment(bootstrapEnvironment)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.properties(<span style="color:#a2fca2;">"spring.application.name:"</span>\xa0+\xa0configName)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.registerShutdownHook(<span style="color:#fcc28c;">false</span>)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.logStartupInfo(<span style="color:#fcc28c;">false</span>)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.web(<span style="color:#fcc28c;">false</span>);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">List</span>&lt;Class&lt;?&gt;&gt;\xa0sources\xa0=\xa0<span style="color:#fcc28c;">new</span>\xa0ArrayList&lt;&gt;();\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0builder.sources(sources.toArray(<span style="color:#fcc28c;">new</span>\xa0Class[sources.size()]));\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0AnnotationAwareOrderComparator.sort(sources);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">final</span>\xa0ConfigurableApplicationContext\xa0context\xa0=\xa0builder.run();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//创建祖先容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0addAncestorInitializer(application,\xa0context);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0mergeDefaultProperties(environment.getPropertySources(),\xa0bootstrapProperties);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">return</span>\xa0context;\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>首先，<code style="margin-left:2px;">SpringBoot</code>项目是通过<code style="margin-left:2px;">SpringApplicationBuilder</code>启动，在上述逻辑中又构建了一个<code style="margin-left:2px;">SpringApplicationBuilder</code>对象，再次执行run方法，所以启动流程会执行两遍，只是读取的配置文件和配置类不同。</p>\n\n<blockquote>\n<p><span style="color:#3e3e3e;">之前有人问我，SpringCloud项目</span><code style="margin-left:2px;">ApplicationContextInitializer</code><span style="color:#3e3e3e;">实现类中的逻辑执行了两遍，原因就在于启动流程会执行两遍。</span></p>\n</blockquote>\n\n<p>同样，当第二次创建<code style="margin-left:2px;">SpringApplicationBuilder</code>并启动时，会不会再次出发监听器，然后接着创建<code style="margin-left:2px;">SpringApplicationBuilder</code>呢？<br>\n肯定不会。否则就是死循环了。上面已经提到了，SpringCloud通过标识符<code style="margin-left:2px;">BOOTSTRAP_PROPERTY_SOURCE_NAME</code>来判断。监听器执行之后，会设置该变量对应值，下次启动前如果有值，表明已经执行。</p>\n\n<p>上面有一行关键的代码：<code style="margin-left:2px;">addAncestorInitializer(application, context);</code></p>\n\n<p>ancestor 中文祖先的意思。具体来看一下：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:inherit;"><span style="color:#fcc28c;">private</span>\xa0<span style="color:#fcc28c;">void</span>\xa0<span style="color:#ffffaa;">addAncestorInitializer</span><span style="color:inherit;">(SpringApplication\xa0application,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfigurableApplicationContext\xa0context)</span>\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">boolean</span>\xa0installed\xa0=\xa0<span style="color:#fcc28c;">false</span>;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//遍历所有的initializer，判断是否已经存在\xa0祖先initializer</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(ApplicationContextInitializer&lt;?&gt;\xa0initializer\xa0:\xa0application\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.getInitializers())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(initializer\xa0<span style="color:#fcc28c;">instanceof</span>\xa0AncestorInitializer)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0installed\xa0=\xa0<span style="color:#fcc28c;">true</span>;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//\xa0如果存在，则设置\xa0bootStrapApplication</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0((AncestorInitializer)\xa0initializer).setParent(context);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//如果不存在，则创建。</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(!installed)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0application.addInitializers(<span style="color:#fcc28c;">new</span>\xa0AncestorInitializer(context));\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n</code></pre>\n\n<p>这里主要是创建 <span style="color:#e96900;">AncestorInitializer</span>对象。</p>\n\n<p>当<span style="color:#e96900;">BootStrap</span>环境初始化完毕后，再次回到<span style="color:#e96900;">SpringBoot</span>初始化流程会触发所有的<span style="color:#e96900;">initializers</span>，当执行<span style="color:#3e3e3e;"><span style="color:#e96900;">AncestorInitializer</span></span>时，将<span style="color:#e96900;">BootStrap ApplicationContext<span style="color:#3e3e3e;">容器</span></span>设为父容器：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#fcc28c;">private</span>\xa0<span style="color:#fcc28c;">static</span>\xa0<span style="color:inherit;"><span style="color:#fcc28c;">class</span>\xa0<span style="color:#ffffaa;">AncestorInitializer</span>\xa0<span style="color:#fcc28c;">implements</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">ApplicationContextInitializer</span>&lt;<span style="color:#ffffaa;">ConfigurableApplicationContext</span>&gt;,\xa0<span style="color:#ffffaa;">Ordered</span>\xa0</span>{\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">private</span>\xa0ConfigurableApplicationContext\xa0parent;\n\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:inherit;"><span style="color:#fcc28c;">public</span>\xa0<span style="color:#ffffaa;">AncestorInitializer</span><span style="color:inherit;">(ConfigurableApplicationContext\xa0parent)</span>\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">this</span>.parent\xa0=\xa0parent;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fc9b9b;">@Override</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:inherit;"><span style="color:#fcc28c;">public</span>\xa0<span style="color:#fcc28c;">void</span>\xa0<span style="color:#ffffaa;">initialize</span><span style="color:inherit;">(ConfigurableApplicationContext\xa0context)</span>\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//如果已经存在父容器，则直接取出</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">while</span>\xa0(context.getParent()\xa0!=\xa0<span style="color:#fcc28c;">null</span>\xa0&amp;&amp;\xa0context.getParent()\xa0!=\xa0context)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context\xa0=\xa0(ConfigurableApplicationContext)\xa0context.getParent();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0reorderSources(context.getEnvironment());\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//设置父容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">new</span>\xa0ParentContextApplicationContextInitializer(<span style="color:#fcc28c;">this</span>.parent)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.initialize(context);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n}\n</code></pre>\n\n<p>上述方法将设置父容器的逻辑委托给<code style="margin-left:2px;">ParentContextApplicationContextInitializer</code>类处理，来看下<code style="margin-left:2px;">initialize</code>方法：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#fcc28c;">public</span>\xa0<span style="color:inherit;"><span style="color:#fcc28c;">class</span>\xa0<span style="color:#ffffaa;">ParentContextApplicationContextInitializer</span>\xa0<span style="color:#fcc28c;">implements</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#ffffaa;">ApplicationContextInitializer</span>&lt;<span style="color:#ffffaa;">ConfigurableApplicationContext</span>&gt;,\xa0<span style="color:#ffffaa;">Ordered</span>\xa0</span>{\n\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">private</span>\xa0<span style="color:#fcc28c;">int</span>\xa0order\xa0=\xa0Ordered.HIGHEST_PRECEDENCE;\n\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">private</span>\xa0<span style="color:#fcc28c;">final</span>\xa0ApplicationContext\xa0parent;\n\n\xa0\xa0\xa0\xa0<span style="color:#fc9b9b;">@Override</span>\n\xa0\xa0\xa0\xa0<span style="color:inherit;"><span style="color:#fcc28c;">public</span>\xa0<span style="color:#fcc28c;">void</span>\xa0<span style="color:#ffffaa;">initialize</span><span style="color:inherit;">(ConfigurableApplicationContext\xa0applicationContext)</span>\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(applicationContext\xa0!=\xa0<span style="color:#fcc28c;">this</span>.parent)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//设置父容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0applicationContext.setParent(<span style="color:#fcc28c;">this</span>.parent);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//创建监听器，主要用来发布项目中存在父子容器事件</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0applicationContext.addApplicationListener(EventPublisher.INSTANCE);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0}\n}</code></pre>\n\n<hr><p>BootStrap Application 容器的作用：<br><strong>提前加载SpringCloud 相关的配置类，比如BootStrap Application会提前加载配置中心相关配置类，优先加读取<code style="margin-left:2px;">bootstrap</code>配置文件等逻辑。</strong></p>\n\n<p>默认加载的配置如下：</p>\n\n<p>\xa0</p>\n\n<p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7iaUeydzEAF5VmlDZAgjjmrO64iazMq8TyeW8KovXgics3m3jnaaJuZRlMSibofYWRiantw3Av6TV2ZRsg/640?wx_fmt=png" style="margin-left:auto;"></p>\n\n<p>\xa0</p>\n\n<hr><h2><strong>SpringBoot上下文</strong></h2>\n\n<p>SpringBoot创建的 Spring容器是最核心的容器，也是使用最多的Spring容器。<br>\n创建的对象会有3种类型，Servlet，Reactive，和默认。<br>\n在SpringBoot2.x版本中的判断如下：</p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#fcc28c;">public</span>\xa0<span style="color:#fcc28c;">class</span>\xa0<span style="color:#ffffaa;">SpringApplication</span>\xa0{\n\xa0\xa0\xa0\xa0<span style="color:#888888;">//......</span>\n\xa0\xa0\xa0\xa0<span style="color:inherit;"><span style="color:#fcc28c;">protected</span>\xa0ConfigurableApplicationContext\xa0<span style="color:#ffffaa;">createApplicationContext</span>()\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Class&lt;?&gt;\xa0contextClass\xa0=\xa0<span style="color:#fcc28c;">this</span>.applicationContextClass;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(contextClass\xa0==\xa0<span style="color:#fcc28c;">null</span>)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">try</span>\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">switch</span>\xa0(<span style="color:#fcc28c;">this</span>.webApplicationType)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">case</span>\xa0SERVLET:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0contextClass\xa0=\xa0Class.forName(DEFAULT_WEB_CONTEXT_CLASS);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">break</span>;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">case</span>\xa0REACTIVE:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0contextClass\xa0=\xa0Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">break</span>;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">default</span>:\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0contextClass\xa0=\xa0Class.forName(DEFAULT_CONTEXT_CLASS);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">catch</span>\xa0(ClassNotFoundException\xa0ex)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">throw</span>\xa0<span style="color:#fcc28c;">new</span>\xa0IllegalStateException(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#a2fca2;">"Unable\xa0create\xa0a\xa0default\xa0ApplicationContext,\xa0"</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0+\xa0<span style="color:#a2fca2;">"please\xa0specify\xa0an\xa0ApplicationContextClass"</span>,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ex);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">return</span>\xa0(ConfigurableApplicationContext)\xa0BeanUtils.instantiateClass(contextClass);\n\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0<span style="color:#888888;">//......</span>\n}\n</code></pre>\n\n<p>具体细节不多介绍了，创建流程可参考之前 SpringBoot启动流程源码分析文章。</p>\n\n<hr><h2><strong>微服务配置容器</strong></h2>\n\n<p>上面 uml 图中提到了一个关键类：<code style="margin-left:2px;">NamedContextFactory</code>，从命名可以看出，这是一个工厂类：抽象容器工厂。同 hystrix 线程隔离原理一样，该工厂根据不同的服务名称，创建不同的容器。该容器有2个实现类，<code style="margin-left:2px;">FeignContext</code>\xa0和\xa0<code style="margin-left:2px;">SpringClientFactory</code>，分别用来加载对应的配置。</p>\n\n<p>\xa0</p>\n\n<p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7iaUeydzEAF5VmlDZAgjjmrO8kKd16uWhPibf0D5gqwr1h6jbicia8uFAiad3GLqmCg2olTTU6r44E51Sg/640?wx_fmt=png" style="margin-left:auto;"></p>\n\n<p>\xa0</p>\n\n<p><br><span style="color:#3e3e3e;">来看一下相关的核心代码：</span></p>\n\n<pre>\n<code style="margin-left:2px;"><span style="color:#fcc28c;">public</span>\xa0<span style="color:#fcc28c;">abstract</span>\xa0<span style="color:inherit;"><span style="color:#fcc28c;">class</span>\xa0<span style="color:#ffffaa;">NamedContextFactory</span>&lt;<span style="color:#ffffaa;">C\xa0extends\xa0NamedContextFactory.Specification</span>&gt;</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0implements\xa0DisposableBean,\xa0ApplicationContextAware\xa0{\n\n\xa0\xa0\xa0\xa0<span style="color:#888888;">//Feign\xa0和Ribbon\xa0配置抽象接口</span>\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">public</span>\xa0<span style="color:inherit;"><span style="color:#fcc28c;">interface</span>\xa0<span style="color:#ffffaa;">Specification</span>\xa0</span>{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0String\xa0getName();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Class&lt;?&gt;[]\xa0getConfiguration();\n\xa0\xa0\xa0\xa0}\n\n\xa0\xa0\xa0\xa0<span style="color:#888888;">//Application集合</span>\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">private</span>\xa0Map&lt;String,\xa0AnnotationConfigApplicationContext&gt;\xa0contexts\xa0=\xa0new\xa0ConcurrentHashMap&lt;&gt;();\n\n\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">protected</span>\xa0AnnotationConfigApplicationContext\xa0getContext(String\xa0name)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//根据服务名称获取对应配置工厂，如果没有，则创建</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(!<span style="color:#fcc28c;">this</span>.contexts.containsKey(name))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0synchronized\xa0(<span style="color:#fcc28c;">this</span>.contexts)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(!<span style="color:#fcc28c;">this</span>.contexts.containsKey(name))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//创建并进行缓存</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">this</span>.contexts.put(name,\xa0createContext(name));\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">return</span>\xa0<span style="color:#fcc28c;">this</span>.contexts.<span style="color:#fcc28c;">get</span>(name);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\n\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">protected</span>\xa0AnnotationConfigApplicationContext\xa0createContext(String\xa0name)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//创建一个\xa0Spring\xa0容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0AnnotationConfigApplicationContext\xa0context\xa0=\xa0new\xa0AnnotationConfigApplicationContext();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(<span style="color:#fcc28c;">this</span>.configurations.containsKey(name))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(Class&lt;?&gt;\xa0configuration\xa0:\xa0<span style="color:#fcc28c;">this</span>.configurations.<span style="color:#fcc28c;">get</span>(name)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0.getConfiguration())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//注入配置类</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.register(configuration);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//注入默认的Feign或Ribbon配置类</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(Map.Entry&lt;String,\xa0C&gt;\xa0entry\xa0:\xa0<span style="color:#fcc28c;">this</span>.configurations.entrySet())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(entry.getKey().startsWith(<span style="color:#a2fca2;">"default."</span>))\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">for</span>\xa0(Class&lt;?&gt;\xa0configuration\xa0:\xa0entry.getValue().getConfiguration())\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.register(configuration);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.register(PropertyPlaceholderAutoConfiguration.<span style="color:#fcc28c;">class</span>,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">this</span>.defaultConfigType);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.getEnvironment().getPropertySources().addFirst(new\xa0MapPropertySource(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">this</span>.propertySourceName,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Collections.&lt;String,\xa0Object&gt;\xa0singletonMap(<span style="color:#fcc28c;">this</span>.propertyName,\xa0name)));\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">if</span>\xa0(<span style="color:#fcc28c;">this</span>.parent\xa0!=\xa0<span style="color:#fcc28c;">null</span>)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//\xa0Uses\xa0Environment\xa0from\xa0parent\xa0as\xa0well\xa0as\xa0beans</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//设置父类为\xa0SpringBoot\xa0创建的Spring\xa0容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.setParent(<span style="color:#fcc28c;">this</span>.parent);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#888888;">//启动容器</span>\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0context.refresh();\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0<span style="color:#fcc28c;">return</span>\xa0context;\n\xa0\xa0\xa0\xa0}\n}\n</code></pre>\n\n<blockquote>\n<p>具体执行细节这里不做展开了，之前的文章《<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTk1MTE5NQ==&amp;mid=2247483724&amp;idx=1&amp;sn=03b5193f49920c1d286b56daff8b1a09&amp;chksm=f90b2cf8ce7ca5ee6b56fb5e0ffa3176126ca3a68ba60fd8b9a3afd2fd1a2f8a201a2b765803&amp;token=302932053&amp;lang=zh_CN&amp;scene=21#wechat_redirect" rel="nofollow">SpringCloud | SpringCloud Feign的前世今生【源码深入分析】</a>》有详细介绍。</p>\n</blockquote>\n\n<p>所以，具体Feign 和 Ribbon配置类会创建多少实例，和项目本身依赖发服务有关。如果依赖10个服务，那就是10个Feign配置容器+10个Ribbon配置容器+SpringBoot容器+BootStrap容器。</p>\n\n<p>可以借助工具来看一下。如果项目引入了<code style="margin-left:2px;">SpringBoot</code>\xa0监控模块<code style="margin-left:2px;">Spring Boot Actuator</code>，那在idea中可以看到已经创建的8个容器如下：</p>\n\n<p>\xa0</p>\n\n<p><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/uFNav9vzn7iaUeydzEAF5VmlDZAgjjmrOWA0z61y6ox9wXr1FpbVcDccDZETlzoysRXhwDlOI2YibbViaBOjialQyw/640?wx_fmt=png" style="margin-left:auto;"></p>\n\n<p>\xa0</p>\n\n<p><span style="color:#ff0000;"><strong>注意：由于Ribbon 默认会采用懒加载，也就是只有第一次请求的时候才会加载。所以idea这里不会显示 Ribbon 相关配置类容器，只显示项目启动流程中创建完成的 Spring 容器。 这也是微服务经常第一次调用超时的根本原因，因为创建并启动一个Spring容器需要一定的时间。</strong></span></p>\n\n<hr><h2><strong>总结</strong></h2>\n\n<p>本篇主要介绍了 SpringCloud 项目中创建的 Spring 容器：</p>\n\n<p><strong>首先 SpringBoot 项目启动，触发监听器，如果引入了SpringCloud 中的<code style="margin-left:2px;">BootstrapApplicationListener</code>，则开始初始化 SpringCloud 相关的上下文：Bootstrap ApplicationContext，将其设置为祖先容器，然后继续创建其子容器：SpringBoot ApplicationContext。</strong></p>\n\n<p><strong>如果引入了 FeignClient，则会实例化一个容器工厂，以服务名称为key，<strong>value为</strong>Feign 和 Ribbon配置类容器，配置隔离，父容器则都为 SpringBoot ApplicationContext。</strong></p>\n\n<p><span style="color:#3da742;">-更多文章-</span></p>\n\n<p><span style="color:#3da742;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485143&amp;idx=1&amp;sn=2fa1c9f11b5763e41b433bcbdcc207ac&amp;chksm=9bed27a5ac9aaeb39edf44782b4856634008efa0fee274ecdf25231f6e9088e02abd7b05f604&amp;scene=21#wechat_redirect" rel="nofollow">刚出炉的一套面试题(JAVA岗)</a></span></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485107&amp;idx=1&amp;sn=438452b39e98c2443755f0b4515a7537&amp;chksm=9bed27c1ac9aaed7fa4797c977d0ac8b5ab9bf6ffe8a0c77aaf52a628d55e78884b4ecbb6b35&amp;scene=21#wechat_redirect" rel="nofollow">这 10 款插件让你的 GitHub 更好用、更有趣</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485103&amp;idx=1&amp;sn=224a03ff53788c9ae007748fbb2d61f2&amp;chksm=9bed27ddac9aaecba2f5e2644eab5739cdd5b6665a086a02de6c0208132c78f74c5d0d6df1c1&amp;scene=21#wechat_redirect" rel="nofollow">Nginx是什么 ? 能干嘛 ？</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485098&amp;idx=1&amp;sn=d7f86005a320f1f61eafba52e388dc21&amp;chksm=9bed27d8ac9aaecefc964e2bad1966fce0c8a3e5357eb59cb713f1cd0022e0d6fa093d1ad671&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（二）</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485059&amp;idx=1&amp;sn=c1e62d593d5288de3f070ff476340a61&amp;chksm=9bed27f1ac9aaee70d3f11a4017fea3e33cb02d7a9a6c9f4bf7d2224e19e4efbc808120771fc&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（一）</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485092&amp;idx=1&amp;sn=1d2766e00d81928c9f33abf121887efc&amp;chksm=9bed27d6ac9aaec07e65037b59a8d6c3f9d41e4abd6142b6646f95a521ec8e33fe63287e216f&amp;scene=21#wechat_redirect" rel="nofollow">为了效率，扎克伯格的26张PPT</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485086&amp;idx=1&amp;sn=804bf83e4dd01a98eba8e2b69a111e4f&amp;chksm=9bed27ecac9aaefa4af53684dcca45dde27b573b5f19f34b7e957ea59e5baef8020c1448cc54&amp;scene=21#wechat_redirect" rel="nofollow">分布式架构知识体系</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485083&amp;idx=1&amp;sn=7e01c7f86fea20658ef253111d6863fa&amp;chksm=9bed27e9ac9aaeff6019f67658c7877078ff93d507c96c327be381f20b67e2ec5f3461959cad&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Consul 之Greenwich版本全攻略</a></u></p>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-关注我-</span></p>\n\n<p style="text-align:center;"><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png"></p>\n\n<p style="margin-left:8px;"><strong><span style="color:#3da742;">看完了，帮我点个“好看”鸭</span></strong></p>\n\n<p style="margin-left:8px;"><span style="color:#3da742;"><strong>点鸭点鸭</strong></span></p>\n\n<p><span style="color:#3da742;">↓↓↓↓</span></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87898978', 'title': '2019新鲜出炉的BAT通关面试题 Java岗', 'readNum': '9620', 'commentNum': '5', 'publishTime': '2019-02-23 11:26:00', 'content': '<div class="htmledit_views" id="content_views">\n                                            <p><span style="color:#888888;">点击上方</span>“<span style="color:#0052ff;">方志朋</span>”，<span style="color:#888888;">选择“置顶或者星标”</span></p>\n\n<p style="margin-left:16px;"><span style="color:#7f7f7f;">你的关注意义重大！</span></p>\n\n<blockquote>\n<p>来源于公号：孤独烟</p>\n</blockquote>\n\n<p>由于近期是互联网寒冬，然而烟哥的好友还是顶着重重压力出去面试，最终斩获无数offer。<br>\n在烟哥的沟通下，终于套得其中一套题目，故在此分享！</p>\n\n<p>公司:国内三巨头其中的一家！<br>\n面试时间约在1月份左右！<br>\n基本上都是在晚上，所以不影响白天上班！</p>\n\n<h3><span style="color:#ffffff;">一面</span></h3>\n\n<p>一面偏架构方面</p>\n\n<p>1、介绍一下自己，讲讲项目经历</p>\n\n<p>2、你们项目中微服务是怎么划分的，划分粒度怎么确定？</p>\n\n<p>3、那在实践微服务架构中，有遇到什么问题么？</p>\n\n<p>4、你们在关于微服务间数据一致性问题，是如何解决的？</p>\n\n<p>5、你们为什么不用其他的MQ,最终选择了RokcetMQ？</p>\n\n<p>6、为什么RocketMQ没有选择ZooKeeper，而是自己实现了一个NameServer集群？</p>\n\n<p>7、嗯，理解的不错，Zookeeper在选举的过程中，还能对外提供服务么？</p>\n\n<p>8、对Paxos算法了解多少？</p>\n\n<p>9、如果让你来设计一个春晚抢红包架构，你会怎么设计？</p>\n\n<p>10、有什么想问我的？</p>\n\n<p>大概聊了40分钟左右～</p>\n\n<h3><span style="color:#ffffff;">二面</span></h3>\n\n<p>二面有点偏底层和算法</p>\n\n<p>1、扯了下项目、讲一下项目经历</p>\n\n<p>2、你们用了redis，redis的底层数据结构了解多少？</p>\n\n<p>3、知道动态字符串sds的优缺点么？<br>\n注:sds为redis底层数据结构之一</p>\n\n<p>4、redis的单线程特性有什么优缺点？</p>\n\n<p>5、用过 Redis 的哪些数据结构, 分别用在什么场景?</p>\n\n<p>6、你们怎么解决缓存击穿问题的？<br>\n注:估计答了Hytrix</p>\n\n<p>7、Hytrix的隔离机制有哪些？Hytrix常见配置是哪些？</p>\n\n<p>8、自己做过哪些调优？JVM调优、数据库调优都行！</p>\n\n<p>9、给了个场景，问你怎么调</p>\n\n<p>10、一道算法题，具体题目忘了，在给出的链接中作答～</p>\n\n<h3><span style="color:#ffffff;">三面</span></h3>\n\n<p>1、讲讲自己基础掌握情况，以及项目经历</p>\n\n<p>2、平时会用到哪些数据结构？</p>\n\n<p>3、链表和数组的优缺点？</p>\n\n<p>4、解决hash冲突的方法有哪些？</p>\n\n<p>5、讲讲自己对HashMap的理解，以及和Weakhashmap的区别？</p>\n\n<p>6、你刚才讲的是JDK1.7版本的实现，知道JDK1.8做了哪些改动么？</p>\n\n<p>7、你们在微服务中用RPC通信还是REST？</p>\n\n<p>8、RPC和HTTP的关系是什么？</p>\n\n<p>9、知道HTTP1.0和1.1的区别么？</p>\n\n<p>10、谈谈什么是HTTP的长连接和短连接？</p>\n\n<p>11、TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？</p>\n\n<p>12、TCP 有哪些状态，相应状态的含义</p>\n\n<p>13、让你评价一下你自己？</p>\n\n<p>然后问了下面试官还有几轮，面试官说不一定！</p>\n\n<h3><span style="color:#ffffff;">四面</span></h3>\n\n<p>1、依然是介绍自己</p>\n\n<p>2、你们数据库的高可用架构是怎么样的？</p>\n\n<p>3、如何保证数据库主从一致性？</p>\n\n<p>4、知道mysql的索引算法么？</p>\n\n<p>5、为什么mongodb的索引用了B树，而mysql用B+树？</p>\n\n<p>6、用mysql过程中，有遇到什么问题么？</p>\n\n<p>7、你们生产用的是哪种事务隔离级别，为什么？</p>\n\n<p>8、谈一谈你对微服务架构的理解</p>\n\n<p>9、你用过哪些RPC框架，讲讲他们优缺点</p>\n\n<p>10、用过docker么，对容器了解多少</p>\n\n<p>11、有什么问我的？</p>\n\n<h3><span style="color:#ffffff;">HR面</span></h3>\n\n<p>问经历，问离职原因，问职业规划，问待遇。<br>\n唯一比较奇葩的一个，居然不问你期望薪水～～</p>\n\n<h3><span style="color:#ffffff;">总结</span></h3>\n\n<p>面试难度：简单<br>\n面试体验：挺好</p>\n\n<p>没有什么特别刁难人的问题，总体体验不错！<br>\n大家注意，开始的第一个问题一定是讲项目，如果很多问题都一知半解，就别讲了。<br><strong>那没有一个拿手都技术？</strong><br>\n好好沉淀，有拿手都技术再出山面试～</p>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-更多文章-</span></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485121&amp;idx=1&amp;sn=5ca16aa0cbffd2382c42413d8bd6c68d&amp;chksm=9bed27b3ac9aaea5791139a4f182173ee17badcb04db31ae3d3344e7af87c6a72ff2fed7db7e&amp;scene=21#wechat_redirect" rel="nofollow">spring cloud config将配置存储在数据库中</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485107&amp;idx=1&amp;sn=438452b39e98c2443755f0b4515a7537&amp;chksm=9bed27c1ac9aaed7fa4797c977d0ac8b5ab9bf6ffe8a0c77aaf52a628d55e78884b4ecbb6b35&amp;scene=21#wechat_redirect" rel="nofollow">这 10 款插件让你的 GitHub 更好用、更有趣</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485103&amp;idx=1&amp;sn=224a03ff53788c9ae007748fbb2d61f2&amp;chksm=9bed27ddac9aaecba2f5e2644eab5739cdd5b6665a086a02de6c0208132c78f74c5d0d6df1c1&amp;scene=21#wechat_redirect" rel="nofollow">Nginx是什么 ? 能干嘛 ？</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485098&amp;idx=1&amp;sn=d7f86005a320f1f61eafba52e388dc21&amp;chksm=9bed27d8ac9aaecefc964e2bad1966fce0c8a3e5357eb59cb713f1cd0022e0d6fa093d1ad671&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（二）</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485059&amp;idx=1&amp;sn=c1e62d593d5288de3f070ff476340a61&amp;chksm=9bed27f1ac9aaee70d3f11a4017fea3e33cb02d7a9a6c9f4bf7d2224e19e4efbc808120771fc&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（一）</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485092&amp;idx=1&amp;sn=1d2766e00d81928c9f33abf121887efc&amp;chksm=9bed27d6ac9aaec07e65037b59a8d6c3f9d41e4abd6142b6646f95a521ec8e33fe63287e216f&amp;scene=21#wechat_redirect" rel="nofollow">为了效率，扎克伯格的26张PPT</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485086&amp;idx=1&amp;sn=804bf83e4dd01a98eba8e2b69a111e4f&amp;chksm=9bed27ecac9aaefa4af53684dcca45dde27b573b5f19f34b7e957ea59e5baef8020c1448cc54&amp;scene=21#wechat_redirect" rel="nofollow">分布式架构知识体系</a></u></p>\n\n<p><u><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485083&amp;idx=1&amp;sn=7e01c7f86fea20658ef253111d6863fa&amp;chksm=9bed27e9ac9aaeff6019f67658c7877078ff93d507c96c327be381f20b67e2ec5f3461959cad&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Consul 之Greenwich版本全攻略</a></u></p>\n\n<p>\xa0</p>\n\n<p><span style="color:#3da742;">-关注我-</span></p>\n\n<p style="text-align:center;"><img alt="640?wx_fmt=png" class="has" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png"></p>\n\n<p style="margin-left:8px;"><strong><span style="color:#3da742;">看完了，帮我点个“好看”鸭</span></strong></p>\n\n<p style="margin-left:8px;"><span style="color:#3da742;"><strong>点鸭点鸭</strong></span></p>\n\n<p><span style="color:#3da742;">↓↓↓↓</span></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87887507', 'title': 'Nginx是什么 ? 能干嘛 ？', 'readNum': '12205', 'commentNum': '1', 'publishTime': '2019-02-18 10:22:00', 'content': '<div class="htmledit_views" id="content_views">\n                                            \n    <div class="rich_media_content" id="js_content">\n                    \n\n                    \n\n                    \n                    \n                    <p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(136,136,136);letter-spacing:.544px;font-size:12px;">点击上方</span><span style="letter-spacing:.544px;font-size:12px;">“<span style="color:rgb(0,82,255);">方志朋</span>”，</span><span style="color:rgb(136,136,136);letter-spacing:.544px;font-size:12px;">选择“置顶或者星标”</span><br></p><p style="margin-left:16px;font-size:17px;letter-spacing:.544px;line-height:normal;"><span style="color:rgb(127,127,127);font-size:12px;letter-spacing:.544px;">你的关注意义重大！</span></p><p style="text-align:center;"><span style="letter-spacing:normal;font-size:12px;color:rgb(136,136,136);"></span><br></p><p style="letter-spacing:.544px;line-height:1.75em;"><span style="font-size:15px;letter-spacing:1px;text-align:left;">想必大家一定听说过Nginx，若没听说过它？那么一定听过它的"同行"Apache吧！Nginx同Apache一样都是一种WEB服务器。基于REST架构风格，以统一资源描述符(Uniform Resources Identifier)URI或者统一资源定位符(Uniform Resources Locator)URL作为沟通依据，通过HTTP协议提供各种网络服务。</span><br></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个WEB服务器有着各自鲜明的特点。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">Apache的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。它不支持高并发的服务器。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存。操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">这些都决定了Apache不可能成为高性能WEB服务器，轻量级高并发服务器Nginx就应运而生了。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">俄罗斯的工程师Igor Sysoev，他在为Rambler Media工作期间，使用C语言开发了Nginx。Nginx作为WEB服务器一直为Rambler Media提供出色而又稳定的服务。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">然后呢，Igor Sysoev将Nginx代码开源，并且赋予自由软件许可证。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">由于：</span></p><ul class="list-paddingleft-2" style="margin-left:8px;"><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">Nginx使用基于事件驱动架构，使得其可以支持数以百万级别的TCP连接</span></p></li><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">高度的模块化和自由软件许可证是的第三方模块层出不穷（这是个开源的时代啊~）</span></p></li><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">Nginx是一个跨平台服务器，可以运行在Linux,Windows,FreeBSD,Solaris, AIX,Mac OS等操作系统上</span></p></li><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">这些优秀的设计带来的极大的稳定性</span></p></li></ul><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">所以，Nginx火了！</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</span></p><h2 style="text-align:left;margin-left:8px;line-height:2em;"><strong><span style="font-size:15px;letter-spacing:1px;">关于代理</span></strong></h2><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">此时就设计到两个角色，一个是被代理角色，一个是目标角色，被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店~客人到adidas专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是adidas厂家，目标角色就是用户。</span></p><h2 style="text-align:left;margin-left:8px;line-height:2em;"><strong><span style="font-size:15px;letter-spacing:1px;">正向代理</span></strong></h2><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触的到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：</span></p><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img style="border-color:rgb(240,237,237);border-style:solid;border-width:0px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5OiaC2v2uEjfwEVeibORnk7yQ0nBGJnAqd87kaXyT1nibz7AfxzX9xwXYzAg/640" alt="640"></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。如图。</span></p><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5Oiakjutv8O9MOhvY7fvcDzc7CtsrexicbzRymQ8ibGdQAW8TtFPjx35EcKw/640" alt="640"></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">总结来说：正向代理，"它代理的是客户端"，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">正向代理的用途：<br>（1）访问原来无法访问的资源，如Google<br>（2） 可以做缓存，加速访问资源<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</span></p><h2 style="text-align:left;margin-left:8px;line-height:2em;"><strong><span style="font-size:15px;letter-spacing:1px;">反向代理</span></strong></h2><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：http://tengine.taobao.org/。那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图（我把服务器和反向代理框在一块，同属于一个环境，后面我有介绍）：</span></p><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img height="288" width="657" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5OiaOTPEHnBQFmnFmmIBAYqgyTkyj3hpRdIRKpewbGeVzibgRb9LGibsgg8w/640" alt="640"></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">反向代理，"它代理的是服务端"，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">反向代理的作用：<br>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网<br>（2）负载均衡，通过反向代理服务器来优化网站的负载</span></p><h3 style="text-align:left;margin-left:8px;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">项目场景</span></h3><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：</span></p><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img height="275" style="border-color:rgb(240,237,237);border-style:solid;border-width:1px;" width="636" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5OiaK6XaauHmpoN62rqvARgz2YlFianVKCfibqtwwwBNhoZzu5jRaYibnqwNA/640" alt="640"></p><h2 style="text-align:left;margin-left:8px;line-height:2em;"><strong><span style="font-size:15px;letter-spacing:1px;">二者区别</span></strong></h2><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">截了一张图来说明正向代理和反向代理二者之间的区别，如图。</span></p><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img style="border-color:rgb(240,237,237);border-style:solid;border-width:1px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5OiaLQv9jLRu7f5qtzkluYk0ibtwWggwK35DFhnTfpxSBibeDyDbqRg5RSHw/640" alt="640"></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">图解：</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息；</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息；</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了。</span></p><h2 style="text-align:left;margin-left:8px;line-height:2em;"><strong><span style="font-size:15px;letter-spacing:1px;">负载均衡</span></strong></h2><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">所以~将服务器接收到的请求按照规则分发的过程，称为负载均衡。</span></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。</span></p><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img height="281" style="border-color:rgb(240,237,237);border-style:solid;border-width:1px;" width="641" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5OiayNyI0vFLiaFYMmRAbUMmvwBvZywNWnGdjjacYdib6XDc6dyBbMbTCLvQ/640" alt="640"></p><p style="font-size:16px;color:rgb(51,51,51);font-weight:400;text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">Nginx支持的负载均衡调度算法方式如下：</span></p><ol class="list-paddingleft-2" style="margin-left:8px;"><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</span></p></li><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</span></p></li><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。</span></p></li><li><p style="text-align:left;line-height:2em;"><span style="font-size:15px;letter-spacing:1px;">url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</span></p></li></ol><p style="font-size:16px;line-height:1.7;color:rgb(51,51,51);font-weight:400;"><img height="332" width="408" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/e1jmIzRpwWg2rULWLhibjQw8uhLpGr5OiaYUdWJibNmZcI9HLHfYD2OlXic9szY4y1ynT0q4amhz1DLT6iceHIFlANw/640" alt="640"></p><p style="margin-left:8px;letter-spacing:.544px;text-align:left;line-height:normal;"><span style="color:rgb(136,136,136);font-size:13px;">原文：<br></span></p><p style="margin-left:8px;letter-spacing:.544px;text-align:left;line-height:normal;"><span style="color:rgb(136,136,136);font-size:13px;">www.cnblogs.com/wcwnina/p/8728391.html</span></p><p style="margin-left:8px;letter-spacing:.544px;text-align:left;line-height:normal;"><span style="color:rgb(136,136,136);font-size:13px;">作者 |\xa0蔷薇Nina</span></p><p style="margin-left:8px;letter-spacing:.544px;text-align:left;line-height:normal;"><span style="color:rgb(136,136,136);font-size:13px;">来源 | 博客园</span></p><p style="letter-spacing:.544px;text-align:center;"><span style="font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;">-更多文章-</span><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:.544px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485098&amp;idx=1&amp;sn=d7f86005a320f1f61eafba52e388dc21&amp;chksm=9bed27d8ac9aaecefc964e2bad1966fce0c8a3e5357eb59cb713f1cd0022e0d6fa093d1ad671&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（二）</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485059&amp;idx=1&amp;sn=c1e62d593d5288de3f070ff476340a61&amp;chksm=9bed27f1ac9aaee70d3f11a4017fea3e33cb02d7a9a6c9f4bf7d2224e19e4efbc808120771fc&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（一）</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485092&amp;idx=1&amp;sn=1d2766e00d81928c9f33abf121887efc&amp;chksm=9bed27d6ac9aaec07e65037b59a8d6c3f9d41e4abd6142b6646f95a521ec8e33fe63287e216f&amp;scene=21#wechat_redirect" rel="nofollow">为了效率，扎克伯格的26张PPT</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485086&amp;idx=1&amp;sn=804bf83e4dd01a98eba8e2b69a111e4f&amp;chksm=9bed27ecac9aaefa4af53684dcca45dde27b573b5f19f34b7e957ea59e5baef8020c1448cc54&amp;scene=21#wechat_redirect" rel="nofollow">分布式架构知识体系</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485083&amp;idx=1&amp;sn=7e01c7f86fea20658ef253111d6863fa&amp;chksm=9bed27e9ac9aaeff6019f67658c7877078ff93d507c96c327be381f20b67e2ec5f3461959cad&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Consul 之Greenwich版本全攻略</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-关注我-</span><br></p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="font-size:14px;letter-spacing:1px;"><strong style="letter-spacing:.544px;"><span style="letter-spacing:1px;color:rgb(61,167,66);">看完了，帮我点个“好看”鸭</span></strong></span></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:1px;"><strong>点鸭点鸭</strong></span></p><p style="letter-spacing:.544px;font-size:13px;line-height:normal;text-align:right;"><span style="color:rgb(61,167,66);">↓↓↓↓</span></p>\n                </div>\n                                      </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:27 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87887515', 'title': 'MAT入门到精通（二）', 'readNum': '8261', 'commentNum': '0', 'publishTime': '2019-02-17 11:36:30', 'content': '<div class="htmledit_views" id="content_views">\n                                            \n    <div class="rich_media_content" id="js_content">\n                    \n\n                    \n\n                    \n                    \n                    <p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(136,136,136);font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;letter-spacing:.544px;font-size:12px;">点击上方</span><span style="font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;letter-spacing:.544px;font-size:12px;">“<span style="color:rgb(0,82,255);">方志朋</span>”，</span><span style="color:rgb(136,136,136);font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;letter-spacing:.544px;font-size:12px;">选择“置顶或者星标”</span><br></p><p style="margin-left:16px;font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;font-size:17px;letter-spacing:.544px;line-height:normal;"><span style="color:rgb(127,127,127);font-size:12px;letter-spacing:.544px;">你的关注意义重大！</span></p><br><p style="color:rgb(121,121,121);min-width:1px;margin-left:8px;">阅读本文大概需要6分钟。</p><p><br></p><p style="margin-left:8px;"><span style="font-size:16px;font-family:\'Helvetica Neue\', Helvetica, \'Hiragino Sans GB\', \'Microsoft YaHei\', Arial, sans-serif;">上一篇文章<a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485059&amp;idx=1&amp;sn=c1e62d593d5288de3f070ff476340a61&amp;chksm=9bed27f1ac9aaee70d3f11a4017fea3e33cb02d7a9a6c9f4bf7d2224e19e4efbc808120771fc&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（一）</a></span><span style="font-size:16px;font-family:\'Helvetica Neue\', Helvetica, \'Hiragino Sans GB\', \'Microsoft YaHei\', Arial, sans-serif;">介绍了MAT的使用场景和基本概念，这篇文章开始介绍MAT的基本功能，后面还有两篇，一篇是MAT的高级功能，另一篇是MAT实战案例分析。</span><br></p><p style="margin-left:8px;"><span style="font-size:16px;font-family:\'Helvetica Neue\', Helvetica, \'Hiragino Sans GB\', \'Microsoft YaHei\', Arial, sans-serif;"><br></span></p><p style="line-height:64px;font-size:18px;font-weight:bold;"><span style="margin-left:30px;">MAT的欢迎页</span></p>03<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>使用MAT打开一个heap dump文件，解析完成后，默认会进入欢迎页，欢迎页里包含了一些常见的分析：最大内存占用分析、常见的分析动作、常用的分析报告、MAT使用教程等等。</span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>我们看下下面这张图，可以看出MAT的主要结构和功能：</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGk6nPwsJhDxMf4Rvuh1vNlm7Tn1DHCI0taY683RLxMHMHSBXTwicXWmA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><ol class="ol-list list-paddingleft-2" style="margin-left:8px;"><li><p class="md-end-block"><strong><span>透视图（inspector）</span></strong><span>：用于展示一个对象的详细信息，例如内存地址、加载器名称、包名、对象名称、对象所属的类的父类、对象所属的类的加载器对象、该对象的堆内存大小和保留大小，gc root信息。</span><span style="font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;">inspector窗口的下半部分是展示类的静态属性和值、对象的实例属性和值、对象所属的类的继承结构。</span></p></li><li><p class="md-end-block"><strong><span>Heap Dump History</span></strong><span>：用于列举最近分析过的文件</span></p></li><li><p class="md-end-block"><strong><span>常用功能栏</span></strong><span>：从左到右依次是：概览、类直方图、支配树、OQL查询、线程视图、报告相关、详细功能。其中概览就是在刚解析完后展示的这个页面，详细功能按钮则是提供了一些更细致的分析能力。</span></p></li><li><p class="md-end-block"><strong><span>概览中的饼图</span></strong><span>：该饼图用于展示retained size最大的对象</span></p></li><li><p class="md-end-block"><strong><span>常用的分析动作</span></strong><span>：类直方图、支配树、按照类和包路径获取消耗资源最多的对象、重名类。</span></p></li><li><p class="md-end-block"><span><strong>常见问题</strong>：Leak Suspects用于查找内存泄漏问题，Top Components负责分析占用堆内存超过整个堆内存1%大小的组件。</span></p></li><li><p class="md-end-block"><strong><span>Components Report</span></strong><span>：这个功能是一组功能的集合，用于分析某一类性的类的实例的问题，例如分析<code style="border-width:1px;border-style:solid;border-color:rgb(231,234,237);font-size:.9em;">java.util.*</code>开头的类的实例对象的一些使用情况，例如：重复字符串、空集合、集合的使用率、软引用的统计、finalizer的统计、Map集合的碰撞率等等。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGOFbjs9TKkMhY4IHqVRe6HDCbUibtyHfJC6CE4SVffib25fAAwScYJlrA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p></li></ol><p style="margin-left:8px;"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><br></span></p><p style="margin-left:8px;"><span></span></p><p style="line-height:64px;font-size:18px;font-weight:bold;"><span style="margin-left:30px;">MAT的基本功能</span></p>04<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>关于概览页面，我们再上一节已经进行过分析，这里不再赘述。我们在这一小节，将重点放在功能栏那一栏，即类直方图、支配树、OQL查询、线程视图等功能。</span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span><br></span></p><p style="color:rgb(51,51,51);line-height:20px;clear:both;"><br></p>4.1类直方图<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>堆直方图是从类的角度看哪些类及该类的实例对象占用着内存情况，默认是按照某个类的shallow heap大小从大到小排序。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGqic3Pdoyn4CKDYZSmNC7CQF6OjzbVa0rWWjhEHDgLBFc5OiaUB9zJvUg/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>Retained Heap这一列的值是空的，因为对于某个类的所有实例计算总的retained heap非常慢，因此使用者需要按需计算。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsG0R9HUf3DncdQrIoyRaEQNwmKWicQ2OYnSmXgCSqLdgUX0Zxos5trXFA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>在直方图页面，可以选择某个条目右键进行分析，例如对所有类的对象做一些分析动作。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGeYH4OpLteibju4mpvJyjMwTp3Iw5cohwPO7PUtSM1JswZzvdhHicqKsw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>在直方图页面，还有一个重要的特性——可以选择一些其他维度进行分类分析，例如superclass、class loader、package。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGAicAUZUmvaJjI5lxV9xibZN1OLNSYKbW1kbRve9GyQ796MUVFYmhpToQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>如果选择按照package来分类，则可以看到下面这种视图</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGJmOyickpyKHubZkxy11aBqlJayQqYgrBMkgO1KM6FSdSgCV1kbuBtMA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="color:rgb(51,51,51);line-height:20px;clear:both;"><br></p><p style="border-width:0px;border-style:none;margin-left:8px;"><br></p>4.2支配树<p><br></p><p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>支配树可以用于查看heap dump中占用内存最大的对象。在支配树中，对于某一层的节点来说，如果它们的parent节点没有被其他对象引用了，那么这写节点都会被垃圾收集器回收。</span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>支配树可以用来排查是哪些对象导致了其他对象无法被垃圾收集器回收，跟类直方图类似，支配树也从类加载器、package等角度来看。</span></p><p><br></p><p style="color:rgb(51,51,51);line-height:20px;clear:both;"><br></p>4.3OQL（对象查询语言）<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>MAT提供另一种类似SQL的对象查询语言——OQL，可以用类似SQL语句的方式查询heap dump中的对象。OQL和关系型数据库具备类似的数据模型：将某个类看作是一张表，将该类的实例对象看作是该表中的行，每个对象中的属性看作是构成行的列。</span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>OQL语言的语法结构如下：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" style="font-size:.9em;text-align:left;background-image:inherit;background-attachment:inherit;border-width:1px;border-style:solid;border-color:rgb(231,234,237);width:inherit;"></pre><p style="margin-left:8px;"><span>SELECT *</span><br><span>FROM [ INSTANCEOF ] &lt;class name="name"&gt;</span><br><span>[ WHERE &lt;filter-expression&gt; ]</span><br><span>&lt;/filter-expression&gt;&lt;/class&gt;</span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>OQL编辑器分为两个区域：</span></p><ul class="ul-list list-paddingleft-2" style="margin-left:8px;"><li><p class="md-end-block"><span>上半部分的区域用于输入查询语句</span></p></li><li><p class="md-end-block"><span>下半部分的区域用于展示查询语句执行的结果</span></p></li></ul><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>下图是查询当前堆里所有的String对象的语句和结果：</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGZp1u7Ilib06kJLVjm2OC0IibNSLIRG6cw1nSvPZB8vwTGwZFglJ8dk7g/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p><br></p><p style="color:rgb(51,51,51);line-height:20px;clear:both;"><br></p>4.4线程视图<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGkPjFuAmWwJx8uxKNmEicjZUEZNftLByATyfSIR1KLicVBprdEWfxQaKA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>通过上图中的那个按钮，可以查看线程视图，线程视图首先给出了在生成快照那个时刻，JVM中的Java线程对象列表。这个按钮的功能，等同于下图中的这个操作：</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGZRErwRRFY5XrNv8nLPE0HYGhCrsHgbUwtRicw6XEomn62Mib8EOrefcw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>在线程视图这个表中，可以看到以下几个信息：线程对象的名字、线程名、线程对象占用的堆内存大小、线程对象的保留堆内存大小、线程的上下文加载器、是否为守护线程。</span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>选中某个线程对象展开，可以看到线程的调用栈和每个栈的局部变量，通过查看线程的调用栈和局部变量的内存大小，可以找到在哪个调用栈里分配了大量的内存。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGaFTQm7uX8x1wWc0baiaFAoHgU44IqdxCfLbpRNnLBz7XcX2Hk3rwkicQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>因此，heap dump和MAT不仅仅用于排查内存相关的问题，也有助于排查线程相关的问题。</span></p><p><br></p><p style="color:rgb(51,51,51);line-height:20px;clear:both;"><br></p>4.5问题分析<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGsuC9wd9TQCzFCrfiaibMUsw5qbppkc3B9FcjibAaV8I4EuYsB3oylaic9w/640?wx_fmt=png" alt="640?wx_fmt=png"></span><span>上图中的这个按钮，是MAT提供的一些常见的问题分析能力。因为这些问题特别常见，所以MAT就提供了对应的组合功能，帮用户快速定位常见问题。</span><br></p><ol class="ol-list list-paddingleft-2" style="margin-left:8px;"><li><p class="md-end-block"><span>Heap Dump OverviewHeap Dump Overview就是整个堆的概括情况，例如：堆内存大小、对象个数、类的个数、类加载器的个数、GC root的个数、堆内存文件的格式、文件的创建时间、位置等信息。这个页面还开一个看一些系统属性、线程概览、Top内存耗费组件、类直方图等信息。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGqiaOu9o5h5yCLBKPAajm2e0S8VnpJBayfHJgJCKPHBPcsjWRvD7A4Jg/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p></li><li><p class="md-end-block"><span>Leak Suspects如下图所示，这个功能用于排查潜在的内存泄漏问题。</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGaMMiaF3hObbj0Xye2cT9k2vJ9tCVusjUemtG4DHAGoXqDG6ajKxdJuA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p></li><li><p class="md-end-block"><span>Top Components针对那些占用堆内存超过整个堆内存1%大小的组件做一系列的分析，例如：Top Consumers、保留集合、潜在的内存浪费问题等其他问题。</span></p><p class="md-end-block"><span></span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsG8XefSTCMhnfyibbhGfGfPOT9aMWoibCZPa1EuFpIZ9I2a98OrgnKicWdA/640?wx_fmt=png" alt="640?wx_fmt=png"><span style="font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;">这一系列的分析，有很多层次，可以用下面这张思维导图理解：</span><span class="md-image md-img-loaded" style="font-size:16px;min-width:10px;min-height:10px;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGhuseYDT37ovhoT2ciccz8UKbtyntXY0xibxAZDsPvLsAQOXCOicYmK5Rg/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></p></li></ol><p><br></p><p style="color:rgb(51,51,51);line-height:20px;clear:both;"><br></p>4.6对象查找<p><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>MAT支持根据对象的十六进制地址查找对象的outbound引用视图，如下图所示：</span><span class="md-image md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGBWrzc5S1iblOjqbKkcTjltAribKkBNWx4NkAr6iauiaM6pCFVdiaEcMgqeg/640?wx_fmt=png" alt="640?wx_fmt=png"></span><br></p><p style="width:inherit;font-family:\'Open Sans\', \'Clear Sans\', \'Helvetica Neue\', Helvetica, Arial, sans-serif;font-size:16px;"><span>这个功能等同于在直方图中选中某个对象，然后右键列举该对象的outbound引用视图：</span><span class="md-image md-expand md-img-loaded" style="min-width:10px;min-height:10px;font-family:monospace;vertical-align:top;"><img style="border-width:0px 4px 0px 2px;border-right-style:solid;border-left-style:solid;border-right-color:transparent;border-left-color:transparent;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/4AG6tic68AGYtSe2cAfRhZSYRxULf9JsGjliaN7aCwUVbhMUZoTcV3l1ZLfMlp068VfBxkLaVn0ZMtf8mLtDqCiag/640?wx_fmt=png" alt="640?wx_fmt=png"></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-更多文章-</span><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485059&amp;idx=1&amp;sn=c1e62d593d5288de3f070ff476340a61&amp;chksm=9bed27f1ac9aaee70d3f11a4017fea3e33cb02d7a9a6c9f4bf7d2224e19e4efbc808120771fc&amp;scene=21#wechat_redirect" rel="nofollow">MAT入门到精通（一）</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485092&amp;idx=1&amp;sn=1d2766e00d81928c9f33abf121887efc&amp;chksm=9bed27d6ac9aaec07e65037b59a8d6c3f9d41e4abd6142b6646f95a521ec8e33fe63287e216f&amp;scene=21#wechat_redirect" rel="nofollow">为了效率，扎克伯格的26张PPT</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485086&amp;idx=1&amp;sn=804bf83e4dd01a98eba8e2b69a111e4f&amp;chksm=9bed27ecac9aaefa4af53684dcca45dde27b573b5f19f34b7e957ea59e5baef8020c1448cc54&amp;scene=21#wechat_redirect" rel="nofollow">分布式架构知识体系</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485083&amp;idx=1&amp;sn=7e01c7f86fea20658ef253111d6863fa&amp;chksm=9bed27e9ac9aaeff6019f67658c7877078ff93d507c96c327be381f20b67e2ec5f3461959cad&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Consul 之Greenwich版本全攻略</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-关注我-</span><br></p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="font-size:14px;letter-spacing:1px;"><strong style="letter-spacing:.544px;"><span style="letter-spacing:1px;color:rgb(61,167,66);">看完了，帮我点个“好看”鸭</span></strong></span></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:1px;"><strong>点鸭点鸭</strong></span></p><p style="letter-spacing:.544px;font-size:13px;line-height:normal;text-align:right;"><span style="color:rgb(61,167,66);">↓↓↓↓</span></p>\n                </div>\n                                      </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:27'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/86634907', 'title': '阿里分布式事务框架GTS开源了！', 'readNum': '21262', 'commentNum': '9', 'publishTime': '2019-01-24 23:27:05', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="https://blog.csdn.net/forezp/article/details/86634907">https://blog.csdn.net/forezp/article/details/86634907</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>就在昨天，阿里分布式事务框架GTS开源了一个免费社区版Fescar，看到了这个消息内心非常的激动。在微服务系统中，分布式事务一直是痛点，也是难点。社区里也有一些开源的分布式解决方案的框架，比如ByteTCC、LCN，但是这些框架没有一个权威的组织在维护，或多或少大家都有点不敢用。阿里开源的分布式事务解决框架Fescar会不会一统分布式事务江湖，大家拭目以待。</p>\n<p>我们现在来看看什么是FESCAR。Fescar项目地址：<a href="https://github.com/alibaba/fescar">https://github.com/alibaba/fescar</a></p>\n<h2><a id="FESCAR_9"></a>什么是FESCAR？</h2>\n<p>FESCAR是一种分布式事务解决方案，具有高性能和易用性的微服务架构。</p>\n<h2><a id="_13"></a>微服务中的分布式事务问题</h2>\n<p>在传统的单体应用程序中，假设我们的业务由3个模块构成，分为库存、订单、账户模块。 他们使用同一个单个本地数据源。</p>\n<p>本地事务可以保证数据的一致性。</p>\n<p><img src="https://camo.githubusercontent.com/400c70938b835e0b8ecc70ca61b3504e2aba891e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353239363737303234342d34636564663337652d396463362d346663302d613937662d6634323430623964383634302e706e67" alt=""></p>\n<p>微服务架构发生了变化。提到的3个模块设计为3个不同数据源之上的3个服务（每个服务单独的数据库）。 本地事务能够保证每个服务中的数据一致性。</p>\n<p>但是在分布式微服务系统总共，整个业务逻辑的一致性如何保证呢？</p>\n<p><img src="https://camo.githubusercontent.com/5729bd180e2c5b4a54f93c9d0a40dc06117e8565/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353239363738313233312d34303239646139632d383830332d343361342d616332662d3663386231653265613434382e706e67" alt=""></p>\n<h2><a id="FESCAR_27"></a>FESCAR是怎么解决上面提出的问题？</h2>\n<p>FESCAR为上述问题即分布式事务问题，提供了解决方案。</p>\n<p><img src="https://camo.githubusercontent.com/b3a71332ae0a91db7f8616286a69b879fcbea672/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353239363739313037342d33626365376263652d303235652d343563332d393338362d3762393531333564616465382e706e67" alt=""></p>\n<p>首先，如何定义分布式事务？</p>\n<p>分布式事务是一个全局事务，由一批Branch Transation组成，通常Branch Transation只是本地事务。</p>\n<p><img src="https://camo.githubusercontent.com/9d741875c9d7f99887fc4075b9fd4a4b67b69ade/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353031353435343937392d61313865313666362d656434312d343466312d396337612d6264383263346435666639392e706e67" alt=""></p>\n<p>在FESACR项目中有3个基本组件：</p>\n<ul>\n<li>事务协调员（TC）：维护全局和分支事务的状态，推动全局提交或回滚。</li>\n<li>事务管理者（TM）：定义全局事务的范围：开始全局事务，提交或回滚全局事务。</li>\n<li>资源管理器（RM）：管理分支事务处理的资源，与TC通信以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>\n</ul>\n<p><img src="https://camo.githubusercontent.com/e8fd6ca40ba959962a537cbc1be58013486cf46c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353031333931353238362d34613930663064662d356664612d343165312d393165302d3261613364333331633033352e706e67" alt=""></p>\n<p>FESCAR管理分布式事务的典型生命周期：</p>\n<ul>\n<li>TM要求TC开始新的全局事务。 TC生成表示全局事务的XID。</li>\n<li>XID通过微服务的调用链传播。</li>\n<li>RM将本地事务注册为XID到TC的相应全局事务的分支。</li>\n<li>TM要求TC提交或回滚XID的相应全局事务。</li>\n<li>TC在XID的相应全局事务下驱动所有分支事务以完成分支提交或rollbaking。</li>\n</ul>\n<p><img src="https://camo.githubusercontent.com/0384806afd7c10544c258ae13717e4229942aa13/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353239363931373838312d32366661626562392d373166612d346633652d386137612d6663333137643333383966342e706e67" alt=""></p>\n<h2><a id="_61"></a>历史</h2>\n<ul>\n<li>TXC：淘宝分布式事务组件。 阿里巴巴中间件团队自2014年启动该项目，以满足应用程序架构从单一服务变为微服务所导致的分布式事务问题。</li>\n<li>GTS：全局事务服务。 TXC作为Aliyun中间件产品，2016年更换新名称GTS。</li>\n<li>FESCAR：2019年开源基于TXC / GTS的开源项目FESCAR，以便与社区密切合作，共同成长。</li>\n</ul>\n<h3><a id="_68"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/87887502', 'title': '分布式架构知识体系', 'readNum': '9304', 'commentNum': '0', 'publishTime': '2019-02-15 09:04:01', 'content': '<div class="htmledit_views" id="content_views">\n                                            \n    <div class="rich_media_content" id="js_content">\n                    \n\n                    \n\n                    \n                    \n                    <p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(136,136,136);font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;letter-spacing:.544px;font-size:12px;">点击上方</span><span style="font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;letter-spacing:.544px;font-size:12px;">“<span style="color:rgb(0,82,255);">方志朋</span>”，</span><span style="color:rgb(136,136,136);font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;letter-spacing:.544px;font-size:12px;">选择“置顶或者星标”</span><br></p><p style="margin-left:16px;font-family:\'-apple-system-font\', BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif;font-size:17px;letter-spacing:.544px;line-height:normal;"><span style="color:rgb(127,127,127);font-size:12px;letter-spacing:.544px;">你的关注意义重大！</span></p><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">1.问题<br></h2><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>1、何为分布式何为微服务？</p></li><li><p>2、为什么需要分布式？</p></li><li><p>3、分布式核心理论基础，节点、网络、时间、顺序，一致性？</p></li><li><p>4、分布式是系统有哪些设计模式？</p></li><li><p>5、分布式有哪些类型？</p></li><li><p>6、如何实现分布式？</p></li></ul><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">2.关键词</h2><p>节点，时间，一致性，CAP，ACID，BASE，P2P，机器伸缩，网络变更，负载均衡，限流，鉴权，服务发现，服务编排，降级，熔断，幂等，分库分表，分片分区，自动运维，容错处理，全栈监控，故障恢复，性能调优</p><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">3.全文概要</h2><p>随着移动互联网的发展智能终端的普及，计算机系统早就从单机独立工作过渡到多机器协作工作。计算机以集群的方式存在，按照分布式理论的指导构建出庞大复杂的应用服务，也已经深入人心。本文力求从分布式基础理论，架构设计模式，工程应用，部署运维，业界方案这几大方面，介绍基于MSA(微服务架构)的分布式的知识体系大纲。从而对SOA到MSA进化有个立体的认识，从概念上和工具应用上更近一步了解微服务分布式的本质，身临其境的感受如何搭建全套微服务架构的过程。</p><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">4.基础理论</h2><h3 style="font-weight:bold;font-size:1.3em;">4.1SOA到MSA的进化</h3><h4 style="font-weight:bold;font-size:1.2em;">SOA面向服务架构</h4><p>由于业务发展到一定层度后，需要对服务进行解耦，进而把一个单一的大系统按逻辑拆分成不同的子系统，通过服务接口来通讯，面向服务的设计模式，最终需要总线集成服务，而且大部分时候还共享数据库，出现单点故障的时候会导致总线层面的故障，更进一步可能会把数据库拖垮，所以才有了更加独立的设计方案的出现。</p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATlBCZ4AKP7MZ9LichWMacoiaDS2c5LwnBtz4fSkcZgkUEUF02hGbvtkQ9w/640?wx_fmt=png" alt="640?wx_fmt=png"></p><h4 style="font-weight:bold;font-size:1.2em;">MSA微服务架构</h4><p>微服务是真正意义上的独立服务，从服务入口到数据持久层，逻辑上都是独立隔离的，无需服务总线来接入，但同时增加了整个分布式系统的搭建和管理难度，需要对服务进行编排和管理，所以伴随着微服务的兴起，微服务生态的整套技术栈也需要无缝接入，才能支撑起微服务的治理理念。</p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATl0Sib9jEl11zpkUpw9yORQneDJcsuSeRf9uia8cf5GQGoGqHPnvdKpCvQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><h3 style="font-weight:bold;font-size:1.3em;">4.2节点与网络</h3><h4 style="font-weight:bold;font-size:1.2em;">节点</h4><p>传统的节点也就是一台单体的物理机，所有的服务都揉进去包括服务和数据库；随着虚拟化的发展，单台物理机往往可以分成多台虚拟机，实现资源利用的最大化，节点的概念也变成单台虚拟机上面服务；近几年容器技术逐渐成熟后，服务已经彻底容器化，也就是节点只是轻量级的容器服务。总体来说，节点就是能提供单位服务的逻辑计算资源的集合。</p><h4 style="font-weight:bold;font-size:1.2em;">网络</h4><p>分布式架构的根基就是网络，不管是局域网还是公网，没有网络就无法把计算机联合在一起工作，但是网络也带来了一系列的问题。网络消息的传播有先后,消息丢失和延迟是经常发生的事情，我们定义了三种网络工作模式：</p><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>同步网络</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>节点同步执行</p></li><li><p>消息延迟有限</p></li><li><p>高效全局锁</p></li></ul><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>半同步网络</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>锁范围放宽</p></li></ul><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>异步网络</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>节点独立执行</p></li><li><p>消息延迟无上限</p></li><li><p>无全局锁</p></li><li><p>部分算法不可行</p><p>常用网络传输层有两大协议的特点简介：</p></li></ul><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>TCP协议</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>首先tcp尽管其他可以更快</p></li><li><p>tcp解决重复和乱序问题</p></li></ul><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>UDP协议</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>常量数据流</p></li><li><p>丢包不致命</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">4.3时间与顺序</h3><h4 style="font-weight:bold;font-size:1.2em;">时间</h4><p>慢速物理时空中，时间独自在流淌着，对于串行的事务来说，很简单的就是跟着时间的脚步走就可以，先来后到的发生。而后我们发明了时钟来刻画以往发生的时间点，时钟让这个世界尽然有序。但是对于分布式世界来说，跟时间打交道着实是一件痛苦的事情。分布式世界里面，我们要协调不同节点之间的先来后到关系，但是不同节点本身承认的时间又各执己见，于是我们创造了网络时间协议（NTP）试图来解决不同节点之间的标准时间，但是NTP本身表现并不如人意，所以我们又构造除了逻辑时钟，最后改进为向量时钟：</p><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>NTP的一些缺点，无法完全满足分布式下并发任务的协调问题</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>节点间时间不同步</p></li><li><p>硬件时钟漂移</p></li><li><p>线程可能休眠</p></li><li><p>操作系统休眠</p></li><li><p>硬件休眠</p></li></ul><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATlKZHY7tmxJt3CbWuRt5cUazpeahA2UG5HX3Sibsm6W1AvknicVROQb4eg/640?wx_fmt=png" alt="640?wx_fmt=png"></p><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>逻辑时钟</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>定义事件先来后到</p></li><li><p>t’ = max(t, t_msg + 1)</p><p><br></p></li><li><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATlqXib2xEtFDUb56Rd0YricsSVib7DScGTCt8rTzVFvgIsxvLB1w4MhvxPg/640?wx_fmt=gif" alt="640?wx_fmt=gif"></p></li></ul><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>向量时钟</p></blockquote><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>t_i’ = max(t_i, t_msg_i)</p></li></ul><blockquote style="border-left:4px solid rgb(221,221,221);color:rgb(119,119,119);"><p>原子钟</p></blockquote><h4 style="font-weight:bold;font-size:1.2em;">顺序</h4><p>有了衡量时间的工具，解决顺序问题自然就是水到渠成了。因为整个分布式的理论基础就是如何协商不同节点的一致性问题，而顺序则是一致性理论的基本概念，所以前文我们才需要花时间介绍衡量时间的刻度和工具。</p><h3 style="font-weight:bold;font-size:1.3em;">4.4一致性理论</h3><p>说到一致性理论，我们必须看一张关于一致性强弱对系统建设影响的对比图：</p><p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATlnB5qzCtxLr5ic1yX8vYHK7rLkNU8l2nNS5CjCgpRAIOY6BkXYZukCzg/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p>该图对比了不同一致性算法下的事务，性能，错误，延迟的平衡。</p><h4 style="font-weight:bold;font-size:1.2em;">强一致性ACID</h4><p>单机环境下我们对传统关系型数据库有苛刻的要求，由于存在网络的延迟和消息丢失，ACID便是保证事务的原则，这四大原则甚至我们都不需要解释出来就耳熟能详了：</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>Atomicity：原子性，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</p></li><li><p>Consistency：一致性，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p></li><li><p>Isolation：隔离性，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p></li><li><p>Durabilit：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">分布式一致性CAP</h4><p>分布式环境下，我们无法保证网络的正常连接和信息的传送，于是发展出了CAP/FLP/DLS这三个重要的理论：</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>CAP:分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition）。</p></li><li><p>FLP：在异步环境中，如果节点间的网络延迟没有上限，只要有一个恶意的节点存在，就没有算法能在有限的时间内达成共识。</p></li><li><p>DLS:</p><p>（1）在一个部分同步网络的模型（也就是说：网络延时有界限但是我们并不知道在哪里）下运行的协议可以容忍1/3任意（换句话说，拜占庭）错误；</p><p>（2）在一个异步模型中的确定性的协议（没有网络延时上限）不能容错（不过这个论文没有提起随机化算法可以容忍1/3的错误）；</p><p>（3）同步模型中的协议（网络延时可以保证小于已知d时间）可以，令人吃惊的，达到100%容错，虽然对1/2的节点出错可以发生的情况有所限制</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">弱一致性BASE</h4><p>多数情况下，其实我们也并非一定要求强一致性，部分业务可以容忍一定程度的延迟一致，所以为了兼顾效率，发展出来了最终一致性理论BASE，BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>基本可用(Basically Available)：基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p></li><li><p>软状态(Soft State)：软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。</p></li><li><p>最终一致性(Eventual Consistency)：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">一致性算法</h4><p>分布式架构的核心就在一致性的实现和妥协，那么如何设计一套算法来保证不同节点之间的通信和数据达到无限趋向一致性，就非常重要了。保证不同节点在充满不确定性网络环境下能达成相同副本的一致性是非常困难的，业界对该课题也做了大量的研究。</p><p>首先我们要了解一致性的大前提<strong><em>原则</em></strong>(CALM):</p><p>CALM原则的全称是 Consistency and Logical Monotonicity ，主要描述的是分布式系统中单调逻辑与一致性的关系，它的内容如下，参考consistency as logical monotonicity</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>在分布式系统中，单调的逻辑都能保证 “最终一致性”，这个过程中不需要依赖中心节点的调度</p></li><li><p>任意分布式系统，如果所有的非单调逻辑都有中心节点调度，那么这个分布式系统就可以实现最终“一致性”</p></li></ul><p>然后再关注分布式系统的<strong><em>数据结构</em></strong>CRDT(Conflict-Free Replicated Data Types)：</p><p>我们了解到分布式一些规律原则之后，就要着手考虑如何来实现解决方案，一致性算法的前提是数据结构，或者说一切算法的根基都是数据结构，设计良好的数据结构加上精妙的算法可以高效的解决现实的问题。经过前人不断的探索，我们得知分布式系统被广泛采用的数据结构CRDT。</p><p>参考《谈谈CRDT》,A comprehensive study of Convergent and Commutative Replicated Data Types</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>基于状态(state-based)：即将各个节点之间的CRDT数据直接进行合并，所有节点都能最终合并到同一个状态，数据合并的顺序不会影响到最终的结果。</p></li><li><p>基于操作(operation-based)：将每一次对数据的操作通知给其他节点。只要节点知道了对数据的所有操作（收到操作的顺序可以是任意的），就能合并到同一个状态。</p></li></ul><p>了解数据结构后，我们需要来关注一下分布式系统的一些重要的<strong><em>协议</em></strong>HATs(Highly Available Transactions)，ZAB(Zookeeper Atomic Broadcast)：</p><p>参考《高可用事务》，《ZAB协议分析》</p><p>最后要学习的是业界主流的一致性<strong><em>算法</em></strong>：</p><p>说实话具体的算法我也还没完全搞懂，一致性算法是分布式系统最核心本质的内容，这部分的发展也会影响架构的革新，不同场景的应用也催生不同的算法</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>Paxos：《优雅的Paxos算法》</p></li><li><p>Raft ：《Raft 一致性算法》</p></li><li><p>Gossip：《Gossip Visualization》</p></li></ul><p>这一节我们说完分布式系统里面核心理论基础，如何达成不同节点之间的数据一致性，下面我们将会讲到目前都有哪些主流的分布式系统。</p><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">5.场景分类</h2><h3 style="font-weight:bold;font-size:1.3em;">5.1文件系统</h3><p>单台计算机的存储始终有上限，随着网络的出现，多台计算机协作存储文件的方案也相继被提出来。最早的分布式文件系统其实也称为网络文件系统，第一个文件服务器在1970年代被发展出来。在1976年迪吉多公司设计出File Access Listener（FAL），而现代分布式文件系统则出自赫赫有名的Google的论文，《The Google File System》奠定了分布式文件系统的基础。现代主流分布式文件系统参考《分布式文件系统对比》,下面列举几个常用的文件系统</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>HDFS</p></li><li><p>FastDFS</p></li><li><p>Ceph</p></li><li><p>mooseFS</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.2数据库</h3><p>数据库当然也是属于文件系统，主数据增加了事务，检索，擦除等高级特性，所以复杂度又增加了，既要考虑数据一致性也得保证足够的性能。传统关系型数据库为了兼顾事务和性能的特性，在分布式方面的发展有限，非关系型数据库摆脱了事务的强一致性束缚，达到了最终一致性的效果，从而有了飞跃的发展，NoSql(Not Only Sql)也产生了多个架构的数据库类型，包括KV，列式存储，文档类型等。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>列式存储：Hbase</p></li><li><p>文档存储：Elasticsearch，MongoDB</p></li><li><p>KV类型：Redis</p></li><li><p>关系型：Spanner</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.3计算</h3><p>分布式计算系统构建在分布式存储的基础上，充分发挥分布式系统的数据冗余灾备，多副本高效获取数据的特性，进而并行计算，把原本需要长时间计算的任务拆分成多个任务并行处理，从而提高了计算效率。分布式计算系统在场景上分为离线计算，实时计算和流式计算。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>离线：Hadoop</p></li><li><p>实时：Spark</p></li><li><p>流式：Storm，Flink/Blink</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.4缓存</h3><p>缓存作为提升性能的利器无处不在，小到CPU缓存架构，大道分布式应用存储。分布式缓存系统提供了热点数据的随机访问机制，大大了提升了访问时间，但是带来的问题是如何保证数据的一致性，引入分布式锁来解决这个问题，主流的分布式存储系统基本就是Redis了</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>持久化：Redis</p></li><li><p>非持久化：Memcache</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.5消息</h3><p>分布式消息队列系统是消除异步带来一系列的复杂步骤的一大利器，多线程高并发场景先我们常常要谨慎的去设计业务代码，来保证多线程并发情况下不出现资源竞争导致的死锁问题。而消息队列以一种延迟消费的模式将异步任务都存到队列，然后再逐个消化。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>Kafka</p></li><li><p>RabbitMQ</p></li><li><p>RocketMQ</p></li><li><p>ActiveMQ</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.6监控</h3><p>分布式系统从单机到集群的形态发展，复杂度也大大提高，所以对整个系统的监控也是必不可少。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>Zookeeper</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.7应用</h3><p>分布式系统的核心模块就是在应用如何处理业务逻辑，应用直接的调用依赖于特定的协议来通信，有基于RPC协议的也有基于通用的HTTP协议。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>HSF</p></li><li><p>Dubble</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.8日志</h3><p>错误对应分布式系统是家常便饭，而且我们设计系统的时候本身就需要把容错作为普遍存在的现象来考虑。那么当出现故障的时候，快速恢复和排查故障就显得非常重要了。分布式日志采集存储和检索则可以给我提供有力的工具来定位请求链路中出现问题的环节。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>日志采集：flume</p></li><li><p>日志存储：ElasticSearch/Solr，SLS</p></li><li><p>日志定位：Zipkin</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">5.9账本</h3><p>前文我们提到所谓分布式系统，是迫于单机的性能有限，而堆硬件却又无法无休止的增加，单机堆硬件最终也会遇到性能增长曲线的瓶颈。于是我们才采用了多台计算机来干同样的活，但是这样的分布式系统始终需要中心化的节点来监控或者调度系统的资源，即使该中心节点也可能是多节点组成。而区块链则是真正的区中心化分布式系统，系统里面才有P2P网络协议各自通信，没有真正意义的中心节点，彼此按照区块链节点的算力，权益等机制来协调新区块的产生。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>比特币</p></li><li><p>以太坊</p></li></ul><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">6.设计模式</h2><p>上节我们列举了不同场景下不同分布式系统架构扮演的角色和实现的功能，本节我们更进一步归纳分布式系统设计的时候是如何考虑架构设计的，不同设计方案直接的区别和侧重点，不同场景需要选择合作设计模式，来减少试错的成本，设计分布式系统需要考虑以下的问题。</p><h3 style="font-weight:bold;font-size:1.3em;">6.1可用性</h3><p>可用性是系统运行和工作的时间比例，通常以正常运行时间的百分比来衡量。它可能受系统错误，基础架构问题，恶意攻击和系统负载的影响。分布式系统通常为用户提供服务级别协议（SLA），因此应用程序必须设计为最大化可用性。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>健康检查：系统实现全链路功能检查，外部工具定期通过公开端点访问系统</p></li><li><p>负载均衡：使用队列起到削峰作用，作为请求和服务之间的缓冲区，以平滑间歇性的重负载</p></li><li><p>节流：限制应用级别、租户或整个服务所消耗资源的范围</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">6.2数据管理</h3><p>数据管理是分布式系统的关键要素，并影响大多数质量的属性。由于性能，可扩展性或可用性等原因，数据通常托管在不同位置和多个服务器上，这可能带来一系列挑战。例如，必须维护数据一致性，并且通常需要跨不同位置同步数据。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>缓存：根据需要将数据从数据存储层加载到缓存</p></li><li><p>CQRS(Command Query Responsibility Segregation)： \xa0 \xa0命令查询职责分离</p></li><li><p>事件溯源：仅使用追加方式记录域中完整的系列事件</p></li><li><p>索引表：在经常查询引用的字段上创建索引</p></li><li><p>物化视图：生成一个或多个数据预填充视图</p></li><li><p>拆分：将数据拆分为水平的分区或分片</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">6.3设计与实现</h3><p>良好的设计包括诸如组件设计和部署的一致性，简化管理和开发的可维护性，以及允许组件和子系统用于其他应用程序和其他方案的可重用性等因素。在设计和实施阶段做出的决策对分布式系统和服务质量和总体拥有成本产生巨大影响。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>代理：反向代理</p></li><li><p>适配器： \xa0 \xa0在现代应用程序和遗留系统之间实现适配器层</p></li><li><p>前后端分离： \xa0 \xa0后端服务提供接口供前端应用程序调用</p></li><li><p>计算资源整合：将多个相关任务或操作合并到一个计算单元中</p></li><li><p>配置分离：将配置信息从应用程序部署包中移出到配置中心</p></li><li><p>网关聚合：使用网关将多个单独的请求聚合到一个请求中</p></li><li><p>网关卸载：将共享或专用服务功能卸载到网关代理</p></li><li><p>网关路由：使用单个端点将请求路由到多个服务</p></li><li><p>领导人选举：通过选择一个实例作为负责管理其他实例管理员，协调分布式系统的云</p></li><li><p>管道和过滤器：将复杂的任务分解为一系列可以重复使用的单独组件</p></li><li><p>边车：将应用的监控组件部署到单独的进程或容器中，以提供隔离和封装</p></li><li><p>静态内容托管：将静态内容部署到CDN，加速访问效率</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">6.4消息</h3><p>分布式系统需要一个连接组件和服务的消息传递中间件，理想情况是以松散耦合的方式，以便最大限度地提高可伸缩性。异步消息传递被广泛使用，并提供许多好处，但也带来了诸如消息排序，幂等性等挑战</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>竞争消费者：多线程并发消费</p></li><li><p>优先级队列： \xa0 \xa0消息队列分优先级，优先级高的先被消费</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">6.5管理与监控</h3><p>分布式系统在远程数据中心中运行，无法完全控制基础结构，这使管理和监视比单机部署更困难。应用必须公开运行时信息，管理员可以使用这些信息来管理和监视系统，以及支持不断变化的业务需求和自定义，而无需停止或重新部署应用。</p><h3 style="font-weight:bold;font-size:1.3em;">6.6性能与扩展</h3><p>性能表示系统在给定时间间隔内执行任何操作的响应性，而可伸缩性是系统处理负载增加而不影响性能或容易增加可用资源的能力。分布式系统通常会遇到变化的负载和活动高峰，特别是在多租户场景中，几乎是不可能预测的。相反，应用应该能够在限制范围内扩展以满足需求高峰，并在需求减少时进行扩展。可伸缩性不仅涉及计算实例，还涉及其他元素，如数据存储，消息队列等。</p><h3 style="font-weight:bold;font-size:1.3em;">6.7弹性</h3><p>弹性是指系统能够优雅地处理故障并从故障中恢复。分布式系统通常是多租户，使用共享平台服务，竞争资源和带宽，通过Internet进行通信，以及在商用硬件上运行，意味着出现瞬态和更永久性故障的可能性增加。为了保持弹性，必须快速有效地检测故障并进行恢复。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>隔离：将应用程序的元素隔离到池中，以便在其中一个失败时，其他元素将继续运行。</p></li><li><p>断路器：处理连接到远程服务或资源时可能需要不同时间修复的故障。</p></li><li><p>补偿交易：撤消一系列步骤执行的工作，这些步骤共同定义最终一致的操作</p></li><li><p>健康检查：系统实现全链路功能检查，外部工具定期通过公开端点访问系统</p></li><li><p>重试：通过透明地重试先前失败的操作，使应用程序在尝试连接到服务或网络资源时处理预期的临时故障</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">6.8安全</h3><p>安全性是系统能够防止在设计使用之外的恶意或意外行为，并防止泄露或丢失信息。分布式系统在受信任的本地边界之外的Internet上运行，通常向公众开放，并且可以为不受信任的用户提供服务。必须以保护应用程序免受恶意攻击，限制仅允许对已批准用户的访问，并保护敏感数据。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>联合身份：将身份验证委派给外部身份提供商</p></li><li><p>看门人： \xa0 \xa0通过使用专用主机实例来保护应用程序和服务，该实例充当客户端与应用程序或服务之间的代理，验证和清理请求，并在它们之间传递请求和数据</p></li><li><p>代客钥匙：使用为客户端提供对特定资源或服务的受限直接访问的令牌或密钥。</p></li></ul><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">7.工程应用</h2><p>前文我们介绍了分布式系统的核心理论，面临的一些难题和解决问题的折中思路，罗列了现有主流分布式系统的分类，而且归纳了建设分布式系统的一些方法论，那么接下来我们将从工程角度来介绍真刀真枪搭建分布式系统包含的内容和步骤。</p><h3 style="font-weight:bold;font-size:1.3em;">7.1资源调度</h3><p>巧妇难为无米之炊，我们一切的软件系统都是构建在硬件服务器的基础上，从最开始的物理机直接部署软件系统，到虚拟机的应用，最后到了资源上云容器化，硬件资源的使用也开始了集约化的管理。本节从对比的是传统运维角色对应的职责范围，在devops环境下，开发运维一体化，我们要实现的也是资源的灵活高效使用。</p><h4 style="font-weight:bold;font-size:1.2em;">弹性伸缩</h4><p>过去软件系统随着用户量增加需要增加机器资源的话，传统的方式就是找运维申请机器，然后部署好软件服务接入集群，整个过程依赖的是运维人员的人肉经验，效率低下而且容易出错。微服务分布式则无需人肉增加物理机器，在容器化技术的支撑下，我们只需要申请云资源，然后执行容器脚本即可。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>应用扩容</p><p>用户激增需要对服务进行扩展，包括自动化扩容，峰值过后的自动缩容</p></li><li><p>机器下线</p><p>对于过时应用，进行应用下线，云平台收回容器宿主资源</p></li><li><p>机器置换</p><p>对于故障机器，可供置换容器宿主资源，服务自动启动，无缝切换</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">网络管理</h4><p>有了计算资源后，另外最重要的就是网络资源了。在现有的云化背景下，我们几乎不会直接接触到物理的带宽资源，而是直接的由云平台统一管理带宽资源，我们需要的是对网络资源的最大化应用和有效的管理。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>域名申请</p><p>应用申请配套域名资源的申请，多套域名映射规则的规范</p></li><li><p>域名变更</p><p>域名变更统一平台管理</p></li><li><p>负载管理</p><p>多机应用的访问策略设定</p></li><li><p>安全外联</p><p>基础访问鉴权，拦截非法请求</p></li><li><p>统一接入</p><p>提供统一接入的权限申请平台，提供统一的登录管理</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">故障快照</h4><p>在系统故障的时候我们第一要务是系统恢复，同时保留案发现场也是非常重要的，资源调度平台则需要有统一的机制保存好故障现场。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>现场保留</p><p>内存分布，线程数等资源现象的保存，如JavaDump钩子接入</p></li><li><p>调试接入</p><p>采用字节码技术无需入侵业务代码，可以供生产环境现场日志打点调试</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">7.2流量调度</h3><p>在我们建设好分布式系统后，最先受到考验的关口就是网关了，进而我们需要关注好系统流量的情况，也就是如何对流量的管理，我们追求的是在系统可容纳的流量上限内，把资源留给最优质的流量使用，而把非法恶意的流量挡在门外，这样节省成本的同时确保系统不会被冲击崩溃。</p><h4 style="font-weight:bold;font-size:1.2em;">负载均衡</h4><p>负载均衡是我们对服务如何消化流量的通用设计，通常分为物理层的底层协议分流的硬负载均衡和软件层的软负载。负载均衡解决方案已经是业界成熟的方案，我们通常会针对特定业务在不同环境进行优化，常用有如下的负载均衡解决方案</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>交换机</p></li><li><p>F5</p></li><li><p>LVS/ALI-LVS</p></li><li><p>Nginx/Tengine</p></li><li><p>VIPServer/ConfigServer</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">网关设计</h4><p>负载均衡首当其冲的就是网关，因为中心化集群流量最先打到的地方就是网关了，如果网关扛不住压力的话，那么整个系统将不可用。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>高性能</p><p>网关设计第一需要考虑的是高性能的流量转发，网关单节点通常能达到上百万的并发流量</p></li><li><p>分布式</p><p>出于流量压力分担和灾备考虑，网关设计同样需要分布式</p></li><li><p>业务筛选</p><p>网关同设计简单的规则，排除掉大部分的恶意流量</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">流量管理</h4><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>请求校验</p><p>请求鉴权可以把多少非法请求拦截，清洗</p></li><li><p>数据缓存</p><p>多数无状态的请求存在数据热点，所以采用CDN可以把相当大一部分的流量消费掉</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">流控控制</h4><p>剩下的真实流量我们采用不同的算法来分流请求</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>流量分配</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>计数器</p></li><li><p>队列</p></li><li><p>漏斗</p></li><li><p>令牌桶</p></li><li><p>动态流控</p></li></ul></li><li><p>流量限制</p><p>在流量激增的时候，通常我们需要有限流措施来防止系统出现雪崩，那么就需要预估系统的流量上限，然后设定好上限数，但流量增加到一定阈值后，多出来的流量则不会进入系统，通过牺牲部分流量来保全系统的可用性。</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>QPS粒度</p></li><li><p>线程数粒度</p></li><li><p>RT阈值</p></li><li><p>限流策略</p></li><li><p>限流工具 - Sentinel</p></li></ul></li></ul><h3 style="font-weight:bold;font-size:1.3em;">7.3服务调度</h3><p>所谓打铁还需自身硬，流量做好了调度管理后，剩下的就是服务自身的健壮性了。分布式系统服务出现故障是常有的事情，甚至我们需要把故障本身当做是分布式服务的一部分。</p><h4 style="font-weight:bold;font-size:1.2em;">注册中心</h4><p>我们网络管理一节中介绍了网关，网关是流量的集散地，而注册中心则是服务的根据地。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>状态类型</p><p>第一好应用服务的状态，通过注册中心就可以检测服务是否可用</p></li><li><p>生命周期</p><p>应用服务不同的状态组成了应用的生命周期</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">版本管理</h4><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>集群版本</p><p>集群不用应用有自身对应的版本号，由不同服务组成的集群也需要定义大的版本号</p></li><li><p>版本回滚</p><p>在部署异常的时候可以根据大的集群版本进行回滚管理</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">服务编排</h4><p>服务编排的定义是：通过消息的交互序列来控制各个部分资源的交互。参与交互的资源都是对等的，没有集中的控制。微服务环境下服务众多我们需要有一个总的协调器来协议服务之间的依赖，调用关系，K8S则是我们的不二选择。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>K8S</p></li><li><p>Spring Cloud</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>HSF</p></li><li><p>ZK+Dubble</p></li></ul></li></ul><h4 style="font-weight:bold;font-size:1.2em;">服务控制</h4><p>前面我们解决了网络的健壮性和效率问题，这节介绍的是如何使我们的服务更加健壮。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>发现</p><p>资源管理那节我们介绍了从云平台申请了容器宿主资源后，通过自动化脚本就可以启动应用服务，启动后服务则需要发现注册中心，并且把自身的服务信息注册到服务网关，也即是网关接入。注册中心则会监控服务的不同状态，做健康检查，把不可用的服务归类标记。</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>网关接入</p></li><li><p>健康检查</p></li></ul></li><li><p>降级</p><p>当用户激增的时候，我们首先是在流量端做手脚，也就是限流。当我们发现限流后系统响应变慢了，有可能导致更多的问题时，我们也需要对服务本身做一些操作。服务降级就是把当前不是很核心的功能关闭掉，或者不是很要紧的准确性放宽范围，事后再做一些人工补救。</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>降低一致性约束</p></li><li><p>关闭非核心服务</p></li><li><p>简化功能</p></li></ul></li><li><p>熔断</p><p>当我们都做了以上的操作后，还是觉得不放心，那么就需要再进一步操心。熔断是对过载的一种自身保护，犹如我们开关跳闸一样。比如当我们服务不断对数据库进行查询的时候，如果业务问题造成查询问题，这是数据库本身需要熔断来保证不会被应用拖垮，并且访问友好的信息，告诉服务不要再盲目调用了。</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>闭合状态</p></li><li><p>半开状态</p></li><li><p>断开状态</p></li><li><p>熔断工具- Hystrix</p></li></ul></li><li><p>幂等</p><p>我们知道，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。那么久需要对单次操作赋予一个全局的id来做标识，这样多次请求后我们可以判断来源于同个客户端，避免出现脏数据。</p><ul style="list-style-type:square;margin-left:0px;" class="list-paddingleft-2"><li><p>全局一致性ID</p></li><li><p>Snowflake</p></li></ul></li></ul><h3 style="font-weight:bold;font-size:1.3em;">7.4数据调度</h3><p>数据存储最大的挑战就是数据冗余的管理，冗余多了效率变低而且占用资源，副本少了起不到灾备的作用，我们通常的做法是把有转态的请求，通过转态分离，转化为无状态请求。</p><h4 style="font-weight:bold;font-size:1.2em;">状态转移</h4><p>分离状态至全局存储，请求转换为无状态流量，比如我们通常会将登陆信息缓存至全局redis中间件，而不需要在多个应用中去冗余用户的登陆数据。</p><h4 style="font-weight:bold;font-size:1.2em;">分库分表</h4><p>数据横向扩展</p><h4 style="font-weight:bold;font-size:1.2em;">分片分区</h4><p>多副本冗余</p><h3 style="font-weight:bold;font-size:1.3em;">7.5自动化运维</h3><p>我们从资源申请管理的时候就介绍到devops的趋势，真正做到开发运维一体化则需要不同的中间件来配合完成。</p><h4 style="font-weight:bold;font-size:1.2em;">配置中心</h4><p>全局配置中心按环境来区分，统一管理，减少了多处配置的混乱局面</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>switch</p></li><li><p>diamend</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">部署策略</h4><p>微服务分布式部署是家常便饭，如何让我们的服务更好的支撑业务发展，稳健的部署策略是我们首先需要考虑的，如下的部署策略适合不同业务和不同的阶段。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>停机部署</p></li><li><p>滚动部署</p></li><li><p>蓝绿部署</p></li><li><p>灰度部署</p></li><li><p>A/B测试</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">作业调度</h4><p>任务调度是系统必不可少的一个环节，传统的方式是在Linux机器上配置crond定时任务或者直接在业务代码里面完成调度业务，现在则是成熟的中间件来代替。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>SchedulerX</p></li><li><p>Spring定时任务</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">应用管理</h4><p>运维工作中很大一部分时间需要对应用进行重启，上下线操作，还有日志清理。</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>应用重启</p></li><li><p>应用下线</p></li><li><p>日志清理</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">7.6容错处理</h3><p>既然我们知道分布式系统故障时家常便饭的事情，那么应对故障的方案也是不可或缺的环节。通常我们有主动和被动的方式来处理，主动是在错误出现的时候，我们试图再试试几次，说不定就成功了，成功的话就可以避免了该次错误。被动方式是错误的事情已经发生了，为了挽回，我们只是做时候处理，把负面影响降到最小。</p><h4 style="font-weight:bold;font-size:1.2em;">重试设计</h4><p>重试设计的关键在于设计好重试的时间和次数，如果超过重试次数，或是一段时间，那么重试就没有意义了。开源的项目 spring-retry可以很好的实现我们重试的计划。</p><h4 style="font-weight:bold;font-size:1.2em;">事务补偿</h4><p>事务补偿符合我们最终一致性的理念。补偿事务不一定会将系统中的数据返回到原始操作开始时其所处的状态。 相反，它补偿操作失败前由已成功完成的步骤所执行的工作。补偿事务中步骤的顺序不一定与原始操作中步骤的顺序完全相反。 例如，一个数据存储可能比另一个数据存储对不一致性更加敏感，因而补偿事务中撤销对此存储的更改的步骤应该会首先发生。对完成操作所需的每个资源采用短期的基于超时的锁并预先获取这些资源，这样有助于增加总体活动成功的可能性。 仅在获取所有资源后才应执行工作。 锁过期之前必须完成所有操作。</p><h3 style="font-weight:bold;font-size:1.3em;">7.7全栈监控</h3><p>由于分布式系统是由众多机器共同协作的系统，而且网络也无法保证完全可用，所以我们需要建设一套对各个环节都能监控的系统，这样我们才能从底层到业务各个层面进行监控，出现意外的时候可以及时修复故障，避免更多的问题出现。</p><h4 style="font-weight:bold;font-size:1.2em;">基础层</h4><p>基础层面是对容器资源的监测，包含各个硬件指标的负载情况</p><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>CPU，IO，内存，线程，吞吐</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">中间件</h4><p>分布式系统接入了大量的中间件平台，中间件本身的健康情况也需要监控</p><h4 style="font-weight:bold;font-size:1.2em;">应用层</h4><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>性能监控</p><p>应用层面的需要对每个应用服务的实时指标（qps，rt），上下游依赖等进行监控</p></li><li><p>业务监控</p><p>除了应用本身的监控程度，业务监控也是保证系统正常的一个环节，通过设计合理的业务规则，对异常的情况做报警设置</p></li></ul><h4 style="font-weight:bold;font-size:1.2em;">监控链路</h4><ul style="margin-left:0px;" class="list-paddingleft-2"><li><p>zipkin/eagleeye</p></li><li><p>sls</p></li><li><p>goc</p></li><li><p>Alimonitor</p></li></ul><h3 style="font-weight:bold;font-size:1.3em;">7.8故障恢复</h3><p>当故障已经发生后，我们第一要做的是马上消除故障，确保系统服务正常可用，这个时候通常的做回滚操作。</p><h4 style="font-weight:bold;font-size:1.2em;">应用回滚</h4><p>应用回滚之前需要保存好故障现场，以便排查原因。</p><h4 style="font-weight:bold;font-size:1.2em;">基线回退</h4><p>应用服务回滚后，代码基线也需要revert到前一版本。</p><h4 style="font-weight:bold;font-size:1.2em;">版本回滚</h4><p>整体回滚需要服务编排，通过大版本号对集群进行回滚。</p><h3 style="font-weight:bold;font-size:1.3em;">7.9性能调优</h3><p>性能优化是分布式系统的大专题，涉及的面非常广，这块简直可以单独拿出来做一个系列来讲，本节就先不展开。本身我们做服务治理的过程也是在性能的优化过程。</p><h4 style="font-weight:bold;font-size:1.2em;">分布式锁</h4><p>缓存是解决性能问题的一大利器，理想情况下，每个请求不需要额外计算立刻能获取到结果返回时最快的。小到CPU的三级缓存，大到分布式缓存，缓存无处不在，分布式缓存需要解决的就是数据的一致性，这个时候我们引入了分布式锁的概念，如何处理分布式锁的问题将决定我们获取缓存数据的效率。</p><h4 style="font-weight:bold;font-size:1.2em;">高并发</h4><p>多线程编程模式提升了系统的吞吐量，但也同时带来了业务的复杂度。</p><h4 style="font-weight:bold;font-size:1.2em;">异步</h4><p>事件驱动的异步编程是一种新的编程模式，摒弃了多线程的复杂业务处理问题，同时能够提升系统的响应效率。</p><h2 style="font-weight:bold;font-size:1.4em;border-bottom:1px solid rgb(238,238,238);">8.总结</h2><p>最后总结一下，如果有可能的话，请尝试使用单节点方式而不是分布式系统。分布式系统伴随着一些失败的操作，为了处理灾难性故障，我们使用备份。为了提高可靠性，我们引入了冗余。分布式系统本质就是一堆机器的协同。而我们要做的就是搞出各种手段来然机器的运行达到预期。这么复杂的系统，需要了解各个环节，各个中间件的接入，是一个非常大的工程。庆幸的是，在微服务背景下，多数基础性的工作已经有人帮我们实现了。前文所描述的分布式架构，在工程实现了是需要用到分布式三件套(Docker+K8S+Srping Cloud)基本就可以构建出来了。</p><p>分布式架构核心技术分布图如下：</p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATlvxC42ZnFibWibuAbibZ5D4E7dNxsdeibk5qCPec9Ys0I7uJEzd7xsleicdg/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p>分布式技术栈使用中间件：</p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATl9r7Ct5D5EMVKpRhdIiclflicXuW2RYAezwtxYB3C9V7ickdwZmJRsrvtQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p>最后用一张图来概括分布式系统的知识体系。</p><p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/dsrSk9kr59SKzotDuB58D1rDc5picLATlm3YMqOrsVGtu0ksDpZN1iajU0yaNEm63NN2DWgnIwzHnVvnRZ7KFbJA/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-更多文章-</span><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485083&amp;idx=1&amp;sn=7e01c7f86fea20658ef253111d6863fa&amp;chksm=9bed27e9ac9aaeff6019f67658c7877078ff93d507c96c327be381f20b67e2ec5f3461959cad&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Consul 之Greenwich版本全攻略</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="font-size:14px;color:rgb(0,209,0);text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485065&amp;idx=1&amp;sn=12b61d8de11c56929225dc75bfc87648&amp;chksm=9bed27fbac9aaeeddebb67a93a50dd140a64176a62092d5d5fc6ce8a537282c8d299e2b0587b&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Sleuth 之Greenwich版本全攻略</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="font-size:14px;color:rgb(0,209,0);text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485053&amp;idx=1&amp;sn=7268ce3c34d3c02e0a4308eed29061d2&amp;chksm=9bed270fac9aae1990cc99ba1bc434317fc85f1055a41c7745c72e7cbc71f86f5ddef3f78eb2&amp;scene=21#wechat_redirect" rel="nofollow">MongoDB是个好东西，希望你也会</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="font-size:14px;color:rgb(0,209,0);text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485041&amp;idx=1&amp;sn=f1a3191eda6ed19a18d86e1223c9ec65&amp;chksm=9bed2703ac9aae15fc563f67e5ecfcc428fbe746c909ff5ae24c9b6e7083e81d1d4823e9de15&amp;scene=21#wechat_redirect" rel="nofollow">小说：白话幂等性设计</a></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="font-size:14px;color:rgb(0,209,0);text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485032&amp;idx=1&amp;sn=924ec83a6da7e161281e843278d857a0&amp;chksm=9bed271aac9aae0c33f3c2e1a72823d263b57676bfa2da20e271c83f629b9a211971b07b12eb&amp;scene=21#wechat_redirect" rel="nofollow">好文推荐，15 分钟教你搞懂 Git！</a><br></span></p><p style="letter-spacing:.544px;text-align:center;"><span style="font-size:14px;color:rgb(0,209,0);text-decoration:underline;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&amp;mid=2247485029&amp;idx=1&amp;sn=a1931231cf15261ed8e2bf79b0c996f3&amp;chksm=9bed2717ac9aae0180a6c3e1f1d5417856b320ac87e29e0eff0698aacce22059b41a27917ba5&amp;scene=21#wechat_redirect" rel="nofollow">Spring Cloud Greenwich版本已发布！</a></span></p><p style="letter-spacing:.544px;text-align:center;"><br></p><p style="letter-spacing:.544px;text-align:center;"><span style="color:rgb(61,167,66);font-size:14px;">-关注我-</span><br></p><p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/rtJ5LhxxzwmeeDF9fPPQbQ24cJV10eLE8S3wgTkdrg5ZMg02G0Nh0TCnYtajMyr1SuW0Wup1iaaqRYZxcKAYZHQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="font-size:14px;letter-spacing:1px;"><strong style="letter-spacing:.544px;"><span style="letter-spacing:1px;color:rgb(61,167,66);">看完了，帮我点个“好看”鸭</span></strong></span></p><p style="margin-left:8px;letter-spacing:.544px;word-spacing:2px;text-align:right;"><span style="color:rgb(61,167,66);font-size:14px;letter-spacing:1px;"><strong>点鸭点鸭</strong></span></p><p style="letter-spacing:.544px;font-size:13px;line-height:normal;text-align:right;"><span style="color:rgb(61,167,66);">↓↓↓↓</span></p>\n                </div>\n                                      </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/85340278', 'title': '请您支持我，2018年博客之星评选，需要您宝贵的一票，非常感谢！', 'readNum': '11604', 'commentNum': '37', 'publishTime': '2018-12-29 16:03:38', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>我与CSDN很有缘分，第一篇博客发表于CSDN，后陆陆续续在其他平台上发表博客，但最终还是回归到了CSDN。</p>\n<p>作为一名程序员，自我驱动能力很重要，需要保持一颗对技术追求的心，在任何时候都不要忘记学习技术。我是一个对技术追求比较高的人，在日常工作和学习的时候，对技术有一点想法，或者觉得值得记录下来巩固的知识点，都会整理成文，发表出来。写博客的初心是提高自己，和更多的大佬交流学习。</p>\n<p>但随着我的博客访问量越来越大，不仅仅是提高自己了，必须得保证自己所传播知识的准确性，对其他看我博客的人负责。我的博客从0访问量达到目前的九百万访问量用了2-3年的<br>\n时间，在刚写博客的时候，我觉得我的博客写了可能没人看，因为我写的大家都写了，没有机会，其实这是错误的想法，任何时候都有机会。</p>\n<p>所以那些想博客而有很多担忧的，不必担忧，用心写就行。在参与了这次博客之星的候选名单，我内心是忐忑和激动的，得到了各位读者的认可和CSDN的认可，非常的开心和荣幸！</p>\n<p>同时，我也觉得，我更应该努力的学习和总结，多写出更多优质的文章。</p>\n<h6><a id="httpsbsscsdnnetmtopicblog_star2018httpsbsscsdnnetmtopicblog_star2018__NO45_11"></a>各位读者朋友们，请为我投宝贵的一票，投票地址：<a href="https://bss.csdn.net/m/topic/blog_star2018" rel="nofollow">https://bss.csdn.net/m/topic/blog_star2018</a>  。NO.45候选人是我，感谢您们！</h6>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/85081162', 'title': 'spring cloud gateway 之限流篇', 'readNum': '32792', 'commentNum': '17', 'publishTime': '2018-12-18 21:52:04', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/85081162<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/12/22/sc-f-gatway4.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/12/22/sc-f-gatway4.html</a></strong></p>\n<p>在高并发的系统中，往往需要在系统中做限流，一方面是为了防止大量的请求使服务器过载，导致服务不可用，另一方面是为了防止网络攻击。</p>\n<p>常见的限流方式，比如Hystrix适用线程池隔离，超过线程池的负载，走熔断的逻辑。在一般应用服务器中，比如tomcat容器也是通过限制它的线程数来控制并发的；也有通过时间窗口的平均速度来控制流量。常见的限流纬度有比如通过Ip来限流、通过uri来限流、通过用户访问频次来限流。</p>\n<p>一般限流都是在网关这一层做，比如Nginx、Openresty、kong、zuul、Spring Cloud Gateway等；也可以在应用层通过Aop这种方式去做限流。</p>\n<p>本文详细探讨在 Spring Cloud Gateway 中如何实现限流。</p>\n<h2><a id="_15"></a>常见的限流算法</h2>\n<h3><a id="_18"></a>计数器算法</h3>\n<p>计数器算法采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。具体的实现可以是这样的：对于每次服务调用，可以通过AtomicLong#incrementAndGet()方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。这种实现方式，相信大家都知道有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”</p>\n<h3><a id="_23"></a>漏桶算法</h3>\n<p>漏桶算法为了消除"突刺现象"，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601125728124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。</p>\n<p>这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p>\n<h3><a id="_34"></a>令牌桶算法</h3>\n<p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112575530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。</p>\n<h2><a id="Spring_Cloud_Gateway_43"></a>Spring Cloud Gateway限流</h2>\n<p>在Spring Cloud Gateway中，有Filter过滤器，因此可以在“pre”类型的Filter中自行实现上述三种过滤器。但是限流作为网关最基本的功能，Spring Cloud Gateway官方就提供了RequestRateLimiterGatewayFilterFactory这个类，适用Redis和lua脚本实现了令牌桶的方式。具体实现逻辑在RequestRateLimiterGatewayFilterFactory类中，lua脚本在如下图所示的文件夹中：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601125822176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>具体源码不打算在这里讲述，读者可以自行查看，代码量较少，先以案例的形式来讲解如何在Spring Cloud Gateway中使用内置的限流过滤器工厂来实现限流。</p>\n<p>首先在工程的pom文件中引入gateway的起步依赖和redis的reactive依赖，代码如下：</p>\n<pre><code class="prism language-text">\n &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifatId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>在配置文件中做以下的配置：</p>\n<pre><code class="prism language-text">\nserver:\n  port: 8081\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: limit_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - After=2017-01-20T17:42:47.789-07:00[America/Denver]\n        filters:\n        - name: RequestRateLimiter\n          args:\n            key-resolver: \'#{@hostAddrKeyResolver}\'\n            redis-rate-limiter.replenishRate: 1\n            redis-rate-limiter.burstCapacity: 3\n  application:\n    name: gateway-limiter\n  redis:\n    host: localhost\n    port: 6379\n    database: 0\n\n\n</code></pre>\n<p>在上面的配置文件，指定程序的端口为8081，配置了 redis的信息，并配置了RequestRateLimiter的限流过滤器，该过滤器需要配置三个参数：</p>\n<ul>\n<li>burstCapacity，令牌桶总容量。</li>\n<li>replenishRate，令牌桶每秒填充平均速率。</li>\n<li>key-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。</li>\n</ul>\n<p>KeyResolver需要实现resolve方法，比如根据Hostname进行限流，则需要用hostAddress去判断。实现完KeyResolver之后，需要将这个类的Bean注册到Ioc容器中。</p>\n<pre><code class="prism language-java">\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HostAddrKeyResolver</span> <span class="token keyword">implements</span> <span class="token class-name">KeyResolver</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> Mono<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">resolve</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> HostAddrKeyResolver <span class="token function">hostAddrKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HostAddrKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n</code></pre>\n<p>可以根据uri去限流，这时KeyResolver代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UriKeyResolver</span>  <span class="token keyword">implements</span> <span class="token class-name">KeyResolver</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> Mono<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">resolve</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> UriKeyResolver <span class="token function">uriKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UriKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n \n\n</code></pre>\n<p>也可以以用户的维度去限流：</p>\n<pre><code class="prism language-java">\n   <span class="token annotation punctuation">@Bean</span>\n    KeyResolver <span class="token function">userKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> exchange <span class="token operator">-</span><span class="token operator">&gt;</span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n\n</code></pre>\n<p>用jmeter进行压测，配置10thread去循环请求lcoalhost:8081，循环间隔1s。从压测的结果上看到有部分请求通过，由部分请求失败。通过redis客户端去查看redis中存在的key。如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112584723.png" alt="在这里插入图片描述"></p>\n<p>可见，RequestRateLimiter是使用Redis来进行限流的，并在redis中存储了2个key。关注这两个key含义可以看lua源代码。</p>\n<h2><a id="_164"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-gateway-limiter</p>\n<h3><a id="_168"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_176"></a>参考资料</h2>\n<p>http://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.0.RELEASE/single/spring-cloud-gateway.html#_requestratelimiter_gatewayfilter_factory</p>\n<p>https://windmt.com/2018/05/09/spring-cloud-15-spring-cloud-gateway-ratelimiter/</p>\n<p>http://www.spring4all.com/article/1382</p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/85057268', 'title': 'spring cloud gateway之filter篇', 'readNum': '47295', 'commentNum': '13', 'publishTime': '2018-12-17 21:45:21', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/85057268<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/springcloud/2018/12/21/sc-f-gatway3.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/12/21/sc-f-gatway3.html</a></strong></p>\n<p>在上一篇文章详细的介绍了Gateway的Predict，Predict决定了请求由哪一个路由处理，在路由处理之前，需要经过“pre”类型的过滤器处理，处理返回响应之后，可以由“post”类型的过滤器处理。</p>\n<h2><a id="filter_10"></a>filter的作用和生命周期</h2>\n<p>由filter工作流程点，可以知道filter有着非常重要的作用，在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等。首先需要弄清一点为什么需要网关这一层，这就不得不说下filter的作用了。</p>\n<h3><a id="_16"></a>作用</h3>\n<p>当我们有很多个服务时，比如下图中的user-service、goods-service、sales-service等服务，客户端请求各个服务的Api时，每个服务都需要做相同的事情，比如鉴权、限流、日志输出等。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011017456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>对于这样重复的工作，有没有办法做的更好，答案是肯定的。在微服务的上一层加一个全局的权限控制、限流、日志输出的Api Gatewat服务，然后再将请求转发到具体的业务服务层。这个Api Gateway服务就是起到一个服务边界的作用，外接的请求访问系统，必须先通过网关层。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011045154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_27"></a>生命周期</h3>\n<p>Spring Cloud Gateway同zuul类似，有“pre”和“post”两种方式的filter。客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，比如上图中的user-service，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011115924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>与zuul不同的是，filter除了分为“pre”和“post”两种方式的filter外，在Spring Cloud Gateway中，filter从作用范围可分为另外两种，一种是针对于单个路由的gateway filter，它在配置文件中的写法同predict类似；另外一种是针对于所有路由的global gateway filer。现在从作用范围划分的维度来讲解这两种filter。</p>\n<h2><a id="gateway_filter_36"></a>gateway filter</h2>\n<p>过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。过滤器可以限定作用在某些特定请求路径上。  Spring Cloud Gateway包含许多内置的GatewayFilter工厂。</p>\n<p>GatewayFilter工厂同上一篇介绍的Predicate工厂类似，都是在配置文件application.yml中配置，遵循了约定大于配置的思想，只需要在配置文件配置GatewayFilter Factory的名称，而不需要写全部的类名，比如AddRequestHeaderGatewayFilterFactory只需要在配置文件中写AddRequestHeader，而不是全部类名。在配置文件中配置的GatewayFilter Factory最终都会相应的过滤器工厂类处理。</p>\n<p>Spring Cloud Gateway 内置的过滤器工厂一览表如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011143809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>现在挑几个常见的过滤器工厂来讲解，每一个过滤器工厂在官方文档都给出了详细的使用案例，如果不清楚的还可以在org.springframework.cloud.gateway.filter.factory看每一个过滤器工厂的源码。</p>\n<h3><a id="AddRequestHeader_GatewayFilter_Factory_49"></a>AddRequestHeader GatewayFilter Factory</h3>\n<p>创建工程，引入相关的依赖,包括spring boot 版本2.0.5，spring Cloud版本Finchley，gateway依赖如下：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>在工程的配置文件中，加入以下的配置：</p>\n<pre><code class="prism language-text">server:\n  port: 8081\nspring:\n  profiles:\n    active: add_request_header_route\n\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: add_request_header_route\n        uri: http://httpbin.org:80/get\n        filters:\n        - AddRequestHeader=X-Request-Foo, Bar\n        predicates:\n        - After=2017-01-20T17:42:47.789-07:00[America/Denver]\n  profiles: add_request_header_route\n\n</code></pre>\n<p>在上述的配置中，工程的启动端口为8081，配置文件为add_request_header_route，在add_request_header_route配置中，配置了roter的id为add_request_header_route，路由地址为http://httpbin.org:80/get，该router有AfterPredictFactory，有一个filter为AddRequestHeaderGatewayFilterFactory(约定写成AddRequestHeader)，AddRequestHeader过滤器工厂会在请求头加上一对请求头，名称为X-Request-Foo，值为Bar。为了验证AddRequestHeaderGatewayFilterFactory是怎么样工作的，查看它的源码，AddRequestHeaderGatewayFilterFactory的源码如下：</p>\n<pre><code class="prism language-java">\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AddRequestHeaderGatewayFilterFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractNameValueGatewayFilterFactory</span> <span class="token punctuation">{</span>\n\n\t<span class="token annotation punctuation">@Override</span>\n\t<span class="token keyword">public</span> GatewayFilter <span class="token function">apply</span><span class="token punctuation">(</span>NameValueConfig config<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span> <span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> chain<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n\t\t\tServerHttpRequest request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\t\t\t\t\t<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t\t\t\t\t<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t\t\t<span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>由上面的代码可知，根据旧的ServerHttpRequest创建新的 ServerHttpRequest ，在新的ServerHttpRequest加了一个请求头，然后创建新的 ServerWebExchange ，提交过滤器链继续过滤。</p>\n<p>启动工程，通过curl命令来模拟请求：</p>\n<pre><code class="prism language-text">\ncurl localhost:8081\n\n</code></pre>\n<p>最终显示了从 http://httpbin.org:80/get得到了请求，响应如下：</p>\n<pre><code class="prism language-text">{\n  "args": {},\n  "headers": {\n    "Accept": "*/*",\n    "Connection": "close",\n    "Forwarded": "proto=http;host=\\"localhost:8081\\";for=\\"0:0:0:0:0:0:0:1:56248\\"",\n    "Host": "httpbin.org",\n    "User-Agent": "curl/7.58.0",\n    "X-Forwarded-Host": "localhost:8081",\n    "X-Request-Foo": "Bar"\n  },\n  "origin": "0:0:0:0:0:0:0:1, 210.22.21.66",\n  "url": "http://localhost:8081/get"\n}\n\n</code></pre>\n<p>可以上面的响应可知，确实在请求头中加入了X-Request-Foo这样的一个请求头，在配置文件中配置的AddRequestHeader过滤器工厂生效。</p>\n<p>跟AddRequestHeader过滤器工厂类似的还有AddResponseHeader过滤器工厂，在此就不再重复。</p>\n<h3><a id="RewritePath_GatewayFilter_Factory_142"></a>RewritePath GatewayFilter Factory</h3>\n<p>在Nginx服务启中有一个非常强大的功能就是重写路径，Spring Cloud Gateway默认也提供了这样的功能，这个功能是Zuul没有的。在配置文件中加上以下的配置：</p>\n<pre><code>\nspring:\n  profiles:\n    active: rewritepath_route\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: rewritepath_route\n        uri: https://blog.csdn.net\n        predicates:\n        - Path=/foo/**\n        filters:\n        - RewritePath=/foo/(?&lt;segment&gt;.*), /$\\{segment}\n  profiles: rewritepath_route\n\n</code></pre>\n<p>上面的配置中，所有的/foo/**开始的路径都会命中配置的router，并执行过滤器的逻辑，在本案例中配置了RewritePath过滤器工厂，此工厂将/foo/(?.*)重写为{segment}，然后转发到https://blog.csdn.net。比如在网页上请求localhost:8081/foo/forezp，此时会将请求转发到https://blog.csdn.net/forezp的页面，比如在网页上请求localhost:8081/foo/forezp/1，页面显示404，就是因为不存在https://blog.csdn.net/forezp/1这个页面。</p>\n<h3><a id="_169"></a>自定义过滤器</h3>\n<p>Spring Cloud Gateway内置了19种强大的过滤器工厂，能够满足很多场景的需求，那么能不能自定义自己的过滤器呢，当然是可以的。在spring Cloud Gateway中，过滤器需要实现GatewayFilter和Ordered2个接口。写一个RequestTimeFilter，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestTimeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GatewayFilter</span><span class="token punctuation">,</span> Ordered <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Log log <span class="token operator">=</span> LogFactory<span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span>GatewayFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String REQUEST_TIME_BEGIN <span class="token operator">=</span> <span class="token string">"requestTimeBegin"</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> Mono<span class="token generics function"><span class="token punctuation">&lt;</span>Void<span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n        exchange<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>REQUEST_TIME_BEGIN<span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>\n                Mono<span class="token punctuation">.</span><span class="token function">fromRunnable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n                    Long startTime <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>REQUEST_TIME_BEGIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRawPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>在上面的代码中，Ordered中的int getOrder()方法是来给过滤器设定优先级别的，值越大则优先级越低。还有有一个filterI(exchange,chain)方法，在该方法中，先记录了请求的开始时间，并保存在ServerWebExchange中，此处是一个“pre”类型的过滤器，然后再chain.filter的内部类中的run()方法中相当于"post"过滤器，在此处打印了请求所消耗的时间。然后将该过滤器注册到router中，代码如下：</p>\n<pre><code class="prism language-java">    <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> RouteLocator <span class="token function">customerRouteLocator</span><span class="token punctuation">(</span>RouteLocatorBuilder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// @formatter:off</span>\n        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>r <span class="token operator">-</span><span class="token operator">&gt;</span> r<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"/customer/**"</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">filters</span><span class="token punctuation">(</span>f <span class="token operator">-</span><span class="token operator">&gt;</span> f<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RequestTimeFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                                <span class="token punctuation">.</span><span class="token function">addResponseHeader</span><span class="token punctuation">(</span><span class="token string">"X-Response-Default-Foo"</span><span class="token punctuation">,</span> <span class="token string">"Default-Bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">"http://httpbin.org:80/get"</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">order</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token string">"customer_filter_router"</span><span class="token punctuation">)</span>\n                <span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// @formatter:on</span>\n    <span class="token punctuation">}</span>\n\n\n</code></pre>\n<p>重启程序，通过curl命令模拟请求：</p>\n<pre><code class="prism language-text"> curl localhost:8081/customer/123\n\n</code></pre>\n<p>在程序的控制台输出一下的请求信息的日志：</p>\n<pre><code class="prism language-text">\n2018-11-16 15:02:20.177  INFO 20488 --- [ctor-http-nio-3] o.s.cloud.gateway.filter.GatewayFilter   : /customer/123: 152ms\n\n</code></pre>\n<h2><a id="_241"></a>自定义过滤器工厂</h2>\n<p>在上面的自定义过滤器中，有没有办法自定义过滤器工厂类呢?这样就可以在配置文件中配置过滤器了。现在需要实现一个过滤器工厂，在打印时间的时候，可以设置参数来决定是否打印请参数。查看GatewayFilterFactory的源码，可以发现GatewayFilterfactory的层级如下：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZmFuZ3poaXBlbmcuY29tL2ltZy9qaWFuc2h1LzIyNzk1OTQtZjk3ZTEwNDVjZWJjOTU0Yy5wbmc?x-oss-process=image/format,png" alt="微信截图_20181204175448.png"></p>\n<p>过滤器工厂的顶级接口是GatewayFilterFactory，我们可以直接继承它的两个抽象类来简化开发AbstractGatewayFilterFactory和AbstractNameValueGatewayFilterFactory，这两个抽象类的区别就是前者接收一个参数（像StripPrefix和我们创建的这种），后者接收两个参数（像AddResponseHeader）。</p>\n<p>过滤器工厂的顶级接口是GatewayFilterFactory，有2个两个较接近具体实现的抽象类，分别为AbstractGatewayFilterFactory和AbstractNameValueGatewayFilterFactory，这2个类前者接收一个参数，比如它的实现类RedirectToGatewayFilterFactory；后者接收2个参数，比如它的实现类AddRequestHeaderGatewayFilterFactory类。现在需要将请求的日志打印出来，需要使用一个参数，这时可以参照RedirectToGatewayFilterFactory的写法。</p>\n<pre><code class="prism language-java">\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestTimeGatewayFilterFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractGatewayFilterFactory</span><span class="token generics function"><span class="token punctuation">&lt;</span>RequestTimeGatewayFilterFactory<span class="token punctuation">.</span>Config<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>\n\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Log log <span class="token operator">=</span> LogFactory<span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span>GatewayFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String REQUEST_TIME_BEGIN <span class="token operator">=</span> <span class="token string">"requestTimeBegin"</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String KEY <span class="token operator">=</span> <span class="token string">"withParams"</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> List<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">shortcutFieldOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token function">RequestTimeGatewayFilterFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>Config<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> GatewayFilter <span class="token function">apply</span><span class="token punctuation">(</span>Config config<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> chain<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n            exchange<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>REQUEST_TIME_BEGIN<span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>\n                    Mono<span class="token punctuation">.</span><span class="token function">fromRunnable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n                        Long startTime <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>REQUEST_TIME_BEGIN<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRawPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                                    <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">": "</span><span class="token punctuation">)</span>\n                                    <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span>\n                                    <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                            <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isWithParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" params:"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                            <span class="token punctuation">}</span>\n                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token punctuation">}</span>\n                    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n            <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Config</span> <span class="token punctuation">{</span>\n\n        <span class="token keyword">private</span> <span class="token keyword">boolean</span> withParams<span class="token punctuation">;</span>\n\n        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isWithParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> withParams<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWithParams</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> withParams<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>withParams <span class="token operator">=</span> withParams<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n\n</code></pre>\n<p>在上面的代码中 apply(Config config)方法内创建了一个GatewayFilter的匿名类，具体的实现逻辑跟之前一样，只不过加了是否打印请求参数的逻辑，而这个逻辑的开关是config.isWithParams()。静态内部类类Config就是为了接收那个boolean类型的参数服务的，里边的变量名可以随意写，但是要重写List shortcutFieldOrder()这个方法。<br>\n。</p>\n<p>需要注意的是，在类的构造器中一定要调用下父类的构造器把Config类型传过去，否则会报ClassCastException</p>\n<p>最后，需要在工程的启动文件Application类中，向Srping Ioc容器注册RequestTimeGatewayFilterFactory类的Bean。</p>\n<pre><code class="prism language-java">\n    <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> RequestTimeGatewayFilterFactory <span class="token function">elapsedGatewayFilterFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RequestTimeGatewayFilterFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n</code></pre>\n<p>然后可以在配置文件中配置如下：</p>\n<pre><code class="prism language-text">spring:\n  profiles:\n    active: elapse_route\n\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: elapse_route\n        uri: http://httpbin.org:80/get\n        filters:\n        - RequestTime=false\n        predicates:\n        - After=2017-01-20T17:42:47.789-07:00[America/Denver]\n  profiles: elapse_route\n\n</code></pre>\n<p>启动工程，在浏览器上访问localhost:8081?name=forezp，可以在控制台上看到，日志输出了请求消耗的时间和请求参数。</p>\n<h2><a id="global_filter_354"></a>global filter</h2>\n<p>Spring Cloud Gateway根据作用范围划分为GatewayFilter和GlobalFilter，二者区别如下：</p>\n<ul>\n<li>\n<p>GatewayFilter : 需要通过spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上</p>\n</li>\n<li>\n<p>GlobalFilter : 全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</p>\n</li>\n</ul>\n<p>Spring Cloud Gateway框架内置的GlobalFilter如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011412503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>上图中每一个GlobalFilter都作用在每一个router上，能够满足大多数的需求。但是如果遇到业务上的定制，可能需要编写满足自己需求的GlobalFilter。在下面的案例中将讲述如何编写自己GlobalFilter，该GlobalFilter会校验请求中是否包含了请求参数“token”，如何不包含请求参数“token”则不转发路由，否则执行正常的逻辑。代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span><span class="token punctuation">,</span> Ordered <span class="token punctuation">{</span>\n\n    Logger logger<span class="token operator">=</span>LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span> TokenFilter<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> Mono<span class="token generics function"><span class="token punctuation">&lt;</span>Void<span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String token <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> null <span class="token operator">||</span> token<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span> <span class="token string">"token is empty..."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n            exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>UNAUTHORIZED<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>在上面的TokenFilter需要实现GlobalFilter和Ordered接口，这和实现GatewayFilter很类似。然后根据ServerWebExchange获取ServerHttpRequest，然后根据ServerHttpRequest中是否含有参数token，如果没有则完成请求，终止转发，否则执行正常的逻辑。</p>\n<p>然后需要将TokenFilter在工程的启动类中注入到Spring Ioc容器中，代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> TokenFilter <span class="token function">tokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>启动工程，使用curl命令请求：</p>\n<pre><code> curl localhost:8081/customer/123\n \n</code></pre>\n<p>可以看到请没有被转发，请求被终止，并在控制台打印了如下日志：</p>\n<pre><code>2018-11-16 15:30:13.543  INFO 19372 --- [ctor-http-nio-2] gateway.TokenFilter                      : token is empty...\n</code></pre>\n<p>上面的日志显示了请求进入了没有传“token”的逻辑。</p>\n<h2><a id="_423"></a>总结</h2>\n<p>本篇文章讲述了Spring Cloud Gateway中的过滤器，包括GatewayFilter和GlobalFilter。从官方文档的内置过滤器讲起，然后讲解自定义GatewayFilter、GatewayFilterFactory以及自定义的GlobalFilter。有很多内置的过滤器并没有讲述到，比如限流过滤器，这个我觉得是比较重要和大家关注的过滤器，将在之后的文章讲述。</p>\n<h3><a id="_427"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_435"></a>参考资料</h2>\n<p>https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.M1/single/spring-cloud-gateway.html</p>\n<p>https://www.jianshu.com/p/eb3a67291050</p>\n<p>https://blog.csdn.net/qq_36236890/article/details/80822051</p>\n<p>https://windmt.com/2018/05/08/spring-cloud-14-spring-cloud-gateway-filter</p>\n<h2><a id="_445"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-gateway-predicate</p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/84926662', 'title': 'Spring Cloud Gateway 之Predict篇', 'readNum': '42980', 'commentNum': '23', 'publishTime': '2018-12-09 12:53:44', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/84926662<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/12/05/sc-f-gateway2.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/12/05/sc-f-gateway2.html</a></strong></p>\n<h2><a id="Spring_Cloud_gateway_6"></a>Spring Cloud gateway工作流程</h2>\n<p>在之前的文章的Spring Cloud Gateway初体验中，大家已经对Spring Cloud Gateway的功能有一个初步的认识，网关作为一个系统的流量的入口，有着举足轻重的作用，通常的作用如下：</p>\n<ul>\n<li>协议转换，路由转发</li>\n<li>流量聚合，对流量进行监控，日志输出</li>\n<li>作为整个系统的前端工程，对流量进行控制，有限流的作用</li>\n<li>作为系统的前端边界，外部流量只能通过网关才能访问系统</li>\n<li>可以在网关层做权限的判断</li>\n<li>可以在网关层做缓存</li>\n</ul>\n<p>Spring Cloud Gateway作为Spring Cloud框架的第二代网关，在功能上要比Zuul更加的强大，性能也更好。随着Spring Cloud的版本迭代，Spring Cloud官方有打算弃用Zuul的意思。在笔者调用了Spring Cloud Gateway的使用和功能上，Spring Cloud Gateway替换掉Zuul的成本上是非常低的，几乎可以无缝切换。Spring Cloud Gateway几乎包含了zuul的所有功能。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010743550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><strong>注：该图片来自官网</strong></p>\n<p>如上图所示，客户端向Spring Cloud Gateway发出请求。 如果Gateway Handler Mapping确定请求与路由匹配（这个时候就用到predicate），则将其发送到Gateway web handler处理。 Gateway web handler处理请求时会经过一系列的过滤器链。 过滤器链被虚线划分的原因是过滤器链可以在发送代理请求之前或之后执行过滤逻辑。 先执行所有“pre”过滤器逻辑，然后进行代理请求。 在发出代理请求之后，收到代理服务的响应之后执行“post”过滤器逻辑。这跟zuul的处理过程很类似。在执行所有“pre”过滤器逻辑时，往往进行了鉴权、限流、日志输出等功能，以及请求头的更改、协议的转换；转发之后收到响应之后，会执行所有“post”过滤器的逻辑，在这里可以响应数据进行了修改，比如响应头、协议的转换等。</p>\n<p>在上面的处理过程中，有一个重要的点就是讲请求和路由进行匹配，这时候就需要用到predicate，它是决定了一个请求走哪一个路由。</p>\n<h2><a id="predicate_28"></a>predicate简介</h2>\n<blockquote>\n<p>Predicate来自于java8的接口。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。add–与、or–或、negate–非。</p>\n</blockquote>\n<p>Spring Cloud Gateway内置了许多Predict,这些Predict的源码在org.springframework.cloud.gateway.handler.predicate包中，如果读者有兴趣可以阅读一下。现在列举各种Predicate如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010916598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><strong>注：图片来自网络</strong></p>\n<p>在上图中，有很多类型的Predicate,比如说时间类型的Predicated（AfterRoutePredicateFactory BeforeRoutePredicateFactory BetweenRoutePredicateFactory），当只有满足特定时间要求的请求会进入到此predicate中，并交由router处理；cookie类型的CookieRoutePredicateFactory，指定的cookie满足正则匹配，才会进入此router;以及host、method、path、querparam、remoteaddr类型的predicate，每一种predicate都会对当前的客户端请求进行判断，是否满足当前的要求，如果满足则交给当前请求处理。如果有很多个Predicate，并且一个请求满足多个Predicate，则按照配置的顺序第一个生效。</p>\n<h2><a id="predicate_41"></a>predicate实战</h2>\n<p>现在以案例的形式来讲解predicate，本文中的案例基本来源于官方文档，官方文档地址：http://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.0.RELEASE/single/spring-cloud-gateway.html ；如果有任何问题欢迎和我联系，和我讨论。</p>\n<p>创建一个工程，在工程的pom文件引入spring cloud gateway 的起步依赖spring-cloud-starter-gateway，spring cloud版本和spring boot版本，代码如下：</p>\n<pre><code class="prism language-text">\n  &lt;parent&gt;\n       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n       &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n       &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;\n   &lt;/parent&gt;\n\n   &lt;dependencyManagement&gt;\n       &lt;dependencies&gt;\n           &lt;dependency&gt;\n               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n               &lt;version&gt;Finchley.SR1&lt;/version&gt;\n               &lt;type&gt;pom&lt;/type&gt;\n               &lt;scope&gt;import&lt;/scope&gt;\n           &lt;/dependency&gt;\n       &lt;/dependencies&gt;\n   &lt;/dependencyManagement&gt;\n\n &lt;dependency&gt;\n     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n     &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n &lt;/dependency&gt;\n\n</code></pre>\n<h3><a id="After_Route_Predicate_Factory_76"></a>After Route Predicate Factory</h3>\n<p>AfterRoutePredicateFactory，可配置一个时间，当请求的时间在配置时间之后，才交给 router去处理。否则则报错，不通过路由。</p>\n<p>在工程的application.yml配置如下：</p>\n<pre><code class="prism language-text">server:\n  port: 8081\nspring:\n  profiles:\n    active: after_route\n\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: after_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - After=2017-01-20T17:42:47.789-07:00[America/Denver]\n  profiles: after_route\n\n</code></pre>\n<p>在上面的配置文件中，配置了服务的端口为8081，配置spring.profiles.active:after_route指定了程序的spring的启动文件为after_route文件。在application.yml再建一个配置文件，语法是三个横线，在此配置文件中通过spring.profiles来配置文件名，和spring.profiles.active一致，然后配置spring cloud gateway 相关的配置，id标签配置的是router的id，每个router都需要一个唯一的id，uri配置的是将请求路由到哪里，本案例全部路由到http://httpbin.org:80/get。</p>\n<p>predicates：<br>\nAfter=2017-01-20T17:42:47.789-07:00[America/Denver] 会被解析成PredicateDefinition对象 （name =After ，args= 2017-01-20T17:42:47.789-07:00[America/Denver]）。在这里需要注意的是predicates的After这个配置，遵循的契约大于配置的思想，它实际被AfterRoutePredicateFactory这个类所处理，这个After就是指定了它的Gateway web handler类为AfterRoutePredicateFactory，同理，其他类型的predicate也遵循这个规则。</p>\n<p>当请求的时间在这个配置的时间之后，请求会被路由到http://httpbin.org:80/get。</p>\n<p>启动工程，在浏览器上访问http://localhost:8081/，会显示http://httpbin.org:80/get返回的结果，此时gateway路由到了配置的uri。如果我们将配置的时间设置到当前时之后，浏览器会显示404，此时证明没有路由到配置的uri.</p>\n<p>跟时间相关的predicates还有Before Route Predicate Factory、Between Route Predicate Factory，读者可以自行查阅官方文档，再次不再演示。</p>\n<h3><a id="Header_Route_Predicate_Factory_114"></a>Header Route Predicate Factory</h3>\n<p>Header Route Predicate Factory需要2个参数，一个是header名，另外一个header值，该值可以是一个正则表达式。当此断言匹配了请求的header名和值时，断言通过，进入到router的规则中去。</p>\n<p>在工程的配置文件加上以下的配置：</p>\n<pre><code class="prism language-text">\nspring:\n  profiles:\n    active: header_route\n\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: header_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Header=X-Request-Id, \\d+\n  profiles: header_route\n\n\n</code></pre>\n<p>在上面的配置中，当请求的Header中有X-Request-Id的header名，且header值为数字时，请求会被路由到配置的 uri. 使用curl执行以下命令:</p>\n<pre><code class="prism language-text">$ curl -H \'X-Request-Id:1\' localhost:8081\n\n</code></pre>\n<p>执行命令后，会正确的返回请求结果，结果省略。如果在请求中没有带上X-Request-Id的header名，并且值不为数字时，请求就会报404，路由没有被正确转发。</p>\n<h3><a id="Cookie_Route_Predicate_Factory_150"></a>Cookie Route Predicate Factory</h3>\n<p>Cookie Route Predicate Factory需要2个参数，一个时cookie名字，另一个时值，可以为正则表达式。它用于匹配请求中，带有该名称的cookie和cookie匹配正则表达式的请求。</p>\n<p>在配置文件添加以下配置：</p>\n<pre><code class="prism language-text">\nspring:\n  profiles:\n    active: cookie_route\n\n\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: cookie_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Cookie=name, forezp\n  profiles: cookie_route\n\n</code></pre>\n<p>在上面的配置中，请求带有cookie名为<br>\nname, cookie值为forezp 的请求将都会转发到uri为 http://httpbin.org:80/get的地址上。<br>\n使用curl命令进行请求，在请求中带上 cookie，会返回正确的结果，否则，请求报404错误。</p>\n<pre><code class="prism language-text">$ curl -H \'Cookie:name=forezp\' localhost:8081\n\n</code></pre>\n<h3><a id="Host_Route_Predicate_Factory_188"></a>Host Route Predicate Factory</h3>\n<p>Host Route Predicate Factory需要一个参数即hostname，它可以使用. * 等去匹配host。这个参数会匹配请求头中的host的值，一致，则请求正确转发。</p>\n<p>在工程的配置文件，加上以下配置：</p>\n<pre><code class="prism language-text">\nspring:\n  profiles:\n    active: host_route\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: host_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Host=**.fangzhipeng.com\n  profiles: host_route\n</code></pre>\n<p>在上面的配置中，请求头中含有Host为fangzhipeng.com的请求将会被路由转发转发到配置的uri。 启动工程，执行以下的curl命令，请求会返回正确的请求结果：</p>\n<pre><code class="prism language-text">\ncurl -H \'Host:www.fangzhipeng.com\' localhost:8081\n\n</code></pre>\n<h3><a id="Method_Route_Predicate_Factory_223"></a>Method Route Predicate Factory</h3>\n<p>Method Route Predicate Factory 需要一个参数，即请求的类型。比如GET类型的请求都转发到此路由。在工程的配置文件加上以下的配置：</p>\n<pre><code class="prism language-text">\nspring:\n  profiles:\n    active: method_route\n\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: method_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Method=GET\n  profiles: method_route\n\n\n</code></pre>\n<p>在上面的配置中，所有的GET类型的请求都会路由转发到配置的uri。使用 curl命令模拟 get类型的请求，会得到正确的返回结果。</p>\n<pre><code class="prism language-text">\n$ curl localhost:8081\n\n</code></pre>\n<p>使用 curl命令模拟 post请求，则返回404结果。</p>\n<pre><code class="prism language-text">$ curl -XPOST localhost:8081\n\n</code></pre>\n<h3><a id="Path_Route_Predicate_Factory_263"></a>Path Route Predicate Factory</h3>\n<p>Path Route Predicate Factory 需要一个参数: 一个spel表达式，应用匹配路径。</p>\n<p>在工程的配置文件application.yml文件中，做以下的配置：</p>\n<pre><code class="prism language-text">\nspring:\n  profiles:\n    active: path_route\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: path_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Path=/foo/{segment}\n  profiles: path_route\n\n</code></pre>\n<p>在上面的配置中，所有的请求路径满足/foo/{segment}的请求将会匹配并被路由，比如/foo/1 、/foo/bar的请求，将会命中匹配，并成功转发。</p>\n<p>使用curl模拟一个请求localhost:8081/foo/dew，执行之后会返回正确的请求结果。</p>\n<pre><code class="prism language-text">$ curl localhost:8081/foo/dew\n\n</code></pre>\n<h3><a id="Query_Route_Predicate_Factory_298"></a>Query Route Predicate Factory</h3>\n<p>Query Route Predicate Factory 需要2个参数:一个参数名和一个参数值的正则表达式。在工程的配置文件application.yml做以下的配置：</p>\n<pre><code class="prism language-text">\nspring:\n  profiles:\n    active: query_route\n---\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: query_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Query=foo, ba.\n  profiles: query_route\n\n</code></pre>\n<p>在上面的配置文件中，配置了请求中含有参数foo，并且foo的值匹配ba.，则请求命中路由，比如一个请求中含有参数名为foo，值的为bar，能够被正确路由转发。</p>\n<p>模拟请求的命令如下：</p>\n<pre><code class="prism language-text">$ curl localhost:8081?foo=bar\n\n\n</code></pre>\n<p>Query Route Predicate Factory也可以只填一个参数，填一个参数时，则只匹配参数名，即请求的参数中含有配置的参数名，则命中路由。比如以下的配置中，配置了请求参数中含有参数名为foo 的参数将会被请求转发到uri为http://httpbin.org:80/get。</p>\n<pre><code class="prism language-text">\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: query_route\n        uri: http://httpbin.org:80/get\n        predicates:\n        - Query=foo\n  profiles: query_route\n\n</code></pre>\n<h2><a id="_350"></a>总结</h2>\n<p>在本篇文章中，首先介绍了Spring Cloud Gateway的工作流程和原理，然后介绍了gateway框架内置的predict及其分类，最后以案例的形式重点讲解了几个重要的Predict。Predict作为断言，它决定了请求会被路由到哪个router 中。在断言之后，请求会被进入到filter过滤器的逻辑，下篇文章将会为大家介绍Spring Cloud Gateway过滤器相关的内容。</p>\n<h3><a id="_354"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_362"></a>参考资料</h2>\n<p>http://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.0.RELEASE/single/spring-cloud-gateway.html</p>\n<p>https://www.jianshu.com/p/35b60946b8ce</p>\n<p>https://www.jianshu.com/p/03d42105f81f</p>\n<h2><a id="_371"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-gateway-predicate</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫一扫，支持下作者吧\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83792388', 'title': 'Spring Cloud Gateway初体验', 'readNum': '99073', 'commentNum': '37', 'publishTime': '2018-11-06 18:55:37', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/83792388<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h4><a id="SpringCloud_Spring_Boothttpswwwfangzhipengcomshare20171001resourcesharinghtml_5"></a><a href="https://www.fangzhipeng.com/share/2017/10/01/resource-sharing.html" rel="nofollow">点击获取SpringCloud 、Spring Boot视频</a></h4>\n<p>这篇文章讲述了如何简单地使用Spring Cloud Gateway，来源于Spring Cloud官方案例，地址https://spring.io/guides/gs/gateway 。</p>\n<h2><a id="_9"></a>简介</h2>\n<p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。本文首先用官方的案例带领大家来体验下Spring Cloud的一些简单的功能，在后续文章我会使用详细的案例和源码解析来详细讲解Spring Cloud Gateway.</p>\n<h2><a id="_13"></a>创建工程</h2>\n<p>本案例的的源码下载于<a href="https://github.com/spring-guides/gs-gateway.git">官方案例</a>，也可以在我的Github上下载。工程使用的Spring Boot版本为2.0.5.RELEASE，Spring Cloud版本为Finchley.SR1。</p>\n<p>新建一个工程，取名为sc-f-gateway-first-sight在工程的pom文件引用工程所需的依赖，包括spring boot和spring cloud，以及gateway的起步依赖spring-cloud-starter-gateway，代码如下：</p>\n<pre><code>   &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;Finchley.SR1&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>** 注：详细的pom文件依赖，可以见源码。**</p>\n<h2><a id="_46"></a>创建一个简单的路由</h2>\n<p>在spring cloud gateway中使用RouteLocator的Bean进行路由转发，将请求进行处理，最后转发到目标的下游服务。在本案例中，会将请求转发到http://httpbin.org:80这个地址上。代码如下：</p>\n<pre><code class="prism language-java">\n<span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> RouteLocator <span class="token function">myRoutes</span><span class="token punctuation">(</span>RouteLocatorBuilder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">&gt;</span> p\n            <span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"/get"</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">filters</span><span class="token punctuation">(</span>f <span class="token operator">-</span><span class="token operator">&gt;</span> f<span class="token punctuation">.</span><span class="token function">addRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">"http://httpbin.org:80"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    \n    <span class="token punctuation">}</span>\n</code></pre>\n<p>在上面的myRoutes方法中，使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种<strong>predicates</strong>和<strong>filters</strong>，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p>\n<p>上面创建的route可以让请求“/get”请求都转发到“http://httpbin.org/get”。在route配置上，我们添加了一个filter，该filter会将请求添加一个header,key为hello，value为world。</p>\n<p>启动springboot项目，在浏览器上http://localhost:8080/get，浏览器显示如下:</p>\n<pre><code class="prism language-json"><span class="token punctuation">{</span>\n  <span class="token string">"args"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> \n  <span class="token string">"headers"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"Accept"</span><span class="token punctuation">:</span> <span class="token string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span><span class="token punctuation">,</span> \n    <span class="token string">"Accept-Encoding"</span><span class="token punctuation">:</span> <span class="token string">"gzip, deflate, br"</span><span class="token punctuation">,</span> \n    <span class="token string">"Accept-Language"</span><span class="token punctuation">:</span> <span class="token string">"zh-CN,zh;q=0.9,en;q=0.8"</span><span class="token punctuation">,</span> \n    <span class="token string">"Cache-Control"</span><span class="token punctuation">:</span> <span class="token string">"max-age=0"</span><span class="token punctuation">,</span> \n    <span class="token string">"Connection"</span><span class="token punctuation">:</span> <span class="token string">"close"</span><span class="token punctuation">,</span> \n    <span class="token string">"Cookie"</span><span class="token punctuation">:</span> <span class="token string">"_ga=GA1.1.412536205.1526967566; JSESSIONID.667921df=node01oc1cdl4mcjdx1mku2ef1l440q1.node0; screenResolution=1920x1200"</span><span class="token punctuation">,</span> \n    <span class="token string">"Forwarded"</span><span class="token punctuation">:</span> <span class="token string">"proto=http;host=\\"localhost:8080\\";for=\\"0:0:0:0:0:0:0:1:60036\\""</span><span class="token punctuation">,</span> \n    <span class="token string">"Hello"</span><span class="token punctuation">:</span> <span class="token string">"World"</span><span class="token punctuation">,</span> \n    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"httpbin.org"</span><span class="token punctuation">,</span> \n    <span class="token string">"Upgrade-Insecure-Requests"</span><span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> \n    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"</span><span class="token punctuation">,</span> \n    <span class="token string">"X-Forwarded-Host"</span><span class="token punctuation">:</span> <span class="token string">"localhost:8080"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> \n  <span class="token string">"origin"</span><span class="token punctuation">:</span> <span class="token string">"0:0:0:0:0:0:0:1, 210.22.21.66"</span><span class="token punctuation">,</span> \n  <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"http://localhost:8080/get"</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<p>可见当我们向gateway工程请求“/get”,gateway会将工程的请求转发到“http://httpbin.org/get”，并且在转发之前，加上一个filter，该filter会将请求添加一个header,key为hello，value为world。</p>\n<p>注意HTTPBin展示了请求的header hello和值world。</p>\n<h2><a id="Hystrix_108"></a>使用Hystrix</h2>\n<p>在spring cloud gateway中可以使用Hystrix。Hystrix是 spring cloud中一个服务熔断降级的组件，在微服务系统有着十分重要的作用。<br>\nHystrix是 spring cloud gateway中是以filter的形式使用的，代码如下：</p>\n<pre><code class="prism language-java">   <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> RouteLocator <span class="token function">myRoutes</span><span class="token punctuation">(</span>RouteLocatorBuilder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        String httpUri <span class="token operator">=</span> <span class="token string">"http://httpbin.org:80"</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">&gt;</span> p\n                <span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"/get"</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">filters</span><span class="token punctuation">(</span>f <span class="token operator">-</span><span class="token operator">&gt;</span> f<span class="token punctuation">.</span><span class="token function">addRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span>httpUri<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">&gt;</span> p\n                <span class="token punctuation">.</span><span class="token function">host</span><span class="token punctuation">(</span><span class="token string">"*.hystrix.com"</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">filters</span><span class="token punctuation">(</span>f <span class="token operator">-</span><span class="token operator">&gt;</span> f\n                    <span class="token punctuation">.</span><span class="token function">hystrix</span><span class="token punctuation">(</span>config <span class="token operator">-</span><span class="token operator">&gt;</span> config\n                        <span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"mycmd"</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">setFallbackUri</span><span class="token punctuation">(</span><span class="token string">"forward:/fallback"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span>httpUri<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n</code></pre>\n<p>在上面的代码中，我们使用了另外一个router，该router使用host去断言请求是否进入该路由，当请求的host有“*.hystrix.com”，都会进入该router，该router中有一个hystrix的filter,该filter可以配置名称、和指向性fallback的逻辑的地址，比如本案例中重定向到了“/fallback”。</p>\n<p>现在写的一个“/fallback”的l逻辑：</p>\n<pre><code class="prism language-java">\n <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/fallback"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> Mono<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">fallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token string">"fallback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n</code></pre>\n<p>Mono是一个Reactive stream，对外输出一个“fallback”字符串。</p>\n<p>使用curl执行以下命令：</p>\n<pre><code> curl --dump-header - --header \'Host: www.hystrix.com\' http://localhost:8080/delay/3\n\n</code></pre>\n<p>返回的响应为：</p>\n<pre><code>fallback\n</code></pre>\n<p>可见，带hostwww.hystrix.com的请求执行了hystrix的fallback的逻辑。</p>\n<h2><a id="_167"></a>总结</h2>\n<p>本文通过官方的一个简单的案例，来讲解了spring cloud gateway的简单用法，在spring cloud gateway中有2个重要的概念<strong>predicates</strong>和<strong>filters</strong>，它们个将会在后续文章讲解。敬请期待。</p>\n<h2><a id="_172"></a>源码下载</h2>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-gateway-first-sight</p>\n<h3><a id="_177"></a>更多阅读</h3>\n<ul>\n<li><a href="https://blog.csdn.net/forezp/article/details/83792388">史上最简单的SpringCloud教程 | 第十四篇: Spring Cloud Gateway初体验</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/84926662">史上最简单的SpringCloud教程 | 第十五篇: Spring Cloud Gateway 之Predict篇</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/85057268">史上最简单的SpringCloud教程 | 第十六篇: Spring Cloud Gateway 之filter篇</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/85081162">史上最简单的SpringCloud教程 | 第十七篇: Spring Cloud Gateway 之限流篇</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/85210153">史上最简单的SpringCloud教程 | 第十八篇: spring cloud gateway之服务注册与发现</a></li>\n</ul>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/83042018', 'title': 'Kubernetes对象模型', 'readNum': '22745', 'commentNum': '1', 'publishTime': '2018-10-13 20:44:20', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/83042018<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h2><a id="Kubernetes_4"></a>Kubernetes对象</h2>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/kubernetes/2018/10/13/k8s-object-model.html" rel="nofollow">https://www.fangzhipeng.com/kubernetes/2018/10/13/k8s-object-model.html</a></strong></p>\n<p>在之前的文章已经讲到了很多Kubernets对象，包括pod，service,deployment等等。Kubernets对象是一种持久化，表示集群状态的实体。它是一种声明式的意图的记录，一般使用yaml文件描述对象，它使用Kubernetes对象来表示集群的状态，通过API/kubectl管理Kubernetes对象。</p>\n<p><img src="https://img-blog.csdn.net/20181013204337458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>\n<h3><a id="nameuid_12"></a>name和uid</h3>\n<p>在Kubernetes对象模型中，使用了name和uid作为对象的唯一标识，其中name在同一种对象中是唯一的，在不同类型对象可以是相同的；uid是唯一标识的。</p>\n<p>在API中对象的访问路径：/api/{version}/namespaces/{namespaxe/{object-kind}/name，比如：/api/v1/namespace/default/pods/hello-kubernetes</p>\n<p>在Kubernetes集群的整个生命周期内创建的每个对象实例都具有不同的UID.</p>\n<h3><a id="Namespace_21"></a>Namespace(名字空间)</h3>\n<p>Namesapce，不仅仅是一个属性，本身也是一个object。</p>\n<ul>\n<li>Namesapce:用于将物理集群划分为多个虚拟集群。</li>\n<li>Namespace间完全隔离，因此也常被用来隔离不同的用户以及权限。</li>\n<li>Kubernetes内置了三个Namesapces:default、kube-system和kube-public，Node和PersistentVolume不属于任何namespace。</li>\n</ul>\n<h3><a id="Label_29"></a>Label（标签）</h3>\n<p>Label用于建立集群对象之间的灵活、松耦合的多维关联关系。</p>\n<ul>\n<li>一个label是一个键-值对，其中的key、value均由用户自己定义。</li>\n<li>lable可以附着在任何对象上，每个对象也可以有任意个标签。标签可在对象定义时附加上，也可以通过命令动态管理标签。</li>\n<li>label可以将有组织目的的结构映射到集群对象上，从而形成一个与现实世界管理结构同步对应松耦合的、多维的对象管理结构。</li>\n</ul>\n<p>通过lable selector 查询和筛选建立对象间的关系的。</p>\n<p><img src="https://img-blog.csdn.net/20181013204353463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>\n<p>如上图所示，有两个service1和 service2，对应的pod有标签release:stable和标签release:rc-1，通过selector，就可以筛选出相应的标签的pod。而pod由通过nodeselector筛选出不同环境的node。</p>\n<h3><a id="Annotations_42"></a>Annotations</h3>\n<p>Annotations:可以将任意非标识性元数据附加到对象上。</p>\n<ul>\n<li>Annotations也是以键值对的形式呈现。</li>\n<li>工具和库可以检索并使用这些Annotations元数据</li>\n<li>将数据作为Annotations附着在对象上，有利于创建一些用于部署、管理和做内部检查的共享工具和客户端。</li>\n</ul>\n<h2><a id="Kubernetes_49"></a>Kubernetes对象分类</h2>\n<p>常用的对象分类有以下几种：</p>\n<ul>\n<li>workload类，即工作负载类\n<ul>\n<li>pod</li>\n<li>controller</li>\n<li>deployment</li>\n<li>stateful</li>\n<li>daemonset</li>\n<li>job</li>\n</ul>\n</li>\n<li>discovery&amp;loadbalance类，与服务相关的对象\n<ul>\n<li>service</li>\n<li>endpoint</li>\n<li>ingress</li>\n</ul>\n</li>\n<li>config&amp;storage，向应用初始化配置话信息\n<ul>\n<li>configmap</li>\n<li>secret</li>\n<li>volume</li>\n<li>persistentVolumeClaim</li>\n</ul>\n</li>\n<li>cluster，集群类对象\n<ul>\n<li>Node</li>\n<li>namespace</li>\n<li>persitenceVolume</li>\n<li>clusterRole</li>\n<li>ClusterRoleVindeing</li>\n<li>ResoruceQuota</li>\n</ul>\n</li>\n</ul>\n<h3><a id="pod_77"></a>工作负载，以pod为中心</h3>\n<p>pod是一个有特定关系的容器集合。</p>\n<ul>\n<li>Pod是集群中可以创建和部署的最小且最简单的Kubernetes对象的单元。</li>\n<li>Pod也是一种封装。它封装了应用容器，存储资源、独立的网络IP以及决定容器如何运行的策略选项。</li>\n<li>每个pod中预置了一个Pause容器，其namespace、IPC资源、网络和存储资源被pod内其它容器共享。Pod中的所有容器紧密协作，并且作为一个整体被管理、调度和运行。</li>\n</ul>\n<h4><a id="pod_84"></a>pod的生命周期</h4>\n<p>pod是一个非持久化实体。</p>\n<p><img src="https://img-blog.csdn.net/20181013204407932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>\n<p>如图所示，pod有如下几个生命周期：</p>\n<ul>\n<li>pending，即挂起，即pod对象已经被kubernetes所接受，但有一个或者多个pod尚未创建。</li>\n<li>running，运行中，pod已经绑定到node上，所有pod中所有容器已经创建</li>\n<li>succeed，成功状态，pod的所有的容器已经成功终止。</li>\n<li>failed，失败状态，即有最少又一个容器正常退出。</li>\n</ul>\n<h3><a id="service_97"></a>service</h3>\n<p>pod是一个非持久化的实体，pod随时都有可能被销毁掉或者重新创建，所以pod的所在节点是不确定的，为了防止因pod的提供服务不确定性而采用了地址唯一的service用来提供服务，service可以通过负载均衡的调用它背后的pod对象，从而提供稳定的服务。</p>\n<p>servie是与云原生应用中“微服务”概念一一对应。</p>\n<ul>\n<li>kubernetes集群为每一个service分配一个集群唯一的IP地址，在 service的生命周期内，该ip地址不变；在内部DNS指出下，轻松实现服务发现机制。</li>\n<li>service通过label selector关联到实际支撑业务运行的pod上，并通过集群内置的服务负载均衡分发到后端pod上。</li>\n<li>通过nodeport或者设置loadbalance机制实现集群外部对service的访问。</li>\n</ul>\n<h3><a id="controllers_107"></a>controllers</h3>\n<p>controller是kubernetes的核心对象之一。</p>\n<ul>\n<li>controller用于保证集群内一组pod能始终按照某种期望的状态正常运行</li>\n<li>状态包括：Pod副本数量、节点选择、资源约束、持久化数据运维等</li>\n<li>kubernetes支持多种controller，常用的deployment、replicaseet、statefulset、daemonset等。</li>\n</ul>\n<h3><a id="ReplicaSet_115"></a>ReplicaSet</h3>\n<p>ReplicaSet：确保健康Pod的副本始终满足用户定义的数量。</p>\n<ul>\n<li>前身是ReplicationController()rc</li>\n<li>相比rc，增加了集合式label selector的支持。</li>\n<li>支持单独使用，但更多隐藏在Deployment控制器后面，由deployment自动管理。</li>\n</ul>\n<h3><a id="Deployment_123"></a>Deployment</h3>\n<p>Deployment:为pod和 ReplicaSet提供声明式的定义。</p>\n<ul>\n<li>用户在deployment文件中描述期望状态，Deployment Controller就会自动将Pod和Replica Set的实际状态改变到期望状态。</li>\n<li>Deployment支持Pod的滚动更新，并自动管理背后的ReplicaSet</li>\n<li>Deployment支持将Pod滚动到任意版本。</li>\n</ul>\n<h3><a id="StatefulSet_131"></a>StatefulSet</h3>\n<p>StatefulSet:提供对有状态应用的部署和控制的支持，1.9版本GA，正式毕业。可以用于生产环境中。</p>\n<ul>\n<li>使用场景：文档的持久化存储，稳定的网络标志，有序部署有序扩展，有序收缩有序删除，有序自动滚动升级等。</li>\n<li>Pod的存储必须由PersistentVolume Provisioner根据请求的Storage Class 进行配置，或由管理员预先配置好。</li>\n<li>考虑数据安全性，伸缩或删除StatefulSey不会删除关联的存储；另外StartefulSet目前要求Headless Service 负责Pod的网络身份，用户有责任创建此服务。</li>\n</ul>\n<h3><a id="DaemonSet_139"></a>DaemonSet</h3>\n<p>保证在每个Node上都运行一个Pod副本。</p>\n<ul>\n<li>适用于系统Daemon程序、系统跟踪、日志收集等</li>\n<li>Kubernetes1.6之后，可设置更新策略：支持滚动更新</li>\n<li>可指定Node：nodeSelector、nodeAffinity、podAffinity</li>\n</ul>\n<h3><a id="ConfigMap_147"></a>ConfigMap</h3>\n<p>常用来向pod提供非敏感的配置信息。</p>\n<ul>\n<li>ConfigMap用于保存配置数据的键值对，可以用来保存单个，也可以用来保存配置文件。</li>\n<li>ConfigMap可以使用命令行基于字面值、文件或者目录来创建或者通过configmap对象定义文件创建。</li>\n<li>ConfigMap可以通过三种形式在pod中使用：环境变量、容器命令行参数货以文件形式通过数据卷插件挂载到pod中。</li>\n</ul>\n<h3><a id="Secret_155"></a>Secret</h3>\n<p>secret解决的事集群内密码、token、密钥等敏感数据的配置问题。</p>\n<ul>\n<li>常用于与ServiceAccount关联，存储在tmpfs文件系统中，Pod删除后sercret文件也会对应删除</li>\n<li>支持opaque，kubernetes.io/Service Account,kubernetes.io/dockerconfigjson三种类型。</li>\n</ul>\n<h2><a id="_162"></a>总结</h2>\n<p>本文主要对Kubernetes的对象模型进行一个初略的讲解。后续文章会对重点对象模型进行一个详细的讲解或者实战的演示。</p>\n<h3><a id="_167"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/82832980', 'title': 'Kubernetes组件与架构', 'readNum': '20055', 'commentNum': '0', 'publishTime': '2018-09-24 22:21:02', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/82832980<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/kubernetes/2018/09/30/k8s-basic1.html" rel="nofollow">https://www.fangzhipeng.com/kubernetes/2018/09/30/k8s-basic1.html</a></strong></p>\n<p>Kubernetes是一个可移植，可扩展的开源平台，用于管理容器化工作负载和服务，有助于声明性配置和自动化。 它拥有庞大，快速发展的生态系统。 Kubernetes服务，支持和工具广泛可用。</p>\n<p>谷歌在2014年开放了Kubernetes项目.Kubernetes建立在谷歌大规模运行生产工作量的十五年经验基础上，结合了社区中最佳的创意和实践。</p>\n<h2><a id="K8s_11"></a>K8s架构图</h2>\n<p><img src="https://img-blog.csdnimg.cn/20190601115928267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>Kubernetes是由一组节点组成，这些节点可以是物理主机，也可以是虚拟机。Kubernetes平台运行这些节点之上，构成了集群。Kubernetes集群分为两种Node，一种Master Node和用于实际部署的Pod的工作Node。一个集群往往由多个Master Node，这几个Master Node控制着整个集群的所有Node。</p>\n<p>master节点包含以下的组件：</p>\n<ul>\n<li>etcd 用于存储集群中所有对象产生的数据</li>\n<li>api server 唯一可以和etcd 数据库交互的组件，通过通过kubectl调用api server 的api。</li>\n<li>controller manager 管理资源对象</li>\n<li>schedualer 调度Node，发布Pod</li>\n</ul>\n<p>Node节点包含以下的组件</p>\n<ul>\n<li>kubelete  用于和Master节点交互，运行了node上的Service进程</li>\n<li>kube-proxy 负责网络相关，用于服务的负载</li>\n</ul>\n<h2><a id="Master_30"></a>Master组件</h2>\n<p>Master节点上集群的大脑，是集群逻辑上的控制中心。</p>\n<p>Master组件起到控制整个集群的作用。 Master组件做出关于群集的全局决策（例如调度），以及检测和响应群集事件（当rc控制器的’副本’字段不满足时启动新的pod）。</p>\n<p>Master组件可以在群集中的任何计算机上运行。 但是，为简单起见，通常Mater组件在同一台计算机上运行。</p>\n<p>下图是K8s的master节点的架构图，从图中可以看出，master节点爆款四个组件，分别为Etcd、Api Server、kube-scheduler、Controller。它们之间互相协作，共同控制着k8s集群。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZmFuZ3poaXBlbmcuY29tL2ltZy9qaWFuc2h1LzIyNzk1OTQtYTEyMmU4Y2JhODAwNDI0ZS5wbmc?x-oss-process=image/format,png" alt="1.png"></p>\n<h3><a id="etcd_43"></a>etcd</h3>\n<p>etcd是Coreos开源的（Apache 2.0协议）一个分布式键值存储数据库，它提供了一种在一组机器上存储数据的可靠方法。 etcd采用了master-slave架构，在网络分区期间优雅地处理Leader选举，并且可以容忍机器故障，包括Leader。</p>\n<p>CoreOs另外开源了CoreDns组件，也是一个对于K8s非常的重要的组件，这在后续文章会详细介绍。</p>\n<p>etcd是一致性高和高可用的键值存储，用作Kubernetes的所有群集数据的存储，包括各种K8s对象和k8s状态等数据。</p>\n<h3><a id="Api_Server_52"></a>Api Server</h3>\n<p>Api Server 是唯一可以操作etcd 数据库的组件，并提供了认证、授权等机制。它严格遵守了REST规范，去操作这些资源，具有CRUD特性。它是Kubernetes控制的前端工程，它能够水平扩展，可以通过部署多个实例来达到高可用的目的。</p>\n<h3><a id="kubescheduler_57"></a>kube-scheduler</h3>\n<p>通过API Server的watch接口监听新建Pod副本信息，并通过算法为该pod选择一个合适的node。调度器可用选择合适的策略，策略的考虑包括个人和集体资源的情况，软件、硬件条件的影响，亲和性和反亲和性的规范等因素。调度器是可插拔的，并且我们期待支持多集群的调度，未来甚至希望可以支持用户自定义的调度器。</p>\n<h3><a id="controllermanager_62"></a>controller-manager</h3>\n<p>集群内各种资源controller 的核心管理者。针对于每一种具体的资源，都有相应的Controller，保证其下管理的每个Controller所对应的资源始终处于“期望的状态”。</p>\n<p>从逻辑上讲，每个控制器都是一个单独的过程，但为了降低复杂性，它们都被编译成单个二进制文件并在单个进程中运行。</p>\n<p>这些控制器包括：</p>\n<p>Node controller：负责在节点出现故障时注意和响应。<br>\nReplication Controller：负责为系统中的Replication Controller对象维护正确数量的pod。<br>\nEndpoint Controller：填充Endpoint Controller象（即，连接服务和窗格）。<br>\nService Account &amp; Token Controllers：为新的命名空间创建默认帐户和API访问令牌。</p>\n<h2><a id="Node_75"></a>Node组件</h2>\n<p>Node是K8s集群中真正的工作负载节点，K8s集群由多个Node共同承担工作负载，pod被分配到某个具体的node上执行。k8s通过node controller对node资源进行管理。支持动态在集群中添加或删除node。</p>\n<h3><a id="kubelet_80"></a>kubelet</h3>\n<p>它位于集群中每个 node上非容器形式的服务进程组件，是Master和node之间的桥梁。处理Master下发到本Node上的pod创建、启停等管理任务，向API server注册Node信息。监控本Node上容器和节点资源情况，并定期向Master汇报节点资源占用情况。它还会向Master汇报容器运行的健康情况。</p>\n<h3><a id="Kubeproxy_85"></a>Kube-proxy</h3>\n<p>Service抽象概念的实现，将到service的请求按策略（负载均衡算法分发到后端的pod ）上，默认使用iptables mode实现；支持nodeport模式，实现从外部访问集群内的service。</p>\n<h2><a id="_89"></a>总结</h2>\n<p>kubernetes组件由两类节点组成，分别为master和node。</p>\n<p>其中master组件是控制整个集群大脑，它包括apiserver、scheduler、controller manager、etcd组件。apiserver为外部控制集群提供了REST API，并提供了安全机制；etcd是k8s记录各种资源的唯一数据库，只有api server能够直接访问;controller manager用来管理controller，保证了每种资源的正常工作；schedula是用来调度pod 到具体的节点。</p>\n<p>而node节点包含了2个组件，分别为kubelete和kubeproxy，kubelete是pod管家，管理着pod的生命周期，与此同时与api server保持联系，实时上报pod的数据；kubeproxy组件实现了 service的抽象，使应用能够被访问。</p>\n<p>由此可见,kubernetes集群是由众多的节点组成，每一个节点又有k8s的组件，这些组件相互协作，共同维护，保证集群的正常运行。</p>\n<h2><a id="_99"></a>参考资料</h2>\n<p>书籍《k8s权威指南》</p>\n<p>https://kubernetes.io/docs/concepts/overview/components/#master-components</p>\n<p>https://www.kubernetes.org.cn/kubernetes%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84</p>\n<p>https://www.imooc.com/learn/978</p>\n<p>关注我的公众号,精彩内容不能错过！</p>\n<h3><a id="_111"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://www.fangzhipeng.com/img/avatar.jpg" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:28 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/82730382', 'title': '使用Kubespray部署Kubernetes集群', 'readNum': '22858', 'commentNum': '2', 'publishTime': '2018-09-16 22:09:41', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/82730382<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/kubernetes/2018/09/15/kubespray-istl.html" rel="nofollow">https://www.fangzhipeng.com/kubernetes/2018/09/15/kubespray-istl.html</a></strong></p>\n<p>Kubespray是Google开源的一个部署生产级别的Kubernetes服务器集群的开源项目，它整合了Ansible作为部署的工具。项目地址：https://github.com/kubernetes-incubator/kubespray</p>\n<h2><a id="_8"></a>部署历程</h2>\n<p>目前为止，对于Kubernetes集群的部署，我只谈的上是一个入门者，涉及到了众多的运维知识，对于一个开发来说，确实挺难的。万事开头难，好事多磨，经过一个多星期的反复尝试，终于搭建好了。对比市面上的部署方式，主流的有三种方式。一是完全手动部署，非常的繁琐，容易部署。二是采用kubeAdmin开源项目进行部署，这个也是谷歌官方开源的一个项目。三是，采用kubeSpray进行部署。我的理念是有好的工具当然是用好工具，所以手动部署是不可能的，完全排除，所以Kubeadmin和KubeSpray。而我对Ansibe这个运维组件兴趣非常的大，所以我最终选择了KubeSpray进行了部署。</p>\n<p>部署的工程是非常艰难的，在我决定搞Kubernetes之时，为了学习不难么枯燥和孤独，我专门组建了一个群，找了一些朋友一起来学习和交流，采用的方式是大家一起学习，一起写文档，一起交流，另外有主机的出主机。所以，一开始的主机是几个朋友自己的主机，不在一个局域网内，计算机操作系统也不太一样，这为后面的部署带来了一个大坑。另外由于国内的屏蔽了谷歌的网络，导致谷歌的相关镜像下载不下来，这也是一个坑。</p>\n<p>坑点1，不在一个局域网不能部署Kubernetes？我专门打电话问了阿里云，客户说不可以，是不是真的不可以，我是不确定的。另外集群的型号不同和操作系统不同也会导致失败。</p>\n<p>坑点2，长城屏蔽了谷歌的镜像，所以我刚开始是根据谷歌的镜像在阿里云镜像仓库一顿搜索，导致Kubernetes各个版本组件不兼容，出现了问题。</p>\n<p>现在我也这篇文章来详细讲解我的部署过程，供其他人参考，如果有其他人想加入我们的Kubernetes兴趣群，加我微信miles02和我联系。</p>\n<h2><a id="_20"></a>主机相关</h2>\n<p>主机需要在同一局域网内？所以我们重新租了三台机器，进行了操作。现在列举主机相关的信息如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>主机</th>\n<th>系统版本</th>\n<th>配置</th>\n<th>ip</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ansible</td>\n<td>CentOS  7.2</td>\n<td>1核1G</td>\n<td>172.31.84.154</td>\n</tr>\n<tr>\n<td>Mater、Node</td>\n<td>CentOS  7.2</td>\n<td>2核2G</td>\n<td>172.31.84.155</td>\n</tr>\n<tr>\n<td>Node</td>\n<td>CentOS  7.2</td>\n<td>2核2G</td>\n<td>172.31.84.156</td>\n</tr>\n</tbody>\n</table><p>Ansible那台主机使用KubeSpray进行部署，这台机器不做Kubernetes相关集群的部署。另外2台机器，一台既作为Master，又作为Node，另外一台是一个Node。</p>\n<p>本次部署，使用的KubeSpray版本为v2.1.2。</p>\n<h2><a id="MasterNode_35"></a>Master、Node节点的操作</h2>\n<p>因为本次使用KubeSpray操作部署，所以所有的主机都需要关闭防火墙等相关的操作。</p>\n<p>所以的主机都需要关闭selinux，执行的命令如下：</p>\n<pre><code>setenforce 0\nsed -i --follow-symlinks \'s/SELINUX=enforcing/SELINUX=disabled/g\' /etc/sysconfig/selinux\n\n</code></pre>\n<p>防火墙和网络设置，所有的主机都执行以下命令：</p>\n<pre><code>systemctl stop firewalld\nmodprobe br_netfilter\necho \'1\' &gt; /proc/sys/net/bridge/bridge-nf-call-iptables\nsysctl -w net.ipv4.ip_forward=1\n\n</code></pre>\n<p>这样与Kubernetes集群相关的集群设置就完毕了。</p>\n<h2><a id="Ansibe_59"></a>Ansibe主机操作</h2>\n<p>Ansibe主机也需要关闭selinux和关闭防火墙以及网络设置，同上面。</p>\n<h3><a id="Ansible_63"></a>在Ansible主机上设置免密码操作其它主机</h3>\n<p>首先生成ssh公钥和私钥。</p>\n<pre><code>ssh-keygen\n\n</code></pre>\n<p>按三次回车。</p>\n<p>建立ssh通道，将秘钥分发给master主机。</p>\n<pre><code>ssh-copy-id root@172.31.84.155 \nssh-copy-id root@172.31.84.156\n\n</code></pre>\n<h3><a id="Ansible_81"></a>安装Ansible</h3>\n<p>安装ansible和jinja2，安装命令如下。</p>\n<pre><code>\nsudo yum install epel-release\nsudo yum install ansible\n\neasy_install pip\npip2 install jinja2 --upgrade\n\n\n</code></pre>\n<p>如果执行 pip2 install jinja2–upgrade 提示升级，则升级，再执行一次命令。</p>\n<h3><a id="python36_100"></a>安装python36</h3>\n<pre><code>sudo yum install python36 -y \n\n</code></pre>\n<h3><a id="AnsibleKubeSpray_107"></a>在Ansible集群上安装KubeSpray</h3>\n<p>在ansible机器上下载KubeSpray代码，并解压，执行如下的命令：</p>\n<pre><code>wget https://github.com/kubernetes-incubator/kubespray/archive/v2.1.2.tar.gz\ntar -zxvf v2.1.2.tar.gz\nmv kubespray-2.1.2 kuberspray\n\n</code></pre>\n<h2><a id="KubeSpray_119"></a>安装KubeSpray所需的包</h2>\n<p>执行如下命令：</p>\n<pre><code>cd kubespray\npip install -r requirements.txt\n</code></pre>\n<h2><a id="_128"></a>定义集群</h2>\n<p>执行以下的命令。</p>\n<pre><code>IP=(172.31.84.155 172.31.84.156)\nCONFIG_FILE=./kubespray/inventory/inventory.cfg python36 ./kubespray/contrib/inventory_builder/inventory.py ${IP[*]}\n</code></pre>\n<p>vim ~./kubespray/inventory/inventory.cfg</p>\n<pre><code>[all]\nnode1    ansible_host=172.31.84.156 ip=172.31.84.156\nnode2    ansible_host=172.31.84.155 ip=172.31.84.155\n\n[kube-master]\nnode1\n\n[kube-node]\nnode1\nnode2\n\n[etcd]\nnode1\n\n[k8s-cluster:children]\nkube-node\nkube-master\n\n[calico-rr]\n\n[vault]\nnode1\n</code></pre>\n<h3><a id="_163"></a>替换镜像</h3>\n<p>在kuberspay源码源代码中搜索包含 gcr.io/google_containers 和 quay.io 镜像的文件，并替换为我们之前已经上传到阿里云的进行，替换脚步如下：</p>\n<pre><code>grc_image_files=(\n./kubespray/extra_playbooks/roles/dnsmasq/templates/dnsmasq-autoscaler.yml\n./kubespray/extra_playbooks/roles/download/defaults/main.yml\n./kubespray/extra_playbooks/roles/kubernetes-apps/ansible/defaults/main.yml\n./kubespray/roles/download/defaults/main.yml\n./kubespray/roles/dnsmasq/templates/dnsmasq-autoscaler.yml\n./kubespray/roles/kubernetes-apps/ansible/defaults/main.yml\n)\n\n</code></pre>\n<p>在执行</p>\n<pre><code>for file in ${grc_image_files[@]} ; do\n    sed -i \'s/gcr.io\\/google_containers/registry.cn-hangzhou.aliyuncs.com\\/szss_k8s/g\' $file\ndone\n</code></pre>\n<p>同理替换quay_image：</p>\n<pre><code>quay_image_files=(\n./kubespray/extra_playbooks/roles/download/defaults/main.yml\n./kubespray/roles/download/defaults/main.yml\n)\n\n</code></pre>\n<p>再执行：</p>\n<pre><code>for file in ${quay_image_files[@]} ; do\n    sed -i \'s/quay.io\\/coreos\\//registry.cn-hangzhou.aliyuncs.com\\/szss_quay_io\\/coreos-/g\' $file\n    sed -i \'s/quay.io\\/calico\\//registry.cn-hangzhou.aliyuncs.com\\/szss_quay_io\\/calico-/g\' $file\n    sed -i \'s/quay.io\\/l23network\\//registry.cn-hangzhou.aliyuncs.com\\/szss_quay_io\\/l23network-/g\' $file\ndone\n\n</code></pre>\n<h3><a id="ansible_playbookKubernetes_206"></a>使用ansible playbook部署Kubernetes集群</h3>\n<p>以上全部完成，执行安装操作：</p>\n<pre><code>cd kubespray\nansible-playbook -i inventory/inventory.cfg cluster.yml -b -v --private-key=~/.ssh/id_rsa\n\n</code></pre>\n<p>大约过了10分钟，如果顺利的话，集群会成功搭建。</p>\n<h3><a id="_218"></a>验证几点是否成功</h3>\n<p>登录Kubernete集群的Mater集群，执行如下命令：</p>\n<pre><code>kubectl get no\n\n</code></pre>\n<p>控制台打印出了正确的Kubernetes节点信息，则安装成功。</p>\n<h3><a id="_228"></a>增加节点</h3>\n<pre><code>cd kubespray\nansible-playbook -i inventory/inventory.cfg cluster.yml -b -v --private-key=~/.ssh/id_rsa --limit node3\n\n</code></pre>\n<h2><a id="_236"></a>遇到问题卸载</h2>\n<p>ansible执行卸载操作：</p>\n<pre><code>\nansible-playbook -i inventory/mycluster/hosts.ini reset.yml\n\n</code></pre>\n<p>安装失败清理Kubernetes机器</p>\n<pre><code>\nrm -rf /etc/kubernetes/\nrm -rf /var/lib/kubelet\nrm -rf /var/lib/etcd\nrm -rf /usr/local/bin/kubectl\nrm -rf /etc/systemd/system/calico-node.service\nrm -rf /etc/systemd/system/kubelet.service\nsystemctl stop etcd.service\nsystemctl disable etcd.service\nsystemctl stop calico-node.service\nsystemctl disable calico-node.service\ndocker stop $(docker ps -q)\ndocker rm $(docker ps -a -q)\nservice docker restart\n\n</code></pre>\n<h3><a id="_265"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_274"></a>参考资料</h2>\n<p>参考了一下的文章：</p>\n<p>https://github.com/kubernetes-incubator/kubespray</p>\n<p>https://mp.weixin.qq.com/s/-SXuXhY7KIFl1zYvVT93ZA</p>\n<p>https://blog.csdn.net/zhuchuangang/article/details/77712614</p>\n<ul>\n<li>关注我的公众号,精彩内容不能错过！</li>\n</ul>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIyNzk1OTQtMDgwNTc0OGQ5MmJiYTAzMy5qcGc?x-oss-process=image/format,png" alt="forezp.jpg"></p>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:28'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/82563339', 'title': 'Kubernetes资料收集', 'readNum': '19268', 'commentNum': '0', 'publishTime': '2018-09-09 22:31:00', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/82563339<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>个人博客纯净版：https://www.fangzhipeng.com/archives.html</p>\n<h2><a id="_7"></a>官方文档</h2>\n<p>https://kubernetes.io/docs/home/?path=users&amp;persona=app-developer&amp;level=foundational</p>\n<h2><a id="_12"></a>视频资料</h2>\n<p><a href="https://www.ibm.com/developerworks/community/wikis/home?lang=zh#!/wiki/W30b0c771924e_49d2_b3b7_88a2a2bc2e43/page/Kubernetes%E7%B3%BB%E5%88%97" rel="nofollow"><strong>IBM视频（强烈推荐）</strong></a></p>\n<p><a href="https://www.imooc.com/learn/978" rel="nofollow">慕课网入门视频</a></p>\n<h2><a id="_18"></a>入门资料</h2>\n<ul>\n<li><a href="https://blog.csdn.net/forezp/article/details/82454600">docker入门</a></li>\n<li><a href="https://blog.csdn.net/forezp/article/details/82563153">minikube安装</a></li>\n</ul>\n<h3><a id="_23"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<ul>\n<li>关注我的公众号,精彩内容不能错过！</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/82563153', 'title': '如何在Mac中创建MiniKube', 'readNum': '21088', 'commentNum': '0', 'publishTime': '2018-09-09 22:12:17', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/82563153<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版<a href="https://www.fangzhipeng.com/kubernetes/2018/09/16/minikube-istl.html" rel="nofollow">https://www.fangzhipeng.com/kubernetes/2018/09/16/minikube-istl.html</a></strong></p>\n<p>这篇文章介绍了如何在Mac系统中创建MiniKube。</p>\n<h2><a id="MiniKube_9"></a>什么事MiniKube?</h2>\n<p>Minikube是一个工具，可以在本地轻松运行Kubernetes。 Minikube在笔记本电脑的VM中运行单节点Kubernetes集群，供希望尝试Kubernetes或日常开发的用户使用。</p>\n<p>项目地址：https://github.com/kubernetes/minikube</p>\n<h2><a id="_15"></a>搭建</h2>\n<p>在官方项目中，在搭建MiniKube的过程中，需要使用到谷歌官方的镜像，由于某些原因，镜像下载不下来。如果使用VPN，可以根据官方的项目搭建，本文基于阿里社区开源的Minikube进行搭建。</p>\n<h3><a id="Docker_19"></a>安装Docker</h3>\n<p>Mac电脑安装Docker，下载地址https://download.docker.com/mac/stable/Docker.dmg ，下载完成安装即可。</p>\n<p>安装成功，执行docker -version命令，确认。</p>\n<h3><a id="virtualbox_25"></a>安装virtualbox</h3>\n<p>下载地址：https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18-124319-OSX.dmg</p>\n<p>下载成功安装即可。</p>\n<h3><a id="_kubeCtl_31"></a>安装 kubeCtl组件</h3>\n<p>在mac终端运行以下命令：</p>\n<pre><code> brew install kubernetes-cli\n \n</code></pre>\n<p>安装成功，执行</p>\n<pre><code>  kubectl version\n</code></pre>\n<p>###安装 minikuke</p>\n<p>在终端执行以下命令：</p>\n<pre><code> curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.28.1/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/\n \n</code></pre>\n<p>下载完成后，执行以下命令：</p>\n<pre><code> \n minikube start --registry-mirror=https://registry.docker-cn.com\n \n</code></pre>\n<p>如果执行失败，多半是镜像下载不下来，会有提示，根据提示请手动使用镜像，重新启动。</p>\n<p>如果实在执行失败，重新来，执行以下命令：</p>\n<pre><code> minikube delete\n \n rm ~/.minikue\n \n</code></pre>\n<p>启动成功后，可以执行：</p>\n<pre><code> kubectl get nodes\n</code></pre>\n<p>执行</p>\n<pre><code>minikube dashboard\n</code></pre>\n<p>会自动打开浏览器显示的界面如下：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTk4MWFlNzdhNmI3NDg1MjcucG5n?x-oss-process=image/format,png" alt="WX20180909-214913@2x.png"></p>\n<h2><a id="_90"></a>参考资料</h2>\n<p>https://yq.aliyun.com/articles/221687?spm=a2c4e.11153940.blogcont221687.286.7dd57733A8RwNk&amp;p=2#comments</p>\n<p>https://kubernetes.io/docs/tasks/tools/install-kubectl/</p>\n<p>https://github.com/kubernetes/minikube</p>\n<h3><a id="_98"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<ul>\n<li>关注我的公众号,精彩内容不能错过！</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/82454600', 'title': 'Docker入门', 'readNum': '23140', 'commentNum': '1', 'publishTime': '2018-09-06 09:52:17', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/82454600<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/docker/2018/09/12/docker-action.html" rel="nofollow">https://www.fangzhipeng.com/docker/2018/09/12/docker-action.html</a></strong></p>\n<h3><a id="Docker_7"></a>Docker简介</h3>\n<p>Docker是容器技术的一个代表，容器的技术从本质上讲是程序打包、隔离的技术，不是一个很新的技术，核心的技术在内核中已经存在很久了。但容器技术被大众所用，变成这么流行，这么火爆的技术是因为Docker。Docker在13年被开源，变得越来越流行，Docker在微服务领域、云计算领域有着广泛的应用。这是为什么呢。任何技术的流行可能的原因有两点，一是能够解决大家的痛点，二是能够能够适应潮流.docker理顺了软件包的问题，有了docker运行一个镜像是非常容易的，不需要做各种环境的配置。</p>\n<p>什么是Docker？官方的解释如下：</p>\n<blockquote>\n<p>an open resource project to pack,ship and run any application as a lightweght containner.</p>\n<p>Build, Manage and Secure Your Apps Anywhere. Your Way.</p>\n</blockquote>\n<p>可以粗糙的认为是一个轻量级的虚拟机，因为在某种程度上来讲，docker和虚拟机是有非常多的相似点。它们都是讲应用放在相对独立的环境里，调度主机的内核来运行。但Docker确实不是虚拟机，这张图是虚拟机和Docker的对比图，左边这张图是虚拟机，右边是Docker，左边的虚拟机子宿主机上有一层Hypervisor虚拟层，虚拟出了硬件和设备，在虚拟层上面会安装GuestOs，然后再运行各种各样的程序，docker 是不一样的，docker是不一样的，它在宿主机上有一个Docker engine，然后再运行各种各样的应用程序。因为它没有虚拟机层，它会比虚拟机轻量很多，包括程序运行速度也非常的快。</p>\n<p>Docker为何这么火？天时地利人和。Docker 不是什么新技术，Docker的镜像版本管理是其火的根本原因。</p>\n<h3><a id="Docker_21"></a>Docker安装</h3>\n<p>Centos安装：</p>\n<pre><code class="prism language-text">安装：\nyum search docker\nyum -y install docker-io\n\n查看基本信息：docker info \n启动：servie start docker\n</code></pre>\n<h3><a id="Docker_34"></a>Docker架构</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190601120129660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>从这张图可以看出，Docker的架构是非常简答的。中间是Host，上面装了一个Docker daemon的守护进程，守护进程应用做很多docker的操作，那么谁让 docker daemon来做这些操作呢，是最左边client，比如我们再终端操作输入dokcer的命令，客户端讲命令发送给docker守护进程，让docker去做一些操作，比如从最右边的镜像仓库拉取镜像到宿主机上，然后在宿主机上跑镜像，运行容器。</p>\n<h3><a id="Docker_41"></a>常见的Docker命令</h3>\n<pre><code class="prism language-text">docker run -p 80:80 -d  docker.io/nginx\ndocker cp index.html containerId://usr/share/nginx/html\ndocker exec -it containeId /bin/bash\ndocker images\ndocker ps [-a -q]\ndocker stop containerId\ndocker rm containerId\ndocker rmi imagesId\n\ndocker commit –m ’msg’ containerId [name] \ndocker build\ndocker pull\ndocker push\ndocker login\n</code></pre>\n<h3><a id="Dockerfile_60"></a>Dockerfile</h3>\n<h4><a id="_62"></a>常用命令</h4>\n\n<table>\n<thead>\n<tr>\n<th align="left">命令</th>\n<th align="left">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">WORKDIR</td>\n<td align="left">RUN ENTRYPINT CMD执行的工作目录</td>\n</tr>\n<tr>\n<td align="left">ENV</td>\n<td align="left">添加环境变量</td>\n</tr>\n<tr>\n<td align="left">ADD</td>\n<td align="left">添加文件，会解压压缩包</td>\n</tr>\n<tr>\n<td align="left">COPY</td>\n<td align="left">复制文件</td>\n</tr>\n<tr>\n<td align="left">ONBUILD</td>\n<td align="left">触发器</td>\n</tr>\n<tr>\n<td align="left">VOLUME</td>\n<td align="left">挂载卷</td>\n</tr>\n<tr>\n<td align="left">FROM</td>\n<td align="left">基础镜像</td>\n</tr>\n<tr>\n<td align="left">ENTRYPOINT</td>\n<td align="left">基础命令</td>\n</tr>\n<tr>\n<td align="left">RUN</td>\n<td align="left">执行命令</td>\n</tr>\n<tr>\n<td align="left">CMD</td>\n<td align="left">启动程序命令，拼接在基础命令后</td>\n</tr>\n<tr>\n<td align="left">EXPOSE</td>\n<td align="left">暴露端口</td>\n</tr>\n<tr>\n<td align="left">MAINTAINER</td>\n<td align="left">维护者</td>\n</tr>\n</tbody>\n</table><p>如果不理解可以参考博客<a href="https://www.cnblogs.com/51kata/category/789766.html" rel="nofollow">https://www.cnblogs.com/51kata/category/789766.html</a></p>\n<h4><a id="Dockerfile_81"></a>第一个Dockerfile</h4>\n<pre><code class="prism language-text">FROM alpine:latest\nMAINTAINER fzp\nCMD echo \'hello docker\'\n</code></pre>\n<p>这个镜像的基础镜像是alpine:latest，所有者是fzp，容器启动的时候会执行echo命令。</p>\n<p>执行：</p>\n<pre><code class="prism language-text">docker build -t hello-img .\n\ndocker run hello-img\n</code></pre>\n<p>控制台输出： hello docker</p>\n<h4><a id="Dockerfile_101"></a>第二个Dockerfile</h4>\n<pre><code class="prism language-text">FROM ubuntu\nMAINTAINER fzp\nRUN sed -i \'s/archive.ubuntu.com/mirrors.ustc.edu.cn/g\' /etc/apt/sources.list\nRUN apt-get update \nRUN apt-get install -y nginx\nCOPY index.html /var/www/html\nENTRYPOINT ["/usr/sbin/nginx","-g","daemon off;"]\nEXPOSE 80\n</code></pre>\n<p>这个镜像稍微复杂点，基础镜像是ubuntu，镜像所属者fzp，再一下一层是设置镜像加速的地址。将index.html拷贝到镜像的目录下。最后以前台进程的形式启动。</p>\n<p>index.html</p>\n<pre><code class="prism language-text">today i\'m happy\n</code></pre>\n<p>执行命令：</p>\n<pre><code class="prism language-text">docker build -t forezp/hello.nginx .\n\ndocker run forezp/hello.nginx\n</code></pre>\n<p>curl localhost</p>\n<p>控制台输出：today i’m happy</p>\n<h3><a id="Docker_134"></a>Docker存储</h3>\n<p>独立于容器之后的独立化存储</p>\n<p>第一种方式：</p>\n<pre><code class="prism language-text">docker run -p 80:80 -d -v $PWD/code:/var/www/html nginx\n</code></pre>\n<p>-v指令 宿主的路径:容器路径</p>\n<p>将容器的路径的文件夹或者文件挂载到宿主机的路径。</p>\n<p>第二种方式：</p>\n<p>docker run -volumes-from …</p>\n<pre><code class="prism language-text">docker create -v $PWD/data:/var/mydata --name data_container ubuntu\n\ndocker run -it --volumes-from data_container ubuntu /bin/bash\n\ncd /var/mydata\n\ntouch what.txt\n\nexit \n\ncd data\n\nls\n</code></pre>\n<p>可以查看宿主机的data目录有what.txt文件</p>\n<h3><a id="_170"></a>镜像仓库</h3>\n<p>Regiestry,使用官方的docker hub。</p>\n<pre><code class="prism language-text">docker search whalesay\n\ndocker pull dokcer/whalesay\n\ndocker run dokcer/whalesay cowsay docker is fun\n\ndocker tag dokcer/whalesay forezp/whalesay\n\ndcoker push forezp/whalesay\n\ndocker login\n</code></pre>\n<h3><a id="Docker_Compose_188"></a>Docker Compose</h3>\n<p>docker compose是Docker 官方的一个容器编排工具，现在以一个简单的搭建博客的例子来讲解。</p>\n<h4><a id="_192"></a>安装</h4>\n<p>所以的例子都是在linux系统下完成的，docker compose在linux下的安装：</p>\n<pre><code class="prism language-text">curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\nchmod a+x /usr/local/bin/docker-compose\n</code></pre>\n<p>验证安装成了没：</p>\n<pre><code class="prism language-text">docker-compose --version\n</code></pre>\n<h4><a id="Docker_Compse_207"></a>Docker Compse常用命令</h4>\n<ul>\n<li>docker-compose build</li>\n<li>docker-compose up</li>\n<li>docker-compose stop</li>\n<li>docker-compose rm</li>\n</ul>\n<h4><a id="_214"></a>案例实战</h4>\n<p>工程架构：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjc5NTk0LTA1YmNkNDllOWUxYWZkZTgucG5n?x-oss-process=image/format,png" alt="WX20180903-233019@2x.png"></p>\n<p>分为3个容器，最外层一个服务为ngixn，下一层服务为ghost app，最底层容器是Mysql</p>\n<p>在工作目录ghost下，有三个文件夹分别为ngix、ghost、db和一个docker-compose.yml文件，目录结构为：</p>\n<pre><code class="prism language-text">-ghost\n - nginx\n     - Dockerfile\n     - nginx.conf\n - ghost\n   - Dockerfile\n     - config.js\n - db\n - docker-compose.yml\n</code></pre>\n<p><strong>docker-compose.yml编写</strong></p>\n<pre><code class="prism language-text">version: \'2\'\nnetworks:\n  ghost:\nservices:\n  ghost-app:\n    build: ghost\n    networks:\n      - ghost\n    depends_on:\n      - db\n    ports:\n      - "2368:2368"\n  nginx:\n     build: nginx\n     networks:\n      - ghost\n     depends_on:\n      - ghost-app\n     ports:\n      - "80:80"\n  db:\n    image: "mysql:5.7.15"\n    networks:\n      - ghost\n    environment:\n      MYSQL_ROOT_PASSWORD: mysqlroot\n      MYSQL_USER: ghost\n      MYSQL_PASSWORD: ghost\n    volumes:\n      - $PWD/data:/var/lib/mysql\n    ports:\n      - "3306:3306"\n</code></pre>\n<p><strong>nginx相关</strong></p>\n<p>dockerfile编写：</p>\n<pre><code class="prism language-text">FROM nginx\nCOPY nginx.conf /etc/nginx/nginx.conf\nEXPOSE 80\n</code></pre>\n<p>配置文件文件编写nginx.conf</p>\n<pre><code class="prism language-text">worker_processes 4;\nevents {\n        worker_connections 1024;\n        }\nhttp {\n    server {\n       listen 80;\n       location / {\n             proxy_pass http://ghost-app:2368;\n        }\n    }\n}\n</code></pre>\n<p><strong>ghost app相关</strong></p>\n<p>Dockerfile编写：</p>\n<pre><code class="prism language-text">FROM ghost\nCOPY ./config.js /var/lib/ghost/config.js\nEXPOSE 2368\n</code></pre>\n<p>配置文件config.js：</p>\n<pre><code class="prism language-text">var path = require(\'path\'),\nconfig;\nconfig = {\n  production: {\n    url: \'http://mytestblog.com\',\n    mail: {},\n    database: {\n       client: \'mysql\',\n       connection: {\n         host: \'db\',\n         user: \'ghost\',\n         password: \'ghost\',\n         database: \'ghost\',\n         port: \'3306\',\n         charset: \'utf8\'\n       },\n      debug: false\n    },\n    paths: {\n       contentPath: path.join(process.env.GHOST_CONTENT,\'/\')\n     },\n     server: {\n        host: \'0.0.0.0\',\n        port: \'2368\'\n     }\n   }\n};\nmodule.exports = config;\n</code></pre>\n<p>docker-compose打镜像，打完镜像之后运行.</p>\n<pre><code class="prism language-text">docker-compose buid\ndocker-compose up\n</code></pre>\n<p>运行之后在浏览器上访问：<a href="http://119.23.221.204/" rel="nofollow">http://119.23.221.204/</a></p>\n<p>显示界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120220259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><strong>代码位置</strong></p>\n<p>/usr/dockerstudy/ghost</p>\n<h3><a id="_360"></a>常用命令</h3>\n<ul>\n<li>docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) 删除所有容器</li>\n</ul>\n<h3><a id="_364"></a>参考资料</h3>\n<p><a href="https://www.imooc.com/video/15735" rel="nofollow">https://www.imooc.com/video/15735</a></p>\n<h3><a id="_369"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<ul>\n<li>关注我的公众号,精彩内容不能错过！</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041125', 'title': '史上最简单的SpringCloud教程 | 第十三篇: 断路器聚合监控(Hystrix Turbine)(Finchley版本)', 'readNum': '48608', 'commentNum': '42', 'publishTime': '2018-07-14 10:19:59', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springcloud/2018/08/30/sc-f13-turbine/<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/13/sc-f13-turbine.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/13/sc-f13-turbine.html</a></strong></p>\n<p>上一篇文章讲述了如何利用Hystrix Dashboard去监控断路器的Hystrix command。当我们有很多个服务的时候，这就需要聚合所以服务的Hystrix Dashboard的数据了。这就需要用到Spring Cloud的另一个组件了，即Hystrix Turbine。</p>\n<h2><a id="Hystrix_Turbine_8"></a>一、Hystrix Turbine简介</h2>\n<p>看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。</p>\n<h2><a id="_12"></a>二、准备工作</h2>\n<p>本文使用的工程为上一篇文章的工程，在此基础上进行改造。因为我们需要多个服务的Dashboard，所以需要再建一个服务，取名为service-lucy，它的基本配置同service-hi，具体见<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter13">源码</a>,在这里就不详细说明。</p>\n<h2><a id="serviceturbine_16"></a>三、创建service-turbine</h2>\n<p>引入相应的依赖：</p>\n<pre><code> &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n\n</code></pre>\n<p>在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。</p>\n<pre><code>\n@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient\n@RestController\n@EnableHystrix\n@EnableHystrixDashboard\n@EnableCircuitBreaker\n@EnableTurbine\npublic class ServiceTurbineApplication {\n\n    /**\n     * http://localhost:8764/turbine.stream\n     */\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceTurbineApplication.class, args );\n    }\n}\n\n\n</code></pre>\n<p>配置文件application.yml：</p>\n<pre><code>server:\n  port: 8764\n\nspring:\n  application:\n    name: service-turbine\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: "*"\n      cors:\n        allowed-origins: "*"\n        allowed-methods: "*"\n\nturbine:\n  app-config: service-hi,service-lucy\n  aggregator:\n    clusterConfig: default\n  clusterNameExpression: new String("default")\n  combine-host: true\n  instanceUrlSuffix:\n    default: actuator/hystrix.stream     \n\n</code></pre>\n<p>配置文件注解写的很清楚。</p>\n<h2><a id="Turbine_114"></a>四、Turbine演示</h2>\n<p>依次开启eureka-server、service-hi、service-lucy、service-turbine工程。</p>\n<p>打开浏览器输入：http://localhost:8764/turbine.stream,界面如下：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Mprwy3z2-1569837780939)(https://img-blog.csdn.net/20170416135735474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]</p>\n<p>依次请求：</p>\n<blockquote>\n<p>http://localhost:8762/hi?name=forezp</p>\n</blockquote>\n<p>http://localhost:8763/hi?name=forezp</p>\n<p>打开:http://localhost:8763/hystrix,输入监控流http://localhost:8764/turbine.stream</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTQwMDI5NTQw?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>点击monitor stream 进入页面：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTQwMjU2NzU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>可以看到这个页面聚合了2个service的hystrix dashbord数据。</p>\n<p>源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter13">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter13</a></p>\n<h2><a id="_141"></a>五、参考文献</h2>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard" rel="nofollow">hystrix_dashboard</a></p>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_turbine" rel="nofollow">turbine</a></p>\n<h3><a id="_146"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041113', 'title': '史上最简单的SpringCloud教程 | 第十二篇: 断路器监控(Hystrix Dashboard)(Finchley版本)', 'readNum': '55553', 'commentNum': '82', 'publishTime': '2018-07-14 10:19:02', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041113<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/12/sc-f12-dash.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/12/sc-f12-dash.html</a></strong></p>\n<p>在我的第四篇文章<a href="http://blog.csdn.net/forezp/article/details/69934399">断路器</a>讲述了如何使用断路器，并简单的介绍了下Hystrix Dashboard组件，这篇文章更加详细的介绍Hystrix Dashboard。</p>\n<h2><a id="Hystrix_Dashboard_8"></a>一、Hystrix Dashboard简介</h2>\n<p>在微服务架构中为例保证程序的可用性，防止程序出错导致网络阻塞，出现了断路器模型。断路器的状况反应了一个程序的可用性和健壮性，它是一个重要指标。Hystrix Dashboard是作为断路器状态的一个组件，提供了数据监控和友好的图形化界面。</p>\n<h2><a id="_12"></a>二、准备工作</h2>\n<p>本文的的工程栗子，来源于<a href="http://blog.csdn.net/forezp/article/details/69696915">第一篇文章</a>的栗子，在它的基础上进行改造。</p>\n<h2><a id="servicehi_17"></a>三、开始改造service-hi</h2>\n<p>在pom的工程文件引入相应的依赖：</p>\n<pre><code>&lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        \n    &lt;/dependencies&gt;\n</code></pre>\n<p>其中，这三个依赖是必须的，缺一不可。</p>\n<p>在程序的入口ServiceHiApplication类，加上@EnableHystrix注解开启断路器，这个是必须的，并且需要在程序中声明断路点HystrixCommand；加上@EnableHystrixDashboard注解，开启HystrixDashboard</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient\n@RestController\n@EnableHystrix\n@EnableHystrixDashboard\n@EnableCircuitBreaker\npublic class ServiceHiApplication {\n\n    /**\n     * 访问地址 http://localhost:8762/actuator/hystrix.stream\n     * @param args\n     */\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceHiApplication.class, args );\n    }\n\n    @Value("${server.port}")\n    String port;\n\n    @RequestMapping("/hi")\n    @HystrixCommand(fallbackMethod = "hiError")\n    public String home(@RequestParam(value = "name", defaultValue = "forezp") String name) {\n        return "hi " + name + " ,i am from port:" + port;\n    }\n\n    public String hiError(String name) {\n        return "hi,"+name+",sorry,error!";\n    }\n\n}\n</code></pre>\n<p>运行程序： 依次开启eureka-server 和service-hi.</p>\n<h2><a id="Hystrix_Dashboard_89"></a>四、Hystrix Dashboard图形展示</h2>\n<p>打开http://localhost:8762/actuator/hystrix.stream，可以看到一些具体的数据：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTExOTA5MTEw?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>打开localhost:8762/hystrix 可以看见以下界面：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTEwNzM5NTQx?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>在界面依次输入：http://localhost:8762/actuator/hystrix.stream 、2000 、miya<br>\n；点确定。</p>\n<p>在另一个窗口输入： http://localhost:8762/hi?name=forezp</p>\n<p>重新刷新hystrix.stream网页，你会看到良好的图形化界面：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTExMjQzMjYy?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter12">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter12</a></p>\n<h3><a id="_111"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_121"></a>五、参考资料</h2>\n<p><a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-dashboard">hystrix-dashboard</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041101', 'title': '史上最简单的SpringCloud教程 | 第十篇: 高可用的服务注册中心(Finchley版本)', 'readNum': '59724', 'commentNum': '82', 'publishTime': '2018-07-14 10:18:07', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041101<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/10/sc-f10-eureka.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/10/sc-f10-eureka.html</a></strong></p>\n<p>文章 <a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a> 介绍了服务注册与发现，其中服务注册中心Eureka Server，是一个实例，当成千上万个服务向它注册的时候，它的负载是非常高的，这在生产环境上是不太合适的，这篇文章主要介绍怎么将Eureka Server集群化。</p>\n<h3><a id="_10"></a>一、准备工作</h3>\n<blockquote>\n<p>Eureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behaviour, so all you need to do to make it work is add a valid serviceUrl to a peer, e.g.</p>\n<p>摘自官网</p>\n</blockquote>\n<p>Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。</p>\n<p>这篇文章我们基于<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter1">第一篇文章的工程</a>，来做修改。</p>\n<h3><a id="_20"></a>二、改造工作</h3>\n<p>在eureka-server工程中resources文件夹下，创建配置文件application-peer1.yml:</p>\n<pre><code>server:\n  port: 8761\n\nspring:\n  profiles: peer1\neureka:\n  instance:\n    hostname: peer1\n  client:\n    serviceUrl:\n      defaultZone: http://peer2:8769/eureka/\n\n</code></pre>\n<p>并且创建另外一个配置文件application-peer2.yml：</p>\n<pre><code>\nserver:\n  port: 8769\n\nspring:\n  profiles: peer2\neureka:\n  instance:\n    hostname: peer2\n  client:\n    serviceUrl:\n      defaultZone: http://peer1:8761/eureka/\n\n</code></pre>\n<p>这时eureka-server就已经改造完毕。</p>\n<blockquote>\n<p>ou could use this configuration to test the peer awareness on a single host (there’s not much value in doing that in production) by manipulating /etc/hosts to resolve the host names.</p>\n</blockquote>\n<p>按照官方文档的指示，需要改变etc/hosts，linux系统通过vim /etc/hosts ,加上：</p>\n<pre><code>127.0.0.1 peer1\n127.0.0.1 peer2\n</code></pre>\n<p>windows电脑，在c:/windows/systems/drivers/etc/hosts 修改。</p>\n<p>这时需要改造下service-hi:</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://peer1:8761/eureka/\nserver:\n  port: 8762\nspring:\n  application:\n    name: service-hi\n\n</code></pre>\n<h3><a id="_84"></a>三、启动工程</h3>\n<p>启动eureka-server：</p>\n<blockquote>\n<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer1</p>\n</blockquote>\n<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer2</p>\n<p><img src="https://img-blog.csdn.net/20180714101743515?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>\n<p>启动service-hi:</p>\n<blockquote>\n<p>java -jar service-hi-0.0.1-SNAPSHOT.jar</p>\n</blockquote>\n<p>访问：localhost:8761,如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010456696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>你会发现注册了service-hi，并且有个peer2节点，同理访问localhost:8769你会发现有个peer1节点。</p>\n<p>client只向8761注册，但是你打开8769，你也会发现，8769也有 client的注册信息。</p>\n<p>个人感受：这是通过看官方文档的写的demo ，但是需要手动改host是不是不符合Spring Cloud 的高上大？</p>\n<blockquote>\n<h3><a id="Prefer_IP_Address_110"></a>Prefer IP Address</h3>\n</blockquote>\n<p>In some cases, it is preferable for Eureka to advertise the IP Adresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and when the application registers with eureka, it will use its IP Address rather than its hostname.</p>\n<blockquote>\n<p>摘自官网</p>\n</blockquote>\n<p>eureka.instance.preferIpAddress=true是通过设置ip让eureka让其他服务注册它。也许能通过去改变去通过改变host的方式。</p>\n<p>此时的架构图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010520900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>Eureka-eserver peer1 8761,Eureka-eserver peer2 8769相互感应，当有服务注册时，两个Eureka-eserver是对等的，它们都存有相同的信息，这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。</p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter10">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter10</a></p>\n<h3><a id="_126"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_134"></a>四、参考文献</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_high_availability_zones_and_regions" rel="nofollow">high_availability_zones</a></p>\n<p>http://blog.csdn.net/forezp/article/details/70183572</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041078', 'title': '史上最简单的SpringCloud教程 | 第九篇: 服务链路追踪(Spring Cloud Sleuth)(Finchley版本)', 'readNum': '71085', 'commentNum': '89', 'publishTime': '2018-07-14 10:16:13', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041078<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/09/sc-f9-sleuth.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/09/sc-f9-sleuth.html</a></strong></p>\n<p>这篇文章主要讲述服务追踪组件zipkin，Spring Cloud Sleuth集成了zipkin组件。</p>\n<h3><a id="_9"></a>一、简介</h3>\n<blockquote>\n<p>Add sleuth to the classpath of a Spring Boot application (see below for Maven and Gradle examples), and you will see the correlation data being collected in logs, as long as you are logging requests.</p>\n<p>------  <a href="https://github.com/spring-cloud/spring-cloud-sleuth">摘自官网</a></p>\n</blockquote>\n<p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p>\n<h3><a id="_17"></a>二、服务追踪分析</h3>\n<p>微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010210728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010236643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_30"></a>三、术语</h3>\n<ul>\n<li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址)<br>\nspan在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li>\n<li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li>\n<li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束\n<ul>\n<li>cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始</li>\n<li>sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟</li>\n<li>ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间</li>\n<li>cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间<br>\n将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li>\n</ul>\n</li>\n</ul>\n<p>将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010259716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_50"></a>四、构建工程</h3>\n<p>基本知识讲解完毕，下面我们来实战，本文的案例主要有三个工程组成:一个server-zipkin,它的主要作用使用ZipkinServer 的功能，收集调用数据，并展示；一个service-hi,对外暴露hi接口；一个service-miya,对外暴露miya接口；这两个service可以相互调用；并且只有调用了，server-zipkin才会收集数据的，这就是为什么叫服务追踪了。</p>\n<h4><a id="41_serverzipkin_54"></a>4.1 构建server-zipkin</h4>\n<p>在spring Cloud为F版本的时候，已经不需要自己构建Zipkin Server了，只需要下载jar即可，下载地址：</p>\n<p>https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</p>\n<p>也可以在这里下载：</p>\n<p>链接: https://pan.baidu.com/s/1w614Z8gJXHtqLUB6dKWOpQ 密码: 26pf</p>\n<p>下载完成jar 包之后，需要运行jar，如下：</p>\n<blockquote>\n<p>java -jar zipkin-server-2.10.1-exec.jar</p>\n</blockquote>\n<p>访问浏览器localhost:9494</p>\n<h4><a id="42_servicehi_70"></a>4.2 创建service-hi</h4>\n<p>在其pom引入起步依赖spring-cloud-starter-zipkin，代码如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\t\t xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;service-zipkin&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;service-hi&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;sc-f-chapter9&lt;/artifactId&gt;\n\t\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;/parent&gt;\n\n\n\n\t&lt;dependencies&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\n\n\t&lt;/dependencies&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n&lt;/project&gt;\n\n</code></pre>\n<p>在其配置文件application.yml指定zipkin server的地址，头通过配置“spring.zipkin.base-url”指定：</p>\n<pre><code>\n\nserver.port=8988\nspring.zipkin.base-url=http://localhost:9411\nspring.application.name=service-hi\n\n</code></pre>\n<p>通过引入spring-cloud-starter-zipkin依赖和设置spring.zipkin.base-url就可以了。</p>\n<p>对外暴露接口：</p>\n<pre><code>package com.forezp;\n\nimport brave.sampler.Sampler;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n@SpringBootApplication\n@RestController\npublic class ServiceHiApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceHiApplication.class, args);\n\t}\n\n\tprivate static final Logger LOG = Logger.getLogger(ServiceHiApplication.class.getName());\n\n\n\t@Autowired\n\tprivate RestTemplate restTemplate;\n\n\t@Bean\n\tpublic RestTemplate getRestTemplate(){\n\t\treturn new RestTemplate();\n\t}\n\n\t@RequestMapping("/hi")\n\tpublic String callHome(){\n\t\tLOG.log(Level.INFO, "calling trace service-hi  ");\n\t\treturn restTemplate.getForObject("http://localhost:8989/miya", String.class);\n\t}\n\t@RequestMapping("/info")\n\tpublic String info(){\n\t\tLOG.log(Level.INFO, "calling trace service-hi ");\n\n\t\treturn "i\'m service-hi";\n\n\t}\n\n\t@Bean\n\tpublic Sampler defaultSampler() {\n\t\treturn Sampler.ALWAYS_SAMPLE;\n\t}\n\n\n}\n\n\n</code></pre>\n<h4><a id="43_servicemiya_197"></a>4.3 创建service-miya</h4>\n<p>创建过程痛service-hi，引入相同的依赖，配置下spring.zipkin.base-url。</p>\n<p>对外暴露接口：</p>\n<pre><code>\npackage com.forezp;\n\nimport brave.sampler.Sampler;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n@SpringBootApplication\n@RestController\npublic class ServiceMiyaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceMiyaApplication.class, args);\n\t}\n\n\tprivate static final Logger LOG = Logger.getLogger(ServiceMiyaApplication.class.getName());\n\n\n\t@RequestMapping("/hi")\n\tpublic String home(){\n\t\tLOG.log(Level.INFO, "hi is being called");\n\t\treturn "hi i\'m miya!";\n\t}\n\n\t@RequestMapping("/miya")\n\tpublic String info(){\n\t\tLOG.log(Level.INFO, "info is being called");\n\t\treturn restTemplate.getForObject("http://localhost:8988/info",String.class);\n\t}\n\n\t@Autowired\n\tprivate RestTemplate restTemplate;\n\n\t@Bean\n\tpublic RestTemplate getRestTemplate(){\n\t\treturn new RestTemplate();\n\t}\n\n\n\t@Bean\n\tpublic Sampler defaultSampler() {\n\t\treturn Sampler.ALWAYS_SAMPLE;\n\t}\n}\n\n</code></pre>\n<h4><a id="44__259"></a>4.4 启动工程，演示追踪</h4>\n<p>依次启动上面的工程，打开浏览器访问：http://localhost:9411/，会出现以下界面：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010329458.png" alt="在这里插入图片描述"></p>\n<p>访问：http://localhost:8989/miya，浏览器出现：</p>\n<blockquote>\n<p>i’m service-hi</p>\n</blockquote>\n<p>再打开http://localhost:9411/的界面，点击Dependencies,可以发现服务的依赖关系：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010348940.png" alt="在这里插入图片描述"></p>\n<p>点击find traces,可以看到具体服务相互调用的数据：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601010405436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>本文源码下载：</p>\n<p><a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter9">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter9</a></p>\n<h3><a id="_284"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_292"></a>五、参考资料</h3>\n<p><a href="https://github.com/spring-cloud/spring-cloud-sleuth">spring-cloud-sleuth</a></p>\n<p>http://blog.csdn.net/forezp/article/details/70162074</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<h3><a id="_301"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041062', 'title': '原 史上最简单的SpringCloud教程 | 第八篇: 消息总线(Spring Cloud Bus)(Finchley版本)', 'readNum': '86834', 'commentNum': '177', 'publishTime': '2018-07-14 10:15:06', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041062<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/08/sc-f8-bus.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/08/sc-f8-bus.html</a></strong></p>\n<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。</p>\n<h3><a id="_9"></a>一、准备工作</h3>\n<p>本文还是基于上一篇文章来实现。按照官方文档，我们只需要在配置文件中配置 spring-cloud-starter-bus-amqp ；这就是说我们需要装rabbitMq，点击<a href="http://www.rabbitmq.com/" rel="nofollow">rabbitmq</a>下载。至于怎么使用 rabbitmq，搜索引擎下。</p>\n<h3><a id="configclient_13"></a>二、改造config-client</h3>\n<p>在pom文件加上起步依赖spring-cloud-starter-bus-amqp，完整的配置文件如下：</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\n</code></pre>\n<p>在配置文件application.properties中加上RabbitMq的配置，包括RabbitMq的地址、端口，用户名、密码。并需要加上spring.cloud.bus的三个配置，具体如下：</p>\n<pre><code>\nspring.rabbitmq.host=localhost\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=guest\nspring.rabbitmq.password=guest\n\nspring.cloud.bus.enabled=true\nspring.cloud.bus.trace.enabled=true\nmanagement.endpoints.web.exposure.include=bus-refresh\n\n\n</code></pre>\n<p>ConfigClientApplication启动类代码如下：</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient\n@RestController\n@RefreshScope\npublic class ConfigClientApplication {\n\n\t/**\n\t * http://localhost:8881/actuator/bus-refresh\n\t */\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ConfigClientApplication.class, args);\n\t}\n\n\t@Value("${foo}")\n\tString foo;\n\n\t@RequestMapping(value = "/hi")\n\tpublic String hi(){\n\t\treturn foo;\n\t}\n}\n\n\n</code></pre>\n<p>依次启动eureka-server、confg-cserver,启动两个config-client，端口为：8881、8882。</p>\n<p>访问http://localhost:8881/hi  或者http://localhost:8882/hi 浏览器显示：</p>\n<blockquote>\n<p>foo version 3</p>\n</blockquote>\n<p>这时我们去<a href="https://github.com/forezp/SpringcloudConfig/blob/master/respo/config-client-dev.properties">代码仓库</a>将foo的值改为“foo version 4”，即改变配置文件foo的值。如果是传统的做法，需要重启服务，才能达到配置文件的更新。此时，我们只需要发送post请求：http://localhost:8881/actuator/bus-refresh，你会发现config-client会重新读取配置文件</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005838736.png" alt="在这里插入图片描述"></p>\n<p>重新读取配置文件：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005854381.png" alt="在这里插入图片描述"></p>\n<p>这时我们再访问http://localhost:8881/hi  或者http://localhost:8882/hi 浏览器显示：</p>\n<blockquote>\n<p>foo version 4</p>\n</blockquote>\n<p>另外，/actuator/bus-refresh接口可以指定服务，即使用"destination"参数，比如 “/actuator/bus-refresh?destination=customers:**” 即刷新服务名为customers的所有服务。</p>\n<h3><a id="_117"></a>三、分析</h3>\n<p>此时的架构图：<br>\n<img src="https://img-blog.csdnimg.cn/20190601005920376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>当git文件更改的时候，通过pc端用post 向端口为8882的config-client发送请求/bus/refresh／；此时8882端口会发送一个消息，由消息总线向其他服务传递，从而使整个微服务集群都达到更新配置文件。</p>\n<h4><a id="_126"></a>本文源码下载：</h4>\n<p><a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter8">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter8</a></p>\n<h3><a id="_131"></a>五、参考资料</h3>\n<p>http://blog.csdn.net/forezp/article/details/70148235</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041045', 'title': '史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)(Finchley版本)', 'readNum': '81000', 'commentNum': '164', 'publishTime': '2018-07-14 10:14:06', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041045<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html</a></strong></p>\n<p>上一篇文章讲述了一个服务如何从配置中心读取文件，配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用，架构图如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005634592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_11"></a>一、准备工作</h3>\n<p>继续使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。</p>\n<p>在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-netflix- eureka-server，代码如下:</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;config-server&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;config-server&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;sc-f-chapter7&lt;/artifactId&gt;\n\t\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;/parent&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t&lt;/dependencies&gt;\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置，代码如下：</p>\n<pre><code>server:\n  port: 8889\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n</code></pre>\n<p>入口类：</p>\n<pre><code>@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaServerApplication.class, args);\n\t}\n}\n\n\n</code></pre>\n<h3><a id="configserver_98"></a>二、改造config-server</h3>\n<p>在其pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-netflix-eureka-client，代码如下:</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t&lt;/dependencies&gt;\n</code></pre>\n<p>配置文件application.yml，指定服务注册地址为http://localhost:8889/eureka/，其他配置同上一篇文章，完整的配置如下：</p>\n<pre><code>spring.application.name=config-server\nserver.port=8888\n\nspring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/\nspring.cloud.config.server.git.searchPaths=respo\nspring.cloud.config.label=master\nspring.cloud.config.server.git.username= your username\nspring.cloud.config.server.git.password= your password\neureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/\n</code></pre>\n<p>最后需要在程序的启动类Application加上@EnableEureka的注解。</p>\n<h3><a id="configclient_135"></a>三、改造config-client</h3>\n<p>将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-netflix-eureka-client，代码如下：</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n</code></pre>\n<p>配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为http://localhost:8889/eureka/</p>\n<pre><code>spring.application.name=config-client\nspring.cloud.config.label=master\nspring.cloud.config.profile=dev\n#spring.cloud.config.uri= http://localhost:8888/\n\neureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/\nspring.cloud.config.discovery.enabled=true\nspring.cloud.config.discovery.serviceId=config-server\nserver.port=8881\n\n\n</code></pre>\n<ul>\n<li>spring.cloud.config.discovery.enabled 是从配置中心读取文件。</li>\n<li>spring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。</li>\n</ul>\n<p>这时发现，在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。</p>\n<p>依次启动eureka-servr,config-server,config-client<br>\n访问网址：http://localhost:8889/</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005729699.png" alt="在这里插入图片描述"><br>\n访问http://localhost:8881/hi，浏览器显示：</p>\n<blockquote>\n<p>foo version 3</p>\n</blockquote>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter7">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter7</a></p>\n<h3><a id="_192"></a>四、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config" rel="nofollow">spring_cloud_config</a></p>\n<h3><a id="_196"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:29 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041028', 'title': '史上最简单的SpringCloud教程 | 第六篇: 分布式配置中心(Spring Cloud Config)(Finchley版本)', 'readNum': '120823', 'commentNum': '321', 'publishTime': '2018-07-14 10:13:10', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041028<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版:<a href="https://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html</a></strong><br>\n在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。</p>\n<h3><a id="_9"></a>一、简介</h3>\n<p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>\n<h3><a id="Config_Server_13"></a>二、构建Config Server</h3>\n<p>父maven工程省略，父pom文件：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;sc-f-chapter6&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;config-server&lt;/module&gt;\n        &lt;module&gt;config-client&lt;/module&gt;\n    &lt;/modules&gt;\n\n    &lt;name&gt;sc-f-chapter6&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt;\n    &lt;/parent&gt;\n\n   \n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n\n&lt;/project&gt;\n\n</code></pre>\n<p>创建一个spring-boot项目，取名为config-server,其pom.xml如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;config-server&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;config-server&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;sc-f-chapter6&lt;/artifactId&gt;\n\t\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;/parent&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\n&lt;/project&gt;\n\n</code></pre>\n<p>在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能，代码如下：</p>\n<pre><code>\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ConfigServerApplication.class, args);\n\t}\n}\n\n\n</code></pre>\n<p>需要在程序的配置文件application.properties文件配置以下：</p>\n<pre><code>spring.application.name=config-server\nserver.port=8888\n\nspring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/\nspring.cloud.config.server.git.searchPaths=respo\nspring.cloud.config.label=master\nspring.cloud.config.server.git.username=\nspring.cloud.config.server.git.password=\n\n\n\n</code></pre>\n<ul>\n<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>\n<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>\n<li>spring.cloud.config.label：配置仓库的分支</li>\n<li>spring.cloud.config.server.git.username：访问git仓库的用户名</li>\n<li>spring.cloud.config.server.git.password：访问git仓库的用户密码</li>\n</ul>\n<p>如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写，本例子是公开仓库，放心使用。</p>\n<p>远程仓库https://github.com/forezp/SpringcloudConfig/ 中有个文件config-client-dev.properties文件中有一个属性：</p>\n<blockquote>\n<p>foo = foo version 3</p>\n</blockquote>\n<p>启动程序：访问http://localhost:8888/foo/dev</p>\n<pre><code>{"name":"foo","profiles":["dev"],"label":"master",\n"version":"792ffc77c03f4b138d28e89b576900ac5e01a44b","state":null,"propertySources":[]}\n\n</code></pre>\n<p>证明配置服务中心可以从远程程序获取配置信息。</p>\n<p>http请求地址和资源文件映射如下:</p>\n<ul>\n<li>/{application}/{profile}[/{label}]</li>\n<li>/{application}-{profile}.yml</li>\n<li>/{label}/{application}-{profile}.yml</li>\n<li>/{application}-{profile}.properties</li>\n<li>/{label}/{application}-{profile}.properties</li>\n</ul>\n<h3><a id="config_client_193"></a>三、构建一个config client</h3>\n<p>重新创建一个springboot项目，取名为config-client,其pom文件：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;config-client&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;config-client&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;sc-f-chapter6&lt;/artifactId&gt;\n\t\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;/parent&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\n&lt;/project&gt;\n\n</code></pre>\n<p>其配置文件<strong>bootstrap.properties</strong>：</p>\n<pre><code>spring.application.name=config-client\nspring.cloud.config.label=master\nspring.cloud.config.profile=dev\nspring.cloud.config.uri= http://localhost:8888/\nserver.port=8881\n\n</code></pre>\n<ul>\n<li>\n<p>spring.cloud.config.label 指明远程仓库的分支</p>\n</li>\n<li>\n<p>spring.cloud.config.profile</p>\n<ul>\n<li>dev开发环境配置文件</li>\n<li>test测试环境</li>\n<li>pro正式环境</li>\n</ul>\n</li>\n<li>\n<p>spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。</p>\n</li>\n</ul>\n<p>程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值，代码如下：</p>\n<pre><code>@SpringBootApplication\n@RestController\npublic class ConfigClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ConfigClientApplication.class, args);\n\t}\n\n\t@Value("${foo}")\n\tString foo;\n\t@RequestMapping(value = "/hi")\n\tpublic String hi(){\n\t\treturn foo;\n\t}\n}\n\n\n</code></pre>\n<p>打开网址访问：http://localhost:8881/hi，网页显示：</p>\n<blockquote>\n<p>foo version 3</p>\n</blockquote>\n<p>这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的,如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005532911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter6">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter6</a></p>\n<h3><a id="_297"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_305"></a>四、参考资料</h3>\n<p>http://blog.csdn.net/forezp/article/details/70037291</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:29'}
2020-02-05 20:12:30 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81041012', 'title': '史上最简单的SpringCloud教程 | 第五篇: 路由网关(zuul)(Finchley版本)', 'readNum': '119774', 'commentNum': '162', 'publishTime': '2018-07-14 10:11:41', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81041012<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html</a></strong></p>\n<p>在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060100542331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>\n<strong>注意：A服务和B服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。</strong></p>\n<p>在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。</p>\n<h3><a id="Zuul_15"></a>一、Zuul简介</h3>\n<p>Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。</p>\n<p>zuul有以下功能：</p>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n<h3><a id="_32"></a>二、准备工作</h3>\n<p>继续使用上一节的工程。在原有的工程上，创建一个新的工程。</p>\n<h3><a id="servicezuul_36"></a>三、创建service-zuul工程</h3>\n<p>其pom.xml文件如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;service-zuul&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;service-zuul&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n        &lt;artifactId&gt;sc-f-chapter5&lt;/artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：</p>\n<pre><code>@SpringBootApplication\n@EnableZuulProxy\n@EnableEurekaClient\n@EnableDiscoveryClient\npublic class ServiceZuulApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceZuulApplication.class, args );\n    }\n}\n\n\n</code></pre>\n<p>加上配置文件application.yml加上以下的配置代码：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8769\nspring:\n  application:\n    name: service-zuul\nzuul:\n  routes:\n    api-a:\n      path: /api-a/**\n      serviceId: service-ribbon\n    api-b:\n      path: /api-b/**\n      serviceId: service-feign\n\n</code></pre>\n<p>首先指定服务注册中心的地址为http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；</p>\n<p>依次运行这五个工程;打开浏览器访问：http://localhost:8769/api-a/hi?name=forezp ;浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>打开浏览器访问：http://localhost:8769/api-b/hi?name=forezp ;浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>这说明zuul起到了路由的作用</p>\n<h3><a id="_133"></a>四、服务过滤</h3>\n<p>zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；</p>\n<pre><code>@Component\npublic class MyFilter extends ZuulFilter {\n\n    private static Logger log = LoggerFactory.getLogger(MyFilter.class);\n    @Override\n    public String filterType() {\n        return "pre";\n    }\n\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n        log.info(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString()));\n        Object accessToken = request.getParameter("token");\n        if(accessToken == null) {\n            log.warn("token is empty");\n            ctx.setSendZuulResponse(false);\n            ctx.setResponseStatusCode(401);\n            try {\n                ctx.getResponse().getWriter().write("token is empty");\n            }catch (Exception e){}\n\n            return null;\n        }\n        log.info("ok");\n        return null;\n    }\n}\n</code></pre>\n<ul>\n<li>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\n<ul>\n<li>pre：路由之前</li>\n<li>routing：路由之时</li>\n<li>post： 路由之后</li>\n<li>error：发送错误调用</li>\n</ul>\n</li>\n<li>filterOrder：过滤的顺序</li>\n<li>shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</li>\n<li>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</li>\n</ul>\n<p>这时访问：http://localhost:8769/api-a/hi?name=forezp ；网页显示：</p>\n<blockquote>\n<p>token is empty</p>\n</blockquote>\n<p>访问 http://localhost:8769/api-a/hi?name=forezp&amp;token=22 ；<br>\n网页显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter5">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter5</a></p>\n<h3><a id="_198"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_206"></a>五、参考资料：</h3>\n<p>http://blog.csdn.net/forezp/article/details/69939114</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:30'}
2020-02-05 20:12:30 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-1_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81040990', 'title': '史上最简单的SpringCloud教程 | 第四篇:断路器（Hystrix）(Finchley版本)', 'readNum': '111767', 'commentNum': '157', 'publishTime': '2018-07-14 10:10:17', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81040990<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html</a></strong></p>\n<p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>\n<p>为了解决这个问题，业界提出了断路器模型。</p>\n<h3><a id="_11"></a>一、断路器简介</h3>\n<blockquote>\n<p>Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls.</p>\n<p>. ----摘自官网</p>\n</blockquote>\n<p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005310316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005329346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。</p>\n<h3><a id="_27"></a>二、准备工作</h3>\n<p>这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。</p>\n<h3><a id="ribbon_31"></a>三、在ribbon使用断路器</h3>\n<p>改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-netflix-hystrix的起步依赖：</p>\n<pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n</code></pre>\n<p>在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix：</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient\n@EnableHystrix\npublic class ServiceRibbonApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceRibbonApplication.class, args );\n    }\n\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n}\n\n</code></pre>\n<p>改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为"hi,"+name+",sorry,error!"，代码如下：</p>\n<pre><code>@Service\npublic class HelloService {\n\n    @Autowired\n    RestTemplate restTemplate;\n\n    @HystrixCommand(fallbackMethod = "hiError")\n    public String hiService(String name) {\n        return restTemplate.getForObject("http://SERVICE-HI/hi?name="+name,String.class);\n    }\n\n    public String hiError(String name) {\n        return "hi,"+name+",sorry,error!";\n    }\n\n}\n\n</code></pre>\n<p>启动：service-ribbon 工程，当我们访问http://localhost:8764/hi?name=forezp,浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>此时关闭 service-hi 工程，当我们再访问http://localhost:8764/hi?name=forezp，浏览器会显示：</p>\n<blockquote>\n<p>hi ,forezp,orry,error!</p>\n</blockquote>\n<p>这就说明当 service-hi 工程不可用的时候，service-ribbon调用 service-hi的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞。</p>\n<h3><a id="Feign_99"></a>四、Feign中使用断路器</h3>\n<p>Feign是自带断路器的，在D版本的Spring Cloud之后，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：</p>\n<blockquote>\n<p>feign.hystrix.enabled=true</p>\n</blockquote>\n<p>基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类就行了：</p>\n<pre><code>@FeignClient(value = "service-hi",fallback = SchedualServiceHiHystric.class)\npublic interface SchedualServiceHi {\n    @RequestMapping(value = "/hi",method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = "name") String name);\n}\n\n</code></pre>\n<p>SchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中，代码如下：</p>\n<pre><code>@Component\npublic class SchedualServiceHiHystric implements SchedualServiceHi {\n    @Override\n    public String sayHiFromClientOne(String name) {\n        return "sorry "+name;\n    }\n}\n\n</code></pre>\n<p>启动四servcie-feign工程，浏览器打开http://localhost:8765/hi?name=forezp,注意此时service-hi工程没有启动，网页显示：</p>\n<blockquote>\n<p>sorry forezp</p>\n</blockquote>\n<p>打开service-hi工程，再次访问，浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>这证明断路器起到作用了。</p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter4">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter4</a></p>\n<h3><a id="_145"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_153"></a>六、参考资料</h3>\n<p>http://blog.csdn.net/forezp/article/details/69934399</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:30'}
2020-02-05 20:12:30 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:41] - MainThread - INFO - 翻页：3 nextUrl：https://blog.csdn.net/forezp/article/list/3
2020-02-05 20:12:30 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81040965', 'title': '史上最简单的SpringCloud教程 | 第三篇: 服务消费者（Feign）(Finchley版本)', 'readNum': '135608', 'commentNum': '148', 'publishTime': '2018-07-14 10:07:35', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81040965<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html</a></strong></p>\n<p>上一篇文章，讲述了如何通过RestTemplate+Ribbon去消费服务，这篇文章主要讲述如何通过Feign去消费服务。</p>\n<h3><a id="Feign_9"></a>一、Feign简介</h3>\n<p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>\n<p>简而言之：</p>\n<ul>\n<li>Feign 采用的是基于接口的注解</li>\n<li>Feign 整合了ribbon，具有负载均衡的能力</li>\n<li>整合了Hystrix，具有熔断的能力</li>\n</ul>\n<h3><a id="_19"></a>二、准备工作</h3>\n<p>继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.</p>\n<h3><a id="feign_23"></a>三、创建一个feign的服务</h3>\n<p>新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-netflix-eureka-client、Web的起步依赖spring-boot-starter-web，代码如下：</p>\n<pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;service-feign&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;service-feign&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n        &lt;artifactId&gt;sc-f-chapter3&lt;/artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    \n    &lt;/project&gt;\n</code></pre>\n<p>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ ，代码如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8765\nspring:\n  application:\n    name: service-feign\n\n</code></pre>\n<p>在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能：</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class ServiceFeignApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceFeignApplication.class, args );\n    }\n}\n\n\n\n</code></pre>\n<p>定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口，代码如下：</p>\n<pre><code>\n@FeignClient(value = "service-hi")\npublic interface SchedualServiceHi {\n    @RequestMapping(value = "/hi",method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = "name") String name);\n}\n\n\n\n\n</code></pre>\n<p>在Web层的controller层，对外暴露一个"/hi"的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务。代码如下：</p>\n<pre><code>@RestController\npublic class HiController {\n\n\n    //编译器报错，无视。 因为这个Bean是在程序启动的时候注入的，编译器感知不到，所以报错。\n    @Autowired\n    SchedualServiceHi schedualServiceHi;\n\n    @GetMapping(value = "/hi")\n    public String sayHi(@RequestParam String name) {\n        return schedualServiceHi.sayHiFromClientOne( name );\n    }\n}\n\n\n</code></pre>\n<p>启动程序，多次访问http://localhost:8765/hi?name=forezp,浏览器交替显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n<p>hi forezp,i am from port:8763</p>\n</blockquote>\n<p>Feign源码解析：http://blog.csdn.net/forezp/article/details/73480304</p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter3">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter3</a></p>\n<h3><a id="_146"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_154"></a>五、参考资料</h3>\n<p>本文参考了以下：</p>\n<p>http://blog.csdn.net/forezp/article/details/69808079</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:30'}
2020-02-05 20:12:30 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81040946', 'title': '史上最简单的SpringCloud教程 | 第二篇: 服务消费者（rest+ribbon）(Finchley版本)', 'readNum': '165444', 'commentNum': '230', 'publishTime': '2018-07-14 10:05:50', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81040946<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html</a></strong></p>\n<p>在上一篇文章，讲了服务的注册和发现。在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。</p>\n<h3><a id="ribbon_9"></a>一、ribbon简介</h3>\n<blockquote>\n<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>\n<p>-----摘自官网</p>\n</blockquote>\n<p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。</p>\n<p>ribbon 已经默认实现了这些配置bean：</p>\n<ul>\n<li>\n<p>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</p>\n</li>\n<li>\n<p>IRule ribbonRule: ZoneAvoidanceRule</p>\n</li>\n<li>\n<p>IPing ribbonPing: NoOpPing</p>\n</li>\n<li>\n<p>ServerList ribbonServerList: ConfigurationBasedServerList</p>\n</li>\n<li>\n<p>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</p>\n</li>\n<li>\n<p>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</p>\n</li>\n</ul>\n<h3><a id="_33"></a>二、准备工作</h3>\n<p>这一篇文章基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时你会发现：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。</p>\n<p>如何在idea下启动多个实例，请参照这篇文章：<br>\nhttps://blog.csdn.net/forezp/article/details/76408139</p>\n<p>访问localhost:8761如图所示：<br>\n如何一个工程启动多个实例，请看这篇文章:https://blog.csdn.net/forezp/article/details/76408139</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005109420.png" alt="在这里插入图片描述"></p>\n<h4><a id="_45"></a>三、建一个服务消费者</h4>\n<p>重新新建一个spring-boot工程，取名为：service-ribbon;<br>\n在它的pom.xml继承了父pom文件，并引入了以下依赖：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;service-ribbon&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;service-ribbon&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n        &lt;artifactId&gt;sc-f-chapter2&lt;/artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n \n\n&lt;/project&gt;\n\n</code></pre>\n<p>在工程的配置文件指定服务的注册中心地址为http://localhost:8761/eureka/，程序名称为 service-ribbon，程序端口为8764。配置文件application.yml如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8764\nspring:\n  application:\n    name: service-ribbon\n</code></pre>\n<p>在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient\npublic class ServiceRibbonApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceRibbonApplication.class, args );\n    }\n\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n}\n\n\n</code></pre>\n<p>写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下：</p>\n<pre><code>@Service\npublic class HelloService {\n\n    @Autowired\n    RestTemplate restTemplate;\n\n    public String hiService(String name) {\n        return restTemplate.getForObject("http://SERVICE-HI/hi?name="+name,String.class);\n    }\n\n\n}\n\n</code></pre>\n<p>写一个controller，在controller中用调用HelloService 的方法，代码如下：</p>\n<pre><code>\n@RestController\npublic class HelloControler {\n\n    @Autowired\n    HelloService helloService;\n\n    @GetMapping(value = "/hi")\n    public String hi(@RequestParam String name) {\n        return helloService.hiService( name );\n    }\n}\n\n\n</code></pre>\n<p>在浏览器上多次访问http://localhost:8764/hi?name=forezp，浏览器交替显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n<p>hi forezp,i am from port:8763</p>\n</blockquote>\n<p>这说明当我们通过调用restTemplate.getForObject(“http://SERVICE-HI/hi?name=”+name,String.class)方法时，已经做了负载均衡，访问了不同的端口的服务实例。</p>\n<h3><a id="_176"></a>四、此时的架构</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190601005135471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<ul>\n<li>一个服务注册中心，eureka server,端口为8761</li>\n<li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li>\n<li>sercvice-ribbon端口为8764,向服务注册中心注册</li>\n<li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li>\n</ul>\n<p>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter2">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter2</a></p>\n<h3><a id="_187"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_195"></a>五、参考资料</h3>\n<p>本文参考了以下：</p>\n<p>http://blog.csdn.net/forezp/article/details/69788938</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:30'}
2020-02-05 20:12:30 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/81040925', 'title': '史上最简单的 SpringCloud 教程 | 第一篇： 服务的注册与发现Eureka(Finchley版本)', 'readNum': '404525', 'commentNum': '251', 'publishTime': '2018-07-14 10:04:27', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/81040925<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html</a></strong></p>\n<h3><a id="spring_cloud_7"></a>一、spring cloud简介</h3>\n<p>鉴于《史上最简单的Spring Cloud教程》很受读者欢迎，再次我特意升级了一下版本，目前支持的版本为Spring Boot版本2.0.3.RELEASE,Spring Cloud版本为Finchley.RELEASE。</p>\n<p>Finchley版本的官方文档如下：<br>\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<p>spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解，如果不了解的话可以看这篇文章：<a href="http://blog.csdn.net/forezp/article/details/61472783">2小时学会springboot</a>。另外对于“微服务架构” 不了解的话，可以通过搜索引擎搜索“微服务架构”了解下。</p>\n<h3><a id="_18"></a>二、创建服务注册中心</h3>\n<p>在这里，我还是采用Eureka作为服务注册与发现的组件，至于Consul 之后会出文章详细介绍。</p>\n<p><strong>2.1 首先创建一个maven主工程。</strong></p>\n<p>首先创建一个主Maven工程，在其pom文件引入依赖，spring Boot版本为2.0.3.RELEASE，Spring Cloud版本为Finchley.RELEASE。这个pom文件作为父pom文件，起到依赖版本控制的作用，其他module工程继承该pom。这一系列文章全部采用这种模式，其他文章的pom跟这个pom一样。再次说明一下，以后不再重复引入。代码如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;sc-f-chapter1&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;name&gt;sc-f-chapter1&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt;\n    &lt;/parent&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;eureka-server&lt;/module&gt;\n        &lt;module&gt;service-hi&lt;/module&gt;\n    &lt;/modules&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>**2.2 然后创建2个model工程:**一个model工程作为服务注册中心，即Eureka Server,另一个作为Eureka Client。</p>\n<p>下面以创建server为例子，详细说明创建过程：</p>\n<p>右键工程-&gt;创建model-&gt; 选择spring initialir 如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004837909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>下一步-&gt;选择cloud discovery-&gt;eureka server ,然后一直下一步就行了。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004923262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>创建完后的工程，其pom.xml继承了父pom文件，并引入spring-cloud-starter-netflix-eureka-server的依赖，代码如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;eureka-server&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;eureka-server&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n        &lt;artifactId&gt;sc-f-chapter1&lt;/artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p><strong>2.3  启动一个服务注册中心</strong>，只需要一个注解@EnableEurekaServer，这个注解需要在springboot工程的启动application类上加：</p>\n<pre><code>\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run( EurekaServerApplication.class, args );\n    }\n}\n\n\n</code></pre>\n<p>**2.4 **eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml：</p>\n<pre><code>server:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\nspring:\n  application:\n    name: eurka-server\n      \n</code></pre>\n<p>通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server.</p>\n<p><strong>2.5</strong> eureka server 是有界面的，启动工程,打开浏览器访问：<br>\nhttp://localhost:8761 ,界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601004950234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<blockquote>\n<p>No application available 没有服务被发现 ……<sup>_</sup><br>\n因为没有注册服务当然不可能有服务被发现了。</p>\n</blockquote>\n<h3><a id="_eureka_client_189"></a>三、创建一个服务提供者 (eureka client)</h3>\n<p>当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。</p>\n<p>创建过程同server类似,创建完pom.xml如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n    &lt;artifactId&gt;service-hi&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;service-hi&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.forezp&lt;/groupId&gt;\n        &lt;artifactId&gt;sc-f-chapter1&lt;/artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@RestController\npublic class ServiceHiApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run( ServiceHiApplication.class, args );\n    }\n\n    @Value("${server.port}")\n    String port;\n\n    @RequestMapping("/hi")\n    public String home(@RequestParam(value = "name", defaultValue = "forezp") String name) {\n        return "hi " + name + " ,i am from port:" + port;\n    }\n\n}\n\n\n\n</code></pre>\n<p>仅仅@EnableEurekaClient是不够的，还需要在配置文件中注明自己的服务注册中心的地址，application.yml配置文件如下：</p>\n<pre><code>server:\n  port: 8762\n\nspring:\n  application:\n    name: service-hi\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n\n\n</code></pre>\n<p>需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。<br>\n启动工程，打开http://localhost:8761 ，即eureka server 的网址：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601005015918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862</p>\n<p>这时打开 http://localhost:8762/hi?name=forezp ，你会在浏览器上看到 :</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter1">https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter1</a></p>\n<h3><a id="_296"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_304"></a>四、参考资料</h3>\n<p>http://blog.csdn.net/forezp/article/details/69696915</p>\n<p>http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:30'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80244682', 'title': 'docker官方文档翻译5', 'readNum': '23049', 'commentNum': '0', 'publishTime': '2018-05-08 19:43:37', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/80244682<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/docker/2018/09/11/docker-trans5.html" rel="nofollow">https://www.fangzhipeng.com/docker/2018/09/11/docker-trans5.html</a></strong></p>\n<h1><a id="Stacks_7"></a>堆栈（Stacks）</h1>\n<h2><a id="_9"></a>准备工作</h2>\n<ul>\n<li>安装Docker 1.13及以上版本</li>\n<li>安装Docker Compose正如第三部分的准备工作。</li>\n<li>安装Docker Machine正如第四部分的准备工作。</li>\n<li>阅读第一部分的引导。</li>\n<li>学习怎么在第二部分创建容器。</li>\n<li>确保你已经发布friendlyhello 镜像,并推送到公共仓库。我们需要在这一部分用到这个镜像。</li>\n<li>确保你的镜像能够成为一个被部署的容器能正常工作。</li>\n<li>从第三篇文章拷贝一份docker-compose.yml</li>\n<li>确保第四部分的docker machine已经正确安装，通过docker-machine ls查看。</li>\n<li>确保docker swarm正确安装，并且运行。通过执行docker-machine ssh myvm1 "docker node ls 命令验证。</li>\n</ul>\n<h2><a id="_23"></a>介绍</h2>\n<p>在第4部分中，你学习了如何设置一个swarm，这是一群运行Docker的机器，并为其部署了一个应用程序，应用才能修包含的众多容器在多台机器上运行。</p>\n<p>在第5部分中，你将学习分布式应用程序层次结构的顶部：堆栈。 堆栈是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和伸缩。 单个堆栈能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个堆栈）。</p>\n<p>好消息是，从第3部分开始，在创建Compose文件并使用Docker堆栈部署时，从技术上讲，你一直在使用堆栈。 但是，这是在单个主机上运行的单个服务堆栈，通常不会发生在生产环境中。 在这里，你可以把你学到的东西，使多个服务相互关联，并在多台机器上运行它们。</p>\n<p>你做得很好，这就是主场！</p>\n<h2><a id="_33"></a>添加一个新服务和重新部署</h2>\n<p>添加服务到docker-compose文件是非常简单的。首先，添加一个可视化界面的服务，可以让我们查看swarm正在调度的容器。</p>\n<p>1.打开docker-compose文件，并将以下的内容替换成文件的内容。确保用你的镜像信息替换username/repo:tag 的内容。</p>\n<pre><code>version: "3"\nservices:\n  web:\n    # replace username/repo:tag with your name and image details\n    image: username/repo:tag\n    deploy:\n      replicas: 5\n      restart_policy:\n        condition: on-failure\n      resources:\n        limits:\n          cpus: "0.1"\n          memory: 50M\n    ports:\n      - "80:80"\n    networks:\n      - webnet\n  visualizer:\n    image: dockersamples/visualizer:stable\n    ports:\n      - "8080:8080"\n    volumes:\n      - "/var/run/docker.sock:/var/run/docker.sock"\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n    networks:\n      - webnet\nnetworks:\n  webnet:\n\n</code></pre>\n<p>这里新增的唯一东西就是网络对等服务，名为可视化器。 在这里注意两件新事物：一个volumes ，让可视化工具访问Docker的主机套接字文件和一个placement 键，确保这项服务只能在群集管理器上运行 - 从不是工作者。 这是因为这个容器是由Docker创建的一个开源项目构建的，它显示了在一个图表中的Swarm上运行的Docker服务。</p>\n<p>我们稍后会详细讨论lacement constraints 和volumes 。</p>\n<p>2.确保你的shell被配置为与myvm1进行通信（完整的例子在这如下）。</p>\n<ul>\n<li>\n<p>运行docker-machine ls列出机器，并确保您已连接到myvm1，如旁边的星号所示。</p>\n</li>\n<li>\n<p>如果需要，重新运行docker-machine env myvm1，然后运行给定的命令来配置shell。</p>\n</li>\n</ul>\n<p>在Mac或Linux上，命令是：</p>\n<pre><code>eval $(docker-machine env myvm1)\n</code></pre>\n<p>3.在manager上重新运行docker stack deploy命令，并且需要更新的任何服务都会更新：</p>\n<pre><code>\n$ docker stack deploy -c docker-compose.yml getstartedlab\nUpdating service getstartedlab_web (id: angi1bf5e4to03qu9f93trnxm)\nCreating service getstartedlab_visualizer (id: l9mnwkeq2jiononb5ihz9u7a4)\n\n</code></pre>\n<ol start="4">\n<li>查看可视化界面</li>\n</ol>\n<p>你在Compose文件中看到，可视化工具在端口8080上运行。通过运行docker-machine ls来获取其中一个节点的IP地址。 转到8080端口的IP地址，您可以看到可视化器正在运行：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120435252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>可视化器的单个副本按照预期在manager上运行，并且网络的5个实例遍布整个群集。 你可以通过运行docker stack ps 来确认此可视化：</p>\n<pre><code>docker stack ps getstartedlab\n\n</code></pre>\n<p>可视化器是一个独立的服务，可以在包含它的任何应用程序中运行。 它不依赖于其他任何东西。现在让我们创建一个具有依赖性的服务：提供访问者计数器的Redis服务。</p>\n<h2><a id="_113"></a>数据持久化</h2>\n<p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p>\n<ol>\n<li>保存这份新的docker-compose.yml文件，它最后添加了一个redis服务。确保用的镜像信息替换掉username/repo:tag的内容。</li>\n</ol>\n<pre><code>version: "3"\nservices:\n  web:\n    # replace username/repo:tag with your name and image details\n    image: username/repo:tag\n    deploy:\n      replicas: 5\n      restart_policy:\n        condition: on-failure\n      resources:\n        limits:\n          cpus: "0.1"\n          memory: 50M\n    ports:\n      - "80:80"\n    networks:\n      - webnet\n  visualizer:\n    image: dockersamples/visualizer:stable\n    ports:\n      - "8080:8080"\n    volumes:\n      - "/var/run/docker.sock:/var/run/docker.sock"\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n    networks:\n      - webnet\n  redis:\n    image: redis\n    ports:\n      - "6379:6379"\n    volumes:\n      - "/home/docker/data:/data"\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n    command: redis-server --appendonly yes\n    networks:\n      - webnet\nnetworks:\n  webnet:\n\n</code></pre>\n<p>Redis在Docker库中有一个正式镜像，并且已被授予redis的简短镜像名称，所以在这里没有username/repo符号。 Redis端口6379已经由Redis预先配置为从容器暴露给主机，并且在我们的Compose文件中，我们将它从主机展示给所有容器，因此你可以实际输入任何IP的IP 节点添加到Redis桌面管理器中并管理此Redis实例，如果愿意的话。</p>\n<p>最重要的是，redis规范中有几件事情使数据在这个堆栈的部署之间持久化：</p>\n<ul>\n<li>redis总是在管理器上运行，所以它总是使用相同的文件系统。</li>\n<li>redis在主机文件系统中访问任意目录作为容器内的/ data，这是Redis存储数据的地方。</li>\n</ul>\n<p>这就是在主机物理文件系统中为Redis数据创建“source of truth”。 如果没有这个，Redis会将其数据存储在容器文件系统中的/ data中，如果该容器曾经被重新部署，该数据将被清除。</p>\n<p>真实的数据源（source of truth）由2部分组成：</p>\n<ul>\n<li>放置在Redis服务上的 placement constraint，确保它始终使用相同的主机。</li>\n<li>创建的volume ，允许容器作为/ data（位于Redis容器内）访问./data（在主机上）。 在容器重复开启和关闭时，存储在指定主机上的./data文件仍然存在，从而保持连续性。</li>\n</ul>\n<p>2.在manager上创建一个./data目录</p>\n<pre><code>docker-machine ssh myvm1 "mkdir ./data"\n\n</code></pre>\n<p>3.确保你的shell被配置为与myvm1进行通信（完整的例子在这里）。</p>\n<ul>\n<li>运行docker-machine ls命令，列出所有的机器和确保你已经连上myvm1。</li>\n<li>如果需要，重新运行docker-machine env myvm1命令，然后再运行以下命令：</li>\n</ul>\n<pre><code>eval $(docker-machine env myvm1)\n</code></pre>\n<ol start="4">\n<li>运行docker stack deploy命令</li>\n</ol>\n<pre><code>$ docker stack deploy -c docker-compose.yml getstartedlab\n</code></pre>\n<p>5.运行docker service ls命令，去验证这三个服务跟预期一样正常运行。</p>\n<pre><code>$ docker service ls\nID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS\nx7uij6xb4foj        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;6379/tcp\nn5rvhm52ykq7        getstartedlab_visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;8080/tcp\nmifd433bti1d        getstartedlab_web          replicated          5/5                 orangesnap/getstarted:latest    *:80-&gt;80/tcp\n\n\n</code></pre>\n<p>6.查看你的机器的一个节点的web页面，比如http://192.168.99.101，并且查看访客计数的结果，该计数现在已经存在并将信息存储在Redis上。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120511880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>另外，请检查任一节点IP地址的端口8080处的可视化工具，并注意查看随Web和可视化工具一起运行的redis服务。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120545806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_221"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80186178', 'title': 'docker官方文档翻译4', 'readNum': '23614', 'commentNum': '0', 'publishTime': '2018-05-03 20:36:09', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/80186178<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/docker/2018/09/11/docker-trans4.html" rel="nofollow">https://www.fangzhipeng.com/docker/2018/09/11/docker-trans4.html</a></strong></p>\n<h1><a id="Swarms_7"></a>第四篇：Swarms</h1>\n<h2><a id="_9"></a>准备工作</h2>\n<ul>\n<li>安装Docker版本1.13或更高版本。</li>\n<li>安装Docker compose。</li>\n<li>安装docker machine</li>\n<li>阅读第1 2 3部分的内容。</li>\n<li>确保你已发布并推送到注册仓库的friendlyhello镜像。</li>\n<li>确保你的镜像可以部署为一个容器。 运行这个命令，在你的信息中插入用户名，repo和标签：docker run -p 80:80 username / repo：tag，然后访问http：// localhost /。</li>\n<li>第3部分复制docker-compose.yml文件。</li>\n</ul>\n<h2><a id="_19"></a>介绍</h2>\n<p>在第3部分中，介绍了你在第2部分中编写的应用程序，并定义了它应该如何在生产环境中运行，将其转化为服务，并在此过程中将其扩展5倍实例。</p>\n<p>在第4部分中，将此应用程序部署到群集上，并在多台机器上运行它。 通过将多台机器连接到称为swarm的“Dockerized”群集，使多容器，多机器应用成为可能。</p>\n<h2><a id="Swarm_clusters_25"></a>理解Swarm clusters</h2>\n<p>Swarm是一组运行Docker并加入到集群中的机器。加入到集群中之后，你将继续运行你习惯的Docker命令，但现在它现在在Docker Swarm的集群上执行。集群中的机器可以是物理的也可以是虚拟的。加入集群后，单个容器被称为节点。</p>\n<p>Swarm manager可以使用多种策略来运行容器，例如“emptiest node” - 它可以使用容器填充使用率最低的机器。或者“global”，它确保每台机器只获取指定容器的一个实例。swarm managerd的这些策略需要在Compose文件中指定。</p>\n<p>Swarm manager是群体中唯一可以执行你的命令的机器，或者授权其他机器作为worker加入到群体中。workers只是在那里提供能力，并没有权力告诉任何其他机器可以做什么和不可以做什么。</p>\n<p>到目前为止，您已经在本地机器上以单主机模式使用Docker。但是Docker也可以切换到群集模式，这就是使用群集的原因。立即启用群模式使当前的机器成为群管理器。从此，Docker将运行您在您管理的群集上执行的命令，而不仅仅是在当前机器上执行。</p>\n<h2><a id="_35"></a>设置你的集群</h2>\n<p>一个swarm是由多个节点组成，节点可以是物理或者虚拟的机器。它的基本概念足够简单：运行docker swarm init 命令能够开启swarm模式，并且使你的当前机器成为swarm manager,运行docker swarm join命令能够让其他机器加入到 swarm 中成为worker机器。选择的下面的选项卡，看看它是如何各自情况下发挥作用的。我们使用虚拟机快速创建一个双机集群，并且将其变成swarm.</p>\n<h2><a id="_39"></a>创建集群</h2>\n<p>你需需要一个可以创建虚拟机（VM）的虚拟机管理程序，因此请为你的计算机的操作系统安装Oracle VirtualBox。</p>\n<p>现在，创建两个vm使用docker-machine ，使用VirtualBox 驱动：</p>\n<pre><code>docker-machine create --driver virtualbox myvm1\ndocker-machine create --driver virtualbox myvm2\n\n</code></pre>\n<h3><a id="vmip_51"></a>查看vm列表并获取它们的ip地址</h3>\n<p>你现在有2个vms创建，名字为myvm1和myvm2。</p>\n<pre><code>$ docker-machine ls\nNAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS\nmyvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.06.2-ce   \nmyvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.06.2-ce   \n</code></pre>\n<h3><a id="swarm__61"></a>初始化swarm 并且添加节点</h3>\n<p>第一个机器扮演的是manager的角色，它可以执行管理命令并且验证worker 加入到 swarm中去，第二个是worker。</p>\n<p>你可能发送命令到您的vms通过docker-machine ssh。指示myvm1成为一个拥有docker swarm init的swarm manager并输出如下：</p>\n<pre><code>$ docker-machine ssh myvm1 "docker swarm init --advertise-addr &lt;myvm1 ip&gt;"\nSwarm initialized: current node &lt;node ID&gt; is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n  docker swarm join \\\n  --token &lt;token&gt; \\\n  &lt;myvm ip&gt;:&lt;port&gt;\n\nTo add a manager to this swarm, run \'docker swarm join-token manager\' and follow the instructions.\n\n</code></pre>\n<p>如您所见，对docker swarm init的响应包含一个预配置的docker swarm join命令，您可以在要添加的任何节点上运行该命令。 复制这个命令，并通过docker-machine ssh将它发送到myvm2，让myvm2作为一个worker加入你的新群体：</p>\n<pre><code>$ docker-machine ssh myvm2 "docker swarm join \\\n--token &lt;token&gt; \\\n&lt;ip&gt;:2377"\n\nThis node joined a swarm as a worker.\n\n</code></pre>\n<p>恭喜，你已经成功创建了你的第一个swarm。</p>\n<p>运行docker node ls在manager机器上去查看swarm 中的节点：</p>\n<pre><code>$ docker-machine ssh myvm1 "docker node ls"\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS\nbrtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               Active\nrihwohkh3ph38fhillhhb84sk *   myvm1               Ready               Active              Leader\n\n</code></pre>\n<h2><a id="swarm_cluster_104"></a>发布你的应用到swarm cluster中去</h2>\n<p>最难的部分已经完结。现在你只需要重复再第三部分的过程将应用发布到你的swarm中去。请记住只有像myvm1这样的群集管理器才能执行Docker命令; worker只是用来工作的。</p>\n<h2><a id="dockermachineswarm_manager_108"></a>配置一个docker-machine命令成为swarm manager</h2>\n<p>到目前为止，你已经在Docker-machine ssh中将Docker命令包装为与虚拟机交谈。 另一种选择是运行docker-machine env 来获取并运行一个命令，该命令将当前shell配置为与VM上的Docker守护进程进行通信。 此方法对下一步更好，因为它允许您使用本地docker-compose.yml文件“远程”部署应用程序，而无需将其复制到任何位置。</p>\n<p>键入docker-machine env myvm1，然后复制粘贴并运行作为输出最后一行提供的命令，以将shell配置为与swarm管理器myvm1对话。</p>\n<p>配置shell的命令根据你是Mac，Linux还是Windows而有所不同，因此下面的选项卡中显示了每个命令的示例。</p>\n<h3><a id="MACLINUXDOCKER_MACHINE_SHELL_116"></a>MAC或LINUX上的DOCKER MACHINE SHELL环境</h3>\n<p>运行docker-machine env myvm1命令去得到命令配置你的shell与myvm1交互。</p>\n<pre><code>$ docker-machine env myvm1\nexport DOCKER_TLS_VERIFY="1"\nexport DOCKER_HOST="tcp://192.168.99.100:2376"\nexport DOCKER_CERT_PATH="/Users/sam/.docker/machine/machines/myvm1"\nexport DOCKER_MACHINE_NAME="myvm1"\n# Run this command to configure your shell:\n# eval $(docker-machine env myvm1)\n\n</code></pre>\n<p>运行给定的命令来配置你的shell与myvm1进行通信。</p>\n<pre><code>eval $(docker-machine env myvm1)\n\n</code></pre>\n<p>运行docker-machine ls命令去校验现在这个活动的机器，如旁边的星号所示。：</p>\n<pre><code>$ docker-machine ls\nNAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS\nmyvm1   *        virtualbox   Running   tcp://192.168.99.100:2376           v17.06.2-ce   \nmyvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.06.2-ce   \n\n\n</code></pre>\n<h2><a id="swarm_manager_149"></a>在swarm manager中部署容器</h2>\n<p>现在你已经有了myvm1，你可以使用它的权利作为swarm manager器发布你的app通过使用第3部分中用于myvm1的相同docker stack deploy命令和docker-compose.yml的本地副本来部署您的应用程序。此命令可能需要几秒钟才能完成，部署的服务需要一段时间才能提供服务。在swarm管理器上使用docker service ps &lt;service_name&gt;命令验证所有服务是否已被重新部署。</p>\n<p>你通过docker-machine shell配置连接到myvm1，并且你仍然可以访问本地主机上的文件。 确保你和之前操作在同一个目录下，其中包括你在第3部分中创建的docker-compose.yml文件。</p>\n<p>和之前一样，运行下面的命令在mym1机器上部署应用。</p>\n<pre><code>docker stack deploy -c docker-compose.yml getstartedlab\n\n</code></pre>\n<p>正是这样，应用在swarm 集群中国部署了！</p>\n<p>现在，你可以使用第3部分中使用的相同docker命令。只有这一次，请注意，服务（及相关容器）已在myvm1和myvm2之间分配。</p>\n<pre><code>$ docker stack ps getstartedlab\n\nID            NAME                  IMAGE                   NODE   DESIRED STATE\njq2g3qp8nzwx  getstartedlab_web.1   john/get-started:part2  myvm1  Running\n88wgshobzoxl  getstartedlab_web.2   john/get-started:part2  myvm2  Running\nvbb1qbkb0o2z  getstartedlab_web.3   john/get-started:part2  myvm2  Running\nghii74p9budx  getstartedlab_web.4   john/get-started:part2  myvm1  Running\n0prmarhavs87  getstartedlab_web.5   john/get-started:part2  myvm2  Running\n\n</code></pre>\n<h2><a id="_179"></a>访问你的集群</h2>\n<p>你可以从myvm1或myvm2的IP地址访问你的应用程序。</p>\n<p>你创建的网络在它们之间共享并负载平衡。 运行docker-machine ls来获取虚拟机的IP地址，并在浏览器中访问它们中的任何一个，并刷新（或者通过curl请求）。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzMvMTYzMjVmZTBhNzFiNmFiYg?x-oss-process=image/format,png" alt="image"></p>\n<p>有五个可能的容器ID全部随机轮训，来实现负载平衡。</p>\n<p>两个IP地址工作的原因是群中的节点参与入口路由网格。 这可以确保部署在群集中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。 以下是三节点群上端口8080上发布的名为my-web的服务的路由网格示意图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120651372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_193"></a>迭代和扩展应用程序</h2>\n<p>从这里你可以完成你在第二部分和第三部分中学到的一切。</p>\n<p>通过更改docker-compose.yml文件来扩展应用程序。</p>\n<p>通过编辑代码更改应用程序行为，然后重新构建并推送新镜像。 （要做到这一点，请按照与之前构建应用程序和发布镜像相同的步骤进行操作。</p>\n<p>无论哪种情况，只需简单地再次运行docker stack deploy来部署这些更改。</p>\n<p>你可以使用你在myvm2上使用的相同docker swarm join命令将任何物理或虚拟机器加入此群集。之后只需运行Docker堆栈部署，并且你的应用可以利用新资源。</p>\n<h2><a id="_206"></a>清除和重启</h2>\n<h3><a id="Stacks_and_swarms_208"></a>Stacks and swarms（堆栈和集群）</h3>\n<p>你能通过docker stack rm卸载堆栈。例如：</p>\n<pre><code>docker stack rm getstartedlab\n\n</code></pre>\n<h3><a id="dockermachine_shell_218"></a>取消设置docker-machine shell变量设置</h3>\n<p>你可以使用给定的命令取消当前shell中的docker-machine环境变量。在mac或者linux环境中命令如下：</p>\n<pre><code> eval $(docker-machine env -u)\n</code></pre>\n<p>这将shell与docker-machine创建的虚拟机断开连接，并允许您继续在同一个shell中工作，现在使用本机docker命令（例如，在Docker for Mac或Docker for Windows上）。 要了解更多信息，请参阅关于取消设置环境变量的机器主题。</p>\n<h2><a id="Docker_machines_228"></a>重启Docker machines</h2>\n<p>如果不关闭你的本地主机，Docker machines将会停止运行。你能通过运行docker-machine ls命令来检查机器的状态。</p>\n<pre><code>$ docker-machine ls\nNAME    ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORS\nmyvm1   -        virtualbox   Stopped                 Unknown\nmyvm2   -        virtualbox   Stopped                 Unknown\n\n</code></pre>\n<p>要重新启动已停止的计算机，请运行以下命令：</p>\n<pre><code>docker-machine start &lt;machine-name&gt;\n\n</code></pre>\n<p>例如：</p>\n<pre><code>\n$ docker-machine start myvm1\nStarting "myvm1"...\n(myvm1) Check network to re-create if needed...\n(myvm1) Waiting for an IP...\nMachine "myvm1" was started.\nWaiting for SSH to be available...\nDetecting the provisioner...\nStarted machines may have new IP addresses. You may need to re-run the `docker-machine env` command.\n\n$ docker-machine start myvm2\nStarting "myvm2"...\n(myvm2) Check network to re-create if needed...\n(myvm2) Waiting for an IP...\nMachine "myvm2" was started.\nWaiting for SSH to be available...\nDetecting the provisioner...\nStarted machines may have new IP addresses. You may need to re-run the `docker-machine env` command.\n\n</code></pre>\n<h2><a id="_271"></a>总结</h2>\n<p>在第4部分中，你了解了群体是什么，群体中的节点如何成为manager或workwer，创建群体并在其上部署应用程序。 你看到Docker的核心命令并没有从第3部分改变，他们只需要将目标锁定在swarm master上。 你还看到了Docker网络的力量，即使它们运行在不同的机器上，也可以跨容器保持负载平衡请求。 最后，你学习了如何在集群上迭代和缩放应用程序。</p>\n<p>以下是一些您可能想要运行的命令，以便与你的群集和虚拟机进行一点交互：</p>\n<pre><code>docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)\ndocker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1 # Win10\ndocker-machine env myvm1                # View basic information about your node\ndocker-machine ssh myvm1 "docker node ls"         # List the nodes in your swarm\ndocker-machine ssh myvm1 "docker node inspect &lt;node ID&gt;"        # Inspect a node\ndocker-machine ssh myvm1 "docker swarm join-token -q worker"   # View join token\ndocker-machine ssh myvm1   # Open an SSH session with the VM; type "exit" to end\ndocker node ls                # View nodes in swarm (while logged on to manager)\ndocker-machine ssh myvm2 "docker swarm leave"  # Make the worker leave the swarm\ndocker-machine ssh myvm1 "docker swarm leave -f" # Make master leave, kill swarm\ndocker-machine ls # list VMs, asterisk shows which VM this shell is talking to\ndocker-machine start myvm1            # Start a VM that is currently not running\ndocker-machine env myvm1      # show environment variables and command for myvm1\neval $(docker-machine env myvm1)         # Mac command to connect shell to myvm1\n&amp; "C:\\Program Files\\Docker\\Docker\\Resources\\bin\\docker-machine.exe" env myvm1 | Invoke-Expression   # Windows command to connect shell to myvm1\ndocker stack deploy -c &lt;file&gt; &lt;app&gt;  # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file\ndocker-machine scp docker-compose.yml myvm1:~ # Copy file to node\'s home dir (only required if you use ssh to connect to manager and deploy the app)\ndocker-machine ssh myvm1 "docker stack deploy -c &lt;file&gt; &lt;app&gt;"   # Deploy an app using ssh (you must have first copied the Compose file to myvm1)\neval $(docker-machine env -u)     # Disconnect shell from VMs, use native docker\ndocker-machine stop $(docker-machine ls -q)               # Stop all running VMs\ndocker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images\n\n</code></pre>\n<h3><a id="_303"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80171723', 'title': 'docker官方文档翻译3', 'readNum': '23836', 'commentNum': '2', 'publishTime': '2018-05-02 20:43:00', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/80171723<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/docker/2018/09/11/docker-trans3.html" rel="nofollow">https://www.fangzhipeng.com/docker/2018/09/11/docker-trans3.html</a></strong></p>\n<h1><a id="__6"></a>第三部分： 服务</h1>\n<h2><a id="_8"></a>准备工作</h2>\n<ul>\n<li>安装Docker 1.13及以上版本。</li>\n<li>安装Docker Compose</li>\n<li>阅读第一部分和第二部分的内容。</li>\n<li>确保你已经发布friendlyhello镜像到docker公共仓库。</li>\n<li>确保你的镜像能够作为一个可以部署的容器。 运行这个命令，在你的信息中插入用户名，repo和tag：docker run -p 80:80 username / repo：tag，然后访问http：// localhost /。</li>\n</ul>\n<h2><a id="_17"></a>介绍</h2>\n<p>第3部分，我们扩展了我们的应用并实现了负载均衡。 要做到这一点，我们必须在分布式应用程序的层次结构中升级一级：服务。</p>\n<p>堆<br>\n服务（你在这里）<br>\n容器（在第2部分涵盖）</p>\n<h2><a id="_26"></a>关于服务</h2>\n<p>在分布式应用程序中，应用程序的不同部分被称为“服务”。例如，如果你想象一个视频共享站点，它可能包含一个用于将应用程序数据存储在数据库中的服务，一个用于在后台进行视频转码的服务 用户上传的东西，前端的服务等等。</p>\n<p>服务实际上只是“生产中的容器”。一个服务只运行一个镜像，但它编码镜像运行的方式 - 应该使用哪个端口，容器应运行多少个副本，以便服务具有所需的容量，以及 等等。 缩放服务会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p>\n<p>幸运的是，使用Docker平台定义，运行和扩展服务非常简单 - 只需编写一个docker-compose.yml文件即可。</p>\n<h2><a id="dockercomposeyml_35"></a>你的第一个docker-compose.yml文件</h2>\n<p>docker-compose.yml文件是一个YAML格式的文件，它定义了Docker容器在生产中的行为方式。</p>\n<h3><a id="dockercomposeyml_39"></a>docker-compose.yml</h3>\n<p>将这个文件保存为docker-compose.yml，无论你在什么时候想用。 确保你已将第2部分中创建的图像推送到注册仓库中，并通过用你的镜像，替换username / repo：标签来更新此.yml。</p>\n<pre><code>version: "3"\nservices:\n  web:\n    # replace username/repo:tag with your name and image details\n    image: username/repo:tag\n    deploy:\n      replicas: 5\n      resources:\n        limits:\n          cpus: "0.1"\n          memory: 50M\n      restart_policy:\n        condition: on-failure\n    ports:\n      - "80:80"\n    networks:\n      - webnet\nnetworks:\n  webnet:\n\n</code></pre>\n<p>这个docker-compose.yml文件告诉Docker执行以下操作：</p>\n<ul>\n<li>从注册表中拉出我们在第二部分中上传的镜像。</li>\n<li>运行该镜像的5个实例作为名为web的服务，限制每个实例使用最多10％的CPU（所有的内核）和50MB的RAM。</li>\n<li>如果一个失败，立即重启容器。</li>\n<li>将主机上的端口80映射到Web的端口80。</li>\n<li>指示web容器通过称为webnet的负载平衡网络共享端口80。 （在内部，容器本身在临时端口上发布到web的端口80）。</li>\n<li>使用默认设置（这是一个负载平衡覆盖网络）定义webnet网络。</li>\n</ul>\n<h2><a id="_75"></a>运行你的负载均衡应用</h2>\n<p>在我们可以使用docker stack deploy命令之前，我们首先运行：</p>\n<pre><code>docker swarm init\n\n</code></pre>\n<p>现在我们来运行它。 你需要给你的应用一个名字。在这里，取名为getstartedlab：</p>\n<pre><code>docker stack deploy -c docker-compose.yml getstartedlab\n\n</code></pre>\n<p>我们的单一服务堆栈在一台主机上运行了5个我们部署映像的容器实例。</p>\n<p>在我们的应用程序中获取一项服务的服务ID：</p>\n<pre><code>docker service ls\n\n</code></pre>\n<p>查找Web服务的输出，并以你的应用程序名称作为前缀。如果你将其命名为与此示例中显示的相同，则名称为getstartedlab_web。还列出了服务ID以及副本数量，映像名称和端口暴露量。</p>\n<p>在服务中运行的单个容器称为任务。任务会获得数值增加的唯一ID，最大数量为您在docker-compose.yml中定义的副本数量。 列出您的服务的任务：</p>\n<pre><code>docker service ps getstartedlab_web\n\n</code></pre>\n<p>如果您只列出系统中的所有容器，但也不会显示服务过滤的任务，任务也会显示出来：</p>\n<pre><code>docker container ls -q\n</code></pre>\n<p>您可以连续多次运行curl -4 http：// localhost，或者在浏览器上访问该URL并刷新几次。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120741475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>无论哪种方式，容器ID都会发生变化，从而表明有负载均衡的功能; 在每个请求中，以循环的策略选择5个任务中的一个来响应。 容器ID与前一个命令（docker container ls -q）的输出相匹配。</p>\n<h2><a id="_122"></a>扩展你的应用</h2>\n<p>你可以通过更改docker-compose.yml中的副本数量的值，保存更改并重新运行docker stack deploy命令来扩展应用程序：</p>\n<pre><code>docker stack deploy -c docker-compose.yml getstartedlab\n\n</code></pre>\n<p>Docker执行一个就地更新，不需要先撕下堆栈或杀死任何容器。</p>\n<p>现在，重新运行docker container ls -q以查看重新配置的已部署实例。 如果你扩大了副本数，则会启动更多任务，从而启动更多容器。</p>\n<h2><a id="swarm_135"></a>关闭应用程序和swarm</h2>\n<ul>\n<li>关闭应用用docker stack rm命令:</li>\n</ul>\n<pre><code>docker stack rm getstartedlab\n</code></pre>\n<ul>\n<li>关闭swarm</li>\n</ul>\n<pre><code>docker swarm leave --force\n\n</code></pre>\n<p>使用Docker来升级和扩展应用程序同样简单。 你已经朝着学习如何在生产中运行容器迈出了一大步。 接下来，您将学习如何将这个应用程序作为Docker机器集群上的真正群体运行。</p>\n<h2><a id="_151"></a>复习</h2>\n<p>总而言之，在输入docker run是非常简单的，生产环境中的容器的真正实现就是将其作为服务来运行的。 服务在Compose文件中编写了容器的行为，此文件可用于容器扩容，限制和重新部署我们的应用程序。 对服务的更改可以在运行时适用，使用启动服务的相同命令：docker stack deploy。</p>\n<p>现阶段需要探索的一些命令如下：</p>\n<pre><code>docker stack ls                                            # List stacks or apps\ndocker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose file\ndocker service ls                 # List running services associated with an app\ndocker service ps &lt;service&gt;                  # List tasks associated with an app\ndocker inspect &lt;task or container&gt;                   # Inspect task or container\ndocker container ls -q                                      # List container IDs\ndocker stack rm &lt;appname&gt;                             # Tear down an application\ndocker swarm leave --force      # Take down a single node swarm from the manager\n\n</code></pre>\n<p>关注我：</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80158062', 'title': 'Docker官方文档翻译2', 'readNum': '25310', 'commentNum': '1', 'publishTime': '2018-05-01 17:40:30', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/80158062<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/docker/2018/09/11/dokcer-trans2.html" rel="nofollow">https://www.fangzhipeng.com/docker/2018/09/11/dokcer-trans2.html</a></strong></p>\n<h1><a id="_7"></a>容器</h1>\n<h2><a id="_9"></a>准备工作</h2>\n<ul>\n<li>安装Docker，版本为1.13或者1.13之上。</li>\n<li>阅读第一篇文章的内容</li>\n<li>给你的Docker环境一个快速的测试，确保所有的工作准备就绪：</li>\n</ul>\n<blockquote>\n<p>docker run hello-world</p>\n</blockquote>\n<h2><a id="_18"></a>介绍</h2>\n<p>是时候以Docker的方式开始构建一个应用程序了。我们从这个层次结构的底部开始，即它是一个容器，这是我们在这个界面上介绍的。在这个层次（容器？）之上是一个服务，它定义了容器在生产环境中的表现行为，在下一篇文章中我们会进行探讨。最后，在顶层是堆栈，定义了第5篇文章中介绍的所有服务的交互。</p>\n<ul>\n<li>堆栈（第五篇文章介绍）</li>\n<li>服务（第三篇文章介绍）</li>\n<li>容器（这篇文章介绍，you are here）</li>\n</ul>\n<h2><a id="_26"></a>你的新的开发环境</h2>\n<p>在过去，如果你写一个pyhton的应用，你的第一步是在你的机器上安装python的开发环境。但是需要你的机器上的运行环境与应用程序完美适合，并且也需要匹配生产环境。</p>\n<p>利用docker,你能移植一个便捷的python的运行库作为镜像，无需安装。然后，通过构建包含python运行环境和你的应用代码一起的镜像，能够确保你的代码和运行环境完美结合并运行。</p>\n<p>这些便捷的镜像通过被称作DockeFile的文件定义。</p>\n<h2><a id="Dockerfile_34"></a>通过Dockerfile定义一个镜像</h2>\n<p>dockerfile定义了在容器内部跑什么运行环境。访问网络接口和磁盘驱动器等资源是在此环境中虚拟化的，与系统其余部分隔离，因此你需要将端口映射到外部世界，并明确要将哪些文件“复制”到 运行的环境。 然而，在完成这些之后，你可以预期，在此Dockerfile中定义的应用程序的构建在运行时的行为完全相同。</p>\n<h3><a id="Dockerfile_39"></a>Dockerfile</h3>\n<p>创建一个空的文件夹。通过cd命令进入到新创建的文件夹，创建一个文件取名Dockerfile，复制以下内容到文件中，并保存。</p>\n<pre><code># Use an official Python runtime as a parent image\nFROM python:2.7-slim\n\n# Set the working directory to /app\nWORKDIR /app\n\n# Copy the current directory contents into the container at /app\nADD . /app\n\n# Install any needed packages specified in requirements.txt\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Define environment variable\nENV NAME World\n\n# Run app.py when the container launches\nCMD ["python", "app.py"]\n\n</code></pre>\n<p>这个Dockerfile关联了2个我们还没有创建的文件，，即app.py和requirements.txt。下面我们来创建。</p>\n<h2><a id="_69"></a>应用程序部分</h2>\n<p>创建2个文件，requirements.txt和app.py，并且将它们放到和Dockerfile放进同一个文件夹中。这就完成了我们的应用，你可以发现用创建应用很简单。当上面的Dockerfile构建成镜像,app.py和requirements.txt通过Add命令加入到镜像去了，Expose命令能够暴露端口，可以通过http访问。</p>\n<h3><a id="requirementstxt_73"></a>requirements.txt</h3>\n<pre><code>Flask\nRedis\n\n</code></pre>\n<h3><a id="apppy_82"></a>app.py</h3>\n<pre><code>\nfrom flask import Flask\nfrom redis import Redis, RedisError\nimport os\nimport socket\n\n# Connect to Redis\nredis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)\n\napp = Flask(__name__)\n\n@app.route("/")\ndef hello():\n    try:\n        visits = redis.incr("counter")\n    except RedisError:\n        visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"\n\n    html = "&lt;h3&gt;Hello {name}!&lt;/h3&gt;" \\\n           "&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;" \\\n           "&lt;b&gt;Visits:&lt;/b&gt; {visits}"\n    return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)\n\nif __name__ == "__main__":\n    app.run(host=\'0.0.0.0\', port=80)\n\n</code></pre>\n<p>现在我们看到pip install -r requirements.txt为Python安装Flask和Redis库，并且该应用程序打印环境变量NAME以及调用socket.gethostname（）的输出。 最后，因为Redis没有运行（因为我们只安装了Python库，而不是Redis本身），所以我们应该期望在这里尝试使用它会失败并产生错误消息。</p>\n<p>那正是要点！ 您的系统上不需要Python或任何requirements.txt文件，也不需要在您的系统上安装或运行此映像。看起来你并没有真正用Python和Flask建立一个环境，但是你已经拥有了。</p>\n<h2><a id="_118"></a>构建应用</h2>\n<p>我们已经为构建应用做好了准备。确保你对新建的文件与最高的权限。下面是通过ls命令，应该显示以下内容：</p>\n<pre><code>$ ls\nDockerfile\t\tapp.py\t\t\trequirements.txt\n\n</code></pre>\n<p>现在运行构建命令。创建一个Docker镜像，通过-t标记，从而使镜像有一个友好的名字。</p>\n<pre><code>docker build -t friendlyhello .\n\n</code></pre>\n<p>你构建的镜像在哪里？在你的机器的本地Docker镜像注册库“</p>\n<pre><code>\n$ docker image ls\n\nREPOSITORY            TAG                 IMAGE ID\nfriendlyhello         latest              326387cea398\n\n</code></pre>\n<h3><a id="_146"></a>运行应用</h3>\n<p>运行应用程序，使用-p将机器的端口4000映射到容器的已发布端口80：</p>\n<pre><code>docker run -p 4000:80 friendlyhello\n\n</code></pre>\n<p>你应该在http://0.0.0.0:80看到一条消息，Python正在为你的应用程序提供服务。 但是该消息来自容器内部，它不知道将该容器的端口80映射到4000，</p>\n<p>在浏览器中http://localhost:4000 可以查看网页上显示的显示内容。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601120835722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>你也可以通过curl命令查看相同的内容:</p>\n<pre><code>\n$ curl http://localhost:4000\n\n&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 8fc990912a14&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;\n\n</code></pre>\n<p>这个4000：80的端口重映射是为了演示Dockerfile中的EXPOSE与使用docker run -p发布的内容之间的区别。 在后面的步骤中，我们只需将主机上的端口80映射到容器中的端口80并使用http：// localhost。</p>\n<p>按CTRL+C结束进程。</p>\n<p>现在可以让应用程序在后端进程中运行，用detached 模式。</p>\n<pre><code>docker run -d -p 4000:80 friendlyhello\n</code></pre>\n<p>你可以获取应用的容器ID，通过容器ID将应用程序停止。 容器正在后台运行。 可以使用docker container ls命令查看缩写的容器ID：</p>\n<pre><code>$ docker container ls\nCONTAINER ID        IMAGE               COMMAND             CREATED\n1fa4ab2cf395        friendlyhello       "python app.py"     28 seconds ago\n\n</code></pre>\n<p>现在用docker containner stop 命令结束进程，需要用到 container id，如下：</p>\n<pre><code>docker container stop 1fa4ab2cf395\n</code></pre>\n<h2><a id="_197"></a>分享你的镜像：</h2>\n<p>为了演示我们刚才创建的容器具有可移植性，我们上传我们构建的映像并可以在其他的任何地方运行。 毕竟，当你想要将容器部署到生产环境时，弄需要知道如何推送注册仓库。</p>\n<p>注册仓库是存储库的集合，而存储库是图像的集合 - 有点像GitHub存储库，但代码已经创建。 注册仓库上的帐户可以创建许多存储库。 docker CLI默认使用Docker的公共注册库。</p>\n<h2><a id="dokcer_Id_204"></a>登录dokcer Id</h2>\n<p>如果你还没有Docker帐户，请在网站cloud.docker.com注册一个帐户。 记下你的用户名。</p>\n<p>登录到本地计算机上的Docker公共注册库。</p>\n<pre><code>$ docker login\n\n</code></pre>\n<h2><a id="_217"></a>标记镜像</h2>\n<p>将本地映像与注册库中的存储库相关联的命令是username / repository：tag。 该标签是可选的，但建议使用，因为它是注册管理机构用于为Docker镜像提供版本的机制。 为该上下文提供存储库并标记有意义的名称，例如get-started：part2。 这将图像放入启动存储库并将其标记为part2。</p>\n<p>现在，把它放在一起来标记图像。使用你的用户名，存储库和标签名称运行码头标签图像，以便将图像上传到您想要的目的地。 该命令的语法是：</p>\n<pre><code>docker tag image username/repository:tag\n</code></pre>\n<p>比如：</p>\n<pre><code>docker tag friendlyhello john/get-started:part2\n\n</code></pre>\n<p>运行 docker image ls 命令去查看你的新的标记的镜像。</p>\n<pre><code>$ docker image ls\n\nREPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nfriendlyhello            latest              d9e555c53008        3 minutes ago       195MB\njohn/get-started         part2               d9e555c53008        3 minutes ago       195MB\npython                   2.7-slim            1c7128a655f6        5 days ago          183MB\n...\n\n</code></pre>\n<h2><a id="_247"></a>推送镜像</h2>\n<p>上传你的标记的镜像去仓库</p>\n<pre><code>docker push username/repository:tag\n\n</code></pre>\n<p>完成后，此上传的结果将公开发布。 如果你登录到Docker Hub，则可以通过其pull命令在那里看到新映像。</p>\n<h2><a id="_259"></a>从远程仓库获取并运行镜像</h2>\n<p>从现在起，你可以使用docker run并使用此命令在任何机器上运行你的应用程序：</p>\n<pre><code>docker run -p 4000:80 username/repository:tag\n</code></pre>\n<p>如果镜像在本地机器没有，docker 从仓库中拉取。</p>\n<pre><code>$ docker run -p 4000:80 john/get-started:part2\nUnable to find image \'john/get-started:part2\' locally\npart2: Pulling from john/get-started\n10a267c67f42: Already exists\nf68a39a6a5e4: Already exists\n9beaffc0cf19: Already exists\n3c1fe835fb6b: Already exists\n4c9f1fa8fcb8: Already exists\nee7d8f576a14: Already exists\nfbccdcced46e: Already exists\nDigest: sha256:0601c866aab2adcc6498200efd0f754037e909e5fd42069adeff72d1e2439068\nStatus: Downloaded newer image for john/get-started:part2\n * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)\n\n</code></pre>\n<p>无论docker run在哪里执行，它都会将你的镜像以及Python和requirements.txt中的所有依赖关系一起提取出来，并运行你的代码。 它们都在一个整洁的小包中，并且您不需要在主机上安装任何Docker。</p>\n<h2><a id="_288"></a>总结</h2>\n<p>这就是这个页面的内容。 在下一节中，我们将学习如何通过在服务中运行此容器来扩展我们的应用程序。</p>\n<h2><a id="_292"></a>命令复习</h2>\n<p>这里列出了这个页面的基本Docker命令，以及一些相关的命令，如果你想在继续之前探索一下。</p>\n<pre><code>\nocker build -t friendlyhello .  # Create image using this directory\'s Dockerfile\ndocker run -p 4000:80 friendlyhello  # Run "friendlyname" mapping port 4000 to 80\ndocker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode\ndocker container ls                                # List all running containers\ndocker container ls -a             # List all containers, even those not running\ndocker container stop &lt;hash&gt;           # Gracefully stop the specified container\ndocker container kill &lt;hash&gt;         # Force shutdown of the specified container\ndocker container rm &lt;hash&gt;        # Remove specified container from this machine\ndocker container rm $(docker container ls -a -q)         # Remove all containers\ndocker image ls -a                             # List all images on this machine\ndocker image rm &lt;image id&gt;            # Remove specified image from this machine\ndocker image rm $(docker image ls -a -q)   # Remove all images from this machine\ndocker login             # Log in this CLI session using your Docker credentials\ndocker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry\ndocker push username/repository:tag            # Upload tagged image to registry\ndocker run username/repository:tag     \n</code></pre>\n<h3><a id="_316"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80098675', 'title': 'Docker官方文档翻译1', 'readNum': '29274', 'commentNum': '1', 'publishTime': '2018-04-26 19:46:17', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/80098675<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/docker/2018/09/11/docker-trans1.html" rel="nofollow">https://www.fangzhipeng.com/docker/2018/09/11/docker-trans1.html</a></strong></p>\n<p>本系列教程翻译于docker文档，文档地址：https://docs.docker.com/ ，由于某些原因,docker官方文档通常都是打不开，如果打不开，安装完docker之后，可以拉取docker文档的镜像在本地跑。安装docker完成后，输入一下命令：</p>\n<blockquote>\n<p>docker run  -it -d -p 4000:4000 docs/docker.github.io:latest</p>\n</blockquote>\n<p>在浏览器上打开localhost:4000就可以看docker 的文档了。</p>\n<p>本系列教程的翻译于2018年4月份，当时的docker版本为V18.03</p>\n<h1><a id="Docker_16"></a>Docker的相关概念</h1>\n<p>Docker 是一个为开发者和运维者去开发、发布和在容器中运行应用的平台。使用Linux容器来部署应用程序被称为容器化。 容器不是新的概念，它的优势在于很容易发布一个应用。</p>\n<p>容器化变得非常的流行，因为容器化具有以下的优点：</p>\n<ul>\n<li>灵活:即使最复杂的应用也能够被容器化。</li>\n<li>轻量：容器最大化利用和分享主机的内核。</li>\n<li>可互换：你可以即时部署更新和升级应用。</li>\n<li>便捷：你可以在本地构建应用，并部署到容器云，并在任何地方运行。</li>\n<li>可扩展: 你可以增加和自动分发容器的个数。</li>\n<li>可堆叠：您可以垂直堆叠服务并即时堆叠服务。</li>\n</ul>\n<p><img src="https://img-blog.csdn.net/20180426194439130?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>\n<h1><a id="_31"></a>镜像和容器</h1>\n<p>容器是通过运行一个镜像来启动的。镜像是一个可执行程序包，其中包含运行应用程序所需的所有内容 - 代码，运行时库，环境变量和配置文件。</p>\n<p>容器是一个镜像的运行时实例，容器是一个在内存中运行的镜像（这就是，一个镜像有了状态，或者一个用户进程）。你可以通过像linux环境敲打一个docker ps来查看一系列正在运行的容器。</p>\n<h1><a id="_38"></a>容器和虚拟机</h1>\n<p>一个容器是在linux服务本地运行，并和其他的容器共享主机的内核。它运行在一个独立的进程中，相对于其他可执行的进程（比如虚拟机）来说，容器的内存占用空间更小，更加的轻量化。</p>\n<p>相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序虚拟访问主机资源。 一般来说，虚拟机提供的环境比大多数应用程序需要的资源更多。</p>\n<p><img src="https://img-blog.csdn.net/20180426194527198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>\n<h1><a id="Docker_48"></a>准备你的Docker环境</h1>\n<p>安装docker请看官方网站。</p>\n<p>centos安装：</p>\n<blockquote>\n<p>yum -y install docker-io</p>\n</blockquote>\n<p>启动：</p>\n<blockquote>\n<p>service docker start</p>\n</blockquote>\n<p>更多系统的安装请看官网。</p>\n<h1><a id="Docker_62"></a>测试Docker版本</h1>\n<ol>\n<li>运行 docker --version 命令，并确保你安装的Dokcer版本支持改命令：</li>\n</ol>\n<pre><code>\ndocker --version\nDocker version 17.12.0-ce, build c97c6d6\n\n</code></pre>\n<ol start="2">\n<li>运行docker info (docker version 没有–)命令，查看更多的docker的安装信息。</li>\n<li>\n</ol>\n<pre><code>docker info\n\nContainers: 0\n Running: 0\n Paused: 0\n Stopped: 0\nImages: 0\nServer Version: 17.12.0-ce\nStorage Driver: overlay2\n...\n\n</code></pre>\n<h1><a id="docker_91"></a>测试docker安装成功</h1>\n<ol>\n<li>运行一个简单的docker镜像（hello world）来测试docker 安装成功了。</li>\n</ol>\n<pre><code>docker run hello-world\n\nUnable to find image \'hello-world:latest\' locally\nlatest: Pulling from library/hello-world\nca4f61b1923c: Pull complete\nDigest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n\n</code></pre>\n<p>2.列出在你机器上下载的hello world镜像。</p>\n<pre><code>docker image ls\n</code></pre>\n<ol start="3">\n<li>列出退出的hello-world容器（由镜像产生）。如果它仍在运行，则不需要–all选项：</li>\n</ol>\n<pre><code>docker container ls --all\n\nCONTAINER ID     IMAGE           COMMAND      CREATED            STATUS\n54f4984ed6a8     hello-world     "/hello"     20 seconds ago     Exited (0) 19 seconds ago\n\n</code></pre>\n<h1><a id="_127"></a>命令回顾</h1>\n<pre><code>\n## List Docker CLI commands\ndocker\ndocker container --help\n\n## Display Docker version and info\ndocker --version\ndocker version\ndocker info\n\n## Execute Docker image\ndocker run hello-world\n\n## List Docker images\ndocker image ls\n\n## List Docker containers (running, all, all in quiet mode)\ndocker container ls\ndocker container ls --all\ndocker container ls -aq\n\n</code></pre>\n<h1><a id="_153"></a>总结</h1>\n<p>使用Docker，扩展应用程序的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p>\n<h3><a id="_157"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80069961', 'title': 'Controller类的方法上的RequestMapping一定要写在Controller类里吗？', 'readNum': '36771', 'commentNum': '4', 'publishTime': '2018-04-24 20:18:27', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/80069961<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/%E6%9E%B6%E6%9E%84/2018/07/07/ctl-mapping.html" rel="nofollow">https://www.fangzhipeng.com/%E6%9E%B6%E6%9E%84/2018/07/07/ctl-mapping.html</a></strong></p>\n<p>使用Spring Cloud做项目的同学会使用Feign这个组件进行远程服务的调用，Feign这个组件采用模板的方式，有着优雅的代码书写规范。核心原理对Feign等相关注解进行解析，并提取信息，在Spring Boot工程启动时，通过反射生产Request的bean，并将提取的信息，设置到bean中，最后注入到ioc容器中。</p>\n<p>现在有这样的场景，服务A提高RestApi接口，服务B、C、D等服务需要调用服务A提供的RestApi接口，这时最常见的做法是在服务B、C、D分别写一个FeignClient，并需要写RestApi接口的接收参数的实体和接收响应的实体DTo类。这样的做法就是需要不停复制代码。</p>\n<p>有没有办法简洁上面的操作呢？有一种最常见的做法是将将服务A进行模块拆分，将FeignClient和常见的model、dto对外输出的类单独写一个模块，可以类似于取名a-service-open_share。这样将服务A服务分为两个模块，即A服务的业务模块和A服务需要被其他服务引用的公共类的模块。服务B、C、D只需要引用服务A的a-service-open_share就具备调用服务A的能力。</p>\n<p>笔者在这里遇到一个有趣的其问题。首先看问题：</p>\n<p>写一个FeignClient:</p>\n<pre><code>@FeignClient(name = "user-service")\npublic interface UserClient {\n  \n    @GetMapping("/users")\n    List&lt;User&gt; getUsers();\n\n</code></pre>\n<p>写一个实现类：</p>\n<pre><code>\n@RestController\npublic class UserController implements UserClient {\n    @Autowired\n    UserService      userService;\n    \n    @OverRide\n    List&lt;User&gt; getUsers(){\n       return userService.getUsers();\n    }\n\n</code></pre>\n<p>启动工程，浏览器访问接口localhost:8008/users，竟然能正确访问？！明明我在UserController类的getUsers方法没有加RequestMapping这样的注解。为何能正确的映射？！</p>\n<p>带着这样的疑问，我进行了一番的分析和探索！</p>\n<p>首先就是自己写了一个demo，首先创建一个接口类:</p>\n<pre><code>public interface ITest {\n\n    @GetMapping("/test/hi")\n    public String hi();\n}\n</code></pre>\n<p>写一个Controller类TestController</p>\n<pre><code>@RestController\npublic class TestController implements ITest {\n    @Override\n    public String hi() {\n        return "hi you !";\n    }\n    \n</code></pre>\n<p>启动工程，浏览器访问：http://localhost:8762/test/hi，浏览器显示：</p>\n<blockquote>\n<p>hi you !</p>\n</blockquote>\n<p>我去，TestController类的方法 hi()能够得到ITest的方法hi()的   @GetMapping("/test/hi")注解吗? 答案肯定是获取不到的。</p>\n<p>特意编译了TestController字节码文件:<br>\njavap -c TestController</p>\n<pre><code> public class com.example.demo.web.TestController implements com.example.demo.web.ITest {\n  public com.example.demo.web.TestController();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V\n       4: return\n\n  public java.lang.String hi();\n    Code:\n       0: ldc           #2                  // String hi you !\n       2: areturn\n}\n</code></pre>\n<p>上面的字节码没有任何关于@GetMapping("/test/hi")的信息，可见TestController直接获取不到@GetMapping("/test/hi")的信息。</p>\n<p>那应该是Spring MVC在启动时在向容器注入Controller的Bean(HandlerAdapter)时做了处理。初步判断应该是通过反射获取到这些信息，并组装到Controller的Bean中。首先看通过反射能不能获取ITest的注解信息：</p>\n<pre><code> public static void main(String[] args) throws ClassNotFoundException {\n    Class c = Class.forName("com.example.demo.web.TestController");\n    Class[] i=c.getInterfaces();\n    System.out.println("start interfaces.."  );\n    for(Class clz:i){\n        System.out.println(clz.getSimpleName());\n        Method[] methods = clz.getMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(GetMapping.class)) {\n                GetMapping w = method.getAnnotation(GetMapping.class);\n                System.out.println("value:" + w.value()[0]  );\n            }\n        }\n    }\n    System.out.println("end interfaces.."  );\n\n    Method[] methods = c.getMethods();\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(GetMapping.class)) {\n            GetMapping w = method.getAnnotation(GetMapping.class);\n            System.out.println("value:" + w.value());\n        }\n    }\n}\n \n</code></pre>\n<p>允运行上面的代码：</p>\n<blockquote>\n<p>start interfaces…</p>\n<p>ITest</p>\n<p>value:/test/hi</p>\n<p>end interfaces…</p>\n</blockquote>\n<p>可见通过反射是TestController类是可以获取其实现的接口的注解信息的。为了验证Spring Mvc 在注入Controller的bean时通过反射获取了其实现的接口的注解信息，并作为urlMapping进行了映射。于是查看了Spring Mvc 的源码，经过一系列的跟踪在RequestMappingHandlerMapping.java类找到了以下的方法：</p>\n<pre><code>protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n   RequestMappingInfo info = createRequestMappingInfo(method);\n   if (info != null) {\n      RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n      if (typeInfo != null) {\n         info = typeInfo.combine(info);\n      }\n   }\n   return info;\n}\n</code></pre>\n<p>继续跟踪源码在AnnotatedElementUtils 类的searchWithFindSemantics（）方法中发现了如下代码片段：</p>\n<pre><code>// Search on methods in interfaces declared locally\nClass&lt;?&gt;[] ifcs = method.getDeclaringClass().getInterfaces();\nresult = searchOnInterfaces(method, annotationType, annotationName, containerType, processor,\n      visited, metaDepth, ifcs);\nif (result != null) {\n   return result;\n}\n\n</code></pre>\n<p>这就是我要寻找的代码片段，验证了我的猜测。</p>\n<p>写这篇文章我想告诉读者两件事：</p>\n<ul>\n<li>可以将服务的对外类进行一个模块的拆分，比如很多服务都需要用的FeignClient、model、dto、常量信息等，这些信息单独打Jar，其他服务需要使用，引用下即可。</li>\n<li>url映射不一定要写在Contreller类的方法上，也可以写在它实现的接口里面。貌似并没有是luan用，哈。</li>\n</ul>\n<h3><a id="_172"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/79735542', 'title': '《深入理解Spring Cloud与微服务构建》书籍目录', 'readNum': '44736', 'commentNum': '4', 'publishTime': '2018-03-28 22:43:57', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="https://blog.csdn.net/forezp/article/details/79735542">https://blog.csdn.net/forezp/article/details/79735542</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h2><a id="_7"></a>作者简介</h2>\n<p>方志朋，毕业于武汉理工大学，CSDN博客专家，专注于微服务、大数据等领域，乐于分享，爱好开源，活跃于各大开源社区。著有《史上最简单的Spring Cloud教程》，累计访问量超过了300万。</p>\n<h2><a id="_13"></a>购买地址</h2>\n<p><img src="https://img-blog.csdn.net/20180328224501526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV6cA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>\n<p><a href="https://item.m.jd.com/product/12312724.html" rel="nofollow">点击购买书籍-京东</a></p>\n<p><a href="http://product.dangdang.com/25231114.html" rel="nofollow">点击购买书籍-当当</a></p>\n<p><a href="https://www.amazon.cn/dp/B079J8SCGY/ref=sr_1_2?ie=UTF8&amp;qid=1521344315&amp;sr=8-2&amp;keywords=spring+cloud" rel="nofollow">点击购买书籍-亚马逊</a></p>\n<h2><a id="_23"></a>书籍源码下载</h2>\n<p><a href="https://github.com/forezp/springcloud-book">https://github.com/forezp/springcloud-book</a></p>\n<h2><a id="_28"></a>目录</h2>\n<h3><a id="1__30"></a>第1章 微服务简介</h3>\n<ul>\n<li>1.1\u3000单体架构及其存在的不足\n<ul>\n<li>1.1.1\u3000单体架构简介</li>\n<li>1.1.2\u3000单体架构存在的不足</li>\n<li>1.1.3\u3000单体架构使用服务器集群及存在的不足</li>\n</ul>\n</li>\n<li>1.2\u3000微服务\n<ul>\n<li>1.2.1\u3000什么是微服务</li>\n<li>1.2.2\u3000微服务的优势</li>\n</ul>\n</li>\n<li>1.3\u3000微服务的不足\n<ul>\n<li>1.3.1\u3000微服务的复杂度</li>\n<li>1.3.2\u3000分布式事务</li>\n<li>1.3.3\u3000服务的划分</li>\n<li>1.3.4\u3000服务的部署</li>\n</ul>\n</li>\n<li>1.4\u3000微服务和SOA的关系</li>\n<li>1.5\u3000微服务的设计原则</li>\n</ul>\n<h3><a id="2\u3000Spring_Cloud_47"></a>第2章\u3000Spring Cloud简介</h3>\n<ul>\n<li>2.1\u3000微服务应该具备的功能\n<ul>\n<li>2.1.1\u3000服务的注册与发现</li>\n<li>2.1.2\u3000服务的负载均衡</li>\n<li>2.1.3\u3000服务的容错</li>\n<li>2.1.4\u3000服务网关</li>\n<li>2.1.5\u3000服务配置的统一管理</li>\n<li>2.1.6\u3000服务链路追踪</li>\n</ul>\n</li>\n<li>2.2\u3000Spring Cloud\n<ul>\n<li>2.2.1\u3000简介</li>\n<li>2.2.2\u3000常用组件</li>\n<li>2.2.3\u3000项目一览表</li>\n</ul>\n</li>\n<li>2.3\u3000Dubbo简介</li>\n<li>2.4\u3000Spring Cloud与Dubbo比较</li>\n<li>2.5\u3000Kubernetes简介</li>\n<li>2.6\u3000Spring Could与Kubernetes比较</li>\n<li>2.7\u3000总结</li>\n</ul>\n<h3><a id="3\u3000_67"></a>第3章\u3000构建微服务的准备</h3>\n<ul>\n<li>3.1\u3000JDK的安装\n<ul>\n<li>3.1.1\u3000JDK的下载和安装</li>\n<li>3.1.2\u3000环境变量的配置</li>\n</ul>\n</li>\n<li>3.2\u3000IDEA的安装\n<ul>\n<li>3.2.1\u3000IDEA的下载</li>\n<li>3.2.2\u3000用IDEA创建一个Spring Boot工程</li>\n<li>3.2.3\u3000用IDEA启动多个Spring Boot工程实例</li>\n</ul>\n</li>\n<li>3.3\u3000构建工具Maven的使用\n<ul>\n<li>3.3.1\u3000Maven简介</li>\n<li>3.3.2\u3000Maven的安装</li>\n<li>3.3.3\u3000Maven的核心概念</li>\n<li>3.3.4\u3000编写Pom文件</li>\n<li>3.3.5\u3000Maven构建项目的生命周期</li>\n<li>3.3.6\u3000常用的Maven命令</li>\n</ul>\n</li>\n</ul>\n<h3><a id="4\u3000Spring_Boot_84"></a>第4章\u3000开发框架Spring Boot</h3>\n<ul>\n<li>4.1\u3000Spring Boot简介\n<ul>\n<li>4.1.1\u3000Spring Boot的特点</li>\n<li>4.1.2\u3000Spring Boot的优点</li>\n</ul>\n</li>\n<li>4.2\u3000用IDEA构建Spring Boot工程\n<ul>\n<li>4.2.1\u3000项目结构</li>\n<li>4.2.2\u3000在Spring Boot工程中构建Web</li>\n<li>4.2.3\u3000Spring Boot的测试</li>\n</ul>\n</li>\n<li>4.3\u3000Spring Boot配置文件详解\n<ul>\n<li>4.3.1\u3000自定义属性</li>\n<li>4.3.2\u3000将配置文件的属性赋给实体类</li>\n<li>4.3.3\u3000自定义配置文件</li>\n<li>4.3.4\u3000多个环境的配置文件</li>\n</ul>\n</li>\n<li>4.4\u3000运行状态监控Actuator\n<ul>\n<li>4.4.1\u3000查看运行程序的健康状态</li>\n<li>4.4.2\u3000查看运行程序的Bean</li>\n<li>4.4.3\u3000使用Actuator关闭应用程序</li>\n<li>4.4.4\u3000使用shell连接Actuator</li>\n</ul>\n</li>\n<li>4.5\u3000Spring Boot整合JPA</li>\n<li>4.6\u3000Spring Boot整合Redis\n<ul>\n<li>4.6.1\u3000Redis简介</li>\n<li>4.6.2\u3000Redis的安装</li>\n<li>4.6.3\u3000在Spring Boot中使用Redis</li>\n</ul>\n</li>\n<li>4.7\u3000Spring Boot整合Swagger2，搭建Restful API在线文档</li>\n</ul>\n<h3><a id="5\u3000Eureka_109"></a>第5章\u3000服务注册和发现Eureka</h3>\n<ul>\n<li>5.1\u3000Eureka简介\n<ul>\n<li>5.1.1\u3000什么是Eureka</li>\n<li>5.1.2\u3000为什么选择Eureka</li>\n<li>5.1.3\u3000Eureka的基本架构</li>\n</ul>\n</li>\n<li>5.2\u3000编写Eureka Server</li>\n<li>5.3\u3000编写Eureka Client</li>\n<li>5.4\u3000源码解析Eureka\n<ul>\n<li>5.4.1\u3000Eureka的一些概念</li>\n<li>5.4.2\u3000Eureka的高可用架构</li>\n<li>5.4.3\u3000Register服务注册</li>\n<li>5.4.4\u3000Renew服务续约</li>\n<li>5.4.5\u3000为什么Eureka Client获取服务实例这么慢</li>\n<li>5.4.6\u3000Eureka 的自我保护模式</li>\n</ul>\n</li>\n<li>5.5\u3000构建高可用的Eureka Server集群</li>\n<li>5.6\u3000总结</li>\n</ul>\n<h3><a id="6\u3000Ribbon_128"></a>第6章\u3000负载均衡Ribbon</h3>\n<ul>\n<li>6.1\u3000RestTemplate简介</li>\n<li>6.2\u3000Ribbon简介</li>\n<li>6.3\u3000使用RestTemplate和Ribbon来消费服务</li>\n<li>6.4\u3000LoadBalancerClient简介</li>\n<li>6.5\u3000源码解析Ribbon</li>\n</ul>\n<h3><a id="7\u3000Feign_137"></a>第7章\u3000声明式调用Feign</h3>\n<ul>\n<li>7.1\u3000写一个Feign客户端</li>\n<li>7.2\u3000FeignClient详解</li>\n<li>7.3\u3000FeignClient的配置</li>\n<li>7.4\u3000从源码的角度讲解Feign的工作原理</li>\n<li>7.5\u3000在Feign中使用HttpClient和OkHttp</li>\n<li>7.6\u3000Feign是如何实现负载均衡的</li>\n<li>7.7\u3000总结</li>\n</ul>\n<h4><a id="8\u3000Hystrix_148"></a>第8章\u3000熔断器Hystrix</h4>\n<ul>\n<li>8.1\u3000什么是Hystrix</li>\n<li>8.2\u3000Hystrix解决了什么问题</li>\n<li>8.3\u3000Hystrix的设计原则</li>\n<li>8.4\u3000Hystrix的工作机制</li>\n<li>8.5\u3000在RestTemplate和Ribbon上使用熔断器</li>\n<li>8.6\u3000在Feign上使用熔断器</li>\n<li>8.7\u3000使用Hystrix Dashboard监控熔断器的状态\n<ul>\n<li>8.7.1\u3000在RestTemplate中使用Hystrix Dashboar</li>\n<li>8.7.2\u3000在Feign中使用Hystrix Dashboard</li>\n</ul>\n</li>\n<li>8.8\u3000使用Turbine聚合监控</li>\n</ul>\n<h3><a id="9\u3000Spring_Cloud_Zuul_162"></a>第9章\u3000路由网关Spring Cloud Zuul</h3>\n<ul>\n<li>9.1\u3000为什么需要Zuul</li>\n<li>9.2\u3000Zuul的工作原理</li>\n<li>9.3\u3000案例实战\n<ul>\n<li>9.3.1\u3000搭建Zuul服务</li>\n<li>9.3.2\u3000在Zuul上配置API接口的版本号</li>\n<li>9.3.3\u3000在Zuul上配置熔断器</li>\n<li>9.3.4\u3000在Zuul中使用过滤器</li>\n<li>9.3.5\u3000Zuul的常见使用方式</li>\n</ul>\n</li>\n</ul>\n<h3><a id="10\u3000Spring_Cloud_Config_173"></a>第10章\u3000配置中心Spring Cloud Config</h3>\n<ul>\n<li>10.1\u3000Config Server从本地读取配置文件\n<ul>\n<li>10.1.1\u3000构建Config Server</li>\n<li>10.1.2\u3000构建Config Client</li>\n</ul>\n</li>\n<li>10.2\u3000Config Server从远程Git仓库读取配置文件</li>\n<li>10.3\u3000构建高可用的Config Server\n<ul>\n<li>10.3.1\u3000构建Eureka Server</li>\n<li>10.3.2\u3000改造Config Server</li>\n<li>10.3.3\u3000改造Config Client</li>\n</ul>\n</li>\n<li>10.4 使用Spring Cloud Bus刷新配置</li>\n</ul>\n<h3><a id="11\u3000Spring_Cloud_Sleuth_184"></a>第11章\u3000服务链路追踪Spring Cloud Sleuth</h3>\n<ul>\n<li>11.1\u3000为什么需要Spring Cloud Sleuth</li>\n<li>11.2\u3000基本术语</li>\n<li>11.3\u3000案例讲解\n<ul>\n<li>11.3.1\u3000构建Zipkin Server</li>\n<li>11.3.2\u3000构建User Service</li>\n<li>11.3.3\u3000构建Gateway Service</li>\n<li>11.3.4\u3000项目演示</li>\n</ul>\n</li>\n<li>11.4\u3000在链路数据中添加自定义数据</li>\n<li>11.5\u3000使用RabbitMQ 传输链路数据</li>\n<li>11.6\u3000在MySQL数据库中存储链路数据\n<ul>\n<li>11.6.1\u3000使用Http传输链路数据，并存储在MySQL数据库</li>\n<li>11.6.2\u3000使用RabbitMQ传输链路数据，并存储在MySQL数据库</li>\n</ul>\n</li>\n<li>11.7\u3000在ElasticSearch中存储链路数据</li>\n<li>11.8\u3000用Kibana展示链路数据</li>\n</ul>\n<h3><a id="12\u3000Spring_Boot_Admin_200"></a>第12章\u3000微服务监控Spring Boot Admin</h3>\n<ul>\n<li>12.1\u3000使用Spring Boot Admin监控Spring Cloud微服务\n<ul>\n<li>12.1.1\u3000构建Admin Server</li>\n<li>12.1.2\u3000构建Admin Client</li>\n</ul>\n</li>\n<li>12.2\u3000在Spring Boot Admin中集成Turbine\n<ul>\n<li>12.2.1\u3000改造Eureka Client</li>\n<li>12.2.2\u3000另行构建Eureka Client</li>\n<li>12.2.3\u3000构建Turbine工程</li>\n<li>12.2.4\u3000在Admin Server中集成Turbine</li>\n</ul>\n</li>\n<li>12.3\u3000在Spring Boot Admin中添加安全登录界面</li>\n</ul>\n<h3><a id="13\u3000Spring_Boot_Security_210"></a>第13章\u3000Spring Boot Security详解</h3>\n<ul>\n<li>13.1\u3000Spring Security简介\n<ul>\n<li>13.1.1\u3000什么是Spring Security</li>\n<li>13.1.2\u3000为什么选择Spring Security</li>\n<li>13.1.3\u3000Spring Security提供的安全模块</li>\n</ul>\n</li>\n<li>13.2\u3000Spring Boot Security与Spring Security的关系</li>\n<li>13.3\u3000Spring Boot Security案例详解\n<ul>\n<li>13.3.1\u3000构建Spring Boot Security工程</li>\n<li>13.3.2\u3000配置Spring Security</li>\n<li>13.3.3\u3000编写相关界面</li>\n<li>13.3.4\u3000Spring Security方法级别上的保护</li>\n<li>13.3.5\u3000从数据库中读取用户的认证信息</li>\n</ul>\n</li>\n<li>13.4\u3000总结</li>\n</ul>\n<h3><a id="14\u3000Spring_Cloud_OAuth2_224"></a>第14章\u3000使用Spring Cloud OAuth2保护微服务系统</h3>\n<ul>\n<li>14.1\u3000什么是OAuth2</li>\n<li>14.2\u3000如何使用Spring OAuth2\n<ul>\n<li>14.2.1\u3000OAuth2 Provider</li>\n<li>14.2.2\u3000OAuth2 Client</li>\n</ul>\n</li>\n<li>14.3\u3000案例分析\n<ul>\n<li>14.3.1\u3000编写Eureka Server</li>\n<li>14.3.2\u3000编写Uaa授权服务</li>\n<li>14.3.3\u3000编写service-hi资源服务</li>\n</ul>\n</li>\n<li>14.4\u3000总结</li>\n</ul>\n<h3><a id="15\u3000Spring_Security_OAuth2JWT_236"></a>第15章\u3000使用Spring Security OAuth2和JWT保护微服务系统</h3>\n<ul>\n<li>15.1\u3000JWT简介\n<ul>\n<li>15.1.1\u3000什么是JWT</li>\n<li>15.1.2\u3000JWT的结构</li>\n<li>15.1.3\u3000JWT的应用场景</li>\n<li>15.1.4\u3000如何使用JWT</li>\n</ul>\n</li>\n<li>15.2\u3000案例分析\n<ul>\n<li>15.2.1\u3000案例架构设计</li>\n<li>15.2.2\u3000编写主Maven工程</li>\n<li>15.2.3\u3000编写Eureka Server</li>\n<li>15.2.4\u3000编写Uaa授权服务</li>\n<li>15.2.5\u3000编写user-service资源服务</li>\n</ul>\n</li>\n<li>15.3  总结</li>\n</ul>\n<h3><a id="16\u3000Spring_Cloud_252"></a>第16章\u3000使用Spring Cloud构建微服务综合案例</h3>\n<ul>\n<li>16.1\u3000案例介绍\n<ul>\n<li>16.1.1\u3000工程结构</li>\n<li>16.1.2\u3000使用的技术栈</li>\n<li>16.1.3\u3000工程架构</li>\n<li>16.1.4\u3000功能展示</li>\n</ul>\n</li>\n<li>16.2\u3000案例详解\n<ul>\n<li>16.2.1\u3000准备工作</li>\n<li>16.2.2\u3000构建主Maven工程</li>\n<li>16.2.3\u3000构建eureka-server工程</li>\n<li>16.2.4\u3000构建config-server工程</li>\n<li>16.2.5\u3000构建zipkin-service工程</li>\n<li>16.2.6\u3000构建monitoring-service工程</li>\n<li>16.2.7\u3000构建uaa-service工程</li>\n<li>16.2.8\u3000构建gateway-service工程</li>\n<li>16.2.9\u3000构建admin-service工程</li>\n<li>16.2.10\u3000构建user-service工程</li>\n<li>16.2.11\u3000构建blog-service工程</li>\n<li>16.2.12\u3000构建log-service工程</li>\n</ul>\n</li>\n<li>16.3\u3000启动源码工程</li>\n<li>16.4\u3000项目演示</li>\n<li>16.5\u3000总结</li>\n</ul>\n<h3><a id="_275"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/79383631', 'title': 'Kong Api 初体验', 'readNum': '37338', 'commentNum': '1', 'publishTime': '2018-02-27 09:15:01', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/%E6%9E%B6%E6%9E%84/2017/09/17/kong-api-gateway.html" rel="nofollow">https://www.fangzhipeng.com/%E6%9E%B6%E6%9E%84/2017/09/17/kong-api-gateway.html</a></strong></p>\n<p>Kong是一个可扩展的开源API层（也称为API网关或API中间件）。 Kong运行在任何RESTful API的前面，并通过插件扩展，它们提供超出核心平台的额外功能和服务。<br>\nKong最初是在Mashape建立的，用于为其API Marketplace提供超过15,000个API和Microservices，并为超过20万的开发者每月生成数十亿个请求。 今天，Kong被用于小型和大型组织的关键任务部署</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-avVv8VY9-1570074828050)(https://getkong.org/assets/images/docs/kong-architecture.jpg)]</p>\n<!--more-->\n<h2><a id="_10"></a>使用的软件</h2>\n<ul>\n<li>Unbuntu 虚拟机（有自己的服务器更好）</li>\n<li>PostgreSQL</li>\n<li>kong</li>\n<li>kong-dashboard</li>\n<li>docker</li>\n<li>spring boot</li>\n</ul>\n<h2><a id="_PostgreSQL_19"></a>安装 PostgreSQL</h2>\n<p>kong 需要使用到数据库，目前支持PostgreSQL和Cassandran ,我选择大象数据库，安装过程省略，可以参考这篇文章。<br>\nhttp://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html</p>\n<p>安装完后建一个kong的用户、密码为kong、建一个kong 数据库:</p>\n<pre><code>CREATE USER kong; CREATE DATABASE kong OWNER kong;\n</code></pre>\n<h2><a id="kong_30"></a>安装kong</h2>\n<p>下载kong的源文件，下载地址：https://getkong.org/install/ubuntu/</p>\n<p>下载完成之后会有这样一个文件kong-community-edition-0.11.0.*.deb，cd到这个文件的目录：</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install openssl libpcre3 procps perl\n$ sudo dpkg -i kong-community-edition-0.11.0.*.deb\n\n</code></pre>\n<h2><a id="kong_45"></a>配置kong</h2>\n<p>配置文档在这里：</p>\n<p>https://getkong.org/docs/0.9.x/configuration/</p>\n<p>复制配置文件：</p>\n<pre><code>$ cp /etc/kong/kong.conf.default /etc/kong/kong.conf\n</code></pre>\n<p>配置文件：</p>\n<pre><code>/etc/kong/kong.conf\n/etc/kong.conf\n\n</code></pre>\n<p>打开配置文件，里面可以修改很多配置，修改数据库连接，用户名、密码</p>\n<pre><code>pg_host = 127.0.0.1             # The PostgreSQL host to connect to.\npg_port = 5432                  # The port to connect to.\npg_user = kong                  # The username to authenticate if required.\npg_password = kong              # The password to authenticate if required.\npg_database = kong\n\n</code></pre>\n<p>执行以下整合命令：</p>\n<pre><code>$ kong migrations up [-c /path/to/kong.conf]\n\n</code></pre>\n<p>启动kong :</p>\n<pre><code>kong start -c /etc/kong/kong.conf --vv\n</code></pre>\n<p>打开浏览器访问：localhost:8001，浏览器显示了一大串关于kong的json字符串，则启动成功。<br>\nkong管理端口为8001, 监控端口为8000。</p>\n<p>管理端口用rest api对api进行操作，文档地址:https://getkong.org/docs/0.8.x/admin-api</p>\n<h2><a id="_kongdashboard_94"></a>安装 kong-dashboard</h2>\n<p>kong管理端的第三方网页，地址：https://github.com/PGBI/kong-dashboard</p>\n<p>支持npm启动，但是没有成功过，直接选择了docker启动。<br>\n要求先安装docker,docker启动镜像</p>\n<pre><code># Start Kong Dashboard  8080端口启动\ndocker run -d -p 8080:8080 pgbi/kong-dashboard:v2\n\n# Start Kong Dashboard on a custom port  指定一个端口启动\ndocker run -d -p [port]:8080 pgbi/kong-dashboard:v2\n\n# Start Kong Dashboard with basic auth  8080端口启动，带一个用户基本认证\ndocker run -d -p 8080:8080 pgbi/kong-dashboard:v2 -a user=password\n\n</code></pre>\n<h2><a id="_113"></a>演示实例</h2>\n<p>在电脑上开启一个spring boot 工程有一个api接口为http://10.10.20.187:8762/hi</p>\n<p>其实kong管理api有一系列的接口，直接用crul 就可以完成管理，但是有第三个kong-dashboard，我就用了kong-dashboard的管理界面进行操作。</p>\n<p>在上一小节启动docker之后，打开网页http://192.168.86.128:8080（我unbuntu虚拟机的host为192.168.86.128）,填写kong的管理urlhttp://192.168.86.128:8001，就可以进入了。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iSyrzSdW-1570074828052)(http://fangzhipeng.oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830111958.png?x-oss-process=style/caijai)]</p>\n<p>在kong管理界面创建一个api接口：</p>\n<p>填写相关的参数即可，创建完成后如下：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gYXq4fTJ-1570074828054)(http://fangzhipeng.oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830112038.png?x-oss-process=style/caijai)]</p>\n<p>在浏览器上访问：http://192.168.86.128:8000/hi</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>添加api限流插件,一个ip一分钟10次。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-edRMFckb-1570074828054)(http://fangzhipeng.oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830112602.png?x-oss-process=style/caijai)]</p>\n<p>访问超过10次后，会拒绝访问。</p>\n<p>添加file-log的插件,文件存放目录为/temp/file.log  ：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fqqcwDcH-1570074828055)(http://fangzhipeng.oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830114620.png?x-oss-process=style/caijai)]</p>\n<p>再次访问：http://192.168.86.128:8000/hi</p>\n<p>可以在打开/temp/file.log看见里面的日志信息。</p>\n<p>kong 支持了20中插件，插件地址：https://getkong.org/plugins/</p>\n<h2><a id="_151"></a>参考资料</h2>\n<p>https://getkong.org/about/</p>\n<p>http://www.cnblogs.com/SummerinShire/category/861287.html</p>\n<p>http://www.jianshu.com/p/f9a2210f6722</p>\n<p>https://yq.aliyun.com/articles/63180</p>\n<p>http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html</p>\n<h3><a id="_163"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/79735457', 'title': '异步社区的一个专访记录', 'readNum': '26418', 'commentNum': '1', 'publishTime': '2018-03-28 22:37:28', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/79735457<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/life/2018/08/12/yb-zf.html" rel="nofollow">https://www.fangzhipeng.com/life/2018/08/12/yb-zf.html</a></strong></p>\n<h4><a id="_7"></a>异步社区：请您向异步社区的读者做一个简单的介绍吧。</h4>\n<p>各位读者好，我叫方志朋，毕业于武汉理工大学，是《深入理解Spring Cloud与微服务构建》书的作者。目前为CSDN博客专家、Spring Cloud中国社区联合创始人，专注于微服务、大数据等领域，对技术有着狂热的追求，活跃于各大技术社区，包括Spring Cloud中国社区、CSDN、Github、掘金、简书等。在4月8日，我发表的第一篇Spring Cloud文章开始，已经在Spring Cloud社区产生了非常大的影响力。在CSDN开的Spring Cloud 系列个人专栏（http://blog.csdn.net/forezp），到目前为止，获得了280万的阅读量，个人Github(https://github.com/forezp)获得的Star超过了2500个，获得了众多开发者的认可。</p>\n<h4><a id="Spring_Cloud_11"></a>异步社区：是什么初衷让您开始创作《深入理解Spring Cloud与微服务构建》？这本书有哪些特色？学习这本书有哪些知识要点不可错过，可以分享一下吗？</h4>\n<p>我从2017年4月份开始，写了一系列Spring Cloud教程，取名为《史上最简单的Spring Cloud教程》，我的写作初衷就是化繁为简、化整为零，让读者轻松愉快的上手Spring Cloud这一套微服务框架。我完全从一个新手的角度，或者说是一个新手的心理去写这样一系列的文章，尽量写的简单明了，让读者快速上手，让学习技术不再是一件痛苦的事。这一系列文章发表完之后，阅读量呈指数增长，超出了我的想象，获得大量的读者的认可。在之后异步社区的张爽编辑联系我，问我是否愿意写一本关于Spring Cloud 这样一本书，我就想博客终究是博客，或多或少有一些缺陷，书籍由出版社严格把控，更能写出一些干货，让读者有更多的选择，这样更能推进Spring Cloud技术的发展。</p>\n<p>这本书最大的特色就是沿袭了我博客的写作风格，力求做到简单，让读者轻松愉快的学习，另外本书中对Spring Cloud核心组件进行了一个源码的跟踪，让读者能够深入的理解Spring Cloud这一体系，或者说微服务这一体系的实现的原理，然后，我花费了大量时间研究了Spring Cloud OAuth2这一组件，这是一个安全组件，有着举足轻重的作用，最后，在本书的最后一章有一个综合案例，是我在工作和学习中对Spring Cloud的一个提炼，有着非常大的参考价值。</p>\n<p>对于新手来说，这本书干活满满，所有的内容都不能错过；对高手而言，Spring Cloud核心组件源码不容错过，Spring Cloud OAuth2组件的目前的资料较少，所以也不容错过，而本书最后的综合案例更是我本人实战一年工作的提炼，有着非常大的参考价值。</p>\n<h4><a id="OOMartin_FowlerSpring_Cloud__20"></a>异步社区：微服务，是著名的OO专家Martin Fowler提出来的，在最近两年各种演讲、文章、书籍上出现的频率之高，让人们逐渐意识到它对于软件领域所带来的影响，Spring Cloud 作为微服务的践行者，您认为有哪些优势？</h4>\n<p>这要软件架构的演进来讲起。单体架构，可能最为大家所熟悉，在软件的初始阶段最适合使用这一架构，这一架构在软件的初始阶段有着非常大的优势，有这开发速度快、成本低的优点，这一架构只适合业务较简单、并发量较小的应用。随着业务越来越复杂，这一架构会带来代码的可读性越来越差，可持续交付能力差。</p>\n<p>应用服务器集群的架构，随着业务的发展，大多数公司会将单体应用进行集群部署，并增加负载均衡服务器（例如Nginx等）。另外，还需要增加集群部署的缓存服务器和文件服务器，并将数据库读写分离，以应对用户量的增加而带来的高并发访问量。用负载均衡服务器分发高并发的网络请求，用户的访问被分派到不同的应用服务器，应用服务器的负载不再成为瓶颈，用户量增加时，添加应用服务器即可，这时虽然有一定的并发能力，但应用仍为单体架构，代码的可读性、持续的交付能力仍旧很差。</p>\n<p>面向服务的架构即SOA，应用服务器集群架构能够有一定的并发能力，但是如果业务持续发展，垂直子系统越来越多，系统与系统之间的调用也非常频繁，这时最好的做法是将系统服务治理化。服务化架构，最常见的就是面向服务SOA架构，这种架构是根据不同的职责，划分不同的模块，不同的模块采用某种通讯协议相互调用。目前最常见的SOA架构为阿里的Dubbo架构，这种架构通过添加应用服务器、熔断、负载均衡，具有很强的横向扩展能力和弹性伸缩能力。</p>\n<p>微服务架构是对SOA架构的一个扩展，显得更加轻便，不依赖于任何的平台。业务足够复杂，垂直的业务子系统越来越多，这时可以考虑使用微服务架构。当前，互联网技术飞速发展，随着互联网技术渗透到各行各业，越来越多的用户参与到互联网，应用场景也越来越复杂。云计算、大数据、人工智能、区块链、物联网等技术大行其道，对系统的架构提出了越来越高的要求。微服务架构不仅能够满足越来越复杂的业务，也能支撑越来越高的并发量，所以微服务架构是互联网技术推进发展的产物，当一个公司的业务足够复杂，参与的用户（手机端、浏览器端、物联网设备）足够多时，可以用微服务架构。</p>\n<p>所以，微服务架构是系统架构演进的一个产物，是在其他架构的不断演进，不断改善的产物，它能够解决高并发问题，系统解耦问题，持续交付的问题，敏捷开发等诸多问题。</p>\n<h4><a id="Spring_Cloud_35"></a>异步社区：作为Spring Cloud中国社区核心负责人，每天面对最棘手的问题是什么？可以跟我们说说吗？</h4>\n<p>Spring Cloud技术发展至今，国内关注的人越来越多，社区成立之前，相应学习交流的平台和材料比较分散，不利于学习交流，Spring Cloud中国社区应运而生。Spring Cloud社区（http://springcloud.cn）是国内首个Spring Cloud构建微服务架构的交流社区。社区致力于为Spring Boot或Spring Cloud技术人员提供分享和交流的平台，推动Spring Cloud在中国的普及和应用。社区创始人许进，更是为社区作出非常多的努力，他是国内Spring Cloud技术的布道者和推进者。社区通过开展线上交流和线下活动相结合，通过创建社区微信群，将大家聚在一起，相互交流和学习，目前所有微信群的人数高达八千人，欢迎大家访问社区网站。社区发布了多个Spring Cloud的开源项目，为Spring Cloud 在国内的发展作出了突出的贡献。目前来说，最为棘手的问题，在于社区博客缺少高质量文章的投稿，希望有志于开源的小伙伴一起来加入我们，将社区打造得更好。</p>\n<h4><a id="_39"></a>异步社区：职场小白想进入这个领域，您认为必备的职业素养是什么？入门有哪些工具推荐？</h4>\n<p>职场小白想进入这个行业，最基本的职业素养是持续的学习能力和对技术的敬畏之心。学习能力是基本要求，因为在IT这个领域是一个日新月异的领域，发展速度非常的快。所以必须必须要持续学习的能力，才能不不落后。另外，就是要有一个对技术的敬畏之心，程序员使用搜索引擎的技艺特别的高超，复制粘贴的技术无人能比，所以程序员一旦上路之后，就容易觉得技术就那么回事，就是不断的使用别人的创建好的轮子。所以，程序员必须都技术有敬畏之心，不断的探索技术的深度，才能够使自己不断的进步，不断的提升。我还有一个建议不知道对不对，就是建议刚毕业的童鞋去北上广深杭等城市，去最发达城市，最发达的区域，做最前沿的事情，做时代的弄潮儿。</p>\n<p>推荐一款叫MacDown工具吧，它是写博客和文章的神器。之所以推荐这个工具，一是它特别的好用，界面友好，使用起来舒服，二是，推荐它是因为希望读者有写博客和文章的习惯，持续的写，它真的有可能改变一个人很多。另外推荐，网易云笔记，作为文章、博客的备份。注意，这不是打广告哦！</p>\n<h4><a id="why_45"></a>异步社区：当大家使用一个新技术的时候，应该首先问的一个问题就是why？您作为先驱，当时是如何想的，可以说说吗？</h4>\n<p>当使用一件新技术的时候，一定是要问的问题就是为什么要使用这项技术，这项技术解决了什么问题，这项技术有什么优点，有什么难点，成本有多高？那我所在的公司的业务的主系统采用Dubbo框架，开发人员众多、开发时间也足够长，带来的最直接的问题，就是代码的可读性非常差，大多数代码是很难看的懂的，另外方面就是工程过于庞大，持续交付能力差。那我使用微服务这一新技术，就是为了解决这样的问题。微服务的优点无需多描述，它的难点有三个，一是分布式事务，二是服务的划分，三是服务的自动化部署。采用Spring Cloud这一框架构建微服务系统的成本是比较低的，因为大多数Java程序员都会使用Spring，所以成本是可以接受的。</p>\n<h4><a id="Spring_Cloud_49"></a>异步社区：我们该如何使用Spring Cloud来更好地服务于我们的客户群体呢？</h4>\n<p>这个问题看起来很复杂，其实很简单。万变不离其宗，只需要弄懂Spring Cloud各大组件，深入理解Spring Cloud组件的原理，深入理解Spring Cloud这一套组件所构建系统的原理，就可以了。而《深入理解Spring Cloud与微服务构建》这本书正好讲解了这些内容，所以这本书值得你拥有。</p>\n<h4><a id="_53"></a>异步社区：写博客和写书最大的不同是什么？</h4>\n<p>首先我来说一下写博客和写书最大相同点，相同点就是尽量让所写内容简单，写出的东西是对读者负责，人非圣贤，错误在所难免，所以还请各位读者海涵。写博客和写书最大不同在于，写博客可以自由发挥，不在乎一些表述上的细节，可以很轻松的写出一系列的文章；而写书在于需要承受一些压力，尽可能的做到精益求精，尽可能的把事情做的完美。当然，写书的过程中，出版社是可以给予非常多的帮助和建议的，在这里感谢异步社区的童鞋们。</p>\n<h4><a id="2018_57"></a>异步社区：2018年微服务领域将有哪些大的发展和挑战，可以预测一下吗?</h4>\n<p>2017年，微服务是飞速发展的一年，从我的博客的访问量从2017年的四月的几千到至今的460万，足见Spring Cloud技术的火爆程度。目前，国内很多中大型互联网公司都在使用Spring Cloud技术。 评估一家企业是否需要上微服务，主要考察这五大关键要素：数据量和业务复杂度，团队规模，应对业务流量变化，是否需要足够的容错容灾，以及功能重复度和差错成本。</p>\n<p>所以，2018年仍是微服务飞速发展的一年，目前它仍处于发展期。复杂的业务场景、高并发的业务场景，云技术、大数据等仍是微服务大行其道的几个关键领域，它面临的挑战在于各行各业具体怎么去合理的使用微服务，这需要具体行业的开发人员对业务有足够深的认识和理解。</p>\n<h4><a id="_63"></a>异步社区：您理想中的生活是什么样子的？</h4>\n<p>可以说“钱多活少离家近，老婆孩子热炕头吗？”[捂脸]。</p>\n<p>对于我个人言，我需要保证自己能够持续不断的学习，做一个终身学习者、终身学习受益者。同时对这个世界充满敬畏之心、好奇之心、善良之心，成为能够让世界变美好的一份子。我的理想生活的样子是一个普通人生活的样子，有一份体面的工作，有一个不错的收入，维持自己的一些爱好，与相爱的人悠悠信步，与父母相互理解、保护，与志同道合的朋友共事，与有趣之人共话语，过的是丰富且有质感的生命体验。</p>\n<h3><a id="_69"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78676036', 'title': 'JWT如何在Spring Cloud微服务系统中在服务相互调时传递', 'readNum': '52833', 'commentNum': '8', 'publishTime': '2017-11-30 14:42:07', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78676036<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/architecture/2018/01/01/springcloud-jwt.html" rel="nofollow">https://www.fangzhipeng.com/architecture/2018/01/01/springcloud-jwt.html</a></strong></p>\n<p>在微服务系统中，为了保证微服务系统的安全,常常使用jwt来鉴权，但是服务内部的相互调用呢。经常有人在微信上问我，我给出一个解决办法，采用Feign的拦截器。</p>\n<p>在Feign中开启了hystrix，hystrix默认采用的是线程池作为隔离策略。线程隔离有一个难点需要处理，即隔离的线程无法获取当前请求线程的Jwt，这用ThredLocal类可以去解决，但是比较麻烦，所以我才用的是信号量模式。<br>\n在application.yml配置文件中使用一下配置：</p>\n<pre><code>hystrix.command.default.execution.isolation.strategy: SEMAPHORE\n</code></pre>\n<p>写一个Feign的拦截器，Feign在发送网络请求之前会执行以下的拦截器，代码如下：</p>\n<pre><code>\nimport feign.RequestInterceptor;\nimport feign.RequestTemplate;\nimport org.springframework.stereotype.Component;\n\n/**\n * Created by fangzhipeng on 2017/7/28.\n */\n@Component\npublic class JwtFeignInterceptor implements RequestInterceptor {\n\n    private final String key = "Authorization";\n\n\n    @Override\n    public void apply(RequestTemplate template) {\n\n        if (!template.headers().containsKey(key)) {\n            String currentToken = UserUtils.getCurrentToken();\n            if (!StrUtil.isEmpty(currentToken)){\n                template.header(key, currentToken);\n            }\n        }\n    }\n}\n</code></pre>\n<p>也可以参考这篇文章：http://www.spring4all.com/article/948</p>\n<h3><a id="_50"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616779', 'title': 'Openresty最佳案例 | 第9篇：Openresty实现的网关权限控制', 'readNum': '38715', 'commentNum': '0', 'publishTime': '2017-11-23 17:02:28', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616779<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-9-api-gateway.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-9-api-gateway.html</a></strong></p>\n<h2><a id="_7"></a>简介</h2>\n<p>采用openresty 开发出的api网关有很多，比如比较流行的kong、orange等。这些API 网关通过提供插件的形式，提供了非常多的功能。这些组件化的功能往往能够满足大部分的需求，如果要想达到特定场景的需求，可能需要二次开发，比如RBAC权限系统。本小节通过整合前面的知识点，来构建一个RBAC权限认证系统。</p>\n<h2><a id="_11"></a>技术栈</h2>\n<p>本小节采用了以下的技术栈：</p>\n<ul>\n<li>Openresty(lua+nginx)</li>\n<li>mysql</li>\n<li>redis</li>\n<li>cjson</li>\n</ul>\n<h2><a id="_21"></a>验证流程</h2>\n<ul>\n<li>\n<p>用户请求经过nginx，nginx的openresty的模块通过拦截请求来进行权限判断</p>\n</li>\n<li>\n<p>openresty的access_by_lua_file模块，进行了一系列的判断</p>\n<ul>\n<li>用户的请求是否为白名单uri，如果为白名单uri，则直接通过验证，进入下一个验证环节content_by_lua_file,这个环节直接打印一句话：“恭喜，请求通过。”</li>\n<li>如果用户请求不为白名单url，则需要取出请求header中的token,如果请求的header不存在token,则直接返回结果401，无权限访问。</li>\n<li>如果用户请求的uri的请求头包含token ，则取出token，解密token取出用户id</li>\n<li>根据取出的userid去查询数据库获取该用户的权限，如果权限包含了该请求的uri，请求可以通过，否则，请求不通过。</li>\n</ul>\n</li>\n<li>\n<p>请求如果通过access_by_lua_file模块，则进入到content_by_lua_file模块,该模块直接返回一个字符串给用户请求，在实际的开发中，可能为路由到具体的应用程序的服务器。</p>\n</li>\n</ul>\n<p>验证流程图如下所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601114901186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>vim /usr/example/example.conf ，加上以下的配置：</p>\n<pre><code> location / {\n    default_type "text/html";\n    access_by_lua_file /usr/example/lua/api_access.lua;\n    content_by_lua_file /usr/example/lua/api_content.lua;\n  }\n\n</code></pre>\n<p>以上的配置表示，要不符合已有location路径的所有请求，将走这个location为/  的路径。符合这个location的请求将进入 access_by_lua_file和 content_by_lua_file的模块判断。</p>\n<p>vim /usr/example/lua/access_by_lua_file ，加上以下代码：</p>\n<pre><code>local tokentool = require "tokentool"\nlocal mysqltool = require "mysqltool"\n\n function is_include(value, tab)\n   for k,v in ipairs(tab) do\n      if v == value then\n           return true\n       end\n    end\n    return false\n end\n\nlocal white_uri={"/user/login","/user/validate"}\n  \n--local user_id = ngx.req.get_uri_args()["userId"]\n--获取header的token值\nlocal headers = ngx.req.get_headers() \nlocal token=headers["token"]\nlocal url=ngx.var.uri\nif ( not token) or (token==null) or (token ==ngx.null) then\n  if is_include(url,white_uri)then\n     \n  else\n    return ngx.exit(401)\n  end  \nelse \n  ngx.log(ngx.ERR,"token:"..token)\n  local user_id=tokentool.get_user_id(token)\n  if (not user_id) or( user_id ==null) or ( user_id == ngx.null) then\n      return ngx.exit(401)   \n  end \n  \n  ngx.log(ngx.ERR,"user_id"..user_id)\n  local permissions={}\n  permissions =tokentool.get_permissions(user_id)\n  if(not permissions)or(permissions==null)or( permissions ==ngx.null) then\n      permissions= mysqltool.select_user_permission(user_id)\n      if permissions and permissions ~= ngx.null then\n         tokentool.set_permissions(user_id,permissions)\n      end\n  end  \n  if(not permissions)or(permissions==null)or( permissions ==ngx.null) then\n     return ngx.exit(401)\n  end \n  local is_contain_permission = is_include(url,permissions) \n\n  if is_contain_permission == true  then\n     -- ngx.say("congratuation! you have pass the api gateway")\n  else\n      return ngx.exit(401) \n  end   \nend\n\n</code></pre>\n<p>在上述代码中：</p>\n<ul>\n<li>is_include(value, tab)，该方法判断某个字符串在不在这个table中。</li>\n<li>white_uri={"/user/login","/user/validate"} 是一个白名单的列表。</li>\n<li>local headers = ngx.req.get_headers()从请求的uri的请求头获取token</li>\n<li>is_include(url,white_uri)判断该url是否为白名单url</li>\n<li>local user_id=tokentool.get_user_id(token)根据token获取该token对应的用户的user_id，在常见情况下，是根据token解析出user_id，但在不同的语言加密和加密token存在盐值不一样的情况，比较麻烦，所以我偷了个懒，直接存了redis，用户登录成功后存一下。</li>\n<li>permissions =tokentool.get_permissions(user_id)根据user_id<br>\n从redis获取该用户的权限。</li>\n<li>permissions= mysqltool.select_user_permission(user_id)如果redis没有存该用户的权限，则从数据库读。</li>\n<li>tokentool.set_permissions(user_id,permissions)，将从数据库中读取的权限点存在reddis中。</li>\n<li>local is_contain_permission = is_include(url,permissions)，判断该url 在不在该用户对应的权限列表中。</li>\n</ul>\n<p>如果所有的判断通过，则该用户请求的具有权限访问，则进入content_by_lua_file模块，直接在这个模块给请求返回“congratulations! you have passed the api gateway”。</p>\n<p>vim  /usr/example/lua/api_content.lua ,添加以下内容：</p>\n<pre><code>ngx.say("congratulations!"," you have passed ","the api gateway")  \n----200状态码退出  \nreturn ngx.exit(200)  \n\n</code></pre>\n<h2><a id="_132"></a>验证演示</h2>\n<p>打开浏览器访问http://116.196.177.123/user/login，浏览器显示：</p>\n<blockquote>\n<p>congratulations! you have passed the api gateway</p>\n</blockquote>\n<p>/user/login这个url 在白名单的范围内，所以它是可以通过权限验证的。</p>\n<p>打开浏览器访问http://116.196.177.123/user/sss，显示以下内容：</p>\n<blockquote>\n<p>401 Authorization Required</p>\n<p>openresty/1.11.2.4</p>\n</blockquote>\n<p>在redis中添加一对key-value，key为token_forezp，value为1，即token_forezp对应的用户的id为1.</p>\n<pre><code>/usr/servers/redis-3.2.6\n\nsrc/redis-cli\n\nset token_forezp 1\n\n</code></pre>\n<p>初始化以下的sql脚本，即给用户id为1的用户关联角色，角色并关联权限：</p>\n<pre><code>INSERT INTO `permission` VALUES (\'1\', \'/user/orgs\');\nINSERT INTO `role` VALUES (\'1\', \'user\');\nINSERT INTO `role_permission` VALUES (\'1\', \'1\', \'1\');\nINSERT INTO `user` VALUES (\'1\', \'forezp\');\nINSERT INTO `user_role` VALUES (\'1\', \'1\', \'1\');\n\n</code></pre>\n<p>用postman请求，在请求头中加入token，值为token_forezp，请求结果如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601114927844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_176"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:31 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616738', 'title': 'Openresty最佳案例 | 第8篇：RBAC介绍、sql和redis模块工具类', 'readNum': '34659', 'commentNum': '1', 'publishTime': '2017-11-23 17:00:35', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616738<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-8-redis-sql-tool.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-8-redis-sql-tool.html</a></strong></p>\n<h2><a id="RBAC_7"></a>RBAC介绍</h2>\n<p>RBAC（Role-Based Access Control，基于角色的访问控制），用户基于角色的访问权限控制。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。如图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601114815562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="sql_tool_14"></a>sql_tool</h2>\n<p>在本案例中，采用的就是这种权限设计的方式。具体的sql语句脚本如下：</p>\n<pre><code>CREATE TABLE `user` (\n`id`  int(11) NOT NULL AUTO_INCREMENT ,\n`name`  varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,\nPRIMARY KEY (`id`)\n)\nENGINE=InnoDB\nDEFAULT CHARACTER SET=latin1 COLLATE=latin1_swedish_ci\nAUTO_INCREMENT=2\nROW_FORMAT=COMPACT\n;\n\n\nCREATE TABLE role(\n`id`  int(11) NOT NULL AUTO_INCREMENT ,\n`name`  varchar(255) CHARACTER SET latin5 NULL DEFAULT NULL ,\nPRIMARY KEY (`id`)\n)\nENGINE=InnoDB\nDEFAULT CHARACTER SET=latin1 COLLATE=latin1_swedish_ci\nAUTO_INCREMENT=2\nROW_FORMAT=COMPACT\n;\n\nCREATE TABLE permission(\n`id`  int(11) NOT NULL AUTO_INCREMENT ,\n`permission`  varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,\nPRIMARY KEY (`id`)\n)\nENGINE=InnoDB\nDEFAULT CHARACTER SET=latin1 COLLATE=latin1_swedish_ci\nAUTO_INCREMENT=3\nROW_FORMAT=COMPACT\n;\n\nCREATE TABLE user_role(\n`id`  int(11) NOT NULL AUTO_INCREMENT ,\n`user_id`  int(11) NULL DEFAULT NULL ,\n`role_id`  int(11) NULL DEFAULT NULL ,\nPRIMARY KEY (`id`)\n)\nENGINE=InnoDB\nDEFAULT CHARACTER SET=latin1 COLLATE=latin1_swedish_ci\nAUTO_INCREMENT=2\nROW_FORMAT=COMPACT\n;\n\n\nCREATE TABLE role_permission(\n`id`  int(11) NOT NULL AUTO_INCREMENT ,\n`role_id`  int(11) NULL DEFAULT NULL ,\n`permission_id`  int(11) NULL DEFAULT NULL ,\nPRIMARY KEY (`id`)\n)\nENGINE=InnoDB\nDEFAULT CHARACTER SET=latin1 COLLATE=latin1_swedish_ci\nAUTO_INCREMENT=3\nROW_FORMAT=COMPACT\n;\n\n\n</code></pre>\n<p>初始化以下的sql脚本，即给用户id为1的用户关联角色，角色并关联权限：</p>\n<pre><code>INSERT INTO `permission` VALUES (\'1\', \'/user/orgs\');\nINSERT INTO `role` VALUES (\'1\', \'user\');\nINSERT INTO `role_permission` VALUES (\'1\', \'1\', \'1\');\nINSERT INTO `user` VALUES (\'1\', \'forezp\');\nINSERT INTO `user_role` VALUES (\'1\', \'1\', \'1\');\n\n</code></pre>\n<p>在本案例中，需要根据user表中的Id获取该Id对应的权限。首先根据userId获取该用户对应的角色，再根据根据该角色获取相应的权限，往往一个用户具有多个角色，而角色又有多个权限。比如查询userId为1 的用户的权限的sql语句如下：</p>\n<pre><code>\nSELECT  a.id,a.permission from permission a ,role_permission b,role c,user_role d,user e WHERE a.id=b.permission_id and c.id=b.role_id and d.role_id=c.id and d.user_id=e.id and e.id=1"\n\n</code></pre>\n<p>在Openresty中怎么连接数据库，怎么查询sql语句，在之前的文章已将讲述过了。根据用户id获取用户的权限的功能是一个使用率极高的功能，所以考虑将这个功能模块化。</p>\n<p>vim /usr/example/lualib/sql_tool.lua ,编辑加入以下的代码：</p>\n<pre><code>local mysql = require("resty.mysql")  \n \nlocal function close_db(db)  \n    if not db then  \n        return  \n    end  \n    db:close()  \nend  \n\nlocal function select_user_permission(user_id)\n\n   local db, err = mysql:new()\n   if not db then  \n      ngx.say("new mysql error : ", err)  \n      return  \n   end \n   db:set_timeout(1000)  \n  \n   local props = {  \n      host = "127.0.0.1",  \n      port = 3306,  \n      database = "test",  \n      user = "root",  \n      password = "123"  \n   }\n\n  local res, err, errno, sqlstate = db:connect(props)  \n  \n  if not res then  \n     ngx.say("connect to mysql error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n     close_db(db)\n  end\n  \n  local select_sql = "SELECT  a.id,a.permission from permission a ,role_permission b,role c,user_role d,user e WHERE a.id=b.permission_id and c.id=b.role_id and d.role_id=c.id and d.user_id=e.id and e.id="..user_id\n  res, err, errno, sqlstate = db:query(select_sql)  \n  if not res then  \n     ngx.say("select error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n     return close_db(db)  \n  end  \n\n   local permissions={}\n   for i, row in ipairs(res) do  \n     for name, value in pairs(row) do\n\tif name == "permission" then\n          table.insert(permissions, 1, value)\n        end  \n \n     end  \n   end  \n return permissions \nend\n\nlocal _M = {  \n    select_user_permission= select_user_permission\n}  \n  \nreturn _M  \n  \n\n</code></pre>\n<p>在上面的代码中，有一个select_user_permission(user_id)方法，该方法根据用户名获取该用户的权限。查出来存在一个table 类型的 local permissions={}中。</p>\n<p>vim /usr/example/example.conf  加上以下的代码：</p>\n<pre><code>location ~ /sql_tool{\n  default_type \'text/html\';\n  content_by_lua_file /usr/example/lua/test_sql_tool.lua;\n }\n\n</code></pre>\n<p>在浏览器上访问http://116.196.177.123/sql_tool，浏览器显示如下的内容：</p>\n<blockquote>\n<p>/user/orgs</p>\n</blockquote>\n<h2><a id="tokentool_183"></a>tokentool</h2>\n<p>在之前的文章讲述了如何使用Openresty连接redis，并操作redis。 这小节将讲述如何使用openresty连接redis，并写几个方法，用于存储用户的token等，并将这些信息模块化，主要有以下几个方法：</p>\n<ul>\n<li>close_redis(red)  通过连接池的方式释放一个连接</li>\n<li>connect() 连接redis</li>\n<li>has_token(token) redis中存在token 与否</li>\n<li>get_user_id(token) 根据token获取用户id</li>\n<li>set_permissions(user_id,permissions) 根据userid设置权限</li>\n<li>get_permissions(user_id)根据userid获取权限</li>\n</ul>\n<p>vim /usr/example/lualib/tokentool.lua 编辑一下内容：</p>\n<pre><code>module("tokentool", package.seeall)\nlocal redis = require "resty.redis"\nlocal str = require "resty.string"\nlocal cjson = require("cjson")  \n\n\nlocal redis_host = "127.0.0.1"\nlocal redis_port = 6379\n\nlocal function close_redis(red)  \n    if not red then  \n        return  \n    end  \n    local pool_max_idle_time = 10000 --毫秒  \n    local pool_size = 100 --连接池大小  \n    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)  \n    if not ok then  \n        ngx.say("set keepalive error : ", err)  \n    end  \nend \n\nlocal function connect()\n    local red = redis:new()\n    red:set_timeout(1000)\n    local ok, err = red:connect(redis_host, redis_port)\n    if not ok then\n        return false\n    end\n    --local res, err = red:auth("xiaoantimes")\n    --if not res then\n     -- ngx.say("failed to authenticate: ", err)\n     -- return false\n    --end\n    --ok, err = red:select(1)\n    --if not ok then\n      --  return false\n    --end\n    return red\nend\n\nfunction has_token(token)\n    local red = connect()\n    if red == false then\n        return false\n    end\n\n    local res, err = red:get(token)\n    if not res then\n        return false\n    end\n    close_redis(red)  \n    return true\nend\n\nfunction set_permissions(user_id,permissions)\n  if (permissions==null) or( permissions==ngx.null) then\n     return false\n  end \n  local str = cjson.encode(permissions)  \n  ngx.log(ngx.ERR,"set redis p:"..str)\n  local red=connect()\n  if red== false then\n     return false\n  end\n  local ok, err = red:set(user_id,str)\n  if not ok then\n     return false\n  end\n  return true \nend\n\nfunction get_permissions(user_id)\n  local red=connect()\n  if red== false then\n     return false\n  end\n  local res, err = red:get(user_id)\n  if (not res) or (res == ngx.null) then\n     return\n  end \n  ngx.log(ngx.ERR,"get redis p:"..res);\n  local permissions=cjson.decode(res)  \n  return permissions\nend\n\nfunction get_user_id(token)\n    local red = connect()\n    local resp, err = red:get(token)  \n    if not resp then  \n      ngx.say("get msg error : ", err)  \n      return close_redis(red)  \n    end  \n    close_redis(red)  \n    return resp\nend\n\n</code></pre>\n<p>vim /usr/example/lua/test_token_tool.lua，加上以下的内容：</p>\n<pre><code>local tokentool= require "tokentool"\nlocal ret = tokentool.has_token("msg")\nngx.log(ngx.ERR,ret)\nif ret == true then\n   ngx.say("ok")\nelse\n   ngx.say("oops,error")\nend\n \n</code></pre>\n<p>在/usr/example/example.conf加上以下的内容：</p>\n<pre><code> location ~ /token_tool{\n     default_type \'text/html\';\n     lua_code_cache on;\n     content_by_lua_file /usr/example/lua/test_token_tool.lua;\n\n }\n \n</code></pre>\n<p>打开浏览器访问http://116.196.177.123/token_tool，浏览器显示：</p>\n<blockquote>\n<p>ok</p>\n</blockquote>\n<h3><a id="_327"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:31'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616714', 'title': 'Openresty最佳案例 | 第7篇： 模块开发、OpenResty连接Redis', 'readNum': '40089', 'commentNum': '0', 'publishTime': '2017-11-23 16:58:41', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616714<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-7-Redis.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-7-Redis.html</a></strong></p>\n<h2><a id="Lua_6"></a>Lua模块开发</h2>\n<p>在实际的开发过程中，不可能把所有的lua代码写在一个lua文件中，通常的做法将特定功能的放在一个lua文件中，即用lua模块开发。在lualib目录下，默认有以下的lua模块。</p>\n<pre><code>lualib/\n├── cjson.so\n├── ngx\n│   ├── balancer.lua\n│   ├── ocsp.lua\n│   ├── re.lua\n│   ├── semaphore.lua\n│   ├── ssl\n│   │   └── session.lua\n│   └── ssl.lua\n├── rds\n│   └── parser.so\n├── redis\n│   └── parser.so\n└── resty\n    ├── aes.lua\n    ├── core\n    │   ├── base64.lua\n    │   ├── base.lua\n    │   ├── ctx.lua\n    │   ├── exit.lua\n    │   ├── hash.lua\n    │   ├── misc.lua\n    │   ├── regex.lua\n    │   ├── request.lua\n    │   ├── response.lua\n    │   ├── shdict.lua\n    │   ├── time.lua\n    │   ├── uri.lua\n    │   ├── var.lua\n    │   └── worker.lua\n    ├── core.lua\n    ├── dns\n    │   └── resolver.lua\n    ├── limit\n    │   ├── conn.lua\n    │   ├── req.lua\n    │   └── traffic.lua\n    ├── lock.lua\n    ├── lrucache\n    │   └── pureffi.lua\n    ├── lrucache.lua\n    ├── md5.lua\n    ├── memcached.lua\n    ├── mysql.lua\n    ├── random.lua\n    ├── redis.lua\n    ├── sha1.lua\n    ├── sha224.lua\n    ├── sha256.lua\n    ├── sha384.lua\n    ├── sha512.lua\n    ├── sha.lua\n    ├── string.lua\n    ├── upload.lua\n    ├── upstream\n    │   └── healthcheck.lua\n    └── websocket\n        ├── client.lua\n        ├── protocol.lua\n        └── server.lua\n\n\n</code></pre>\n<p>在使用这些模块之前，需要在nginx的配置文件nginx.conf中的http模块加上以下的配置：</p>\n<pre><code> lua_package_path "/usr/example/lualib/?.lua;;";  #lua 模块  \n lua_package_cpath "/usr/example/lualib/?.so;;";  #c模块   \n\n</code></pre>\n<p>现在来简单的开发一个lua模块：</p>\n<pre><code>vim /usr/example/lualib/module1.lua \n\n</code></pre>\n<p>在module1.lua文件加上以下的代码：</p>\n<pre><code>local count = 0  \nlocal function hello()  \n   count = count + 1  \n   ngx.say("count : ", count)  \nend  \n  \nlocal _M = {  \n   hello = hello  \n}  \n  \nreturn _M  \n\n\n</code></pre>\n<p>开发时将所有数据做成局部变量/局部函数；通过 _M导出要暴露的函数，实现模块化封装。</p>\n<p>在／usr/example/lua目录下创建一个test_module_1.lua 文件，在该文件中引用上面的module1.lua文件。</p>\n<pre><code>\nvim /usr/example/lua/test_module_1.lua \n\n</code></pre>\n<p>加上以下代码：</p>\n<pre><code>local module1 = require("module1")  \n  \nmodule1.hello() \n \n</code></pre>\n<p>通过require(“模块名”)来加载模块，如果是多级目录，则需要通过require(“目录1.目录2.模块名”）加载。</p>\n<p>在/user/example/example.conf中加上以下的配置：</p>\n<pre><code>location /lua_module_1 {  \n    default_type \'text/html\';  \n    lua_code_cache on;  \n    content_by_lua_file /usr/example/lua/test_module_1.lua;  \n}\n</code></pre>\n<p>多次在浏览器上访问：http://116.196.177.123/lua_module_1，浏览器显示：</p>\n<pre><code>count : 1\ncount : 2\ncount : 3\n\n...\n\n</code></pre>\n<h2><a id="redis_150"></a>安装redis</h2>\n<p>linux下安装：<br>\ncd /usr/servers</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n\n</code></pre>\n<p>启动redis:</p>\n<pre><code>nohup /usr/servers/redis-3.2.6/src/redis-server  /usr/servers/redis-3.2.6/redis.conf &amp;  \n\n</code></pre>\n<p>查看是否启动：</p>\n<pre><code>ps -ef |grep redis\n</code></pre>\n<p>终端显示：</p>\n<pre><code>root     20985 14268  0 18:49 pts/0    00:00:00 /usr/servers/redis-3.2.6/src/redis-server 127.0.0.1:6379\n\n</code></pre>\n<p>可见redis已经启动。</p>\n<h2><a id="luaredis_184"></a>lua连接redis</h2>\n<p>lua_resty_redis模块地址：https://github.com/openresty/lua-resty-redis</p>\n<blockquote>\n<p>lua-resty-redis - Lua redis client driver for the ngx_lua based on the cosocket API</p>\n</blockquote>\n<p>lua_resty_redis 它是一个基于cosocket API的为ngx_lua模块提供Lua redis客户端的驱动。</p>\n<p>创建一个test_redis_basic.lua文件</p>\n<p>vim /usr/example/lua/test_redis_basic.lua</p>\n<pre><code> local function close_redis(red)  \n    if not red then  \n        return  \n    end  \n  \n    local pool_max_idle_time = 10000 --毫秒  \n    local pool_size = 100 --连接池大小  \n    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)  \n    if not ok then  \n        ngx.say("set keepalive error : ", err)  \n    end  \nend    \n  \nlocal redis = require("resty.redis")  \n  \n\nlocal red = redis:new()  \n \nred:set_timeout(1000)  \n\nlocal ip = "127.0.0.1"  \nlocal port = 6379  \nlocal ok, err = red:connect(ip, port)  \nif not ok then  \n    ngx.say("connect to redis error : ", err)  \n    return close_redis(red)  \nend  \n \nok, err = red:set("msg", "hello world")  \nif not ok then  \n    ngx.say("set msg error : ", err)  \n    return close_redis(red)  \nend  \n  \n\nlocal resp, err = red:get("msg")  \nif not resp then  \n    ngx.say("get msg error : ", err)  \n    return close_redis(red)  \nend  \n\nif resp == ngx.null then  \n    resp = \'\'  \nend  \nngx.say("msg : ", resp)  \n  \nclose_redis(red)  \n\n \n</code></pre>\n<p>上面的代码很简单，通过连接池连接Redis，连接上redis后，通过set一对键值对（msg,helloword）到redis中，然后get(msg)，并通过ngx.say()返回给浏览器。</p>\n<p>vim /usr/example/example.conf,添加以下的配置代码：</p>\n<pre><code>location /lua_redis_basic {  \n    default_type \'text/html\';  \n    lua_code_cache on;  \n    content_by_lua_file /usr/example/lua/test_redis_basic.lua;  \n }  \n\n</code></pre>\n<p>浏览器访问：http://116.196.177.123/lua_redis_basic</p>\n<p>浏览器显示：</p>\n<blockquote>\n<p>msg : hello world</p>\n</blockquote>\n<p>lua_resty_redis支持所有的redis指令，本身Redis就支持lua语言操作。所以lua_resty_redis模块能够提高所有的redis操作的功能。</p>\n<p>在很多时候，Redis是设置了口令的，连接时，如果需要验证口令，需要添加 local res, err = red:auth(“foobared”)，示例代码如下：</p>\n<pre><code>  local redis = require "resty.redis"\n    local red = redis:new()\n\n    red:set_timeout(1000) -- 1 sec\n\n    local ok, err = red:connect("127.0.0.1", 6379)\n    if not ok then\n        ngx.say("failed to connect: ", err)\n        return\n    end\n\n    local res, err = red:auth("foobared")\n    if not res then\n        ngx.say("failed to authenticate: ", err)\n        return\n    end\n\n</code></pre>\n<p>更多请关注的官方文档https://github.com/openresty/lua-resty-redis<br>\n和开涛的博客http://jinnianshilongnian.iteye.com/blog/2187328</p>\n<h3><a id="_295"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616698', 'title': 'Openresty最佳案例 | 第6篇：OpenResty连接Mysql', 'readNum': '39026', 'commentNum': '0', 'publishTime': '2017-11-23 16:57:33', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616698<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-6-mysq.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-6-mysq.html</a></strong></p>\n<h2><a id="centos_mysl_7"></a>centos 安装mysl</h2>\n<p>Centos系统下安装mysql，先下载mysql-community-release-el7-5.noarch.rpm，然后通过yum安装，安装过程一直确定【Y】即可。</p>\n<pre><code>cd /usr/downloads/\n\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\n\nrpm -ivh mysql-community-release-el7-5.noarch.rpm\n\nyum install mysql-community-server\n\n\n</code></pre>\n<p>安装成功后，重启mysql，并进入mysql数据库，给root用户设置一个密码，密码为“123”。</p>\n<pre><code>service mysqld restart\n\nmysql -u root -p\n\nset password for root@localhost = password(\'123\'); \n\n</code></pre>\n<h2><a id="openrestymysql_34"></a>openresty连接mysql</h2>\n<p>lua-resty-mysql模块的官方文档地址： https://github.com/openresty/lua-resty-mysql</p>\n<blockquote>\n<p>lua-resty-mysql - Lua MySQL client driver for ngx_lua based on the cosocket API</p>\n</blockquote>\n<p>lua-resty-mysql模块是基于cosocket API 为ngx_lua提供的一个Lua MySQL客户端。它保证了100%非阻塞。</p>\n<p>vim /usr/example/lua/test_mysql.lua，添加以下的代码：</p>\n<pre><code>local function close_db(db)  \n    if not db then  \n        return  \n    end  \n    db:close()  \nend  \n  \nlocal mysql = require("resty.mysql")  \n \nlocal db, err = mysql:new()  \nif not db then  \n    ngx.say("new mysql error : ", err)  \n    return  \nend  \n\ndb:set_timeout(1000)  \n  \nlocal props = {  \n    host = "127.0.0.1",  \n    port = 3306,  \n    database = "mysql",  \n    user = "root",  \n    password = "123"  \n}  \n  \nlocal res, err, errno, sqlstate = db:connect(props)  \n  \nif not res then  \n   ngx.say("connect to mysql error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n \nlocal drop_table_sql = "drop table if exists test"  \nres, err, errno, sqlstate = db:query(drop_table_sql)  \nif not res then  \n   ngx.say("drop table error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \n\nlocal create_table_sql = "create table test(id int primary key auto_increment, ch varchar(100))"  \nres, err, errno, sqlstate = db:query(create_table_sql)  \nif not res then  \n   ngx.say("create table error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \n\nlocal insert_sql = "insert into test (ch) values(\'hello\')"  \nres, err, errno, sqlstate = db:query(insert_sql)  \nif not res then  \n   ngx.say("insert error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \nres, err, errno, sqlstate = db:query(insert_sql)  \n  \nngx.say("insert rows : ", res.affected_rows, " , id : ", res.insert_id, "&lt;br/&gt;")  \n  \n \nlocal update_sql = "update test set ch = \'hello2\' where id =" .. res.insert_id  \nres, err, errno, sqlstate = db:query(update_sql)  \nif not res then  \n   ngx.say("update error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \nngx.say("update rows : ", res.affected_rows, "&lt;br/&gt;")  \n  \nlocal select_sql = "select id, ch from test"  \nres, err, errno, sqlstate = db:query(select_sql)  \nif not res then  \n   ngx.say("select error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \n  \nfor i, row in ipairs(res) do  \n   for name, value in pairs(row) do  \n     ngx.say("select row ", i, " : ", name, " = ", value, "&lt;br/&gt;")  \n   end  \nend  \n  \nngx.say("&lt;br/&gt;")  \n  \nlocal ch_param = ngx.req.get_uri_args()["ch"] or \'\'  \n \nlocal query_sql = "select id, ch from test where ch = " .. ngx.quote_sql_str(ch_param)  \nres, err, errno, sqlstate = db:query(query_sql)  \nif not res then  \n   ngx.say("select error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \nfor i, row in ipairs(res) do  \n   for name, value in pairs(row) do  \n     ngx.say("select row ", i, " : ", name, " = ", value, "&lt;br/&gt;")  \n   end  \nend  \n  \n\nlocal delete_sql = "delete from test"  \nres, err, errno, sqlstate = db:query(delete_sql)  \nif not res then  \n   ngx.say("delete error : ", err, " , errno : ", errno, " , sqlstate : ", sqlstate)  \n   return close_db(db)  \nend  \n  \nngx.say("delete rows : ", res.affected_rows, "&lt;br/&gt;")  \n  \n  \nclose_db(db)  \n\n\n</code></pre>\n<p>在上面的代码中，展示了基本的创表、插入数据、修改数据、查询数据、删除数据的一些功能。</p>\n<p>其中用到的lua-resty-mysql的一些API方法：</p>\n<ul>\n<li>syntax: db, err = mysql:new() 创建一个mysql数据库连接对象</li>\n<li>syntax: ok, err = db:connect(options) 尝试远程连接mysql\n<ul>\n<li>host mysql的主机名</li>\n<li>port 端口</li>\n<li>database 数据库名</li>\n<li>user 用户名</li>\n<li>password 密码</li>\n<li>charset 编码</li>\n</ul>\n</li>\n<li>syntax: db:set_timeout(time) 设置数据库连接超时时间</li>\n<li>syntax: ok, err = db:set_keepalive(max_idle_timeout, pool_size) 设置连接池</li>\n<li>syntax: ok, err = db:close() 关闭数据库</li>\n<li>syntax: bytes, err = db:send_query(query) 发送查询</li>\n</ul>\n<p>lua-resty-mysql的一些关键的API方法，见https://github.com/openresty/lua-resty-mysql#table-of-contents</p>\n<p>vim /usr/example/example.conf 在配置文件配置：</p>\n<pre><code>\nlocation /lua_mysql {\n   default_type \'text/html\';\n   lua_code_cache on;\n   content_by_lua_file /usr/example/lua/test_mysql.lua;\n }\n\n</code></pre>\n<p>浏览器访问http://116.196.177.123/lua_mysql，浏览器显示以下的内容：</p>\n<pre><code>insert rows : 1 , id : 2\nupdate rows : 1\nselect row 1 : ch = hello\nselect row 1 : id = 1\nselect row 2 : ch = hello2\nselect row 2 : id = 2\n\ndelete rows : 2\n\n</code></pre>\n<h3><a id="_211"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616672', 'title': 'Openresty最佳案例 | 第5篇：http和C_json模块', 'readNum': '38750', 'commentNum': '2', 'publishTime': '2017-11-23 16:56:19', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616672<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-5-httpclient.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-5-httpclient.html</a></strong></p>\n<h2><a id="http_7"></a>http客户端</h2>\n<p>Openresty没有提供默认的Http客户端，需要下载第三方的http客户端。</p>\n<p>下载lua-resty-http到lualib目录下，使用以下的命令下载：</p>\n<pre><code>cd /usr/example/lualib/resty/  \nwget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http_headers.lua  \n\nwget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http.lua  \n\n</code></pre>\n<p>lua-resty-http模块的地址为https://github.com/pintsized/lua-resty-http</p>\n<p>安装成功后，通过require(“resty.http”)引入 lua_http模块，它有以下的api方法：</p>\n<ul>\n<li>syntax: httpc = http.new() 创建一个 http对象</li>\n<li>syntax: res, err = httpc:request_uri(uri, params)根据参数获取内容，包括：\n<ul>\n<li>status 状态码</li>\n<li>headers 响应头</li>\n<li>body 响应体</li>\n</ul>\n</li>\n</ul>\n<p>vim /usr/example/lua/test_http.lua，写以下代码：</p>\n<pre><code>local http = require("resty.http")  \n\nlocal httpc = http.new()  \n  \nlocal resp, err = httpc:request_uri("http://s.taobao.com", {  \n    method = "GET",  \n    path = "/search?q=hello",  \n    headers = {  \n        ["User-Agent"] = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36"  \n    }  \n})  \n  \nif not resp then  \n    ngx.say("request error :", err)  \n    return  \nend  \n  \n \nngx.status = resp.status  \n  \n  \nfor k, v in pairs(resp.headers) do  \n    if k ~= "Transfer-Encoding" and k ~= "Connection" then  \n        ngx.header[k] = v  \n    end  \nend  \n  \nngx.say(resp.body)  \n  \nhttpc:close()  \n\n\n</code></pre>\n<p>vim /usr/example/example.conf 加上以下的配置：</p>\n<pre><code> location /lua_http {\n   default_type \'text/html\';\n   lua_code_cache on;\n   content_by_lua_file /usr/example/lua/test_http.lua;\n }\n\n</code></pre>\n<p>在Nginx的配置文件nginx.conf的http部分，加上以下dns解析：</p>\n<p>vim /usr/servers/nginx/conf/nginx.conf</p>\n<pre><code>resolver 8.8.8.8;  \n\n</code></pre>\n<p>浏览器访问：http://116.196.177.123/lua_http,浏览器会显示淘宝的搜索页。</p>\n<h2><a id="lua_cjson_90"></a>lua_cjson模块</h2>\n<p>Json是一种常见的数据交换格式，常用于http通信协议和其他数据传输领域。在openresty默认内嵌了lua_cjson模块，用来序列化数据。</p>\n<p>lua_cjson模块的地址：https://www.kyne.com.au/~mark/software/lua-cjson-manual.html</p>\n<p>它常用的API如下：</p>\n<ul>\n<li>local cjson = require “cjson” 获取一个cjson对象</li>\n<li>local str = cjson.encode(obj) obj转换成string</li>\n<li>local obj = cjson.decode(str) 将string转obj</li>\n</ul>\n<p>vim /usr/example/lua/test_cjson.lua，添加以下内容：</p>\n<pre><code>local cjson = require("cjson")  \n  \n\nlocal obj = {  \n    id = 1,  \n    name = "zhangsan",  \n    age = nil,  \n    is_male = false,  \n    hobby = {"film", "music", "read"}  \n}  \n  \nlocal str = cjson.encode(obj)  \nngx.say(str, "&lt;br/&gt;")  \n  \n \nstr = \'{"hobby":["film","music","read"],"is_male":false,"name":"zhangsan","id":1,"age":null}\'  \nlocal obj = cjson.decode(str)  \n  \nngx.say(obj.age, "&lt;br/&gt;")  \nngx.say(obj.age == nil, "&lt;br/&gt;")  \nngx.say(obj.age == cjson.null, "&lt;br/&gt;")  \nngx.say(obj.hobby[1], "&lt;br/&gt;")  \n\n\n</code></pre>\n<p>vim /usr/example/example.conf添加以下内容：</p>\n<pre><code> location ~ /lua_cjson {  \n   default_type \'text/html\';  \n   lua_code_cache on;  \n   content_by_lua_file /usr/example/lua/test_cjson.lua;  \n }   \n\n</code></pre>\n<p>在浏览器上访问http://116.196.177.123/lua_cjson，浏览器显示以下内容：</p>\n<pre><code>{"hobby":["film","music","read"],"is_male":false,"name":"zhangsan","id":1}\nnull\nfalse\ntrue\nfilm\n\n\n</code></pre>\n<h3><a id="_154"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616645', 'title': 'Openresty最佳案例 | 第3篇:Openresty的安装', 'readNum': '36092', 'commentNum': '0', 'publishTime': '2017-11-23 16:53:58', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616645<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-3-openresty-install.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-3-openresty-install.html</a></strong></p>\n<p>我的服务器为一台全新的centos 7的服务器，所以从头安装openresty，并记录了安装过程中出现的问题，以及解决办法。</p>\n<h2><a id="1openresty_9"></a>1.首先安装openresty</h2>\n<pre><code>cd /usr\nmkdir servers\nmkdir downloads \n\nyum install libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl \n \ncd /usr/servers\n \nwget https://openresty.org/download/openresty-1.11.2.4.tar.gz\ntar -zxvf openresty-1.11.2.4.tar.gz\ncd /usr/servers/bunble/LuaJIT-2.1-20170405\n\n安装Lua\nmake clean &amp;&amp; make &amp;&amp; make install  \n \n</code></pre>\n<p>安装过程中出现以下的错误：</p>\n<blockquote>\n<p>gcc: Command not found</p>\n</blockquote>\n<h2><a id="2gcc_34"></a>2.安装gcc</h2>\n<pre><code>yum -y install gcc automake autoconf libtool make\n</code></pre>\n<h2><a id="3make_39"></a>3.重新make</h2>\n<pre><code>make clean &amp;&amp; make &amp;&amp; make install\n\nln -sf luajit-2.1.0-alpha /usr/local/bin/luajit  \n\n</code></pre>\n<h2><a id="4ngx_cache_purgenginx_48"></a>4.下载ngx_cache_purge模块，该模块用于清理nginx缓存</h2>\n<p>cd /usr/servers/ngx_openresty–1.11.2.4/bundle<br>\nwget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz<br>\ntar -xvf 2.3.tar.gz</p>\n<h2><a id="5nginx_upstream_check_moduleustream_56"></a>5.下载nginx_upstream_check_module模块，该模块用于ustream健康检查</h2>\n<p>cd /usr/servers/ngx_openresty-1.11.2.4/bundle<br>\nwget https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz<br>\ntar -xvf v0.3.0.tar.gz</p>\n<h2><a id="6opresty_63"></a>6.重新安装opresty</h2>\n<pre><code>cd /usr/servers/ngx_openresty-1.11.2.4\n\n./configure --prefix=/usr/servers --with-http_realip_module  --with-pcre  --with-luajit --add-module=./bundle/ngx_cache_purge-2.3/ --add-module=./bundle/nginx_upstream_check_module-0.3.0/ -j2 \n\n</code></pre>\n<p>提示错误，安装pcre库</p>\n<pre><code>yum install -y pcre pcre-devel\n\n</code></pre>\n<p>&lt;1&gt; gcc 安装<br>\n安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p>\n<pre><code>yum install gcc-c++\n</code></pre>\n<p>&lt;2&gt; PCRE pcre-devel 安装</p>\n<p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p>\n<pre><code>yum install -y pcre pcre-devel\n</code></pre>\n<p>&lt;3&gt; zlib 安装<br>\nzlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p>\n<pre><code>yum install -y zlib zlib-devel\n</code></pre>\n<p>&lt;4&gt; OpenSSL 安装<br>\nOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>\nnginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p>\n<pre><code>yum install -y openssl openssl-devel\n</code></pre>\n<p>&lt;5&gt;.重新安装OpenResty</p>\n<pre><code>cd /usr/servers/ngx_openresty-1.11.2.4\n\n./configure --prefix=/usr/servers --with-http_realip_module  --with-pcre  --with-luajit --add-module=./bundle/ngx_cache_purge-2.3/ --add-module=./bundle/nginx_upstream_check_module-0.3.0/ -j2 \n\nmake &amp;&amp; make install  \n</code></pre>\n<p>&lt;6&gt;.启动Nginx</p>\n<pre><code>/usr/servers/nginx/sbin/nginx\n</code></pre>\n<p>浏览器访问http://116.196.177.123：</p>\n<pre><code>Welcome to OpenResty!\n\nIf you see this page, the OpenResty web platform is successfully installed and working. Further configuration is required.\n\nFor online documentation and support please refer to openresty.org.\n\nThank you for flying OpenResty.\n</code></pre>\n<p>安装成功了。</p>\n<h2><a id="6nginx_139"></a>6.配置nginx</h2>\n<pre><code>vim /usr/servers/nginx/conf/nginx.conf  \n</code></pre>\n<p>错误提示没有安装vim</p>\n<pre><code> yum -y install vim*\n</code></pre>\n<p>1、在http部分添加如下配置</p>\n<p>lua模块路径，多个之间”;”分隔，其中”;;”表示默认搜索路径，默认到/usr/servers/nginx下找</p>\n<p>lua_package_path “/usr/servers/lualib/?.lua;;”;  #lua 模块<br>\nlua_package_cpath “/usr/servers/lualib/?.so;;”;  #c模块</p>\n<p>2、在nginx.conf中的http部分添加include lua.conf包含此文件片段<br>\nJava代码  收藏代码<br>\ninclude lua.conf;</p>\n<p>在/usr/server/nginx/conf下</p>\n<p>vim lua.conf</p>\n<pre><code>#lua.conf  \nserver {  \n    listen       80;  \n    server_name  _;  \n    \n    location /lua {  \n    default_type \'text/html\';  \n        content_by_lua \'ngx.say("hello world")\';  \n    } \n}  \n\n\n</code></pre>\n<h2><a id="7_181"></a>7.环境变量：</h2>\n<p>vim  /etc/profile</p>\n<pre><code>JAVA_HOME=/usr/local/jdk/jdk1.8.0_144\nJRE_HOME=$JAVA_HOME/jre\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\nCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jar\nexport JAVA_HOME JRE_HOME PATH CLASSPATH\nexport PATH=$PATH:/usr/servers/nginx/sbin\n\n</code></pre>\n<p>source /etc/profile</p>\n<p>测试：</p>\n<p>nginx -t</p>\n<blockquote>\n<p>nginx: the configuration file /usr/servers/nginx/conf/nginx.conf syntax is ok<br>\nnginx: configuration file /usr/servers/nginx/conf/nginx.conf test is successful</p>\n</blockquote>\n<p>nginx  -s reload</p>\n<p>浏览器访问http://116.196.177.123/lua<br>\n，浏览器显示：</p>\n<blockquote>\n<p>hello world</p>\n</blockquote>\n<h2><a id="8Lua_213"></a>8.将Lua项目化：</h2>\n<blockquote>\n<p>mkdir /usr/example<br>\ncp -r /usr/servers/lualib/  /usr/example/<br>\nmkdir /usr/example/lua</p>\n</blockquote>\n<blockquote>\n<p>cd /usr/example<br>\nvim example.conf</p>\n</blockquote>\n<pre><code>server {  \n    listen       80;  \n    server_name  _;  \n  \n    location /lua {  \n        default_type \'text/html\';  \n        lua_code_cache off;  \n        content_by_lua_file /usr/example/lua/test.lua;  \n    }  \n} \n\n</code></pre>\n<p>vim /usr/example/lua/test.lua</p>\n<pre><code>ngx.say("hello world");  \n</code></pre>\n<p>cd /usr/servers/nginx/conf/</p>\n<p>vim nginx.conf</p>\n<p>http模块：</p>\n<pre><code>http {\n    include       mime.types;\n    default_type  application/octet-stream;\n    lua_package_path "/usr/example/lualib/?.lua;;";  #lua 模块  \n    lua_package_cpath "/usr/example/lualib/?.so;;";  #c模块   \n    include /usr/example/example.conf;\n ....\n ....\n\n}\n</code></pre>\n<p>nginx -t</p>\n<blockquote>\n<p>nginx: [alert] lua_code_cache is off; this will hurt performance in /usr/example/example.conf:7<br>\nnginx: the configuration file /usr/servers/nginx/conf/nginx.conf syntax is ok<br>\nnginx: configuration file /usr/servers/nginx/conf/nginx.conf test is successful</p>\n</blockquote>\n<p>nginx -s reload</p>\n<p>浏览器访问http://116.196.177.123/lua ，</p>\n<blockquote>\n<p>hello world</p>\n</blockquote>\n<p>导出history的所有命令：</p>\n<pre><code>在你的账户目录下    输入命令\nls -a   \n找到 .bash_history\n这个就是记录命令文件。\n输入命令：\ncat   .bash_history &gt;&gt; history.txt\n\n</code></pre>\n<h2><a id="_286"></a>参考资料</h2>\n<p>http://www.linuxidc.com/Linux/2016-09/134907.htm</p>\n<p>http://jinnianshilongnian.iteye.com/blog/2186270</p>\n<p>https://openresty.org/en/</p>\n<h3><a id="_295"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616660', 'title': 'Openresty最佳案例 | 第4篇：OpenResty常见的api', 'readNum': '38518', 'commentNum': '4', 'publishTime': '2017-11-23 16:55:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616660<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-4-openresty-api.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-4-openresty-api.html</a></strong></p>\n<h2><a id="_7"></a>获取请求参数</h2>\n<p>vim  /usr/example/example.conf</p>\n<pre><code> location /lua_var {\n        default_type \'text/plain\';\n        content_by_lua_block {\n         ngx.say(ngx.var.arg_a)\n        }\n   }\n\n</code></pre>\n<p>重新加载nginx配置文件： nginx -s reload</p>\n<p>在浏览器上访问http://116.196.177.123/lua_var?a=323,浏览器显示：</p>\n<blockquote>\n<p>323</p>\n</blockquote>\n<p>在上述代码中，涉及到了2个api, 一是ngx.say（直接返回请求结果）；二是ngx.var，它是获取请求的参数，比如本例子上的？a=323,获取之后，直接输出为请求结果。</p>\n<h2><a id="_30"></a>获取请求类型</h2>\n<p>vim /usr/example/example.conf</p>\n<pre><code>  location /lua_request{\n       default_type \'text/html\';\n       lua_code_cache off;\n       content_by_lua_file  /usr/example/lua/lua_request.lua;\n   }\n\n\n</code></pre>\n<p>vim /usr/example/lua/lua_request.lua ，添加一下代码：</p>\n<pre><code>\nlocal arg = ngx.req.get_uri_args()\nfor k,v in pairs(arg) do\n   ngx.say("[GET ] key:", k, " v:", v)\nend\n\nngx.req.read_body() -- 解析 body 参数之前一定要先读取 body\nlocal arg = ngx.req.get_post_args()\nfor k,v in pairs(arg) do\n   ngx.say("[POST] key:", k, " v:", v)\nend\n\n</code></pre>\n<p>在上述例子中有以下的api:</p>\n<ul>\n<li>ngx.req.get_uri_args 获取在uri上的get类型参数，返回的是一个table类型的数据结构。</li>\n<li>ngx.req.read_body 读取body，这在解析body之前，一定要先读取body。</li>\n<li>ngx.req.get_post_args 获取form表单类型的参数，返回结果是一个table类型的数据。</li>\n</ul>\n<p>使用curl模拟请求：</p>\n<blockquote>\n<p>curl ‘http://116.196.177.123/lua_request?a=323&amp;b=ss’ -d ‘c=12w&amp;d=2se3’</p>\n</blockquote>\n<p>返回的结果：</p>\n<pre><code>[GET ] key:b v:ss\n[GET ] key:a v:323\n[POST] key:d v:2se3\n[POST] key:c v:12w\n\n</code></pre>\n<h2><a id="_80"></a>获取请求头</h2>\n<p>vim /usr/example/lua/lua_request.lua ，在原有的代码基础上，再添加一下代码:</p>\n<pre><code>\nlocal headers = ngx.req.get_headers()\nngx.say("headers begin", "&lt;br/&gt;")\nngx.say("Host : ", headers["Host"], "&lt;br/&gt;")\nngx.say("user-agent : ", headers["user-agent"], "&lt;br/&gt;")\nngx.say("user-agent : ", headers.user_agent, "&lt;br/&gt;")\nfor k,v in pairs(headers) do\n    if type(v) == "table" then\n        ngx.say(k, " : ", table.concat(v, ","), "&lt;br/&gt;")\n    else\n        ngx.say(k, " : ", v, "&lt;br/&gt;")\n    end\nend\n\n</code></pre>\n<p>重新加载nginx -s reload</p>\n<p>使用curl模拟请求：</p>\n<blockquote>\n<p>curl ‘http://116.196.177.123/lua_request?a=323&amp;b=ss’ -d ‘c=12w&amp;d=2se3’</p>\n</blockquote>\n<pre><code>[GET ] key:b v:ss\n[GET ] key:a v:323\n[POST] key:d v:2se3\n[POST] key:c v:12w\nheaders begin&lt;br/&gt;\nHost : 116.196.77.157&lt;br/&gt;\nuser-agent : curl/7.53.0&lt;br/&gt;\nuser-agent : curl/7.53.0&lt;br/&gt;\nhost : 116.196.77.157&lt;br/&gt;\ncontent-type : application/x-www-form-urlencoded&lt;br/&gt;\naccept : */*&lt;br/&gt;\ncontent-length : 12&lt;br/&gt;\nuser-agent : curl/7.53.0&lt;br/&gt;\n\n</code></pre>\n<h2><a id="http_123"></a>获取http的其他方法</h2>\n<p>vim /usr/example/lua/lua_request.lua ，在原有的代码基础上，再添加一下代码:</p>\n<pre><code>ngx.say("ngx.req.http_version : ", ngx.req.http_version(), "&lt;br/&gt;")  \n--请求方法  \nngx.say("ngx.req.get_method : ", ngx.req.get_method(), "&lt;br/&gt;")  \n--原始的请求头内容  \nngx.say("ngx.req.raw_header : ",  ngx.req.raw_header(), "&lt;br/&gt;")  \n--请求的body内容体  \nngx.say("ngx.req.get_body_data() : ", ngx.req.get_body_data(), "&lt;br/&gt;")  \nngx.say("&lt;br/&gt;") \n\n</code></pre>\n<p>重新加载nginx -s reload</p>\n<p>使用curl模拟请求：</p>\n<blockquote>\n<p>curl ‘http://116.196.177.123/lua_request?a=323&amp;b=ss’ -d ‘c=12w&amp;d=2se3’</p>\n</blockquote>\n<pre><code>//....\nngx.req.http_version : 1.1&lt;br/&gt;\nngx.req.get_method : POST&lt;br/&gt;\nngx.req.raw_header : POST /lua_request?a=323&amp;b=ss HTTP/1.1\nHost: 116.196.77.157\nUser-Agent: curl/7.53.0\nAccept: */*\nContent-Length: 12\n\n</code></pre>\n<h2><a id="_156"></a>输出响应</h2>\n<blockquote>\n<p>vim /usr/example/example.conf，添加一个location,代码如下：</p>\n</blockquote>\n<pre><code> location /lua_response{\n        default_type \'text/html\';\n        lua_code_cache off;\n        content_by_lua_file /usr/example/lua/lua_response.lua ;\n  }\n\n</code></pre>\n<blockquote>\n<p>vim /usr/example/lua/lua_response.lua 添加一下代码：</p>\n</blockquote>\n<pre><code>ngx.header.a="1"\nngx.header.b={"a","b"}\nngx.say("hello","&lt;/br&gt;")\nngx.print("sss")\nreturn ngx.exit(200)\n\n\n\n</code></pre>\n<p>上述代码中有以下api:</p>\n<ul>\n<li>ngx.header 向响应头输出内容</li>\n<li>ngx.say 输出响应体</li>\n<li>ngx.print输出响应体</li>\n<li>ngx.exit 指定http状态码退出</li>\n</ul>\n<p>使用curl模拟请求， curl ‘http://116.196.177.123/lua_response’ ，获取的响应体如下：</p>\n<pre><code>hello\nsss\n\n</code></pre>\n<h2><a id="_199"></a>日志输出</h2>\n<p>在配置文件vim /usr/example/example.conf 加上以下代码：</p>\n<pre><code> location /lua_log{\n       default_type \'text/html\';\n       lua_code_cache off;\n       content_by_lua_file  /usr/example/lua/lua_log.lua;\n  }\n\n\n</code></pre>\n<blockquote>\n<p>vim /usr/example/lua/lua_log.lua ，加上以下代码：</p>\n</blockquote>\n<pre><code>\nlocal log="i\'m log"\nlocal num =10\nngx.log(ngx.ERR, "log",log)\nngx.log(ngx.INFO,"num:" ,num)\n\n</code></pre>\n<p>重新加载配置文件nginx -s reload</p>\n<blockquote>\n<p>curl ‘http://116.196.177.123/lua_log’</p>\n</blockquote>\n<p>打开nginx 的logs目录下的error.log 文件：</p>\n<blockquote>\n<p>tail -fn 1000  /usr/servers/nginx/logs/error.log</p>\n</blockquote>\n<p>可以看到在日志文件中已经输出了日志，这种日志主要用于记录和测试。</p>\n<p>日志级别：</p>\n<ul>\n<li>ngx.STDERR – 标准输出</li>\n<li>ngx.EMERG – 紧急报错</li>\n<li>ngx.ALERT – 报警</li>\n<li>ngx.CRIT – 严重，系统故障，触发运维告警系统</li>\n<li>ngx.ERR – 错误，业务不可恢复性错误</li>\n<li>ngx.WARN – 告警，业务中可忽略错误</li>\n<li>ngx.NOTICE – 提醒，业务比较重要信息</li>\n<li>ngx.INFO – 信息，业务琐碎日志信息，包含不同情况判断等</li>\n<li>ngx.DEBUG – 调试</li>\n</ul>\n<h2><a id="_246"></a>内部调用</h2>\n<p>vim /usr/example/example.conf 添加以下代码：</p>\n<pre><code>location /lua_sum{\n      # 只允许内部调用\n      internal;\n      # 这里做了一个求和运算只是一个例子，可以在这里完成一些数据库、\n      # 缓存服务器的操作，达到基础模块和业务逻辑分离目的\n      content_by_lua_block {\n         local args = ngx.req.get_uri_args()\n         ngx.say(tonumber(args.a) + tonumber(args.b))\n      }\n  }\n\n</code></pre>\n<p>internal 关键字，表示只允许内部调用。使用curl模拟请求，请求命令如下：</p>\n<blockquote>\n<p>$ curl ‘http://116.196.177.123/lua_sum?a=1&amp;b=2’</p>\n</blockquote>\n<p>由于该loction是一个内部调用的，外部不能返回，最终返回的结果为404，如下：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\n&lt;body bgcolor="white"&gt;\n&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\n&lt;hr&gt;&lt;center&gt;openresty/1.11.2.4&lt;/center&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n</code></pre>\n<p>vim /usr/example/example.conf 添加以下代码：</p>\n<pre><code>location = /lua_sum_test {\n   content_by_lua_block {\n      local res = ngx.location.capture("/lua_sum", {args={a=3, b=8}})\n      ngx.say("status:", res.status, " response:", res.body)\n   }  \n}\n\n</code></pre>\n<p>上述的代码通过ngx.location.capture去调用内部的location，并获得返回结果，最终将结果输出，采用curl模拟请求：</p>\n<blockquote>\n<p>$ curl ‘http://116.196.177.123/lua_sum_test’</p>\n</blockquote>\n<p>返回结果如下：</p>\n<pre><code>status:200 response:11\n\n</code></pre>\n<h2><a id="_308"></a>重定向</h2>\n<p>vim /usr</p>\n<pre><code>location /lua_redirect{\n    default_type \'text/html\';\n    content_by_lua_file  /usr/example/lua/lua_redirect.lua;\n}  \n</code></pre>\n<pre><code>ngx.redirect("http://www.fangzhipeng.com", 302)\n\n</code></pre>\n<p>http://116.196.177.123/lua_redirect</p>\n<h2><a id="_329"></a>共享内存</h2>\n<p>vim /usr/servers/nginx/cong/nginx.conf</p>\n<p>在http模块加上以下：</p>\n<pre><code>lua_shared_dict shared_data 1m;\n</code></pre>\n<pre><code> location /lua_shared_dict{\n     default_type \'text/html\';\n     content_by_lua_file /usr/example/lua/lua_shared_dict.lua;\n  }\n\n\n</code></pre>\n<pre><code>local shared_data = ngx.shared.shared_data\nlocal i = shared_data:get("i")\nif not i then\n  i = 1\n  shared_data:set("i",i)\nend\ni = shared_data:incr("i",1)\nngx.say("i:",i)\n\n</code></pre>\n<p>多次访问 http://116.196.177.123/lua_shared_dict，浏览器打印：</p>\n<pre><code>i:1\ni:2\ni:3\ni:4\ni:5\n\n</code></pre>\n<h2><a id="OpenResty_373"></a>OpenResty执行阶段的概念</h2>\n<p>以下内容来自于《openresty 最佳实践》</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601114726664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>如上图所示，openresty的执行阶段分为</p>\n<p>这样我们就可以根据我们的需要，在不同的阶段直接完成大部分典型处理了。</p>\n<ul>\n<li>set_by_lua* : 流程分支处理判断变量初始化</li>\n<li>rewrite_by_lua* : 转发、重定向、缓存等功能(例如特定请求代理到外网)</li>\n<li>access_by_lua* : IP 准入、接口权限等情况集中处理(例如配合 iptable 完成简单防火墙)</li>\n<li>content_by_lua* : 内容生成</li>\n<li>header_filter_by_lua* : 响应头部过滤处理(例如添加头部信息)</li>\n<li>body_filter_by_lua* : 响应体过滤处理(例如完成应答内容统一成大写)</li>\n</ul>\n<p>执行阶段概念：</p>\n<ul>\n<li>log_by_lua* : 会话完成后本地异步完成日志记录(日志可以记录在本地，还可以同步到其 他机器)<br>\n实际上我们只使用其中一个阶段</li>\n<li>content_by_lua* ，也可以完成所有的处理。但这样做，会让 我们的代码比较臃肿，越到后期越发难以维护。把我们的逻辑放在不同阶段，分工明确，代 码独立，后期发力可以有很多有意思的玩法。</li>\n</ul>\n<h3><a id="_399"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616622', 'title': 'Openresty最佳案例 | 第2篇：Lua入门', 'readNum': '36598', 'commentNum': '1', 'publishTime': '2017-11-23 16:52:46', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616622<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-2-Lua.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-2-Lua.html</a></strong></p>\n<h2><a id="lua_6"></a>什么是lua</h2>\n<blockquote>\n<p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>\n</blockquote>\n<blockquote>\n<p>Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。<br>\n—摘抄 http://www.runoob.com/lua/lua-tutorial.html</p>\n</blockquote>\n<h2><a id="_16"></a>环境搭建</h2>\n<p>注意： 在上一篇文章中，OpenResty已经有了Lua的环境，这里安装的是单独的Lua环境，用于学习和开发Lua。大多数的电脑是Windowds版本的电脑，Windows版本下载地址http://luaforge.net/projects/luaforwindows/。</p>\n<p>Linux和Mac电脑下载地址：http://luajit.org/download.html，安装命令如下：</p>\n<pre><code>wget http://luajit.org/download/LuaJIT-2.1.0-beta1.tar.gz\n\ntar -xvf LuaJIT-2.1.0-beta1.tar.gz\ncd LuaJIT-2.1.0-beta1\nmake\nsudo make install\n\n</code></pre>\n<p>使用IDEA开发的同学，可以通过安装插件的形式来集成Lua的环境，插件名为EmmyLua，安装插件后，在Idea的右侧栏就会出现Lua的图标，点击图标，就会出现运行Lua代码的窗口。建议使用该插件，可以免去安装Lua环境的麻烦。</p>\n<h2><a id="Lua_36"></a>第一个Lua程序</h2>\n<p>安装好环境后，我采用EmmyLua插件的形式，对Lua的入门语法进行一个简单的讲解。<br>\n打开EmmyLua的终端，在终端上输入：</p>\n<pre><code>print("hi you")\n\n</code></pre>\n<p>按ctrl+enter，终端显示：</p>\n<blockquote>\n<p>hi you</p>\n</blockquote>\n<h2><a id="Lua_49"></a>Lua基本数据类型</h2>\n<p>lua的基本数据类型有nil、string、boolean、number、function类型。</p>\n<h3><a id="nil__53"></a>nil 类型</h3>\n<p>nil类似于Java中的null ，表示空值。变量第一次赋值为nil。</p>\n<pre><code>local num\nprint(num)\nnum=100\nprint(num)\n\n</code></pre>\n<p>终端输出：</p>\n<blockquote>\n<p>nil</p>\n<p>100</p>\n</blockquote>\n<h3><a id="number__70"></a>number (数字)</h3>\n<p>Number 类型用于表示实数，和 Java里面的 double 类型很类似。可以使用数学函数<br>\nmath.floor（向下取整） 和 math.ceil（向上取整） 进行取整操作。</p>\n<pre><code>\nlocal order = 3.99\nlocal score = 98.01\nprint(math.floor(order))\nprint(math.ceil(score))\n\n</code></pre>\n<p>输出：</p>\n<blockquote>\n<p>3</p>\n<p>99</p>\n</blockquote>\n<h3><a id="string__91"></a>string 字符串</h3>\n<p>Lua 中有三种方式表示字符串:<br>\n1、使用一对匹配的单引号。例：‘hello’。<br>\n2、使用一对匹配的双引号。例："abclua<br>\n3.字符串还可以用一种长括号（即[[ ]]） 括起来的方式定义</p>\n<pre><code>ocal str1 = \'hello world\'\nlocal str2 = "hello lua"\nlocal str3 = [["add\\name",\'hello\']]\nlocal str4 = [=[string have a [[]].]=]\nprint(str1) --&gt;output:hello world\nprint(str2) --&gt;output:hello lua\nprint(str3) --&gt;output:"add\\name",\'hello\'\nprint(str4) --\n\n</code></pre>\n<h3><a id="table__110"></a>table (表)</h3>\n<p>Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是字符串（string） 或者 number 类型，但也可以是除 nil 以外的任意类型的值。</p>\n<pre><code>local corp = {\n    web = "www.google.com", --索引为字符串，key = "web",\n                              -- value = "www.google.com"\n    telephone = "12345678", --索引为字符串\n    staff = {"Jack", "Scott", "Gary"}, --索引为字符串，值也是一个表\n    100876, --相当于 [1] = 100876，此时索引为数字\n            -- key = 1, value = 100876\n    100191, --相当于 [2] = 100191，此时索引为数字\n    [10] = 360, --直接把数字索引给出\n    ["city"] = "Beijing" --索引为字符串\n}\n\nprint(corp.web) --&gt;output:www.google.com\nprint(corp["telephone"]) --&gt;output:12345678\nprint(corp[2]) --&gt;output:100191\nprint(corp["city"]) --&gt;output:"Beijing"\nprint(corp.staff[1]) --&gt;output:Jack\nprint(corp[10]) --&gt;output:36\n\n</code></pre>\n<h3><a id="function_136"></a>function(函数)</h3>\n<p>在 Lua 中，函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函<br>\n数，还可以作为其他函数的返回值。</p>\n<pre><code>\nlocal function foo()\n   print("in the function")\n   --dosomething()\n   local x = 10\n   local y = 20\n   return x + y\nend\nlocal a = foo --把函数赋给变量\nprint(a())\n\n--output:\nin the function\n30\n</code></pre>\n<h2><a id="_158"></a>表达式</h2>\n<blockquote>\n<p>~=   不等于</p>\n</blockquote>\n\n<table>\n<thead>\n<tr>\n<th>逻辑运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>or</td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td>not</td>\n<td>逻辑非</td>\n</tr>\n</tbody>\n</table><ul>\n<li>a and b 如果 a 为 nil，则返回 a，否则返回 b;</li>\n<li>a or b 如果 a 为 nil，则返回 b，否则返回 a。</li>\n</ul>\n<pre><code>local c = nil\nlocal d = 0\nlocal e = 100\nprint(c and d) --&gt;打印 nil\nprint(c and e) --&gt;打印 nil\nprint(d and e) --&gt;打印 100\nprint(c or d) --&gt;打印 0\nprint(c or e) --&gt;打印 100\nprint(not c) --&gt;打印 true\nprint(not d) --&gt; 打印 false\n\n</code></pre>\n<p>在 Lua 中连接两个字符串，可以使用操作符“…”（两个点）.</p>\n<pre><code>print("Hello " .. "World") --&gt;打印 Hello World\nprint(0 .. 1) --&gt;打印 01\n</code></pre>\n<h2><a id="_193"></a>控制语句</h2>\n<p>单个 if 分支 型</p>\n<pre><code>x = 10\nif x &gt; 0 then\n    print("x is a positive number")\nend\n\n</code></pre>\n<p>两个分支 if-else 型</p>\n<pre><code>x = 10\nif x &gt; 0 then\n    print("x is a positive number")\nelse\n    print("x is a non-positive number")\nend\n</code></pre>\n<p>多个分支 if-elseif-else 型:</p>\n<pre><code>score = 90\nif score == 100 then\n    print("Very good!Your score is 100")\nelseif score &gt;= 60 then\n    print("Congratulations, you have passed it,your score greater or equal to 60")\n    --此处可以添加多个elseif\nelse\n    print("Sorry, you do not pass the exam! ")\nend\n\n</code></pre>\n<h2><a id="for__231"></a>for 控制结构</h2>\n<p>Lua 提供了一组传统的、小巧的控制结构，包括用于条件判断的 if 用于迭代的 while、repeat<br>\n和 for，本章节主要介绍 for 的使用.</p>\n<h3><a id="for__236"></a>for 数字型</h3>\n<p>for 语句有两种形式：数字 for（numeric for） 和范型 for（generic for） 。<br>\n数字型 for 的语法如下：</p>\n<pre><code>for var = begin, finish, step do\n--body\nend\n\n</code></pre>\n<p>实例1：</p>\n<pre><code>for i = 1, 5 do\n    print(i)\nend\n-- output:\n1 2 3 4 5\n\n</code></pre>\n<p>实例2：</p>\n<pre><code>for i = 1, 10, 2 do\n    print(i)\nend\n-- output:\n1 3 5 7 9\n\n</code></pre>\n<h3><a id="for__270"></a>for 泛型</h3>\n<p>泛型 for 循环通过一个迭代器（iterator） 函数来遍历所有值：</p>\n<pre><code>-- 打印数组a的所有值\n\nlocal a = {"a", "b", "c", "d"}\nfor i, v in ipairs(a) do\n    print("index:", i, " value:", v)\nend\n\n-- output:\nindex: 1 value: a\nindex: 2 value: b\nindex: 3 value: c\nindex: 4 value: d\n\n</code></pre>\n<p>lua的入门就到这里，因为lua语法虽少，但细节有很多，不可能花很多时间去研究这个。入个门，遇到问题再去查资料就行了。另外需要说明的是本文大部分内容为复制粘贴于OPenResty 最佳实践，感谢原作者的开源电子书，让我获益匪浅。更多内容请参考：</p>\n<p>lua入门教程：http://www.runoob.com/lua/lua-tutorial.html</p>\n<p>OPenResty 最佳实践： https://moonbingbing.gitbooks.io/openresty-best-practices/content/index.html</p>\n<h3><a id="_296"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78616591', 'title': 'Openresty最佳案例 | 第1篇：Nginx介绍', 'readNum': '38875', 'commentNum': '0', 'publishTime': '2017-11-23 16:50:48', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/78616591<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-1-Nginx.html" rel="nofollow">https://www.fangzhipeng.com/openresty/2018/01/01/openresty-best-practice-1-Nginx.html</a></strong></p>\n<h2><a id="Nginx__7"></a>Nginx 简介</h2>\n<p>Nginx是一个高性能的Web 服务器，同时是一个高效的反向代理服务器，它还是一个IMAP/POP3/SMTP<br>\n代理服务器。</p>\n<p>由于Nginx采用的是事件驱动的架构，能够处理并发百万级别的tcp连接，高度的模块化设计和自由的BSD许可，使得Nginx有着非常丰富的第三方模块。比如Openresty、API网关Kong。</p>\n<blockquote>\n<p>BSD开源协议是一个给予使用者很大自由的协议。基本上使用者可以"为所欲为",可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>\n</blockquote>\n<h2><a id="Nginx_17"></a>Nginx的优点</h2>\n<ul>\n<li>高并发响应性能非常好，官方Nginx处理静态文件并发5w/s</li>\n<li>反向代理性能非常强。（可用于负载均衡）</li>\n<li>内存和cpu占用率低。（为Apache的1/5-1/10）</li>\n<li>对后端服务有健康检查功能。</li>\n<li>支持PHP cgi方式和fastcgi方式。</li>\n<li>配置代码简洁且容易上手。</li>\n</ul>\n<h2><a id="Nginx_27"></a>Nginx的安装</h2>\n<p>Centos系统安装，请参考这里http://www.linuxidc.com/Linux/2016-09/134907.htm。先复制粘贴下它的文章。</p>\n<h3><a id="1gcc__32"></a>1.gcc 安装</h3>\n<p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p>\n<blockquote>\n<p>yum install gcc-c++</p>\n</blockquote>\n<h3><a id="2PCRE_pcredevel__38"></a>2.PCRE pcre-devel 安装</h3>\n<p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p>\n<blockquote>\n<p>yum install -y pcre pcre-devel</p>\n</blockquote>\n<h3><a id="3zlib__44"></a>3.zlib 安装</h3>\n<p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p>\n<blockquote>\n<p>yum install -y zlib zlib-devel</p>\n</blockquote>\n<h3><a id="4OpenSSL__50"></a>4.OpenSSL 安装</h3>\n<p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>\nnginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p>\n<blockquote>\n<p>yum install -y openssl openssl-devel</p>\n</blockquote>\n<h3><a id="5_56"></a>5.官网下载</h3>\n<p>1.直接下载.tar.gz安装包，地址：https://nginx.org/en/download.html</p>\n<p>2.使用wget命令下载（推荐）。</p>\n<blockquote>\n<p>wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</p>\n</blockquote>\n<h3><a id="6_64"></a>6.解压</h3>\n<p>依然是直接命令：</p>\n<blockquote>\n<p>tar -zxvf nginx-1.10.1.tar.gz<br>\ncd nginx-1.10.1</p>\n</blockquote>\n<h3><a id="7_71"></a>7.配置</h3>\n<p>其实在 nginx-1.10.1 版本中你就不需要去配置相关东西，默认就可以了。当然，如果你要自己配置目录也是可以的。<br>\n使用默认配置</p>\n<blockquote>\n<p>./configure</p>\n</blockquote>\n<h3><a id="8_78"></a>8.编译安装</h3>\n<blockquote>\n<p>make<br>\nmake install</p>\n</blockquote>\n<p>查找安装路径：</p>\n<blockquote>\n<p>whereis nginx</p>\n</blockquote>\n<h2><a id="Nginx_88"></a>Nginx的模块组成</h2>\n<p>Nginx的模块从结构上分为核心模块、基础模块和第三方模块：</p>\n<ul>\n<li>核心模块：HTTP模块、EVENT模块和MAIL模块</li>\n<li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块，</li>\n<li>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。</li>\n</ul>\n<p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同，epoll是linux内核2.6以后才出现的。Nginx采用epoll模型，异步非阻塞，而Apache采用的是select模型。</p>\n<ul>\n<li>Select特点：select 选择句柄的时候，是遍历所有句柄，也就是说句柄有事件响应时，select需要遍历所有句柄才能获取到哪些句柄有事件通知，因此效率是非常低。</li>\n<li>epoll的特点：epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高。</li>\n</ul>\n<h2><a id="Nginx_104"></a>Nginx常用命令</h2>\n<p>nginx 环境变量配置：</p>\n<blockquote>\n<p>export PATH=$PATH:/usr/servers/nginx/sbin</p>\n</blockquote>\n<ul>\n<li>\n<p>查看nginx进程<br>\nps -ef|grep nginx</p>\n</li>\n<li>\n<p>启动nginx<br>\nnginx<br>\n启动结果显示nginx的主线程和工作线程，工作线程的数量跟nginx.conf中的配置参数worker_processes有关。</p>\n</li>\n<li>\n<p>平滑启动nginx<br>\nkill -HUP <code>cat /var/run/nginx.pid</code><br>\n或者<br>\nnginx -s reload</p>\n</li>\n<li>\n<p>强制停止nginx<br>\npkill -9 nginx</p>\n</li>\n<li>\n<p>检查对nginx.conf文件的修改是否正确<br>\nnginx -t</p>\n</li>\n<li>\n<p>停止nginx的命令<br>\nnginx -s stop或者pkill nginx</p>\n</li>\n<li>\n<p>查看nginx的版本信息<br>\nnginx -v</p>\n</li>\n<li>\n<p>查看完整的nginx的配置信息<br>\nnginx -V</p>\n</li>\n</ul>\n<h2><a id="Nginx_139"></a>Nginx的配置</h2>\n<p>通常情况下，Nginx的配置在Ngix的安装目录下的/conf/config.default 文件里,基本配置如下：</p>\n<pre><code>worker_process # 表示工作进程的数量，一般设置为cpu的核数\n\nworker_connections # 表示每个工作进程的最大连接数\n\nserver{} # 块定义了虚拟主机\n    listen # 监听端口\n    server_name # 监听域名\n    location {} # 是用来为匹配的 URI 进行配置，URI 即语法中的“/uri/”\n    location /{} # 匹配任何查询，因为所有请求都以 / 开头\n        root # 指定对应uri的资源查找路径，这里html为相对路径，完整路径为\n        # /opt/nginx-1.7.7/html/\n        index # 指定首页index文件的名称，可以配置多个，以空格分开。如有多\n        # 个，按配置顺序查找。\n\n</code></pre>\n<p>location 常用配置如下：</p>\n\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>location = /uri</td>\n<td>= 表示精确匹配，只有完全匹配上才能生效</td>\n</tr>\n<tr>\n<td>location ^~ /uri</td>\n<td>^~ 开头对URL路径进行前缀匹配，并且在正则之前。</td>\n</tr>\n<tr>\n<td>location ~ pattern</td>\n<td>开头表示区分大小写的正则匹配</td>\n</tr>\n<tr>\n<td>location ~* pattern</td>\n<td>开头表示不区分大小写的正则匹配</td>\n</tr>\n<tr>\n<td>location /uri</td>\n<td>不带任何修饰符，也表示前缀匹配，但是在正则匹配之后</td>\n</tr>\n<tr>\n<td>location /</td>\n<td>通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default</td>\n</tr>\n</tbody>\n</table><p>Nginx的常用配置非常多，以下内容摘自于布尔教育课件，仅供参考：</p>\n<pre><code>\n#定义Nginx运行的用户和用户组\nuser  www www;\n#启动进程,通常设置成和cpu的数量相等\nworker_processes  8;\nworker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;\n#为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。\nworker_rlimit_nofile 102400;\n#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打\n#开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀\n#，所以最好与ulimit -n的值保持一致。\n\n#全局错误日志及PID文件\nerror_log  /usr/local/nginx/logs/error.log; \n#错误日志定义等级，[ debug | info | notice | warn | error | crit ]\npid        /usr/local/nginx/nginx.pid;\n\n#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀.\n#所以建议与ulimit -n的值保持一致。\nworker_rlimit_nofile 65535;\n\n#工作模式及连接数上限\nevents {\n    use   epoll;             \t#epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n    worker_connections  102400;\t#单个后台worker process进程的最大并发链接数 （最大连接数=连接数*进程数）\n    multi_accept on; #尽可能多的接受请求\n}\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp {\n    #设定mime类型,类型由mime.type文件定义\n    include       mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    access_log    /usr/local/nginx/log/nginx/access.log;\n\t sendfile      on;\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用必须设为 on\n\t#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n\t#autoindex  on;  #开启目录列表访问，合适下载服务器，默认关闭。\n\ttcp_nopush on; #防止网络阻塞\n\tkeepalive_timeout 60;\n\t#keepalive超时时间，客户端到服务器端的连接持续有效时间,当出现对服务器的后,继请求时,keepalive-timeout功能可避免建立或重新建立连接。\n    tcp_nodelay   on; #提高数据的实时响应性\n   #开启gzip压缩\n   gzip on;\n\tgzip_min_length  1k;\n\tgzip_buffers     4 16k;\n\tgzip_http_version 1.1;\n\tgzip_comp_level 2; #压缩级别大小，最大为9，值越小，压缩后比例越小，CPU处理更快。\n\t#值越大，消耗CPU比较高。\n\tgzip_types       text/plain application/x-javascript text/css application/xml;\n\tgzip_vary on;\n\tclient_max_body_size 10m;      #允许客户端请求的最大单文件字节数\n    client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\n    proxy_connect_timeout 90;      #nginx跟后端服务器连接超时时间(代理连接超时)\n    proxy_send_timeout 90;         #后端服务器数据回传时间(代理发送超时)\n    proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)\n    proxy_buffer_size 4k;          #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n    proxy_buffers 4 32k;           #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n    proxy_busy_buffers_size 64k;   #高负荷下缓冲大小（proxy_buffers*2）\n\t\n    #设定请求缓冲\n    large_client_header_buffers  4 4k;\n\tclient_header_buffer_size 4k;\n\t#客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k\n\t#不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n\topen_file_cache max=102400 inactive=20s;\n\t#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n\topen_file_cache_valid 30s;\n\t#这个是指多长时间检查一次缓存的有效信息。\n\topen_file_cache_min_uses 1;\n\t#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive\n    #包含其它配置文件，如自定义的虚拟主机\n    include vhosts.conf;\n}\n\n</code></pre>\n<p>配置详解2如下：</p>\n<pre><code>\n\t#这里为后端服务器wugk应用集群配置，根据后端实际情况修改即可，tdt_wugk为负载均衡名称，可以任意指定\n\t#但必须跟vhosts.conf虚拟主机的pass段一致，否则不能转发后端的请求。weight配置权重，在fail_timeout内检查max_fails次数，失败则剔除均衡。\n\tupstream tdt_wugk {\n\t\tserver   127.0.0.1:8080 weight=1 max_fails=2 fail_timeout=30s;\n\t\tserver   127.0.0.1:8081 weight=1 max_fails=2 fail_timeout=30s;\n\t}\n   #虚拟主机配置\n\tserver {\n\t\t#侦听80端口\n        listen       80;\n        #定义使用www.wuguangke.cn访问\n        server_name  www.wuguangke.cn;\n        #设定本虚拟主机的访问日志\n        access_log  logs/access.log  main;\n\t\t\troot   /data/webapps/wugk;  #定义服务器的默认网站根目录位置\n        index index.php index.html index.htm;   #定义首页索引文件的名称\n        #默认请求\n        location ~ /{\n          root   /data/www/wugk;      #定义服务器的默认网站根目录位置\n          index index.php index.html index.htm;   #定义首页索引文件的名称\n          #以下是一些反向代理的配置.\n\t\t  proxy_next_upstream http_502 http_504 error timeout invalid_header;\n\t\t  #如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。\n          proxy_redirect off;\n          #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n          proxy_set_header Host $host;\n          proxy_set_header X-Real-IP $remote_addr;\n          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\t\t   proxy_pass  http://tdt_wugk;     #请求转向后端定义的均衡模块\n       }\n\t   \n        # 定义错误提示页面\n\t\t\terror_page   500 502 503 504 /50x.html;  \n            location = /50x.html {\n            root   html;\n        }\n\t\t#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。\n\t\tlocation ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$\n\t\t{\n\t\t\troot /data/www/wugk;\n\t\t\t#expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力。\n\t\t\texpires      3d;\n\t\t}\n        #PHP脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\n        location ~ \\.php$ {\n            root /root;\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            fastcgi_param SCRIPT_FILENAME /data/www/wugk$fastcgi_script_name;\n            include fastcgi_params;\n        }\n        #设定查看Nginx状态的地址\n        location /NginxStatus {\n            stub_status  on;\n        }\n     }\n}\n\n</code></pre>\n<h2><a id="Nginx__320"></a>Nginx 内置绑定变量</h2>\n\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$arg_name</td>\n<td>请求中的name参数</td>\n</tr>\n<tr>\n<td>$args</td>\n<td>请求中的参数</td>\n</tr>\n<tr>\n<td>$binary_remote_addr</td>\n<td>远程地址的二进制表示</td>\n</tr>\n<tr>\n<td>$body_bytes_sent</td>\n<td>已发送的消息体字节数</td>\n</tr>\n<tr>\n<td>$content_length HTTP</td>\n<td>请求信息里的"Content-Length"</td>\n</tr>\n<tr>\n<td>$content_type</td>\n<td>请求信息里的"Content-Type"</td>\n</tr>\n<tr>\n<td>$document_root</td>\n<td>针对当前请求的根路径设置值</td>\n</tr>\n<tr>\n<td>$host</td>\n<td>请求信息中的"Host"，如果请求中没有Host行，则等于设置的服务器名</td>\n</tr>\n<tr>\n<td>$hostname</td>\n<td>机器名使用 gethostname系统调用的值</td>\n</tr>\n<tr>\n<td>$http_cookie</td>\n<td>cookie 信息</td>\n</tr>\n<tr>\n<td>$http_referer</td>\n<td>引用地址</td>\n</tr>\n<tr>\n<td>$http_user_agent</td>\n<td>客户端代理信息</td>\n</tr>\n<tr>\n<td>$http_via</td>\n<td>最后一个访问服务器的Ip地址。</td>\n</tr>\n<tr>\n<td>$http_x_forwarded_for</td>\n<td>相当于网络访问路径</td>\n</tr>\n<tr>\n<td>$is_args</td>\n<td>如果请求行带有参数，返回“?”，否则返回空字符串</td>\n</tr>\n<tr>\n<td>$limit_rate</td>\n<td>对连接速率的限制</td>\n</tr>\n<tr>\n<td>$nginx_version</td>\n<td>当前运行的nginx版本号</td>\n</tr>\n<tr>\n<td>$pid worker</td>\n<td>进程的PID</td>\n</tr>\n<tr>\n<td>$query_string</td>\n<td>与args相同</td>\n</tr>\n<tr>\n<td>$realpath_root</td>\n<td>按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径，使用 Nginx 内置绑定变量</td>\n</tr>\n<tr>\n<td>207$remote_addr</td>\n<td>客户端IP地址</td>\n</tr>\n<tr>\n<td>$remote_port</td>\n<td>客户端端口号</td>\n</tr>\n<tr>\n<td>$remote_user</td>\n<td>客户端用户名，认证用</td>\n</tr>\n<tr>\n<td>$request</td>\n<td>用户请求</td>\n</tr>\n<tr>\n<td>$request_body</td>\n<td>这个变量（0.7.58+） 包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义</td>\n</tr>\n<tr>\n<td>$request_body_file</td>\n<td>客户端请求主体信息的临时文件名</td>\n</tr>\n<tr>\n<td>$request_completion</td>\n<td>如果请求成功，设为"OK"；如果请求未完成或者不是一系列请求中最后一部分则设为空</td>\n</tr>\n<tr>\n<td>$request_filename</td>\n<td>当前请求的文件路径名，比如/opt/nginx/www/test.php</td>\n</tr>\n<tr>\n<td>$request_method</td>\n<td>请求的方法，比如"GET"、"POST"等</td>\n</tr>\n<tr>\n<td>$request_uri</td>\n<td>请求的URI，带参数</td>\n</tr>\n<tr>\n<td>$scheme</td>\n<td>所用的协议，比如http或者是https</td>\n</tr>\n<tr>\n<td>$server_addr</td>\n<td>服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)</td>\n</tr>\n<tr>\n<td>$server_name</td>\n<td>请求到达的服务器名</td>\n</tr>\n<tr>\n<td>$server_port</td>\n<td>请求到达的服务器端口号</td>\n</tr>\n<tr>\n<td>$server_protocol</td>\n<td>请求的协议版本，“HTTP/1.0"或"HTTP/1.1”</td>\n</tr>\n<tr>\n<td>$uri</td>\n<td>请求的URI，可能和最初的值有不同，比如经过重定向之类的</td>\n</tr>\n</tbody>\n</table><h2><a id="_363"></a>参考资料</h2>\n<p>http://www.linuxidc.com/Linux/2016-09/134907.htm</p>\n<p>https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx/nginx.html</p>\n<p>布尔教育课件</p>\n<h3><a id="_371"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78081673', 'title': 'Java 代理模式', 'readNum': '45710', 'commentNum': '1', 'publishTime': '2017-09-25 09:00:40', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/78081673">http://blog.csdn.net/forezp/article/details/78081673</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h2><a id="_5"></a>什么是代理</h2>\n<p>代理是一种设计模式，它的核心思想，是将对目标的访问转移到代理对象上。这样做的好处就是，目标对象在不改变代码的情况下，可以通过代理对象加一些额外的功能。这是一种编程思想，在不改变原有代码的情况下，通过代理增加一些扩展功能。</p>\n<p>代理过程如图所示，用户访问代理对象，代理对象通过访问目标对象，来达到用户访问目标对象的目的，</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121037187.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>代理模式包含一下三个角色：</p>\n<ul>\n<li>ISubject：接口对象，该接口是对象和它的代理共用的接口。</li>\n<li>TargetSubject：目标对象，是实现抽象主题接口的类。</li>\n<li>Proxy：代理角色，内部含有对目标对象TargetSubject的引用，从而可以操作真实对象。代理对象提供与目标对象相同的接口，以便在任何时刻都能代替目标对象。同时，代理对象可以在执行目标对象操作时，附加其他的操作，相当于对真实对象进行封装。</li>\n</ul>\n<p>常见的代理模式分为静态代理和动态代理，动态代理在Java中的实现分为JDK动态代理和cglib代理。</p>\n<h2><a id="_24"></a>静态代理</h2>\n<p>在之前已经说过，在代理模式中有三个角色，一是目标接口，二是目标对象，三是代理对象。</p>\n<p>现在以具体代码来实现，首先是目标接口如下：</p>\n<pre><code> public interface IBlogService {\n\n    void writeBlog();\n}\n\n</code></pre>\n<p>目标对象实现了目标接口，代码如下：</p>\n<pre><code>public class BlogService implements IBlogService {\n\n    @Override\n    public void writeBlog() {\n        System.out.println("i\'m writing...");\n    }\n}\n\n\n</code></pre>\n<p>静态代理对象，通过构造方法获取到目标对象，并实现了目标接口，在目标接口的方法里调用了目标对象的方法，代码如下：</p>\n<pre><code>public class BlogStaticProxy implements IBlogService{\n    private IBlogService blogService;\n\n    public BlogStaticProxy(IBlogService blogService) {\n        this.blogService = blogService;\n    }\n\n\n\n    @Override\n    public void writeBlog() {\n        System.out.println("start writing...");\n        blogService.writeBlog();\n        System.out.println("end writing...");\n    }\n}\n\n\n</code></pre>\n<p>测试：</p>\n<pre><code>public class TestStaticProxy {\n\n    public static void main(String[] args) {\n        IBlogService target = new BlogService();\n        BlogStaticProxy proxy = new BlogStaticProxy(target);\n        proxy.write();\n    }\n}\n</code></pre>\n<blockquote>\n<p>start writing…</p>\n<p>i’m writing…</p>\n<p>end writing…</p>\n</blockquote>\n<p>静态代理，在不修改目标对象的情况下，可以通过代理对象做额外的扩展功能。但静态方法不是很灵活，如果目标接口的代码修改，目标对象和代理对象都需要修改。</p>\n<p>动态代理在一定程度上避免这种情况，动态代理不需要代理对象实现目标接口，并且上在java 虚拟机的内存中动态的生成代理对象</p>\n<h2><a id="Jdk_100"></a>Jdk动态对象</h2>\n<p>Jdk的动态代理由Proxy这个类来生成，它有三个参数：</p>\n<ul>\n<li>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>\n<li>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</li>\n<li>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</li>\n</ul>\n<pre><code> public static Object newProxyInstance(ClassLoader loader,\n                                          Class&lt;?&gt;[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n    \n    }\n\n</code></pre>\n<p>Jdk的动态代理代码如下：</p>\n<pre><code> public class JdkBlogProxyFactory {\n\n    private Object target;\n\n    public JdkBlogProxyFactory(Object target) {\n        this.target = target;\n    }\n\n    public Object newInstance() {\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),\n                (proxy, method, args) -&gt; {\n                    System.out.println("start writing");\n                    Object o = method.invoke(target, args);\n                    System.out.println("end writing");\n                    return o;\n                });\n    }\n}\n\n</code></pre>\n<p>测试类：</p>\n<pre><code>public class TestJdkProxy {\n    public static void main(String[] args) {\n\n        IBlogService target = new BlogService();\n\n        System.out.println(target.getClass());\n\n        // 给目标对象，创建代理对象\n        IBlogService proxy = (IBlogService) new JdkBlogProxyFactory(target).newInstance();\n        // class $Proxy0   内存中动态生成的代理对象\n        System.out.println(proxy.getClass());\n\n        // 执行方法   【代理对象】\n        proxy.writeBlog();\n    }\n}\n\n\n</code></pre>\n<p>控制台打印如下：</p>\n<pre><code>class com.forezp.proxy.BlogService\nclass com.sun.proxy.$Proxy0\nstart writing\ni\'m writing...\nend writing\n\n</code></pre>\n<h2><a id="CGLib_175"></a>CGLib动态代理</h2>\n<p>CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>\n<p>CglibBlogFactory代理工厂类如下：</p>\n<pre><code>public class CglibBlogFactory implements MethodInterceptor {\n\n    private Object target;\n\n    public CglibBlogFactory(Object target) {\n        this.target = target;\n    }\n\n    //给目标对象创建一个代理对象\n    public Object getProxyInstance() {\n        //1.工具类\n        Enhancer en = new Enhancer();\n        //2.设置父类\n        en.setSuperclass(target.getClass());\n        //3.设置回调函数\n        en.setCallback(this);\n        //4.创建子类(代理对象)\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println("start writing...");\n        //执行目标对象的方法\n        Object returnValue = method.invoke(target, objects);\n        System.out.println("end writing...");\n        return returnValue;\n    }\n}\n\n</code></pre>\n<p>测试类：</p>\n<pre><code>public class TestCglib {\n\n    public static void main(String[] args) {\n        IBlogService target = new BlogService();\n        //代理对象\n        IBlogService proxy = (IBlogService) new CglibBlogFactory(target).getProxyInstance();\n        //执行代理对象的方法\n        proxy.writeBlog();\n    }\n}\n\n</code></pre>\n<p>运行程序，控制台打印：</p>\n<pre><code>start writing...\ni\'m writing...\nend writing...\n\n</code></pre>\n<h2><a id="_240"></a>参考资料</h2>\n<p><a href="http://www.cnblogs.com/cenyu/p/6289209.html" rel="nofollow">http://www.cnblogs.com/cenyu/p/6289209.html</a></p>\n<p><a href="http://blog.csdn.net/yakoo5/article/details/9099133/">http://blog.csdn.net/yakoo5/article/details/9099133/</a></p>\n<h3><a id="_247"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_254"></a>关注我</h2>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:32 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/78026146', 'title': 'Java注解详解', 'readNum': '47352', 'commentNum': '0', 'publishTime': '2017-09-19 09:15:39', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/78026146">http://blog.csdn.net/forezp/article/details/78026146</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>在使用SpringBoot作为Web敏捷开发的框架之后，SpringBoot除了自动装配配置的便捷之外，在很多时候需要基于注解来开发。注解不仅增加了代码的可读性，还增加了开发的速度。这篇文章主要讲述Java 注解。</p>\n<!--more-->\n<h2><a id="_8"></a>元注解</h2>\n<p>元注解用于注解其他注解的。Java 5.0定义了4个标准的元注解，如下：</p>\n<ul>\n<li>@Target</li>\n<li>@Retention</li>\n<li>@Documented</li>\n<li>Inherited</li>\n</ul>\n<p>现在来说说这四个元注解有什么作用。</p>\n<h3><a id="Target_19"></a>@Target</h3>\n<p>@Target注解用于声明注解的作用范围，例如作用范围为类、接口、方法等。它的取值以及值所对应的范围如下：</p>\n<ul>\n<li>CONSTRUCTOR:用于描述构造器</li>\n<li>FIELD:用于描述域</li>\n<li>LOCAL_VARIABLE:用于描述局部变量</li>\n<li>METHOD:用于描述方法</li>\n<li>PACKAGE:用于描述包</li>\n<li>PARAMETER:用于描述参数</li>\n<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>\n</ul>\n<h3><a id="Retention_31"></a>@Retention</h3>\n<p>该注解声明了注解的生命周期，即注解在什么范围内有效。</p>\n<ul>\n<li>SOURCE:在源文件中有效</li>\n<li>CLASS:在class文件中有效</li>\n<li>RUNTIME:在运行时有效（即运行时保留）</li>\n</ul>\n<p>大多数注解都为RUNTIME</p>\n<h3><a id="Documented_41"></a>@Documented</h3>\n<p>是一个标记注解，有该注解的注解会在生成 java 文档中保留。</p>\n<h3><a id="Inherited_45"></a>@Inherited</h3>\n<p>该注解表明子类是有继承了父类的注解。比如一个注解被该元注解修饰，并且该注解的作用在父类上，那么子类有持有该注解。如果注解没有被该元注解修饰，则子类不持有父类的注解。</p>\n<h2><a id="_49"></a>自定义注解</h2>\n<p>在Java开发者，JDK自带了一些注解，在第三方框架Spring  带了大量的注解，这些注解称为第三方注解。在很多实际开发过程中，我们需要定义自己的注解。那么现在以案例的方式来讲解自定义注解。</p>\n<p>在注解中，需要使用四种元注解来声明注解的作用范围、生命周期、继承，是否生成文档等。另外在注解中也可以有自己的成员变量，如果一个注解没有成员变量则称为标记注解。注解的成员变量，只支持原始类型、Class、Enumeration、Annoation。</p>\n<p>现在定义一个@Writer注解，该注解被Retention、Documented、Inherited、Target修饰，表明该注解的作用范围为类、接口和方法，生命周期为运行时、该注解生成文档，并且子类可继承该注解。该注解有2个成员变量，一个为name一个为 age,代码如下：</p>\n<pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Target({ElementType.TYPE,ElementType.METHOD})\npublic @interface Writer {\n\n    String name();\n\n    int age();\n\n}\n\n</code></pre>\n<p>那么有了该注解，怎么用呢？</p>\n<p>该注解的作用范围为类、方法，写一个WriterTest，代码如下：</p>\n<pre><code>@Writer(name = "forezp", age = 12)\npublic class WriterTest {\n\n    @Writer(name = "miya", age = 10)\n    public void writeBlog() {\n        System.out.println("writing blog");\n    }\n    \n  }\n \n</code></pre>\n<p>该类有了这个注解有何用？</p>\n<p>一般来说，用该类修饰的类，需要通过反射来做一下逻辑的开发的工作，可广泛用于AOP、程序的配置等。现在写一个方法通过反射来解析该注解：</p>\n<pre><code>  public static void main(String[] args) throws ClassNotFoundException {\n        Class c = Class.forName("com.forezp.annotation.WriterTest");\n        if (c.isAnnotationPresent(Writer.class)) {\n            Writer w = (Writer) c.getAnnotation(Writer.class);\n            System.out.println("name:" + w.name() + "   age:" + w.age());\n        }\n        Method[] methods = c.getMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Writer.class)) {\n                Writer w = method.getAnnotation(Writer.class);\n                System.out.println("name:" + w.name() + "   age:" + w.age());\n            }\n        }\n    }\n\n</code></pre>\n<p>这些代码基本为反射的内容，因为反射在另一篇文章已经详细讲述过，不再重复，运行该Main方法,控制台打印出如下内容：</p>\n<blockquote>\n<p>name:forezp   age:12</p>\n<p>name:miya   age:10</p>\n</blockquote>\n<h2><a id="_118"></a>案例实战</h2>\n<p>有了上述的讲解，你可能对注解有所了解，但是对注解的具体应用并不是很深刻。现在以一个案例来详细讲述。</p>\n<p>大家都对ORM框架Mybitis都非常的熟悉，在这个框架中用了大量的注解。现在模仿这个框架，通过自定义注解，来解析sql 的查询语句。实现过程大概如下：</p>\n<ul>\n<li>定义@Table @Colum注解</li>\n<li>定义一个实体User，定义一些基本的字段，并用注解修饰</li>\n<li>用User类new对象，给对象的某些字段赋值</li>\n<li>通过反射和注解来生成sql 的查询语句</li>\n</ul>\n<p>首先定义个一个Table注解，它的作用范围为类，代码如下：</p>\n<pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Inherited\npublic @interface Table {\n    String value() default "";\n}\n\n</code></pre>\n<p>定义一个Column注解，作用范围为字段，代码如下：</p>\n<pre><code>@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface Column {\n    String value();\n}\n\n</code></pre>\n<p>定义一个User类，在该类的加上@Table注解，在具体的字段上 @Column注解，代码如下：</p>\n<pre><code>@Table("user")\npublic class User {\n    @Column("id")\n    private int id;\n    @Column("name")\n    private String name;\n    @Column("age")\n    private int age;\n    @Column("address")\n    private String address;\n    ..//省略getter setter\n   }\n</code></pre>\n<p>写一个生成sql语句的类，它是通过反射来获取表名、字段名，加上判断实体对象的字段值来生成 查询的 sql 语句的。代码如下：</p>\n<pre><code>public class GenUserSql {\n\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        User u1 = new User();\n        User u2 = new User();\n        u1.setId(1);\n        u2.setName("forezp");\n        genSql(u2);\n        genSql(u1);\n    }\n\n    private static void genSql(User user) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        Class c = user.getClass();\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append("select * from ");\n        if (c.isAnnotationPresent(Table.class)) {\n            Table table = (Table) c.getAnnotation(Table.class);\n            String tableName = table.value();\n            stringBuilder.append(tableName).append(" where 1=1 and ");\n        }\n        Field[] fields = c.getDeclaredFields();\n        for (Field field : fields) {\n            String columnName;\n            if (field.isAnnotationPresent(Column.class)) {\n                Column column = field.getAnnotation(Column.class);\n                columnName = column.value();\n            } else {\n                continue;\n            }\n            String fieldName = field.getName();\n            String getMethodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);\n                       Method method = c.getMethod(getMethodName);\n            Object fieldValue = method.invoke(user);\n            if (fieldValue == null || ((fieldValue instanceof Integer) &amp;&amp; (Integer) fieldValue == 0)) {\n                continue;\n            }\n            if (fieldValue instanceof Integer) {\n                stringBuilder.append(columnName + "=" + fieldValue);\n            }\n            if (fieldValue instanceof String) {\n                stringBuilder.append(columnName + "=" + "\'" + fieldValue + "\'");\n            }\n\n        }\n        System.out.println(stringBuilder.toString());\n\n    }\n}\n\n</code></pre>\n<p>运行程序，控制台打印如下：</p>\n<blockquote>\n<p>select * from user where 1=1 and name=‘forezp’</p>\n</blockquote>\n<p>select * from user where 1=1 and id=1</p>\n<blockquote></blockquote>\n<h3><a id="_235"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_242"></a>参考资料</h2>\n<p><a href="http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" rel="nofollow">http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html</a></p>\n<p>慕课网视频</p>\n<h2><a id="_248"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/java-study">https://github.com/forezp/java-study</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:32'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/77580491', 'title': 'Java并发编程：JMM和volatile关键字', 'readNum': '47666', 'commentNum': '2', 'publishTime': '2017-08-25 16:46:29', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/77580491">http://blog.csdn.net/forezp/article/details/77580491</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h2><a id="Java_5"></a>Java内存模型</h2>\n<p>随着计算机的CPU的飞速发展，CPU的运算能力已经远远超出了从主内存（运行内存）中读取的数据的能力，为了解决这个问题，CPU厂商设计出了CPU内置高速缓存区。高速缓存区的加入使得CPU在运算的过程中直接从高速缓存区读取数据，在一定程度上解决了性能的问题。但也引起了另外一个问题，在CPU多核的情况下，每个处理器都有自己的缓存区，数据如何保持一致性。为了保证多核处理器的数据一致性，引入多处理器的数据一致性的协议，这些协议包括MOSI、Synapse、Firely、DragonProtocol等。</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112120980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>JVM在执行多线程任务时，共享数据保存在主内存中，每一个线程（执行再不同的处理器）有自己的高速缓存，线程对共享数据进行修改的时候，首先是从主内存拷贝到线程的高速缓存，修改之后，然后从高速缓存再拷贝到主内存。当有多个线程执行这样的操作的时候，会导致共享数据出现不可预期的错误。</p>\n<p>举个例子：</p>\n<blockquote>\n<p>i++;//操作</p>\n</blockquote>\n<p>这个i++操作，线程首先从主内存读取i的值，比如i=0，然后复制到自己的高速缓存区，进行i++操作，最后将操作后的结果从高速缓存区复制到主内存中。如果是两个线程通过操作i++,预期的结果是2。这时结果真的为2吗？答案是否定的。线程1读取主内存的i=0,复制到自己的高速缓存区，这时线程2也读取i=0,复制到自己的高速缓存区，进行i++操作，怎么最终得到的结构为1，而不是2。</p>\n<p>为了解决缓存不一致的问题，有两种解决方案：</p>\n<ul>\n<li>在总线加锁，即同时只有一个线程能执行i++操作（包括读取、修改等）。</li>\n<li>通过缓存一致性协议</li>\n</ul>\n<p>第一种方式就没什么好说的，就是同步代码块或者同步方法。也就只能一个线程能进行对共享数据的读取和修改，其他线程处于线程阻塞状态。<br>\n第二种方式就是缓存一致性协议，比如Intel 的MESI协议，它的核心思想就是当某个处理器写变量的数据，如果其他处理器也存在这个变量，会发出信号量通知该处理器高速缓存的数据设置为无效状态。当其他处理需要读取该变量的时候，会让其重新从主内存中读，然后再复制到高速缓存区。</p>\n<h2><a id="_30"></a>编发编程的概念</h2>\n<p>并发编程的有三个概念，包括原子性、可见性、有序性。</p>\n<h3><a id="_34"></a>原子性</h3>\n<p>原子性是指，操作为原子性的，要么成功，要么失败，不存在第三种情况。比如：</p>\n<pre><code>String s="abc";\n</code></pre>\n<p>这个复杂操作是原子性的。再比如：</p>\n<pre><code>int i=0;\ni++;\n</code></pre>\n<p>i=0这是一个赋值操作，这一步是原子性操作；那么i++是原子性操作吗？当然不是，首先它需要读取i=0，然后需要执行运算，写入i的新值1，它包含了读取和写入两个步骤，所以不是原子性操作。</p>\n<h3><a id="_51"></a>可见性</h3>\n<p>可见性是指共享数据的时候，一个线程修改了数据，其他线程知道数据被修改，会重新读取最新的主存的数据。<br>\n举个例子：</p>\n<pre><code>i=0;//主内存\n\ni++;//线程1\n\nj=i;//线程2\n\n</code></pre>\n<p>线程1修改了i值，但是没有将i值复制到主内存中，线程2读取i的值，并将i的值赋值给j,我们期望j=1,但是由于线程1修改了，没有来得及复制到主内存中，线程2读取了i,并赋值给j，这时j的值为0。<br>\n也就是线程i值被修改，其他线程并不知道。</p>\n<h3><a id="_67"></a>有序性</h3>\n<p>是指代码执行的有序性，因为代码有可能发生指令重排序（Instruction Reorder）。</p>\n<p>Java 语言提供了 volatile 和 synchronized 两个关键字来线程代码操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 在单线程中执行代码，无论指令是否重排，最终的执行结果是一致的。</p>\n<h2><a id="volatile_73"></a>volatile详解</h2>\n<h3><a id="volatile_75"></a>volatile关键字作用</h3>\n<p>被volatile关键字修饰变量，起到了2个作用：</p>\n<blockquote>\n<p>1.某个线程修改了被volatile关键字修饰变量是，根据数据一致性的协议，通过信号量，更改其他线程的高速缓存中volatile关键字修饰变量状态为无效状态，其他线程如果需要重写读取该变量会再次从主内存中读取，而不是读取自己的高速缓存中的。</p>\n<p>2.被volatile关键字修饰变量不会指令重排序。</p>\n</blockquote>\n<h3><a id="volatile_83"></a>volatile能够保证可见性和防止指令重排</h3>\n<p>在Java并发编程实战一书中有这样</p>\n<pre><code>public class NoVisibility {\n    private static boolean ready;\n    private static int a;\n\n    public static void main(String[] args) throws InterruptedException {\n        new ReadThread().start();\n        Thread.sleep(100);\n        a = 32;\n        ready = true;\n      \n\n    }\n\n    private static class ReadThread extends Thread {\n        @Override\n        public void run() {\n            while (!ready) {\n                Thread.yield();\n            }\n            System.out.println(a);\n        }\n    }\n}\n\n</code></pre>\n<p>在上述代码中，有可能（概率非常小，但是有这种可能性）永远不会打印a的值，因为线程ReadThread读取了主内存的ready为false,主线程虽然更新了ready，但是ReadThread的高速缓存中并没有更新。<br>\n另外：</p>\n<blockquote>\n<p>a = 32;</p>\n<p>ready = true;</p>\n</blockquote>\n<p>这两行代码有可能发生指令重排。也就是可以打印出a的值为0。</p>\n<p>如果在变量加上volatile关键字，可以防止上述两种不正常的情况的发生。</p>\n<h3><a id="volatile_128"></a>volatile不能保证原子性</h3>\n<p>首先用一段代码测试下，开起了10个线程，这10个线程共享一个变量inc（被volatile修饰），并在每个线程循环1000次对inc进行inc++操作。我们预期的结果是10000.</p>\n<pre><code>public class VolatileTest {\n\n\n    public volatile int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final VolatileTest test = new VolatileTest();\n        for (int i = 0; i &lt; 10; i++) {\n            new Thread(() -&gt; {\n                for (int j = 0; j &lt; 1000; j++)\n                    test.increase();\n            }).start();\n        }\n        //保证前面的线程都执行完\n        Thread.sleep(3000);\n        System.out.println(test.inc);\n    }\n\n}\n\n</code></pre>\n<p>多次运行main函数，你会发现结果永远都不会为10000，都是小于10000。可能有这样的疑问，volatile保证了共享数据的可见性，线程1修改了inc变量线程2会重新从主内存中重新读，这样就能保证inc++的正确性了啊，可为什么没有得到我们预期的结果呢？</p>\n<p>在之前已经讲述过inc++这样的操作不是一个原子性操作，它分为读、加加、写。一种情况，当线程1读取了inc的值，还没有修改，线程2也读取了，线程1修改完了，通知线程2将线程的缓存的 inc的值无效需要重读，可这时它不需要读取inc ，它仍执行写操作，然后赋值给主线程，这时数据就会出现问题。</p>\n<p>所以volatile不能保证原子性 。这时需要用锁来保证,在increase方法加上synchronized，重新运行打印的结果为10000 。</p>\n<pre><code> public synchronized void increase() {\n        inc++;\n}\n\n</code></pre>\n<h3><a id="volatile_175"></a>volatile的使用场景</h3>\n<h4><a id="_177"></a>状态标记</h4>\n<p>volatile最常见的使用场景是状态标记，如下：</p>\n<pre><code>private volatile boolean asheep ;\n\n//线程1\n \nwhile(!asleep){\n    countSheep();\n}\n\n//线程2\nasheep=true;\n\n</code></pre>\n<h4><a id="_195"></a>防止指令重排</h4>\n<pre><code>volatile boolean inited = false;\n//线程1:\ncontext = loadContext();  \ninited = true;  \n//上面两行代码如果不用volatile修饰，可能会发生指令重排，导致报错\n \n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n\n</code></pre>\n<h3><a id="_214"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_222"></a>参考资料</h2>\n<p>《Java 并发编程实战》</p>\n<p>《深入理解JVM》</p>\n<p>海子的博客：<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" rel="nofollow">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/77620769', 'title': 'Java并发编程：线程封闭和ThreadLocal详解', 'readNum': '50566', 'commentNum': '3', 'publishTime': '2017-08-27 15:39:09', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/77620769">http://blog.csdn.net/forezp/article/details/77620769</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h2><a id="_6"></a>什么是线程封闭</h2>\n<p>当访问共享变量时，往往需要加锁来保证数据同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了。这种技术称为线程封闭。在Java语言中，提供了一些类库和机制来维护线程的封闭性，例如局部变量和ThreadLocal类，本文主要深入讲解如何使用ThreadLocal类来保证线程封闭。</p>\n<h2><a id="ThreadLocal_10"></a>理解ThreadLocal类</h2>\n<p>ThreadLocal类能使线程中的某个值与保存值的对象关联起来，它提供了get、set方法，这些方法为每个使用该变量的线程保存一份独立的副本，因此get总是set当前线程的set最新值。</p>\n<p>首先我们来看个例子，这个例子来自于http://www.cnblogs.com/dolphin0520/p/3920407.html</p>\n<pre><code>\npublic class Test1 {\n\n    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;();\n    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;();\n\n\n    public void set() {\n        longLocal.set(Thread.currentThread().getId());\n        stringLocal.set(Thread.currentThread().getName());\n    }\n\n    public long getLong() {\n        return longLocal.get();\n    }\n\n    public String getString() {\n        return stringLocal.get();\n    }\n    public static void main(String[] args) throws InterruptedException {\n        final Test1 test = new Test1();\n\n\n        test.set();\n        System.out.println(test.getLong());\n        System.out.println(test.getString());\n\n\n        Thread thread1 = new Thread(() -&gt; {\n            test.set();\n            System.out.println(test.getLong());\n            System.out.println(test.getString());\n        });\n        thread1.start();\n        thread1.join();\n\n        System.out.println(test.getLong());\n        System.out.println(test.getString());\n    }\n}\n\n</code></pre>\n<p>运行该程序，代码输出的结果为：</p>\n<blockquote>\n<p>1</p>\n<p>main</p>\n<p>10</p>\n<p>Thread-0</p>\n<p>1</p>\n<p>main</p>\n</blockquote>\n<p>从这段代码可以看出在mian线程和thread1线程确实都保存着各自的副本，它们的副本各自不干扰。</p>\n<h2><a id="ThreadLocal_78"></a>ThreadLocal源码解析</h2>\n<p>来从源码的角度来解析ThreadLocal这个类，这个类存放在java.lang包，这个类有很多方法。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121122248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>它内部又个ThreadLocalMap类，主要有set()、get()、setInitialValue 等方法。</p>\n<p>首先来看下set方法，获取当前Thread的 map，如果不存在则新建一个并设置值，如果存在设置值，源码如下：</p>\n<pre><code>public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n</code></pre>\n<p>跟踪createMap，可以发现它根据Thread创建来一个ThreadLocalMap。</p>\n<pre><code>  void createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n\n</code></pre>\n<p>t.threadLocals为当前线程的一个变量，也就是ThreadLocal的数据都是存放在当前线程的threadLocals变量里面的，由此可见用ThreadLocal存放的数据是线程安全的。因为它对于不同的线程来，使用ThreadLocal的set方法都会根据线程判断该线程是否存在它的threadLocals成员变量，如果没有就建一个，有的话就存下数据。</p>\n<pre><code>ThreadLocal.ThreadLocalMap threadLocals = null;\n\n</code></pre>\n<p>ThreadLocalMap为ThreadLocal的一个内部类，源码如下：</p>\n<pre><code> static class ThreadLocalMap {\n\n        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal&lt;?&gt; k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n</code></pre>\n<p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>\n<p>在使用ThreadLocal的get方法之前一定要先set，要不然会报空指针异常。还有一种方式就是在初始化的时候调用initialValue（）方法赋值。改造下之前的例子，代码如下：</p>\n<pre><code>public class Test2 {\n\n    ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(){\n\n        @Override\n        protected Long initialValue() {\n            return Thread.currentThread().getId();\n        }\n    };\n    ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(){\n        @Override\n        protected String initialValue() {\n            return Thread.currentThread().getName();\n        }\n    };\n\n    public long getLong() {\n        return longLocal.get();\n    }\n\n    public String getString() {\n        return stringLocal.get();\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final Test2 test = new Test2();\n\n\n\n        System.out.println(test.getLong());\n        System.out.println(test.getString());\n\n\n        Thread thread1 = new Thread(() -&gt; {\n          \n            System.out.println(test.getLong());\n            System.out.println(test.getString());\n        });\n        thread1.start();\n        thread1.join();\n\n        System.out.println(test.getLong());\n        System.out.println(test.getString());\n    }\n}\n\n</code></pre>\n<p>运行该程序，代码输出的结果为：</p>\n<blockquote>\n<p>1</p>\n<p>main</p>\n<p>10</p>\n<p>Thread-0</p>\n<p>1</p>\n<p>main</p>\n</blockquote>\n<h2><a id="ThreadLocal_200"></a>ThreadLocal常用的使用场景</h2>\n<p>通常讲JDBC连接保存在ThreadLocal对象中，每个对象都有属于自己的连接，代码如下：</p>\n<pre><code>private static ThreadLocal&lt;Connection&gt; connectionHolder\n= new ThreadLocal&lt;Connection&gt;() {\n    public Connection initialValue() {\n       return DriverManager.getConnection(DB_URL);\n    }\n};\n \npublic static Connection getConnection() {\n    return connectionHolder.get();\n}\n\n</code></pre>\n<h2><a id="_218"></a>参考资料</h2>\n<p>《Java并发编程实战》</p>\n<p>《深入理解JVM》</p>\n<h3><a id="_223"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/77170470', 'title': '上传文件，经过Zuul，中文文件名乱码解决办法', 'readNum': '63026', 'commentNum': '5', 'publishTime': '2017-08-14 21:51:31', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/77170470">http://blog.csdn.net/forezp/article/details/77170470</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h2><a id="_6"></a>问题描述</h2>\n<p>在项目中又一个上传文件的oss服务，直接调用服务的上传文件成功，如果经过网关zuul服务，上传中文名字的文件，文件名会出现乱码，最终导致上传失败，如果上传英文名字的文件，没有任何问题。怀疑网关zuul对中文做编码处理。</p>\n <!--more-->\n<h2><a id="_12"></a>解决问题的过程</h2>\n<p>这个问题出现之后，我个人的解决办法如下：</p>\n<ul>\n<li>\n<p>第一反应是看文档，文档地址：<a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul" rel="nofollow">http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul</a></p>\n</li>\n<li>\n<p>粗略地看了下文档，以为没有给出解决方案（其实已经给出，只是没有理解好文档）。狂撸源码，依然没有找到解决办法。</p>\n</li>\n<li>\n<p>Google搜，搜到了这条Issue，<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1385">https://github.com/spring-cloud/spring-cloud-netflix/issues/1385</a></p>\n</li>\n</ul>\n<p>这位大神给出的解决办法，使用zuul servlet去上传文件，而不是默认的spring mvc。使用 zuul servlet之需要在请求uri，前面加上"/zuul"即可。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121304161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_27"></a>解决方案</h2>\n<p>首先列出我的zuul服务的配置：</p>\n<pre><code>server.port: 5000\nzuul:\n   routes:\n      oss-api:\n      path: /oss/**\n      serviceId: oss-service\n</code></pre>\n<p>oss服务上传文件的接口，代码如下：</p>\n<pre><code>@RestController\n@RequestMapping("/file")\npublic class FileUploadController {\n    @PostMapping("/upload")  \n    public RespDTO handleFileUpload(@RequestParam("file") MultipartFile file) {\n        //上传代码省略\n        return RespDTO.onSuc(upLoadResult);\n    }\n</code></pre>\n<p>那么，经过网关，调用上传文件的url地址如下：</p>\n<blockquote>\n<p>localhost:5000/oss/file/upload</p>\n</blockquote>\n<p>这时如果出现中文文件名，上传文件的文件名会出现失败。按照上述大神的办法，直接在这个uri，前面加上"/zuul"，那么请求地址如下：</p>\n<blockquote>\n<p>localhost:5000/zuul/oss/file/upload</p>\n</blockquote>\n<p>测试一下，果然通过，上传中文名的文件乱码问题解决。</p>\n<h3><a id="_63"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_71"></a>关注我的公众号</h2>\n<p>精彩内容不能错过！</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/76795269', 'title': 'Spring Cloud Sleuth进阶实战', 'readNum': '110084', 'commentNum': '15', 'publishTime': '2017-08-06 22:37:05', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/76795269<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/08/12/springcloud-sleuth.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/08/12/springcloud-sleuth.html</a></strong></p>\n<h2><a id="Spring_Cloud_Sleuth_5"></a>为什么需要Spring Cloud Sleuth</h2>\n<p>微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性，如果出现了错误和异常，很难去定位。主要体现在，一个请求可能需要调用很多个服务，而内部服务的调用复杂性，决定了问题难以定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题，很快定位。</p>\n<p>举个例子，在微服务系统中，一个来自用户的请求，请求先达到前端A（如前端界面），然后通过远程调用，达到系统的中间件B、C（如负载均衡、网关等），最后达到后端服务D、E，后端经过一系列的业务逻辑计算最后将数据返回给用户。对于这样一个请求，经历了这么多个服务，怎么样将它的请求过程的数据记录下来呢？这就需要用到服务链路追踪。</p>\n<p>Google开源的 Dapper链路追踪组件，并在2010年发表了论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，这篇文章是业内实现链路追踪的标杆和理论基础，具有非常大的参考价值。<br>\n目前，链路追踪组件有Google的Dapper，Twitter 的Zipkin，以及阿里的Eagleeye （鹰眼）等，它们都是非常优秀的链路追踪开源组件。</p>\n<p>本文主要讲述如何在Spring Cloud Sleuth中集成Zipkin。在Spring Cloud Sleuth中集成Zipkin非常的简单，只需要引入相应的依赖和做相关的配置即可。</p>\n<h2><a id="_16"></a>基本术语</h2>\n<p>Spring Cloud Sleuth采用的是Google的开源项目Dapper的专业术语。</p>\n<ul>\n<li>Span：基本工作单元，发送一个远程调度任务 就会产生一个Span，Span是一个64位ID唯一标识的，Trace是用另一个64位ID唯一标识的，Span还有其他数据信息，比如摘要、时间戳事件、Span的ID、以及进度ID。</li>\n<li>Trace：一系列Span组成的一个树状结构。请求一个微服务系统的API接口，这个API接口，需要调用多个微服务，调用每个微服务都会产生一个新的Span，所有由这个请求产生的Span组成了这个Trace。</li>\n<li>Annotation：用来及时记录一个事件的，一些核心注解用来定义一个请求的开始和结束 。这些注解包括以下：\n<ul>\n<li>cs - Client Sent -客户端发送一个请求，这个注解描述了这个Span的开始</li>\n<li>\n<pre><code>sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络传输的时间。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户端)，如果ss的时间戳减去sr时间戳，就可以得到服务器请求的时间。</li>\n<li>cr - Client Received （客户端接收响应）-此时Span的结束，如果cr的时间戳减去cs时间戳便可以得到整个请求所消耗的时间。</li>\n</ul>\n<h2><a id="_27"></a>案例实战</h2>\n<p>本文案例一共四个工程采用多Module形式。需要新建一个主Maven工程，主要指定了Spring Boot的版本为1.5.3，Spring Cloud版本为Dalston.RELEASE。包含了eureka-server工程，作为服务注册中心，eureka-server的创建过程这里不重复；zipkin-server作为链路追踪服务中心，负责存储链路数据；gateway-service作为服务网关工程，负责请求的转发,同时它也作为链路追踪客户端，负责产生数据，并上传给zipkin-service；user-service为一个应用服务，对外暴露API接口，同时它也作为链路追踪客户端，负责产生数据。</p>\n<h3><a id="zipkinserver_32"></a>构建zipkin-server工程</h3>\n<p>新建一个Module工程，取名为zipkin-server，其pom文件继承了主Maven工程的pom文件；作为Eureka Client，引入Eureka的起步依赖spring-cloud-starter-eureka，引入zipkin-server依赖，以及zipkin-autoconfigure-ui依赖，后两个依赖提供了Zipkin的功能和Zipkin界面展示的功能。代码如下：</p>\n<pre><code>\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;sleuth&lt;/artifactId&gt;\n\t\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;/parent&gt;\n\n\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<p>在程序的启动类ZipkinServiceApplication加上@EnableZipkinServer开启ZipkinServer的功能，加上@EnableEurekaClient注解，启动Eureka Client。代码如下：</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableZipkinServer\npublic class ZipkinServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ZipkinServerApplication.class, args);\n\t}\n}\n\n</code></pre>\n<p>在配置文件application.yml文件，指定程序名为zipkin-server，端口为9411，服务注册地址为http://localhost:8761/eureka/。</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 9411\nspring:\n  application:\n    name: zipkin-server\n\n</code></pre>\n<h3><a id="userservice_94"></a>构建user-service</h3>\n<p>在主Maven工程下建一个Module工程，取名为user-service，作为应用服务，对外暴露API接口。pom文件继承了主Maven工程的pom文件，并引入了Eureka的起步依赖spring-cloud-starter-eureka，Web起步依赖spring-boot-starter-web，Zipkin的起步依赖spring-cloud-starter-zipkin，代码如下：</p>\n<pre><code>\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;RELEASE&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<p>在配置文件applicatiom.yml，指定了程序名为user-service，端口为8762，服务注册地址为http://localhost:8761/eureka/，Zipkin Server地址为http://localhost:9411。spring.sleuth.sampler.percentage为1.0,即100%的概率将链路的数据上传给Zipkin Server，在默认的情况下，该值为0.1，代码如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8762\nspring:\n  application:\n    name: user-service\n  zipkin:\n    base-url: http://localhost:9411\n  sleuth:\n    sampler:\n      percentage: 1.0\n\n</code></pre>\n<p>在UserController类建一个“/user/hi”的API接口，对外提供服务，代码如下：</p>\n<pre><code>@RestController\n@RequestMapping("/user")\npublic class UserController {\n\n    @GetMapping("/hi")\n    public String hi(){\n        return "I\'m forezp";\n    }\n}\n\n</code></pre>\n<p>最后作为Eureka Client，需要在程序的启动类UserServiceApplication加上@EnableEurekaClient注解。</p>\n<h3><a id="gatewayservice_156"></a>构建gateway-service</h3>\n<p>新建一个名为gateway-service工程，这个工程作为服务网关，将请求转发到user-service，作为Zipkin客户端，需要将链路数据上传给Zipkin Server，同时它也作为Eureka Client。它在pom文件除了需要继承主Maven工程的 pom，还需引入的依赖如下：</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;RELEASE&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n&lt;/dependencies&gt;\n\n</code></pre>\n<p>在application.yml文件，配置程序名为gateway-service，端口为5000，服务注册地址为http://localhost:8761/eureka/，Zipkin Server地址为http://localhost:9411，以“/user-api/**”开头的Uri请求，转发到服务名为 user-service的服务。配置代码如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n\nserver:\n  port: 5000\nspring:\n  application:\n    name: gateway-service\n  sleuth:\n    sampler:\n      percentage: 1.0\n  zipkin:\n    base-url: http://localhost:9411\n\nzuul:\n  routes:\n    api-a:\n      path: /user-api/**\n      serviceId: user-service\n\n</code></pre>\n<p>在程序的启动类GatewayServiceApplication，加上@EnableEurekaClient注解开启Eureka Client，加上@EnableZuulProxy注解，开启Zuul代理功能。代码如下：</p>\n<pre><code>@SpringBootApplication\n@EnableZuulProxy\n@EnableEurekaClient\npublic class GatewayServiceApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(GatewayServiceApplication.class, args);\n\t}\n}\n</code></pre>\n<h3><a id="_225"></a>项目演示</h3>\n<p>完整的项目搭建完毕，依次启动eureka-server、zipkin-server、user-service、gateway-service。在浏览器上访问http://localhost:5000/user-api/user/hi，浏览器显示：</p>\n<blockquote>\n<p>I’m forezp</p>\n</blockquote>\n<p>访问http://localhost:9411，即访问Zipkin的展示界面，界面显示如图1所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112521791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>这个界面主要用来查找服务的调用情况，可以根据服务名、开始时间、结束时间、请求消耗的时间等条件来查找。点击“Find Trackes”按钮，界面如图所示。从图可知服务的调用情况，比如服务调用时间、服务的消耗时间，服务调用的链路情况。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112549467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>点击Dependences按钮，可以查看服务的依赖关系，在本案例中，gateway-service将请求转发到了user-service，它们的依赖关系如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112619798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_245"></a>怎么在链路数据中添加自定义数据</h2>\n<p>现在需要实现这样一个功能，需要在链路数据中加上操作人。这需要在gateway-service上实现。建一个ZuulFilter过滤器，它的类型为“post”，order为900，开启拦截。在拦截逻辑方法里，通过Tracer的addTag方法加上自定义的数据，比如本案例中加入了链路的操作人。另外也可以在这个过滤器中获取当前链路的traceId信息,traceId作为链路数据的唯一标识，可以存储在log日志中，方便后续查找。</p>\n<pre><code>@Component\npublic class LoggerFilter extends ZuulFilter {\n\n    @Autowired\n    Tracer tracer;\n    @Override\n    public String filterType() {\n        return FilterConstants.POST_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return 900;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n\n        tracer.addTag("operator","forezp");\n        System.out.print(tracer.getCurrentSpan().traceIdString());\n        return null;\n    }\n}\n\n</code></pre>\n<h2><a id="springcloudstarterstreamrabbit_282"></a>使用spring-cloud-starter-stream-rabbit进行链路通讯</h2>\n<p>在上述的案例中，最终gateway-service收集的数据，是通过Http上传给zip-server的，在Spring Cloud Sleuth中支持消息组件来通讯的，在这一小节使用RabbitMQ来通讯。首先来改造zipkin-server，在pom文件将zipkin-server的依赖去掉，加上spring-cloud-sleuth-zipkin-stream和spring-cloud-starter-stream-rabbit，代码如下：</p>\n<pre><code>\n\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-sleuth-zipkin-stream&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>在application.yml配置上RabbitMQ的配置，包括host、端口、用户名、密码，如下：</p>\n<pre><code>spring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\n</code></pre>\n<p>在程序的启动类ZipkinServerApplication上@EnableZipkinStreamServer注解，开启ZipkinStreamServer。代码如下：</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableZipkinStreamServer\npublic class ZipkinServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ZipkinServerApplication.class, args);\n\t}\n}\n\n</code></pre>\n<p>现在来改造下Zipkin Client（包括gateway-service、user-service），在pom文件中将spring-cloud-starter-zipkin以来改为spring-cloud-sleuth-zipkin-stream和spring-cloud-starter-stream-rabbit，代码如下：</p>\n<pre><code>\n&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-sleuth-zipkin-stream&lt;/artifactId&gt;\n\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>同时在applicayion.yml文件加上RabbitMQ的配置，同zipkin-server工程。</p>\n<p>这样，就将链路的上传数据从Http改了为用消息代组件RabbitMQ。</p>\n<h2><a id="Mysql_346"></a>将链路数据存储在Mysql数据库</h2>\n<p>在上述的例子中，Zipkin Server是将数据存储在内存中，一旦程序重启，之前的链路数据全部丢失，那么怎么将链路数据存储起来呢？Zipkin支持Mysql、Elasticsearch、Cassandra存储。这一小节讲述用Mysql存储，下一节讲述用Elasticsearch存储。</p>\n<p>首先，在zipkin-server工程加上Mysql的连接依赖mysql-connector-java，JDBC的起步依赖spring-boot-starter-jdbc，代码如下：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>在配置文件application.yml加上数据源的配置，包括数据库的Url、用户名、密码、连接驱动，另外需要配置zipkin.storage.type为mysql，代码如下：</p>\n<pre><code>spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/spring-cloud-zipkin?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.jdbc.Driver\nzipkin:\n  storage:\n    type: mysql\n\n</code></pre>\n<p>另外需要在Mysql数据库中初始化数据库脚本，数据库脚本地址：https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql/src/main/resources/mysql.sql</p>\n<pre><code>CREATE TABLE IF NOT EXISTS zipkin_spans (\n  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT \'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit\',\n  `trace_id` BIGINT NOT NULL,\n  `id` BIGINT NOT NULL,\n  `name` VARCHAR(255) NOT NULL,\n  `parent_id` BIGINT,\n  `debug` BIT(1),\n  `start_ts` BIGINT COMMENT \'Span.timestamp(): epoch micros used for endTs query and to implement TTL\',\n  `duration` BIGINT COMMENT \'Span.duration(): micros used for minDuration and maxDuration query\'\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT \'ignore insert on duplicate\';\nALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT \'for joining with zipkin_annotations\';\nALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT \'for getTracesByIds\';\nALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT \'for getTraces and getSpanNames\';\nALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT \'for getTraces ordering and range\';\n\nCREATE TABLE IF NOT EXISTS zipkin_annotations (\n  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT \'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit\',\n  `trace_id` BIGINT NOT NULL COMMENT \'coincides with zipkin_spans.trace_id\',\n  `span_id` BIGINT NOT NULL COMMENT \'coincides with zipkin_spans.id\',\n  `a_key` VARCHAR(255) NOT NULL COMMENT \'BinaryAnnotation.key or Annotation.value if type == -1\',\n  `a_value` BLOB COMMENT \'BinaryAnnotation.value(), which must be smaller than 64KB\',\n  `a_type` INT NOT NULL COMMENT \'BinaryAnnotation.type() or -1 if Annotation\',\n  `a_timestamp` BIGINT COMMENT \'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp\',\n  `endpoint_ipv4` INT COMMENT \'Null when Binary/Annotation.endpoint is null\',\n  `endpoint_ipv6` BINARY(16) COMMENT \'Null when Binary/Annotation.endpoint is null, or no IPv6 address\',\n  `endpoint_port` SMALLINT COMMENT \'Null when Binary/Annotation.endpoint is null\',\n  `endpoint_service_name` VARCHAR(255) COMMENT \'Null when Binary/Annotation.endpoint is null\'\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT \'Ignore insert on duplicate\';\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT \'for joining with zipkin_spans\';\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT \'for getTraces/ByIds\';\nALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT \'for getTraces and getServiceNames\';\nALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT \'for getTraces\';\nALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT \'for getTraces\';\nALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT \'for dependencies job\';\n\nCREATE TABLE IF NOT EXISTS zipkin_dependencies (\n  `day` DATE NOT NULL,\n  `parent` VARCHAR(255) NOT NULL,\n  `child` VARCHAR(255) NOT NULL,\n  `call_count` BIGINT,\n  `error_count` BIGINT\n) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;\n\nALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);\n\n</code></pre>\n<h2><a id="ElasticSearch_432"></a>将链路数据存储在ElasticSearch</h2>\n<p>使用Mysql存储链路数据，在并发高的情况下，显然不合理，这时可以选择使用ElasticSearch存储。读者需要自行安装ElasticSearch、Kibana（下一小节使用），下载地址为https://www.elastic.co/products/elasticsearch。安装完成后并启动它们，其中ElasticSearch的默认端口为9200，Kibana的端口为5601。</p>\n<p>安装的过程可以参考我的这篇文章：http://blog.csdn.net/forezp/article/details/71189836</p>\n<p>本小节的案例在上上小节的案例的基础上进行改造。首先在pom文件，加上zipkin的依赖和zipkin-autoconfigure-storage-elasticsearch-http的依赖，代码如下：</p>\n<pre><code>\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;zipkin&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.28.0&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;zipkin-autoconfigure-storage-elasticsearch-http&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.28.0&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>在application.yml文件加上Zipkin的配置，配置了zipkin的存储类型为elasticsearch，使用的StorageComponent为elasticsearch。然后需要配置elasticsearch，包括hosts，可以配置多个，用“，”隔开；index为zipkin等，具体配置如下：</p>\n<pre><code>\nzipkin:\n  storage:\n    type: elasticsearch\n    StorageComponent: elasticsearch\n    elasticsearch:\n      cluster: elasticsearch\n      max-requests: 30\n      index: zipkin\n      index-shards: 3\n      index-replicas: 1\n      hosts: localhost:9200\n\n</code></pre>\n<h2><a id="kibana_473"></a>在kibana上展示</h2>\n<p>上一小节讲述了如何将链路数据存储在ElasticSearch，ElasticSearch可以和Kibana结合，将链路数据展示在 Kibana上。安装完Kibana，并启动，它默认会向本地的9200端口的ElasticSearch读取数据，它默认的端口为5601。访问http://localhost:5601，显示的界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060111265373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在上述的界面点击"Management"按钮，然后点击“Add New”，添加一个index，在上节我们在ElasticSearch中写入链路数据的index配置为“zipkin”,那么在界面填写为“zipkin-*”，点击“Create”按钮。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112714600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>创建完index之后，点击Discover，就可以在界面上展示链路数据了。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112738122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="Httpmysql_489"></a>采用Http的方式传输链路数据怎么存在mysql中（补充）</h2>\n<p>在我的项目中，采用rabbitmq传输，并存储在mysql中，遇到了程序启动慢的问题，遂决定改成http传输链路数据，但采用http 传输链路是我之前没有讲解过的，于是做下补充。</p>\n<p>源码工程在：https://github.com/forezp/SpringCloudLearning/tree/master/chapter-sleuth-mysql</p>\n<p>首先在zipkin-server 的pom文件中，加上以下的依赖：</p>\n<pre><code> &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n            &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;\n            &lt;version&gt;1.19.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n            &lt;artifactId&gt;zipkin-storage-mysql&lt;/artifactId&gt;\n            &lt;version&gt;1.19.0&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n            &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n</code></pre>\n<p>工程的配置文件bootstrap.yml：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 9411\nspring:\n  application:\n    name: zipkin-server\n\n\n  sleuth:\n    sampler:\n      percentage: 1.0\n    enabled: false\n\n\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/spring-cloud-zipkin?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false\n    username: root\n    password: 123456\n\nzipkin:\n  storage:\n    type: mysql\n\n\n</code></pre>\n<p>在程序的启动类ZipkinServerApplication中注入MySQLStorage的bean，代码如下：</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@EnableZipkinServer\npublic class ZipkinServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ZipkinServerApplication.class, args);\n\t}\n\n\n\t@Bean\n\tpublic MySQLStorage mySQLStorage(DataSource datasource) {\n\t\treturn MySQLStorage.builder().datasource(datasource).executor(Runnable::run).build();\n\t}\n}\n\n\n\n</code></pre>\n<p>只需要这几步才有http传输的链路数据就可以存在mysql数据库中。</p>\n<h3><a id="_588"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_596"></a>源码下载</h2>\n<p>最原始的工程：</p>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/chapter-sleuth</p>\n<p>采用RabbitMq通讯的工程：</p>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/chapter-sleuth-stream</p>\n<p>采用Mysql存储的工程：</p>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/chapter-sleuth-stream-mysql</p>\n<p>采用ES存储的工程：</p>\n<p>https://github.com/forezp/SpringCloudLearning/tree/master/chapter-sleuth-stream-elasticsearch</p>\n<h2><a id="_614"></a>参考资料</h2>\n<p>http://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html</p>\n<p>https://github.com/openzipkin/zipkin</p>\n<h2><a id="_621"></a>关注我的公众号</h2>\n<p>精彩内容不能错过！</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/76408139', 'title': '如何在IDEA启动多个Spring Boot工程实例', 'readNum': '142908', 'commentNum': '37', 'publishTime': '2017-07-30 22:27:01', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/76408139<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/architecture/2017/08/10/idea-boot-instances.html" rel="nofollow">https://www.fangzhipeng.com/architecture/2017/08/10/idea-boot-instances.html</a></strong></p>\n<p>在我讲解的案例中，经常一个工程启动多个实例，分别占用不同的端口，有很多读者百思不得其解，在博客上留言，给我发邮件，加我微信询问。所以有必要在博客上记录下，方便读者。</p>\n<h3><a id="step_1_9"></a>step 1</h3>\n<p>在IDEA上点击Application右边的下三角<br>\n,弹出选项后，点击Edit Configuration</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601114510336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="step_2_15"></a>step 2</h3>\n<p>打开配置后，将默认的Single instance only(单实例)的钩去掉。<br>\n<img src="https://img-blog.csdnimg.cn/2019060111453773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="step_3_20"></a>step 3</h3>\n<p>通过修改application文件的server.port的端口，启动。多个实例，需要多个端口，分别启动。</p>\n<h3><a id="_23"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/76211680', 'title': '深入理解Zuul之源码解析', 'readNum': '80190', 'commentNum': '9', 'publishTime': '2017-07-27 21:42:57', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/76211680<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/08/11/sc-zuul-raw.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/08/11/sc-zuul-raw.html</a></strong></p>\n<h2><a id="Zuul__7"></a>Zuul 架构图</h2>\n<p><img src="https://img-blog.csdnimg.cn/20190601012124618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在zuul中， 整个请求的过程是这样的，首先将请求给zuulservlet处理，zuulservlet中有一个zuulRunner对象，该对象中初始化了RequestContext：作为存储整个请求的一些数据，并被所有的zuulfilter共享。zuulRunner中还有 FilterProcessor，FilterProcessor作为执行所有的zuulfilter的管理器。FilterProcessor从filterloader 中获取zuulfilter，而zuulfilter是被filterFileManager所加载，并支持groovy热加载，采用了轮询的方式热加载。有了这些filter之后，zuulservelet首先执行的Pre类型的过滤器，再执行route类型的过滤器，最后执行的是post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行error类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。</p>\n<h2><a id="zuul_15"></a>zuul工作原理源码分析</h2>\n<p>在之前已经讲过，如何使用zuul，其中不可缺少的一个步骤就是在程序的启动类加上＠EnableZuulProxy，该EnableZuulProxy类代码如下：</p>\n<pre><code>@EnableCircuitBreaker\n@EnableDiscoveryClient\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(ZuulProxyConfiguration.class)\npublic @interface EnableZuulProxy {\n}\n\n\n</code></pre>\n<p>其中，引用了ZuulProxyConfiguration，跟踪ZuulProxyConfiguration，该类注入了DiscoveryClient、RibbonCommandFactoryConfiguration用作负载均衡相关的。注入了一些列的filters，比如PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter，代码如如下：</p>\n<pre><code> @Bean\n\tpublic PreDecorationFilter preDecorationFilter(RouteLocator routeLocator, ProxyRequestHelper proxyRequestHelper) {\n\t\treturn new PreDecorationFilter(routeLocator, this.server.getServletPrefix(), this.zuulProperties,\n\t\t\t\tproxyRequestHelper);\n\t}\n\n\t// route filters\n\t@Bean\n\tpublic RibbonRoutingFilter ribbonRoutingFilter(ProxyRequestHelper helper,\n\t\t\tRibbonCommandFactory&lt;?&gt; ribbonCommandFactory) {\n\t\tRibbonRoutingFilter filter = new RibbonRoutingFilter(helper, ribbonCommandFactory, this.requestCustomizers);\n\t\treturn filter;\n\t}\n\n\t@Bean\n\tpublic SimpleHostRoutingFilter simpleHostRoutingFilter(ProxyRequestHelper helper, ZuulProperties zuulProperties) {\n\t\treturn new SimpleHostRoutingFilter(helper, zuulProperties);\n\t}\n \n</code></pre>\n<p>它的父类ZuulConfiguration ，引用了一些相关的配置。在缺失zuulServlet  bean的情况下注入了ZuulServlet，该类是zuul的核心类。</p>\n<pre><code> \t@Bean\n\t@ConditionalOnMissingBean(name = "zuulServlet")\n\tpublic ServletRegistrationBean zuulServlet() {\n\t\tServletRegistrationBean servlet = new ServletRegistrationBean(new ZuulServlet(),\n\t\t\t\tthis.zuulProperties.getServletPattern());\n\t\t// The whole point of exposing this servlet is to provide a route that doesn\'t\n\t\t// buffer requests.\n\t\tservlet.addInitParameter("buffer-requests", "false");\n\t\treturn servlet;\n\t}\n \n</code></pre>\n<p>同时也注入了其他的过滤器，比如ServletDetectionFilter、DebugFilter、Servlet30WrapperFilter，这些过滤器都是pre类型的。</p>\n<pre><code> @Bean\n\tpublic ServletDetectionFilter servletDetectionFilter() {\n\t\treturn new ServletDetectionFilter();\n\t}\n\n\t@Bean\n\tpublic FormBodyWrapperFilter formBodyWrapperFilter() {\n\t\treturn new FormBodyWrapperFilter();\n\t}\n\n\t@Bean\n\tpublic DebugFilter debugFilter() {\n\t\treturn new DebugFilter();\n\t}\n\n\t@Bean\n\tpublic Servlet30WrapperFilter servlet30WrapperFilter() {\n\t\treturn new Servlet30WrapperFilter();\n\t}\n\t\n</code></pre>\n<p>它也注入了post类型的，比如 SendResponseFilter，error类型，比如 SendErrorFilter，route类型比如SendForwardFilter，代码如下：</p>\n<pre><code> \n\t@Bean\n\tpublic SendResponseFilter sendResponseFilter() {\n\t\treturn new SendResponseFilter();\n\t}\n\n\t@Bean\n\tpublic SendErrorFilter sendErrorFilter() {\n\t\treturn new SendErrorFilter();\n\t}\n\n\t@Bean\n\tpublic SendForwardFilter sendForwardFilter() {\n\t\treturn new SendForwardFilter();\n\t}\n \n</code></pre>\n<p>初始化ZuulFilterInitializer类，将所有的filter 向FilterRegistry注册。</p>\n<pre><code> \t@Configuration\n\tprotected static class ZuulFilterConfiguration {\n\n\t\t@Autowired\n\t\tprivate Map&lt;String, ZuulFilter&gt; filters;\n\n\t\t@Bean\n\t\tpublic ZuulFilterInitializer zuulFilterInitializer(\n\t\t\t\tCounterFactory counterFactory, TracerFactory tracerFactory) {\n\t\t\tFilterLoader filterLoader = FilterLoader.getInstance();\n\t\t\tFilterRegistry filterRegistry = FilterRegistry.instance();\n\t\t\treturn new ZuulFilterInitializer(this.filters, counterFactory, tracerFactory, filterLoader, filterRegistry);\n\t\t}\n\n\t}\n \n</code></pre>\n<p>而FilterRegistry管理了一个ConcurrentHashMap，用作存储过滤器的，并有一些基本的CURD过滤器的方法，代码如下：</p>\n<pre><code> public class FilterRegistry {\n\n    private static final FilterRegistry INSTANCE = new FilterRegistry();\n\n    public static final FilterRegistry instance() {\n        return INSTANCE;\n    }\n\n    private final ConcurrentHashMap&lt;String, ZuulFilter&gt; filters = new ConcurrentHashMap&lt;String, ZuulFilter&gt;();\n\n    private FilterRegistry() {\n    }\n\n    public ZuulFilter remove(String key) {\n        return this.filters.remove(key);\n    }\n\n    public ZuulFilter get(String key) {\n        return this.filters.get(key);\n    }\n\n    public void put(String key, ZuulFilter filter) {\n        this.filters.putIfAbsent(key, filter);\n    }\n\n    public int size() {\n        return this.filters.size();\n    }\n\n    public Collection&lt;ZuulFilter&gt; getAllFilters() {\n        return this.filters.values();\n    }\n\n}\n\n</code></pre>\n<p>FilterLoader类持有FilterRegistry，FilterFileManager类持有FilterLoader，所以最终是由FilterFileManager注入 filterFilterRegistry的ConcurrentHashMap的。FilterFileManager到开启了轮询机制，定时的去加载过滤器，代码如下：</p>\n<pre><code>  void startPoller() {\n        poller = new Thread("GroovyFilterFileManagerPoller") {\n            public void run() {\n                while (bRunning) {\n                    try {\n                        sleep(pollingIntervalSeconds * 1000);\n                        manageFiles();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        };\n        poller.setDaemon(true);\n        poller.start();\n    }\n\n\n</code></pre>\n<p>Zuulservlet作为类似于Spring MVC中的DispatchServlet,起到了前端控制器的作用，所有的请求都由它接管。它的核心代码如下：</p>\n<pre><code> \n   @Override\n    public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException {\n        try {\n            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);\n\n            // Marks this request as having passed through the "Zuul engine", as opposed to servlets\n            // explicitly bound in web.xml, for which requests will not have the same data attached\n            RequestContext context = RequestContext.getCurrentContext();\n            context.setZuulEngineRan();\n\n            try {\n                preRoute();\n            } catch (ZuulException e) {\n                error(e);\n                postRoute();\n                return;\n            }\n            try {\n                route();\n            } catch (ZuulException e) {\n                error(e);\n                postRoute();\n                return;\n            }\n            try {\n                postRoute();\n            } catch (ZuulException e) {\n                error(e);\n                return;\n            }\n\n        } catch (Throwable e) {\n            error(new ZuulException(e, 500, "UNHANDLED_EXCEPTION_" + e.getClass().getName()));\n        } finally {\n            RequestContext.getCurrentContext().unset();\n        }\n    }\n\n \n</code></pre>\n<p>跟踪init（），可以发现这个方法为每个请求生成了RequestContext,RequestContext继承了ConcurrentHashMap&lt;String, Object&gt;，在请求结束时销毁掉该RequestContext，RequestContext的生命周期为请求到zuulServlet开始处理，直到请求结束返回结果。<br>\nRequestContext类在存储了很多重要的信息，包括HttpServletRequest、HttpServletRespons、ResponseDataStream、ResponseStatusCode等。 RequestContext对象在处理请求的过程中，一直存在，所以这个对象为所有Filter共享。</p>\n<p>从ZuulServlet的service（）方法可知，它是先处理pre()类型的处理器，然后在处理route()类型的处理器，最后再处理post类型的处理器。</p>\n<p>首先来看一看pre()的处理过程，它会进入到ZuulRunner,该类的作用是将请求的HttpServletRequest、HttpServletRespons放在RequestContext类中，并包装了一个FilterProcessor，代码如下：</p>\n<pre><code>  public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n\n        RequestContext ctx = RequestContext.getCurrentContext();\n        if (bufferRequests) {\n            ctx.setRequest(new HttpServletRequestWrapper(servletRequest));\n        } else {\n            ctx.setRequest(servletRequest);\n        }\n\n        ctx.setResponse(new HttpServletResponseWrapper(servletResponse));\n      \n  }\n    \n    \n public void preRoute() throws ZuulException {\n    FilterProcessor.getInstance().preRoute();\n}\n\n</code></pre>\n<p>而FilterProcessor类为调用filters的类，比如调用pre类型所有的过滤器：</p>\n<pre><code>  public void preRoute() throws ZuulException {\n        try {\n            runFilters("pre");\n        } catch (ZuulException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new ZuulException(e, 500, "UNCAUGHT_EXCEPTION_IN_PRE_FILTER_" + e.getClass().getName());\n        }\n    }\n\n</code></pre>\n<p>跟踪runFilters（）方法，可以发现，它最终调用了FilterLoader的getFiltersByType(sType)方法来获取同一类的过滤器，然后用for循环遍历所有的ZuulFilter，执行了 processZuulFilter（）方法，跟踪该方法可以发现最终是执行了ZuulFilter的方法，最终返回了该方法返回的Object对象。</p>\n<pre><code> public Object runFilters(String sType) throws Throwable {\n        if (RequestContext.getCurrentContext().debugRouting()) {\n            Debug.addRoutingDebug("Invoking {" + sType + "} type filters");\n        }\n        boolean bResult = false;\n        List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);\n        if (list != null) {\n            for (int i = 0; i &lt; list.size(); i++) {\n                ZuulFilter zuulFilter = list.get(i);\n                Object result = processZuulFilter(zuulFilter);\n                if (result != null &amp;&amp; result instanceof Boolean) {\n                    bResult |= ((Boolean) result);\n                }\n            }\n        }\n        return bResult;\n    }\n\n</code></pre>\n<p>route、post类型的过滤器的执行过程和pre执行过程类似。</p>\n<h2><a id="Zuul_314"></a>Zuul默认过滤器</h2>\n<h4><a id="_316"></a>默认的核心过滤器一览表</h4>\n<p>Zuul默认注入的过滤器，它们的执行顺序在FilterConstants类，我们可以先定位在这个类，然后再看这个类的过滤器的执行顺序以及相关的注释，可以很轻松定位到相关的过滤器，也可以直接打开<br>\nspring-cloud-netflix-core.jar的 zuul.filters包，可以看到一些列的filter，现在我以表格的形式，列出默认注入的filter.</p>\n\n<table>\n<thead>\n<tr>\n<th>过滤器</th>\n<th align="right">order</th>\n<th align="center">描述</th>\n<th align="center">类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ServletDetectionFilter</td>\n<td align="right">-3</td>\n<td align="center">检测请求是用 DispatcherServlet还是 ZuulServlet</td>\n<td align="center">pre</td>\n</tr>\n<tr>\n<td>Servlet30WrapperFilter</td>\n<td align="right">-2</td>\n<td align="center">在Servlet 3.0 下，包装 requests</td>\n<td align="center">pre</td>\n</tr>\n<tr>\n<td>FormBodyWrapperFilter</td>\n<td align="right">-1</td>\n<td align="center">解析表单数据</td>\n<td align="center">pre</td>\n</tr>\n<tr>\n<td>SendErrorFilter</td>\n<td align="right">0</td>\n<td align="center">如果中途出现错误</td>\n<td align="center">error</td>\n</tr>\n<tr>\n<td>DebugFilter</td>\n<td align="right">1</td>\n<td align="center">设置请求过程是否开启debug</td>\n<td align="center">pre</td>\n</tr>\n<tr>\n<td>PreDecorationFilter</td>\n<td align="right">5</td>\n<td align="center">根据uri决定调用哪一个route过滤器</td>\n<td align="center">pre</td>\n</tr>\n<tr>\n<td>RibbonRoutingFilter</td>\n<td align="right">10</td>\n<td align="center">如果写配置的时候用ServiceId则用这个route过滤器，该过滤器可以用Ribbon 做负载均衡，用hystrix做熔断</td>\n<td align="center">route</td>\n</tr>\n<tr>\n<td>SimpleHostRoutingFilter</td>\n<td align="right">100</td>\n<td align="center">如果写配置的时候用url则用这个route过滤</td>\n<td align="center">route</td>\n</tr>\n<tr>\n<td>SendForwardFilter</td>\n<td align="right">500</td>\n<td align="center">用RequestDispatcher请求转发</td>\n<td align="center">route</td>\n</tr>\n<tr>\n<td>SendResponseFilter</td>\n<td align="right">1000</td>\n<td align="center">用RequestDispatcher请求转发</td>\n<td align="center">post</td>\n</tr>\n</tbody>\n</table><p>过滤器的order值越小，就越先执行，并且在执行过滤器的过程中，它们共享了一个RequestContext对象，该对象的生命周期贯穿于请求，可以看出优先执行了pre类型的过滤器，并将执行后的结果放在RequestContext中，供后续的filter使用，比如在执行PreDecorationFilter的时候，决定使用哪一个route，它的结果的是放在RequestContext对象中，后续会执行所有的route的过滤器，如果不满足条件就不执行该过滤器的run方法。最终达到了就执行一个route过滤器的run()方法。</p>\n<p>而error类型的过滤器，是在程序发生异常的时候执行的。</p>\n<p>post类型的过滤，在默认的情况下，只注入了SendResponseFilter，该类型的过滤器是将最终的请求结果以流的形式输出给客户单。</p>\n<h4><a id="SimpleHostRoutingFilter_340"></a>现在来看SimpleHostRoutingFilter是如何工作?</h4>\n<p>进入到SimpleHostRoutingFilter类的方法的run()方法，核心代码如下：</p>\n<pre><code>\t@Override\n\tpublic Object run() {\n\t\tRequestContext context = RequestContext.getCurrentContext();\n\t    //省略代码\n\n\t\tString uri = this.helper.buildZuulRequestURI(request);\n\t\tthis.helper.addIgnoredHeaders();\n\n\t\ttry {\n\t\t\tCloseableHttpResponse response = forward(this.httpClient, verb, uri, request,\n\t\t\t\t\theaders, params, requestEntity);\n\t\t\tsetResponse(response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ZuulRuntimeException(ex);\n\t\t}\n\t\treturn null;\n\t}\n\n</code></pre>\n<p>查阅这个类的全部代码可知，该类创建了一个HttpClient作为请求类，并重构了url,请求到了具体的服务，得到的一个CloseableHttpResponse对象，并将CloseableHttpResponse对象的保存到RequestContext对象中。并调用了ProxyRequestHelper的setResponse方法，将请求状态码，流等信息保存在RequestContext对象中。</p>\n<pre><code>private void setResponse(HttpResponse response) throws IOException {\n\t\tRequestContext.getCurrentContext().set("zuulResponse", response);\n\t\tthis.helper.setResponse(response.getStatusLine().getStatusCode(),\n\t\t\t\tresponse.getEntity() == null ? null : response.getEntity().getContent(),\n\t\t\t\trevertHeaders(response.getAllHeaders()));\n\t}\n</code></pre>\n<h4><a id="SendResponseFilter_376"></a>现在来看SendResponseFilter是如何工作?</h4>\n<p>这个过滤器的order为1000,在默认且正常的情况下，是最后一个执行的过滤器，该过滤器是最终将得到的数据返回给客户端的请求。</p>\n<p>在它的run()方法里，有两个方法：addResponseHeaders()和writeResponse()，即添加响应头和写入响应数据流。</p>\n<pre><code>\n\tpublic Object run() {\n\t\ttry {\n\t\t\taddResponseHeaders();\n\t\t\twriteResponse();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tReflectionUtils.rethrowRuntimeException(ex);\n\t\t}\n\t\treturn null;\n\t}\n\n</code></pre>\n<p>其中writeResponse（）方法是通过从RequestContext中获取ResponseBody获或者ResponseDataStream来写入到HttpServletResponse中的，但是在默认的情况下ResponseBody为null，而ResponseDataStream在route类型过滤器中已经设置进去了。具体代码如下：</p>\n<pre><code>private void writeResponse() throws Exception {\n\t\tRequestContext context = RequestContext.getCurrentContext();\n\t\n\t\tHttpServletResponse servletResponse = context.getResponse();\n\t\t\t//代码省略\n\t\tOutputStream outStream = servletResponse.getOutputStream();\n\t\tInputStream is = null;\n\t\ttry {\n\t\t\tif (RequestContext.getCurrentContext().getResponseBody() != null) {\n\t\t\t\tString body = RequestContext.getCurrentContext().getResponseBody();\n\t\t\t\twriteResponse(\n\t\t\t\t\t\tnew ByteArrayInputStream(\n\t\t\t\t\t\t\t\tbody.getBytes(servletResponse.getCharacterEncoding())),\n\t\t\t\t\t\toutStream);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t//代码省略\n\t\t\tis = context.getResponseDataStream();\n\t\t\tInputStream inputStream = is;\n\t\t\t\t//代码省略\n\t\t\n\t\t\twriteResponse(inputStream, outStream);\n\t\t\t\t//代码省略\n\t\t\t}\n\t\t}\n\t    ..//代码省略\n\t}\n\n</code></pre>\n<h2><a id="zuul_433"></a>如何在zuul上做日志处理</h2>\n<p>由于zuul作为api网关，所有的请求都经过这里，所以在网关上，可以做请求相关的日志处理。<br>\n我的需求是这样的，需要记录请求的 url,ip地址，参数，请求发生的时间，整个请求的耗时，请求的响应状态，甚至请求响应的结果等。<br>\n很显然，需要实现这样的一个功能，需要写一个ZuulFliter，它应该是在请求发送给客户端之前做处理，并且在route过滤器路由之后，在默认的情况下，这个过滤器的order应该为500-1000之间。那么如何获取这些我需要的日志信息呢？找RequestContext,在请求的生命周期里这个对象里，存储了整个请求的所有信息。</p>\n<p>现在编码，在代码的注释中，做了详细的说明，代码如下：</p>\n<pre><code>@Component\npublic class LoggerFilter extends ZuulFilter {\n  \n\n    @Override\n    public String filterType() {\n        return FilterConstants.POST_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext context = RequestContext.getCurrentContext();\n        HttpServletRequest request = context.getRequest();\n        String method = request.getMethod();//氢气的类型，post get ..\n        Map&lt;String, String&gt; params = HttpUtils.getParams(request);\n        String paramsStr = params.toString();//请求的参数\n        long statrtTime = (long) context.get("startTime");//请求的开始时间\n        Throwable throwable = context.getThrowable();//请求的异常，如果有的话\n        request.getRequestURI()；//请求的uri\n        HttpUtils.getIpAddress(request);//请求的iP地址\n        context.getResponseStatusCode();//请求的状态\n        long duration=System.currentTimeMillis() - statrtTime);//请求耗时\n\n        return null;\n    }\n\n}\n\n</code></pre>\n<p>现在读者也许有疑问，如何得到的statrtTime，即请求开始的时间，其实这需要另外一个过滤器，在网络请求route之前(大部分耗时都在route这一步)，在过滤器中，在RequestContext存储一个时间即可，另写一个过滤器，代码如下：</p>\n<pre><code>@Component\npublic class AccessFilter extends ZuulFilter {\n\n    @Override\n    public String filterType() {\n        return "pre";\n    }\n\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext ctx = RequestContext.getCurrentContext();\n        ctx.set("startTime",System.currentTimeMillis());\n       \n        return null;\n    }\n}\n\n\n</code></pre>\n<p>可能还有这样的需求，我需要将响应结果，也要存储在log中，在之前已经分析了，在route结束后，将从具体服务获取的响应流存储在RequestContext中，在SendResponseFilter过滤器写入在HttpServletResponse中，最终返回给客户端。那么我只需要在SendResponseFilter写入响应流之前把响应流写入到 log日志中即可，那么会引发另外一个问题，因为响应流写入到 log后，RequestContext就没有响应流了，在SendResponseFilter就没有流输入到HttpServletResponse中，导致客户端没有任何的返回数据，那么解决的办法是这样的：</p>\n<pre><code>InputStream inputStream =RequestContext.getCurrentContext().getResponseDataStream();\nInputStream newInputStream= copy(inputStream);\ntranserferTolog(inputStream);\nRequestContext.getCurrentContext().setResponseDataStream(newInputStream);\n\n</code></pre>\n<p>从RequestContext获取到流之后，首先将流 copy一份，将流转化下字符串，存在日志中，再set到RequestContext中，<br>\n这样SendResponseFilter就可以将响应返回给客户端。这样的做法有点影响性能，如果不是字符流，可能需要做更多的处理工作。</p>\n<h3><a id="_529"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/75333088', 'title': '深入理解Hystrix之文档翻译', 'readNum': '58417', 'commentNum': '3', 'publishTime': '2017-07-19 09:16:25', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/75333088<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2018/08/31/trans-hystrix1.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2018/08/31/trans-hystrix1.html</a></strong></p>\n<h2><a id="Hystrix_6"></a>什么是Hystrix</h2>\n<p>在分布式系统中，服务与服务之间依赖错综复杂，一种不可避免的情况就是某些服务将会出现失败。Hystrix是一个库，它提供了服务与服务之间的容错功能，主要体现在延迟容错和容错，从而做到控制分布式系统中的联动故障。Hystrix通过隔离服务的访问点，阻止联动故障，并提供故障的解决方案，从而提高了这个分布式系统的弹性。</p>\n<h2><a id="Hystrix_10"></a>Hystrix解决了什么问题</h2>\n<p>在复杂的分布式系统中，可能有成百上千个依赖服务，这些服务由于某种故障，比如机房的不可靠性、网络服务商的不可靠性等因素，导致某个服务不可用，如果系统不隔离该不可用的服务，可能会导致整个系统不可用。</p>\n<p>例如，对于依赖30个服务的应用程序，每个服务的正常运行时间为99.99％，这是您期望的</p>\n<blockquote>\n<p>99.9930 = 99.7％的正常运行时间<br>\n10亿次请求中有0.3％= 3,000,000次失败<br>\n2小时停机时间/月，即使所有的依赖都有很好的正常运行时间。</p>\n</blockquote>\n<p>实际情况可能比这更糟糕。</p>\n<p>如果不设计整个系统的韧性，即使所有依赖关系表现良好，即使0.01％的停机时间对数十个服务中的每一个服务的总体影响等同于每个月停机的潜在时间。</p>\n<p>当所以的服务都出UP状态，即Ok状态，一个请求流程可能是这样：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvSHlzdHJpeC93aWtpL2ltYWdlcy9zb2EtMS02NDAucG5n?x-oss-process=image/format,png" alt=""></p>\n<p>当某一个服务出现了延迟，可能会阻止整个该请求：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mi5aUwqs-1570075727410)(https://github.com/Netflix/Hystrix/wiki/images/soa-2-640.png)]</p>\n<p>在高并发的情况下，单个服务的延迟，可能导致所有的请求都处于延迟状态，可能在几秒钟就使服务处于负载饱和的状态。</p>\n<p>服务的单个点的请求故障，会导致整个服务出现故障，更为糟糕的是该故障服务，会导致其他的服务出现负载饱和，资源耗尽，直到不可用，从而导致这个分布式系统都不可用。这就是“雪崩”。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvSHlzdHJpeC93aWtpL2ltYWdlcy9zb2EtMy02NDAucG5n?x-oss-process=image/format,png" alt=""></p>\n<p>当通过第三方客户端执行网络访问时，这些问题会加剧。第三方客户就是一个“黑匣子”，其中实施细节被隐藏，并且可以随时更改，网络或资源配置对于每个客户端库都是不同的，通常难以监视和 更改。</p>\n<p>通过的故障包括：</p>\n<p>网络连接失败或降级。 服务和服务器失败或变慢。 新的库或服务部署会改变行为或性能特征。 客户端库有错误。</p>\n<p>所有这些都代表需要隔离和管理的故障和延迟，以便单个故障依赖关系不能导致整个应用程序或系统的故障。</p>\n<h2><a id="Hystrix_53"></a>Hystrix的设计原则</h2>\n<p>原则如下：</p>\n<ul>\n<li>防止单个服务的故障，耗尽整个系统服务的容器（比如tomcat）的线程资源。</li>\n<li>减少负载并快速失败，而不是排队。</li>\n<li>在可行的情况下提供回退以保护用户免受故障。</li>\n<li>使用隔离技术（如隔板，泳道和断路器模式）来限制任何一个依赖的影响。</li>\n<li>通过近乎实时的指标，监控和警报来优化发现故障的时间。</li>\n<li>通过配置更改的低延迟传播优化恢复时间，并支持Hystrix大多数方面的动态属性更改，从而允许您使用低延迟反馈循环进行实时操作修改。</li>\n<li>保护整个依赖客户端执行中的故障，而不仅仅是在网络流量上进行保护降级、限流。</li>\n</ul>\n<h2><a id="Hystrix__67"></a>Hystrix 是怎么实现它的设计目标的？</h2>\n<ul>\n<li>通过HystrixCommand 或者HystrixObservableCommand 将所有的外部系统（或者称为依赖）包装起来，整个包装对象是单独运行在一个线程之中（这是典型的命令模式）。</li>\n<li>超时请求应该超过你定义的阈值</li>\n<li>为每个依赖关系维护一个小的线程池（或信号量）; 如果它变满了，那么依赖关系的请求将立即被拒绝，而不是排队等待。</li>\n<li>统计成功，失败（由客户端抛出的异常），超时和线程拒绝。</li>\n<li>打开断路器可以在一段时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，手动或自动的关闭断路器。</li>\n<li>当请求被拒绝、连接超时或者断路器打开，直接执行fallback逻辑。</li>\n<li>近乎实时监控指标和配置变化。</li>\n</ul>\n<p>当您使用Hystrix包装每个底层依赖项时，上图所示的体系结构如下图所示。 每个依赖关系彼此隔离，在延迟发生时可以饱和的资源受到限制，迅速执行fallback的逻辑，该逻辑决定了在依赖关系中发生任何类型的故障时会做出什么响应：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Sh3QvO81-1570075727424)(https://github.com/Netflix/Hystrix/wiki/images/soa-4-isolation-640.png)]</p>\n<h2><a id="Hystrix_82"></a>Hystrix是怎么工作的？</h2>\n<h3><a id="_84"></a>架构图</h3>\n<p>下图显示通过Hystrix向服务依赖关系发出请求时会发生什么：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dpa2kvTmV0ZmxpeC9IeXN0cml4L2ltYWdlcy9oeXN0cml4LWNvbW1hbmQtZmxvdy1jaGFydC5wbmc?x-oss-process=image/format,png" alt=""></p>\n<p>具体将从以下几个方面进行描述：</p>\n<h4><a id="1HystrixCommandHystrixObservableCommand___92"></a>1.构建一个HystrixCommand或者HystrixObservableCommand  对象。</h4>\n<p>第一步是构建一个HystrixCommand或HystrixObservableCommand对象来表示你对依赖关系的请求。 其中构造函数需要和请求时的参数一致。</p>\n<p>构造HystrixCommand对象，如果依赖关系预期返回单个响应。 可以这样写：</p>\n<pre><code>HystrixCommand command = new HystrixCommand(arg1, arg2);\n</code></pre>\n<p>同理，可以构建HystrixObservableCommand ：</p>\n<pre><code>HystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2);\n\n</code></pre>\n<h4><a id="2Command_109"></a>2.执行Command</h4>\n<p>通过使用Hystrix命令对象的以下四种方法之一，可以执行该命令有四种方法（前两种方法仅适用于简单的HystrixCommand对象，并不适用于HystrixObservableCommand）：</p>\n<ul>\n<li>execute()–阻塞，，然后返回从依赖关系接收到的单个响应（或者在发生错误时抛出异常）</li>\n<li>queue()–返回一个可以从依赖关系获得单个响应的future 对象</li>\n<li>observe()–订阅Observable代表依赖关系的响应，并返回一个Observable，该Observable会复制该来源Observable</li>\n<li>toObservable() --返回一个Observable，当您订阅它时，将执行Hystrix命令并发出其响应</li>\n</ul>\n<pre><code>K             value   = command.execute();\nFuture&lt;K&gt;     fValue  = command.queue();\nObservable&lt;K&gt; ohValue = command.observe();         \nObservable&lt;K&gt; ocValue = command.toObservable();\n</code></pre>\n<p>同步调用execute（）调用queue（）.get（）. queue（）依次调用toObservable（）.toBlocking（）.toFuture（）。 这就是说，最终每个HystrixCommand都由一个Observable实现支持，甚至是那些旨在返回单个简单值的命令。</p>\n<h4><a id="3_127"></a>3.响应是否有缓存？</h4>\n<p>如果为该命令启用请求缓存，并且如果缓存中对该请求的响应可用，则此缓存响应将立即以“可观察”的形式返回。</p>\n<h4><a id="4_131"></a>4.断路器是否打开？</h4>\n<p>当您执行该命令时，Hystrix将检查断路器以查看电路是否打开。</p>\n<p>如果电路打开（或“跳闸”），则Hystrix将不会执行该命令，但会将流程路由到（8）获取回退。</p>\n<p>如果电路关闭，则流程进行到（5）以检查是否有可用于运行命令的容量。</p>\n<h4><a id="5_139"></a>5.线程池/队列/信号量是否已经满负载？</h4>\n<p>如果与命令相关联的线程池和队列（或信号量，如果不在线程中运行）已满，则Hystrix将不会执行该命令，但将立即将流程路由到（8）获取回退。</p>\n<h4><a id="6HystrixObservableCommandconstruct__HystrixCommandrun_143"></a>6.HystrixObservableCommand.construct() 或者 HystrixCommand.run()</h4>\n<p>在这里，Hystrix通过您为此目的编写的方法调用对依赖关系的请求，其中之一是：</p>\n<ul>\n<li>\n<p>HystrixCommand.run（） - 返回单个响应或者引发异常</p>\n</li>\n<li>\n<p>HystrixObservableCommand.construct（） - 返回一个发出响应的Observable或者发送一个onError通知</p>\n</li>\n</ul>\n<p>如果run（）或construct（）方法超出了命令的超时值，则该线程将抛出一个TimeoutException（或者如果命令本身没有在自己的线程中运行，则会产生单独的计时器线程）。 在这种情况下，Hystrix将响应通过8进行路由。获取Fallback，如果该方法不取消/中断，它会丢弃最终返回值run（）或construct（）方法。</p>\n<p>请注意，没有办法强制潜在线程停止工作 - 最好的Hystrix可以在JVM上执行它来抛出一个InterruptedException。 如果由Hystrix包装的工作不处理InterruptedExceptions，Hystrix线程池中的线程将继续工作，尽管客户端已经收到了TimeoutException。 这种行为可能使Hystrix线程池饱和，尽管负载“正确地流失”。 大多数Java HTTP客户端库不会解释InterruptedExceptions。 因此，请确保在HTTP客户端上正确配置连接和读/写超时。</p>\n<p>如果该命令没有引发任何异常并返回响应，则Hystrix在执行某些日志记录和度量报告后返回此响应。 在run（）的情况下，Hystrix返回一个Observable，发出单个响应，然后进行一个onCompleted通知; 在construct（）的情况下，Hystrix返回由construct（）返回的相同的Observable。</p>\n<h4><a id="7Circuit__158"></a>7.计算Circuit 的健康</h4>\n<p>Hystrix向断路器报告成功，失败，拒绝和超时，该断路器维护了一系列的计算统计数据组。</p>\n<p>它使用这些统计信息来确定电路何时“跳闸”，此时短路任何后续请求直到恢复时间过去，在首次检查某些健康检查之后，它再次关闭电路。</p>\n<h4><a id="8Fallback_165"></a>8.获取Fallback</h4>\n<p>当命令执行失败时，Hystrix试图恢复到你的回退：当construct（）或run（）（6.）抛出异常时，当命令由于电路断开而短路时（4.），当 命令的线程池和队列或信号量处于容量（5.），或者当命令超过其超时长度时。</p>\n<p>编写Fallback ,它不一依赖于任何的网络依赖，从内存中获取获取通过其他的静态逻辑。如果你非要通过网络去获取Fallback,你可能需要些在获取服务的接口的逻辑上写一个HystrixCommand。</p>\n<h4><a id="9_171"></a>9.返回成功的响应</h4>\n<p>如果 Hystrix command成功，如果Hystrix命令成功，它将以Observable的形式返回对呼叫者的响应或响应。 根据您在上述步骤2中调用命令的方式，此Observable可能会在返回给您之前进行转换：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dpa2kvTmV0ZmxpeC9IeXN0cml4L2ltYWdlcy9oeXN0cml4LXJldHVybi1mbG93LnBuZw?x-oss-process=image/format,png" alt=""></p>\n<ul>\n<li>execute（） - 以与.queue（）相同的方式获取Future，然后在此Future上调用get（）来获取Observable发出的单个值</li>\n<li>queue（） - 将Observable转换为BlockingObservable，以便将其转换为Future，然后返回此未来</li>\n<li>observe（） - 立即订阅Observable并启动执行命令的流程; 返回一个Observable，当您订阅它时，重播排放和通知</li>\n<li>toObservable（） - 返回Observable不变; 您必须订阅它才能实际开始导致命令执行的流程</li>\n<li>\n</ul>\n<h3><a id="Circuit_Breaker_185"></a>断路器（Circuit Breaker）</h3>\n<p>下图显示HystrixCommand或HystrixObservableCommand如何与HystrixCircuitBreaker及其逻辑和决策流程进行交互，包括计数器在断路器中的行为。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dpa2kvTmV0ZmxpeC9IeXN0cml4L2ltYWdlcy9jaXJjdWl0LWJyZWFrZXItMTI4MC5wbmc?x-oss-process=image/format,png" alt=""></p>\n<p>发生电路开闭的过程如下：</p>\n<p>1.假设电路上的音量达到一定阈值（HystrixCommandProperties.circuitBreakerRequestVolumeThreshold（））…</p>\n<p>2.并假设错误百分比超过阈值错误百分比（HystrixCommandProperties.circuitBreakerErrorThresholdPercentage（））…</p>\n<p>3.然后断路器从CLOSED转换到OPEN。</p>\n<p>4.虽然它是开放的，它使所有针对该断路器的请求短路。</p>\n<p>5.经过一段时间（HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds（）），下一个单个请求是通过（这是HALF-OPEN状态）。 如果请求失败，断路器将在睡眠窗口持续时间内返回到OPEN状态。 如果请求成功，断路器将转换到CLOSED，逻辑1.重新接管。</p>\n<h3><a id="Isolation_203"></a>隔离（Isolation）</h3>\n<p>Hystrix采用隔板模式来隔离彼此的依赖关系，并限制对其中任何一个的并发访问。</p>\n<h3><a id="_207"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/74820899', 'title': '深入理解Ribbon之源码解析', 'readNum': '87908', 'commentNum': '13', 'publishTime': '2017-07-08 14:48:05', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/74820899<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/08/11/Ribbon-resources.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/08/11/Ribbon-resources.html</a></strong></p>\n<h2><a id="Ribbon_7"></a>什么是Ribbon</h2>\n<p>Ribbon是Netflix公司开源的一个负载均衡的项目，它属于上述的第二种，是一个客户端负载均衡器，运行在客户端上。它是一个经过了云端测试的IPC库，可以很好地控制HTTP和TCP客户端的一些行为。 Feign已经默认使用了Ribbon。</p>\n<ul>\n<li>负载均衡</li>\n<li>容错</li>\n<li>多协议（HTTP，TCP，UDP）支持异步和反应模型</li>\n<li>缓存和批处理</li>\n</ul>\n<h2><a id="RestTemplateRibbon_16"></a>RestTemplate和Ribbon相结合</h2>\n<p>Ribbon在Netflix组件是非常重要的一个组件，在Zuul中使用Ribbon做负载均衡，以及Feign组件的结合等。在Spring Cloud 中，作为开发中，做的最多的可能是将RestTemplate和Ribbon相结合，你可能会这样写：</p>\n<pre><code>@Configuration\npublic class RibbonConfig {\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n\n</code></pre>\n<p>消费另外一个的服务的接口，差不多是这样的：</p>\n<pre><code>\n@Service\npublic class RibbonService {\n    @Autowired\n    RestTemplate restTemplate;\n    public String hi(String name) {\n        return restTemplate.getForObject("http://eureka-client/hi?name="+name,String.class);\n    }\n}\n\n</code></pre>\n<h2><a id="Ribbon_47"></a>深入理解Ribbon</h2>\n<h3><a id="LoadBalancerClient_50"></a>LoadBalancerClient</h3>\n<p>在Riibon中一个非常重要的组件为LoadBalancerClient，它作为负载均衡的一个客户端。它在spring-cloud-commons包下：<br>\n的LoadBalancerClient是一个接口，它继承ServiceInstanceChooser，它的实现类是RibbonLoadBalancerClient，这三者之间的关系如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011844628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>其中LoadBalancerClient接口，有如下三个方法，其中excute()为执行请求，reconstructURI()用来重构url：</p>\n<pre><code>public interface LoadBalancerClient extends ServiceInstanceChooser {\n  &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;\n  &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException;\n  URI reconstructURI(ServiceInstance instance, URI original);\n\n}\n\n</code></pre>\n<p>ServiceInstanceChooser接口，主要有一个方法，用来根据serviceId来获取ServiceInstance，代码如下:</p>\n<pre><code>public interface ServiceInstanceChooser {\n\n    ServiceInstance choose(String serviceId);\n}\n\n</code></pre>\n<p>LoadBalancerClient的实现类为RibbonLoadBalancerClient，这个类是非常重要的一个类，最终的负载均衡的请求处理，由它来执行。它的部分源码如下：</p>\n<pre><code>public class RibbonLoadBalancerClient implements LoadBalancerClient {\n\n...//省略代码\n\n@Override\n\tpublic ServiceInstance choose(String serviceId) {\n\t\tServer server = getServer(serviceId);\n\t\tif (server == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new RibbonServer(serviceId, server, isSecure(server, serviceId),\n\t\t\t\tserverIntrospector(serviceId).getMetadata(server));\n\t}\n\n\n\nprotected Server getServer(String serviceId) {\n\t\treturn getServer(getLoadBalancer(serviceId));\n   }\n\n\nprotected Server getServer(ILoadBalancer loadBalancer) {\n\t\tif (loadBalancer == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn loadBalancer.chooseServer("default"); // TODO: better handling of key\n\t}\n\n\nprotected ILoadBalancer getLoadBalancer(String serviceId) {\n\t\treturn this.clientFactory.getLoadBalancer(serviceId);\n\t}\n\t\n\t...//省略代码\n\n</code></pre>\n<p>在RibbonLoadBalancerClient的源码中，其中choose()方法是选择具体服务实例的一个方法。该方法通过getServer()方法去获取实例，经过源码跟踪，最终交给了ILoadBalancer类去选择服务实例。</p>\n<p>ILoadBalancer在ribbon-loadbalancer的jar包下,它是定义了实现软件负载均衡的一个接口，它需要一组可供选择的服务注册列表信息，以及根据特定方法去选择服务，它的源码如下 ：</p>\n<pre><code>public interface ILoadBalancer {\n\n    public void addServers(List&lt;Server&gt; newServers);\n    public Server chooseServer(Object key);\n    public void markServerDown(Server server);\n    public List&lt;Server&gt; getReachableServers();\n    public List&lt;Server&gt; getAllServers();\n}\n\n\n</code></pre>\n<p>其中，addServers()方法是添加一个Server集合；chooseServer()方法是根据key去获取Server；markServerDown()方法用来标记某个服务下线；getReachableServers()获取可用的Server集合；getAllServers()获取所有的Server集合。</p>\n<h2><a id="DynamicServerListLoadBalancer_138"></a>DynamicServerListLoadBalancer</h2>\n<p>它的继承类为BaseLoadBalancer，它的实现类为DynamicServerListLoadBalancer，这三者之间的关系如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011911329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>查看上述三个类的源码，可用发现，配置以下信息，IClientConfig、IRule、IPing、ServerList、ServerListFilter和ILoadBalancer，查看BaseLoadBalancer类，它默认的情况下，实现了以下配置：</p>\n<ul>\n<li>IClientConfig ribbonClientConfig:  DefaultClientConfigImpl配置</li>\n<li>IRule ribbonRule: RoundRobinRule 路由策略</li>\n<li>IPing ribbonPing: DummyPing</li>\n<li>ServerList ribbonServerList: ConfigurationBasedServerList</li>\n<li>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</li>\n<li>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</li>\n</ul>\n<p>IClientConfig 用于对客户端或者负载均衡的配置，它的默认实现类为DefaultClientConfigImpl。</p>\n<p>IRule用于复杂均衡的策略，它有三个方法，其中choose()是根据key 来获取server,setLoadBalancer()和getLoadBalancer()是用来设置和获取ILoadBalancer的，它的源码如下：</p>\n<pre><code>public interface IRule{\n\n    public Server choose(Object key);\n    \n    public void setLoadBalancer(ILoadBalancer lb);\n    \n    public ILoadBalancer getLoadBalancer();    \n}\n\n\n</code></pre>\n<p>IRule有很多默认的实现类，这些实现类根据不同的算法和逻辑来处理负载均衡。Ribbon实现的IRule有一下。在大多数情况下，这些默认的实现类是可以满足需求的，如果有特性的需求，可以自己实现。</p>\n<ul>\n<li>\n<p>BestAvailableRule 选择最小请求数</p>\n</li>\n<li>\n<p>ClientConfigEnabledRoundRobinRule 轮询</p>\n</li>\n<li>\n<p>RandomRule 随机选择一个server</p>\n</li>\n<li>\n<p>RoundRobinRule 轮询选择server</p>\n</li>\n<li>\n<p>RetryRule 根据轮询的方式重试</p>\n</li>\n<li>\n<p>WeightedResponseTimeRule 根据响应时间去分配一个weight ，weight越低，被选择的可能性就越低</p>\n</li>\n<li>\n<p>ZoneAvoidanceRule 根据server的zone区域和可用性来轮询选择</p>\n</li>\n</ul>\n<p><img src="https://img-blog.csdnimg.cn/20190601011934207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>IPing是用来想server发生"ping"，来判断该server是否有响应，从而判断该server是否可用。它有一个isAlive()方法，它的源码如下：</p>\n<pre><code>public interface IPing {\n    public boolean isAlive(Server server);\n}\n\n\n</code></pre>\n<p>IPing的实现类有PingUrl、PingConstant、NoOpPing、DummyPing和NIWSDiscoveryPing。它门之间的关系如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011957162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<ul>\n<li>PingUrl 真实的去ping 某个url，判断其是否alive</li>\n<li>PingConstant 固定返回某服务是否可用，默认返回true，即可用</li>\n<li>NoOpPing 不去ping,直接返回true,即可用。</li>\n<li>DummyPing 直接返回true，并实现了initWithNiwsConfig方法。</li>\n<li>NIWSDiscoveryPing，根据DiscoveryEnabledServer的InstanceInfo的InstanceStatus去判断，如果为InstanceStatus.UP，则为可用，否则不可用。</li>\n</ul>\n<p>ServerList是定义获取所有的server的注册列表信息的接口，它的代码如下：</p>\n<pre><code>public interface ServerList&lt;T extends Server&gt; {\n\n    public List&lt;T&gt; getInitialListOfServers();\n    public List&lt;T&gt; getUpdatedListOfServers();   \n\n}\n\n</code></pre>\n<p>ServerListFilter接口，定于了可根据配置去过滤或者根据特性动态获取符合条件的server列表的方法，代码如下：</p>\n<pre><code>public interface ServerListFilter&lt;T extends Server&gt; {\n\n    public List&lt;T&gt; getFilteredListOfServers(List&lt;T&gt; servers);\n\n}\n\n\n</code></pre>\n<p>阅读DynamicServerListLoadBalancer的源码，DynamicServerListLoadBalancer的构造函数中有个initWithNiwsConfig()方法。在改方法中，经过一系列的初始化配置，最终执行了restOfInit()方法。其代码如下：</p>\n<pre><code>\n public DynamicServerListLoadBalancer(IClientConfig clientConfig) {\n        initWithNiwsConfig(clientConfig);\n    }\n    \n    @Override\n    public void initWithNiwsConfig(IClientConfig clientConfig) {\n        try {\n            super.initWithNiwsConfig(clientConfig);\n            String niwsServerListClassName = clientConfig.getPropertyAsString(\n                    CommonClientConfigKey.NIWSServerListClassName,\n                    DefaultClientConfigImpl.DEFAULT_SEVER_LIST_CLASS);\n\n            ServerList&lt;T&gt; niwsServerListImpl = (ServerList&lt;T&gt;) ClientFactory\n                    .instantiateInstanceWithClientConfig(niwsServerListClassName, clientConfig);\n            this.serverListImpl = niwsServerListImpl;\n\n            if (niwsServerListImpl instanceof AbstractServerList) {\n                AbstractServerListFilter&lt;T&gt; niwsFilter = ((AbstractServerList) niwsServerListImpl)\n                        .getFilterImpl(clientConfig);\n                niwsFilter.setLoadBalancerStats(getLoadBalancerStats());\n                this.filter = niwsFilter;\n            }\n\n            String serverListUpdaterClassName = clientConfig.getPropertyAsString(\n                    CommonClientConfigKey.ServerListUpdaterClassName,\n                    DefaultClientConfigImpl.DEFAULT_SERVER_LIST_UPDATER_CLASS\n            );\n\n            this.serverListUpdater = (ServerListUpdater) ClientFactory\n                    .instantiateInstanceWithClientConfig(serverListUpdaterClassName, clientConfig);\n\n            restOfInit(clientConfig);\n        } catch (Exception e) {\n            throw new RuntimeException(\n                    "Exception while initializing NIWSDiscoveryLoadBalancer:"\n                            + clientConfig.getClientName()\n                            + ", niwsClientConfig:" + clientConfig, e);\n        }\n    }\n\n</code></pre>\n<p>在restOfInit()方法上，有一个 updateListOfServers()的方法，该方法是用来获取所有的ServerList的。</p>\n<pre><code> void restOfInit(IClientConfig clientConfig) {\n        boolean primeConnection = this.isEnablePrimingConnections();\n        // turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()\n        this.setEnablePrimingConnections(false);\n        enableAndInitLearnNewServersFeature();\n\n        updateListOfServers();\n        if (primeConnection &amp;&amp; this.getPrimeConnections() != null) {\n            this.getPrimeConnections()\n                    .primeConnections(getReachableServers());\n        }\n        this.setEnablePrimingConnections(primeConnection);\n        LOGGER.info("DynamicServerListLoadBalancer for client {} initialized: {}", clientConfig.getClientName(), this.toString());\n    }\n\n</code></pre>\n<p>进一步跟踪updateListOfServers()方法的源码，最终由serverListImpl.getUpdatedListOfServers()获取所有的服务列表的，代码如下：</p>\n<pre><code>   @VisibleForTesting\n    public void updateListOfServers() {\n        List&lt;T&gt; servers = new ArrayList&lt;T&gt;();\n        if (serverListImpl != null) {\n            servers = serverListImpl.getUpdatedListOfServers();\n            LOGGER.debug("List of Servers for {} obtained from Discovery client: {}",\n                    getIdentifier(), servers);\n\n            if (filter != null) {\n                servers = filter.getFilteredListOfServers(servers);\n                LOGGER.debug("Filtered List of Servers for {} obtained from Discovery client: {}",\n                        getIdentifier(), servers);\n            }\n        }\n        updateAllServerList(servers);\n    }\n\n</code></pre>\n<p>而serverListImpl是ServerList接口的具体实现类。跟踪代码，ServerList的实现类为DiscoveryEnabledNIWSServerList，在ribbon-eureka.jar的com.netflix.niws.loadbalancer下。其中DiscoveryEnabledNIWSServerList有 getInitialListOfServers()和getUpdatedListOfServers()方法，具体代码如下：</p>\n<pre><code>@Override\n    public List&lt;DiscoveryEnabledServer&gt; getInitialListOfServers(){\n        return obtainServersViaDiscovery();\n    }\n\n    @Override\n    public List&lt;DiscoveryEnabledServer&gt; getUpdatedListOfServers(){\n        return obtainServersViaDiscovery();\n    }\n\n</code></pre>\n<p>继续跟踪源码，obtainServersViaDiscovery（），是根据eurekaClientProvider.get()来回去EurekaClient，再根据EurekaClient来获取注册列表信息，代码如下：</p>\n<pre><code>\n private List&lt;DiscoveryEnabledServer&gt; obtainServersViaDiscovery() {\n        List&lt;DiscoveryEnabledServer&gt; serverList = new ArrayList&lt;DiscoveryEnabledServer&gt;();\n\n        if (eurekaClientProvider == null || eurekaClientProvider.get() == null) {\n            logger.warn("EurekaClient has not been initialized yet, returning an empty list");\n            return new ArrayList&lt;DiscoveryEnabledServer&gt;();\n        }\n\n        EurekaClient eurekaClient = eurekaClientProvider.get();\n        if (vipAddresses!=null){\n            for (String vipAddress : vipAddresses.split(",")) {\n                // if targetRegion is null, it will be interpreted as the same region of client\n                List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);\n                for (InstanceInfo ii : listOfInstanceInfo) {\n                    if (ii.getStatus().equals(InstanceStatus.UP)) {\n\n                        if(shouldUseOverridePort){\n                            if(logger.isDebugEnabled()){\n                                logger.debug("Overriding port on client name: " + clientName + " to " + overridePort);\n                            }\n\n                            // copy is necessary since the InstanceInfo builder just uses the original reference,\n                            // and we don\'t want to corrupt the global eureka copy of the object which may be\n                            // used by other clients in our system\n                            InstanceInfo copy = new InstanceInfo(ii);\n\n                            if(isSecure){\n                                ii = new InstanceInfo.Builder(copy).setSecurePort(overridePort).build();\n                            }else{\n                                ii = new InstanceInfo.Builder(copy).setPort(overridePort).build();\n                            }\n                        }\n\n                        DiscoveryEnabledServer des = new DiscoveryEnabledServer(ii, isSecure, shouldUseIpAddr);\n                        des.setZone(DiscoveryClient.getZone(ii));\n                        serverList.add(des);\n                    }\n                }\n                if (serverList.size()&gt;0 &amp;&amp; prioritizeVipAddressBasedServers){\n                    break; // if the current vipAddress has servers, we dont use subsequent vipAddress based servers\n                }\n            }\n        }\n        return serverList;\n    }\n</code></pre>\n<p>其中eurekaClientProvider的实现类是LegacyEurekaClientProvider，它是一个获取eurekaClient类，通过静态的方法去获取eurekaClient，其代码如下：</p>\n<pre><code>class LegacyEurekaClientProvider implements Provider&lt;EurekaClient&gt; {\n\n    private volatile EurekaClient eurekaClient;\n\n    @Override\n    public synchronized EurekaClient get() {\n        if (eurekaClient == null) {\n            eurekaClient = DiscoveryManager.getInstance().getDiscoveryClient();\n        }\n\n        return eurekaClient;\n    }\n}\n\n</code></pre>\n<p>EurekaClient的实现类为DiscoveryClient，在之前已经分析了它具有服务注册、获取服务注册列表等的全部功能。</p>\n<p>由此可见，负载均衡器是从EurekaClient获取服务信息，并根据IRule去路由，并且根据IPing去判断服务的可用性。</p>\n<p>那么现在还有个问题，负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢。</p>\n<p>在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务，代码如下：</p>\n<pre><code>   public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,\n            IPing ping, IPingStrategy pingStrategy) {\n\t    ...//代码省略\n        setupPingTask();\n         ...//代码省略\n    }\n\n</code></pre>\n<p>setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，想EurekaClient发送一次"ping"。</p>\n<pre><code>    void setupPingTask() {\n        if (canSkipPing()) {\n            return;\n        }\n        if (lbTimer != null) {\n            lbTimer.cancel();\n        }\n        lbTimer = new ShutdownEnabledTimer("NFLoadBalancer-PingTimer-" + name,\n                true);\n        lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);\n        forceQuickPing();\n    }\n\n</code></pre>\n<p>PingTask源码，即new一个Pinger对象，并执行runPinger()方法。</p>\n<pre><code>class PingTask extends TimerTask {\n        public void run() {\n            try {\n            \tnew Pinger(pingStrategy).runPinger();\n            } catch (Exception e) {\n                logger.error("LoadBalancer [{}]: Error pinging", name, e);\n            }\n        }\n    }\n\n</code></pre>\n<p>查看Pinger的runPinger()方法，最终根据  pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。</p>\n<pre><code>  public void runPinger() throws Exception {\n            if (!pingInProgress.compareAndSet(false, true)) { \n                return; // Ping in progress - nothing to do\n            }\n            \n            // we are "in" - we get to Ping\n\n            Server[] allServers = null;\n            boolean[] results = null;\n\n            Lock allLock = null;\n            Lock upLock = null;\n\n            try {\n                /*\n                 * The readLock should be free unless an addServer operation is\n                 * going on...\n                 */\n                allLock = allServerLock.readLock();\n                allLock.lock();\n                allServers = allServerList.toArray(new Server[allServerList.size()]);\n                allLock.unlock();\n\n                int numCandidates = allServers.length;\n                results = pingerStrategy.pingServers(ping, allServers);\n\n                final List&lt;Server&gt; newUpList = new ArrayList&lt;Server&gt;();\n                final List&lt;Server&gt; changedServers = new ArrayList&lt;Server&gt;();\n\n                for (int i = 0; i &lt; numCandidates; i++) {\n                    boolean isAlive = results[i];\n                    Server svr = allServers[i];\n                    boolean oldIsAlive = svr.isAlive();\n\n                    svr.setAlive(isAlive);\n\n                    if (oldIsAlive != isAlive) {\n                        changedServers.add(svr);\n                        logger.debug("LoadBalancer [{}]:  Server [{}] status changed to {}", \n                    \t\tname, svr.getId(), (isAlive ? "ALIVE" : "DEAD"));\n                    }\n\n                    if (isAlive) {\n                        newUpList.add(svr);\n                    }\n                }\n                upLock = upServerLock.writeLock();\n                upLock.lock();\n                upServerList = newUpList;\n                upLock.unlock();\n\n                notifyServerStatusChangeListener(changedServers);\n            } finally {\n                pingInProgress.set(false);\n            }\n        }\n\n</code></pre>\n<p>由此可见，LoadBalancerClient是在初始化的时候，会向Eureka回去服务注册列表，并且向通过10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。</p>\n<h2><a id="RestTemplateRibbon_520"></a>RestTemplate是如何和Ribbon结合的</h2>\n<p>最后，回答问题的本质，为什么在RestTemplate加一个@LoadBalance注解就可可以开启负载均衡呢？</p>\n<pre><code> @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n</code></pre>\n<p>全局搜索ctr+shift+f  @LoadBalanced有哪些类用到了LoadBalanced有哪些类用到了， 发现LoadBalancerAutoConfiguration类，即LoadBalancer自动配置类。</p>\n<pre><code>@Configuration\n@ConditionalOnClass(RestTemplate.class)\n@ConditionalOnBean(LoadBalancerClient.class)\n@EnableConfigurationProperties(LoadBalancerRetryProperties.class)\npublic class LoadBalancerAutoConfiguration {\n\n@LoadBalanced\n\t@Autowired(required = false)\n\tprivate List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();\n}\n\t@Bean\n\tpublic SmartInitializingSingleton loadBalancedRestTemplateInitializer(\n\t\t\tfinal List&lt;RestTemplateCustomizer&gt; customizers) {\n\t\treturn new SmartInitializingSingleton() {\n\t\t\t@Override\n\t\t\tpublic void afterSingletonsInstantiated() {\n\t\t\t\tfor (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) {\n\t\t\t\t\tfor (RestTemplateCustomizer customizer : customizers) {\n\t\t\t\t\t\tcustomizer.customize(restTemplate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\t\n\t@Configuration\n\t@ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")\n\tstatic class LoadBalancerInterceptorConfig {\n\t\t@Bean\n\t\tpublic LoadBalancerInterceptor ribbonInterceptor(\n\t\t\t\tLoadBalancerClient loadBalancerClient,\n\t\t\t\tLoadBalancerRequestFactory requestFactory) {\n\t\t\treturn new LoadBalancerInterceptor(loadBalancerClient, requestFactory);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic RestTemplateCustomizer restTemplateCustomizer(\n\t\t\t\tfinal LoadBalancerInterceptor loadBalancerInterceptor) {\n\t\t\treturn new RestTemplateCustomizer() {\n\t\t\t\t@Override\n\t\t\t\tpublic void customize(RestTemplate restTemplate) {\n\t\t\t\t\tList&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList&lt;&gt;(\n\t\t\t\t\t\t\trestTemplate.getInterceptors());\n\t\t\t\t\tlist.add(loadBalancerInterceptor);\n\t\t\t\t\trestTemplate.setInterceptors(list);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n}\n</code></pre>\n<p>在该类中，首先维护了一个被@LoadBalanced修饰的RestTemplate对象的List，在初始化的过程中，通过调用customizer.customize(restTemplate)方法来给RestTemplate增加拦截器LoadBalancerInterceptor。</p>\n<p>而LoadBalancerInterceptor，用于实时拦截，在LoadBalancerInterceptor这里实现来负载均衡。LoadBalancerInterceptor的拦截方法如下：</p>\n<pre><code>@Override\n\tpublic ClientHttpResponse intercept(final HttpRequest request, final byte[] body,\n\t\t\tfinal ClientHttpRequestExecution execution) throws IOException {\n\t\tfinal URI originalUri = request.getURI();\n\t\tString serviceName = originalUri.getHost();\n\t\tAssert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);\n\t\treturn this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));\n\t}\n\n</code></pre>\n<h2><a id="_605"></a>总结</h2>\n<p>综上所述，Ribbon的负载均衡，主要通过LoadBalancerClient来实现的，而LoadBalancerClient具体交给了ILoadBalancer来处理，ILoadBalancer通过配置IRule、IPing等信息，并向EurekaClient获取注册列表的信息，并默认10秒一次向EurekaClient发送“ping”,进而检查是否更新服务列表，最后，得到注册列表后，ILoadBalancer根据IRule的策略进行负载均衡。</p>\n<p>而RestTemplate 被@LoadBalance注解后，能过用负载均衡，主要是维护了一个被@LoadBalance注解的RestTemplate列表，并给列表中的RestTemplate添加拦截器，进而交给负载均衡器去处理。</p>\n<h3><a id="_612"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_620"></a>关注我的公众号</h3>\n<p>精彩内容不能错过！</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:33 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/73480304', 'title': '深入理解Feign之源码解析', 'readNum': '127714', 'commentNum': '18', 'publishTime': '2017-06-20 09:31:13', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/73480304<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a><br>\n出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/08/11/sc-feign-raw.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/08/11/sc-feign-raw.html</a></strong></p>\n<h2><a id="Feign_8"></a>什么是Feign</h2>\n<p>Feign是受到Retrofit，JAXRS-2.0和WebSocket的影响，它是一个jav的到http客户端绑定的开源项目。 Feign的主要目标是将Java Http 客户端变得简单。Feign的源码地址：https://github.com/OpenFeign/feign</p>\n<h2><a id="Feign_12"></a>写一个Feign</h2>\n<p>在我之前的博文有写到如何用Feign去消费服务，文章地址：http://blog.csdn.net/forezp/article/details/69808079  。</p>\n<p>现在来简单的实现一个Feign客户端，首先通过@FeignClient，客户端，其中value为调用其他服务的名称，FeignConfig.class为FeignClient的配置文件，代码如下：</p>\n<pre><code>\n@FeignClient(value = "service-hi",configuration = FeignConfig.class)\npublic interface SchedualServiceHi {\n    @GetMapping(value = "/hi")\n    String sayHiFromClientOne(@RequestParam(value = "name") String name);\n}\n\n</code></pre>\n<p>其自定义配置文件如下，当然也可以不写配置文件，用默认的即可：</p>\n<pre><code>@Configuration\npublic class FeignConfig {\n\n    @Bean\n    public Retryer feignRetryer() {\n        return new Retryer.Default(100, SECONDS.toMillis(1), 5);\n    }\n    \n}\n\n\n</code></pre>\n<p>查看FeignClient注解的源码，其代码如下：</p>\n<pre><code>\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface FeignClient {\n\n@AliasFor("name")\nString value() default "";\n\t\n@AliasFor("value")\nString name() default "";\n\t\n@AliasFor("value")\nString name() default "";\nString url() default "";\nboolean decode404() default false;\n\nClass&lt;?&gt;[] configuration() default {};\nClass&lt;?&gt; fallback() default void.class;\n\nClass&lt;?&gt; fallbackFactory() default void.class;\n}\n\nString path() default "";\n\nboolean primary() default true;\n\n</code></pre>\n<p>FeignClient注解被@Target(ElementType.TYPE)修饰，表示FeignClient注解的作用目标在接口上；<br>\n@Retention(RetentionPolicy.RUNTIME)，注解会在class字节码文件中存在，在运行时可以通过反射获取到；@Documented表示该注解将被包含在javadoc中。</p>\n<p>feign 用于声明具有该接口的REST客户端的接口的注释应该是创建（例如用于自动连接到另一个组件。 如果功能区可用，那将是<br>\n用于负载平衡后端请求，并且可以配置负载平衡器<br>\n使用与伪装客户端相同名称（即值）@RibbonClient 。</p>\n<p>其中value()和name()一样，是被调用的 service的名称。<br>\nurl(),直接填写硬编码的url,decode404()即404是否被解码，还是抛异常；configuration()，标明FeignClient的配置类，默认的配置类为FeignClientsConfiguration类，可以覆盖Decoder、Encoder和Contract等信息，进行自定义配置。fallback(),填写熔断器的信息类。</p>\n<h2><a id="FeignClient_84"></a>FeignClient的配置</h2>\n<p>默认的配置类为FeignClientsConfiguration，这个类在spring-cloud-netflix-core的jar包下，打开这个类，可以发现它是一个配置类，注入了很多的相关配置的bean，包括feignRetryer、FeignLoggerFactory、FormattingConversionService等,其中还包括了Decoder、Encoder、Contract，如果这三个bean在没有注入的情况下，会自动注入默认的配置。</p>\n<ul>\n<li>Decoder feignDecoder: ResponseEntityDecoder(这是对SpringDecoder的封装)</li>\n<li>Encoder feignEncoder: SpringEncoder</li>\n<li>Logger feignLogger: Slf4jLogger</li>\n<li>Contract feignContract: SpringMvcContract</li>\n<li>Feign.Builder feignBuilder: HystrixFeign.Builder</li>\n</ul>\n<p>代码如下：</p>\n<pre><code>@Configuration\npublic class FeignClientsConfiguration {\n\n...//省略代码\n\n@Bean\n\t@ConditionalOnMissingBean\n\tpublic Decoder feignDecoder() {\n\t\treturn new ResponseEntityDecoder(new SpringDecoder(this.messageConverters));\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic Encoder feignEncoder() {\n\t\treturn new SpringEncoder(this.messageConverters);\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic Contract feignContract(ConversionService feignConversionService) {\n\t\treturn new SpringMvcContract(this.parameterProcessors, feignConversionService);\n\t}\n\n...//省略代码\n}\n\n\n</code></pre>\n<p>重写配置：</p>\n<p>你可以重写FeignClientsConfiguration中的bean，从而达到自定义配置的目的，比如FeignClientsConfiguration的默认重试次数为Retryer.NEVER_RETRY，即不重试，那么希望做到重写，写个配置文件，注入feignRetryer的bean,代码如下：</p>\n<pre><code>@Configuration\npublic class FeignConfig {\n\n    @Bean\n    public Retryer feignRetryer() {\n        return new Retryer.Default(100, SECONDS.toMillis(1), 5);\n    }\n\n}\n\n</code></pre>\n<p>在上述代码更改了该FeignClient的重试次数，重试间隔为100ms，最大重试时间为1s,重试次数为5次。</p>\n<h2><a id="Feign_148"></a>Feign的工作原理</h2>\n<p>feign是一个伪客户端，即它不做任何的请求处理。Feign通过处理注解生成request，从而实现简化HTTP API开发的目的，即开发人员可以使用注解的方式定制request api模板，在发送http request请求之前，feign通过处理注解的方式替换掉request模板中的参数，这种实现方式显得更为直接、可理解。</p>\n<p>通过包扫描注入FeignClient的bean，该源码在FeignClientsRegistrar类：<br>\n首先在启动配置上检查是否有@EnableFeignClients注解，如果有该注解，则开启包扫描，扫描被@FeignClient注解接口。代码如下：</p>\n<pre><code>private void registerDefaultConfiguration(AnnotationMetadata metadata,\n\t\t\tBeanDefinitionRegistry registry) {\n\t\tMap&lt;String, Object&gt; defaultAttrs = metadata\n\t\t\t\t.getAnnotationAttributes(EnableFeignClients.class.getName(), true);\n\n\t\tif (defaultAttrs != null &amp;&amp; defaultAttrs.containsKey("defaultConfiguration")) {\n\t\t\tString name;\n\t\t\tif (metadata.hasEnclosingClass()) {\n\t\t\t\tname = "default." + metadata.getEnclosingClassName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tname = "default." + metadata.getClassName();\n\t\t\t}\n\t\t\tregisterClientConfiguration(registry, name,\n\t\t\t\t\tdefaultAttrs.get("defaultConfiguration"));\n\t\t}\n\t}\n\n\n</code></pre>\n<p>程序启动后通过包扫描，当类有@FeignClient注解，将注解的信息取出，连同类名一起取出，赋给BeanDefinitionBuilder，然后根据BeanDefinitionBuilder得到beanDefinition，最后beanDefinition式注入到ioc容器中，源码如下：</p>\n<pre><code>public void registerFeignClients(AnnotationMetadata metadata,\n\t\t\tBeanDefinitionRegistry registry) {\n\t\tClassPathScanningCandidateComponentProvider scanner = getScanner();\n\t\tscanner.setResourceLoader(this.resourceLoader);\n\n\t\tSet&lt;String&gt; basePackages;\n\n\t\tMap&lt;String, Object&gt; attrs = metadata\n\t\t\t\t.getAnnotationAttributes(EnableFeignClients.class.getName());\n\t\tAnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(\n\t\t\t\tFeignClient.class);\n\t\tfinal Class&lt;?&gt;[] clients = attrs == null ? null\n\t\t\t\t: (Class&lt;?&gt;[]) attrs.get("clients");\n\t\tif (clients == null || clients.length == 0) {\n\t\t\tscanner.addIncludeFilter(annotationTypeFilter);\n\t\t\tbasePackages = getBasePackages(metadata);\n\t\t}\n\t\telse {\n\t\t\tfinal Set&lt;String&gt; clientClasses = new HashSet&lt;&gt;();\n\t\t\tbasePackages = new HashSet&lt;&gt;();\n\t\t\tfor (Class&lt;?&gt; clazz : clients) {\n\t\t\t\tbasePackages.add(ClassUtils.getPackageName(clazz));\n\t\t\t\tclientClasses.add(clazz.getCanonicalName());\n\t\t\t}\n\t\t\tAbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() {\n\t\t\t\t@Override\n\t\t\t\tprotected boolean match(ClassMetadata metadata) {\n\t\t\t\t\tString cleaned = metadata.getClassName().replaceAll("\\\\$", ".");\n\t\t\t\t\treturn clientClasses.contains(cleaned);\n\t\t\t\t}\n\t\t\t};\n\t\t\tscanner.addIncludeFilter(\n\t\t\t\t\tnew AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));\n\t\t}\n\n\t\tfor (String basePackage : basePackages) {\n\t\t\tSet&lt;BeanDefinition&gt; candidateComponents = scanner\n\t\t\t\t\t.findCandidateComponents(basePackage);\n\t\t\tfor (BeanDefinition candidateComponent : candidateComponents) {\n\t\t\t\tif (candidateComponent instanceof AnnotatedBeanDefinition) {\n\t\t\t\t\t// verify annotated class is an interface\n\t\t\t\t\tAnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;\n\t\t\t\t\tAnnotationMetadata annotationMetadata = beanDefinition.getMetadata();\n\t\t\t\t\tAssert.isTrue(annotationMetadata.isInterface(),\n\t\t\t\t\t\t\t"@FeignClient can only be specified on an interface");\n\n\t\t\t\t\tMap&lt;String, Object&gt; attributes = annotationMetadata\n\t\t\t\t\t\t\t.getAnnotationAttributes(\n\t\t\t\t\t\t\t\t\tFeignClient.class.getCanonicalName());\n\n\t\t\t\t\tString name = getClientName(attributes);\n\t\t\t\t\tregisterClientConfiguration(registry, name,\n\t\t\t\t\t\t\tattributes.get("configuration"));\n\n\t\t\t\t\tregisterFeignClient(registry, annotationMetadata, attributes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\nprivate void registerFeignClient(BeanDefinitionRegistry registry,\n\t\t\tAnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {\n\t\tString className = annotationMetadata.getClassName();\n\t\tBeanDefinitionBuilder definition = BeanDefinitionBuilder\n\t\t\t\t.genericBeanDefinition(FeignClientFactoryBean.class);\n\t\tvalidate(attributes);\n\t\tdefinition.addPropertyValue("url", getUrl(attributes));\n\t\tdefinition.addPropertyValue("path", getPath(attributes));\n\t\tString name = getName(attributes);\n\t\tdefinition.addPropertyValue("name", name);\n\t\tdefinition.addPropertyValue("type", className);\n\t\tdefinition.addPropertyValue("decode404", attributes.get("decode404"));\n\t\tdefinition.addPropertyValue("fallback", attributes.get("fallback"));\n\t\tdefinition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));\n\t\tdefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);\n\n\t\tString alias = name + "FeignClient";\n\t\tAbstractBeanDefinition beanDefinition = definition.getBeanDefinition();\n\n\t\tboolean primary = (Boolean)attributes.get("primary"); // has a default, won\'t be null\n\n\t\tbeanDefinition.setPrimary(primary);\n\n\t\tString qualifier = getQualifier(attributes);\n\t\tif (StringUtils.hasText(qualifier)) {\n\t\t\talias = qualifier;\n\t\t}\n\n\t\tBeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,\n\t\t\t\tnew String[] { alias });\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);\n\t}\n\n\n\n</code></pre>\n<p>注入bean之后，通过jdk的代理，当请求Feign Client的方法时会被拦截，代码在ReflectiveFeign类，代码如下：</p>\n<pre><code> public &lt;T&gt; T newInstance(Target&lt;T&gt; target) {\n    Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);\n    Map&lt;Method, MethodHandler&gt; methodToHandler = new LinkedHashMap&lt;Method, MethodHandler&gt;();\n    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = new LinkedList&lt;DefaultMethodHandler&gt;();\n\n    for (Method method : target.type().getMethods()) {\n      if (method.getDeclaringClass() == Object.class) {\n        continue;\n      } else if(Util.isDefault(method)) {\n        DefaultMethodHandler handler = new DefaultMethodHandler(method);\n        defaultMethodHandlers.add(handler);\n        methodToHandler.put(method, handler);\n      } else {\n        methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));\n      }\n    }\n    InvocationHandler handler = factory.create(target, methodToHandler);\n    T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]{target.type()}, handler);\n\n    for(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {\n      defaultMethodHandler.bindTo(proxy);\n    }\n    return proxy;\n  }\n\n</code></pre>\n<p>在SynchronousMethodHandler类进行拦截处理，当被FeignClient的方法被拦截会根据参数生成RequestTemplate对象，该对象就是http请求的模板，代码如下：</p>\n<pre><code> @Override\n  public Object invoke(Object[] argv) throws Throwable {\n    RequestTemplate template = buildTemplateFromArgs.create(argv);\n    Retryer retryer = this.retryer.clone();\n    while (true) {\n      try {\n        return executeAndDecode(template);\n      } catch (RetryableException e) {\n        retryer.continueOrPropagate(e);\n        if (logLevel != Logger.Level.NONE) {\n          logger.logRetry(metadata.configKey(), logLevel);\n        }\n        continue;\n      }\n    }\n  }\n\n</code></pre>\n<p>其中有个executeAndDecode()方法，该方法是通RequestTemplate生成Request请求对象，然后根据用client获取response。</p>\n<pre><code>  Object executeAndDecode(RequestTemplate template) throws Throwable {\n    Request request = targetRequest(template);\n    ...//省略代码\n    response = client.execute(request, options);\n    ...//省略代码\n\n}\n\n</code></pre>\n<h2><a id="Client_344"></a>Client组件</h2>\n<p>其中Client组件是一个非常重要的组件，Feign最终发送request请求以及接收response响应，都是由Client组件完成的，其中Client的实现类，只要有Client.Default，该类由HttpURLConnnection实现网络请求，另外还支持HttpClient、Okhttp.</p>\n<p>首先来看以下在FeignRibbonClient的自动配置类，FeignRibbonClientAutoConfiguration ，主要在工程启动的时候注入一些bean,其代码如下：</p>\n<pre><code>@ConditionalOnClass({ ILoadBalancer.class, Feign.class })\n@Configuration\n@AutoConfigureBefore(FeignAutoConfiguration.class)\npublic class FeignRibbonClientAutoConfiguration {\n\n@Bean\n\t@ConditionalOnMissingBean\n\tpublic Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,\n\t\t\tSpringClientFactory clientFactory) {\n\t\treturn new LoadBalancerFeignClient(new Client.Default(null, null),\n\t\t\t\tcachingFactory, clientFactory);\n\t}\n\n}\n\n</code></pre>\n<p>在缺失配置feignClient的情况下，会自动注入new Client.Default(),跟踪Client.Default()源码，它使用的网络请求框架为HttpURLConnection，代码如下：</p>\n<pre><code>  @Override\n    public Response execute(Request request, Options options) throws IOException {\n      HttpURLConnection connection = convertAndSend(request, options);\n      return convertResponse(connection).toBuilder().request(request).build();\n    }\n\n</code></pre>\n<p>怎么在feign中使用HttpClient，查看FeignRibbonClientAutoConfiguration的源码</p>\n<pre><code>@ConditionalOnClass({ ILoadBalancer.class, Feign.class })\n@Configuration\n@AutoConfigureBefore(FeignAutoConfiguration.class)\npublic class FeignRibbonClientAutoConfiguration {\n...//省略代码\n\n@Configuration\n\t@ConditionalOnClass(ApacheHttpClient.class)\n\t@ConditionalOnProperty(value = "feign.httpclient.enabled", matchIfMissing = true)\n\tprotected static class HttpClientFeignLoadBalancedConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate HttpClient httpClient;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(Client.class)\n\t\tpublic Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,\n\t\t\t\tSpringClientFactory clientFactory) {\n\t\t\tApacheHttpClient delegate;\n\t\t\tif (this.httpClient != null) {\n\t\t\t\tdelegate = new ApacheHttpClient(this.httpClient);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelegate = new ApacheHttpClient();\n\t\t\t}\n\t\t\treturn new LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);\n\t\t}\n\t}\n\n...//省略代码\n}\n\n</code></pre>\n<p>从代码@ConditionalOnClass(ApacheHttpClient.class)注解可知道，只需要在pom文件加上HttpClient的classpath就行了，另外需要在配置文件上加上feign.httpclient.enabled为true，从\t@ConditionalOnProperty注解可知，这个可以不写，在默认的情况下就为true.</p>\n<p>在pom文件加上：</p>\n<pre><code>\n&lt;dependency&gt;\n    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;\n    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;\n    &lt;version&gt;RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<p>同理，如果想要feign使用Okhttp，则只需要在pom文件上加上feign-okhttp的依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;\n    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;\n    &lt;version&gt;RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id="feign_442"></a>feign的负载均衡是怎么样实现的呢？</h2>\n<p>通过上述的FeignRibbonClientAutoConfiguration类配置Client的类型(httpurlconnection，okhttp和httpclient)时候，可知最终向容器注入的是LoadBalancerFeignClient，即负载均衡客户端。现在来看下LoadBalancerFeignClient的代码：</p>\n<pre><code>\t@Override\n\tpublic Response execute(Request request, Request.Options options) throws IOException {\n\t\ttry {\n\t\t\tURI asUri = URI.create(request.url());\n\t\t\tString clientName = asUri.getHost();\n\t\t\tURI uriWithoutHost = cleanUrl(request.url(), clientName);\n\t\t\tFeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest(\n\t\t\t\t\tthis.delegate, request, uriWithoutHost);\n\n\t\t\tIClientConfig requestConfig = getClientConfig(options, clientName);\n\t\t\treturn lbClient(clientName).executeWithLoadBalancer(ribbonRequest,\n\t\t\t\t\trequestConfig).toResponse();\n\t\t}\n\t\tcatch (ClientException e) {\n\t\t\tIOException io = findIOException(e);\n\t\t\tif (io != null) {\n\t\t\t\tthrow io;\n\t\t\t}\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n</code></pre>\n<p>其中有个executeWithLoadBalancer()方法，即通过负载均衡的方式请求。</p>\n<pre><code>  public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException {\n        RequestSpecificRetryHandler handler = getRequestSpecificRetryHandler(request, requestConfig);\n        LoadBalancerCommand&lt;T&gt; command = LoadBalancerCommand.&lt;T&gt;builder()\n                .withLoadBalancerContext(this)\n                .withRetryHandler(handler)\n                .withLoadBalancerURI(request.getUri())\n                .build();\n\n        try {\n            return command.submit(\n                new ServerOperation&lt;T&gt;() {\n                    @Override\n                    public Observable&lt;T&gt; call(Server server) {\n                        URI finalUri = reconstructURIWithServer(server, request.getUri());\n                        S requestForServer = (S) request.replaceUri(finalUri);\n                        try {\n                            return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));\n                        } \n                        catch (Exception e) {\n                            return Observable.error(e);\n                        }\n                    }\n                })\n                .toBlocking()\n                .single();\n        } catch (Exception e) {\n            Throwable t = e.getCause();\n            if (t instanceof ClientException) {\n                throw (ClientException) t;\n            } else {\n                throw new ClientException(e);\n            }\n        }\n        \n    }\t\n\n</code></pre>\n<p>其中服务在submit()方法上，点击submit进入具体的方法,这个方法是LoadBalancerCommand的方法：</p>\n<pre><code>     Observable&lt;T&gt; o = \n                (server == null ? selectServer() : Observable.just(server))\n                .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() {\n                    @Override\n                    // Called for each server being selected\n                    public Observable&lt;T&gt; call(Server server) {\n                        context.setServer(server);\n    \n        }}\n\n</code></pre>\n<p>上述代码中有个selectServe()，该方法是选择服务的进行负载均衡的方法，代码如下：</p>\n<pre><code>    private Observable&lt;Server&gt; selectServer() {\n        return Observable.create(new OnSubscribe&lt;Server&gt;() {\n            @Override\n            public void call(Subscriber&lt;? super Server&gt; next) {\n                try {\n                    Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   \n                    next.onNext(server);\n                    next.onCompleted();\n                } catch (Exception e) {\n                    next.onError(e);\n                }\n            }\n        });\n    }\n\n</code></pre>\n<p>最终负载均衡交给loadBalancerContext来处理，即之前讲述的Ribbon，在这里不再重复。</p>\n<h2><a id="_550"></a>总结</h2>\n<p>总到来说，Feign的源码实现的过程如下：</p>\n<ul>\n<li>首先通过@EnableFeignCleints注解开启FeignCleint</li>\n<li>根据Feign的规则实现接口，并加@FeignCleint注解</li>\n<li>程序启动后，会进行包扫描，扫描所有的@ FeignCleint的注解的类，并将这些信息注入到ioc容器中。</li>\n<li>当接口的方法被调用，通过jdk的代理，来生成具体的RequesTemplate</li>\n<li>RequesTemplate在生成Request</li>\n<li>Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp</li>\n<li>最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。</li>\n</ul>\n<h3><a id="_562"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_570"></a>参考资料</h2>\n<p>https://github.com/OpenFeign/feign</p>\n<p>https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:33'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/73017664', 'title': '深入理解Eureka之源码解析', 'readNum': '233853', 'commentNum': '36', 'publishTime': '2017-06-11 11:22:10', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/73017664<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a><br>\n出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/08/11/eureka-resources.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/08/11/eureka-resources.html</a></strong></p>\n<h2><a id="Eureka_8"></a>Eureka的一些概念</h2>\n<ul>\n<li>\n<p>Register：服务注册<br>\n当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。</p>\n</li>\n<li>\n<p>Renew：服务续约<br>\nEureka客户会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔。</p>\n</li>\n<li>\n<p>Fetch Registries：获取注册列表信息<br>\nEureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。 Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka客户端和Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。</p>\n</li>\n<li>\n<p>Cancel：服务下线<br>\nEureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<br>\nDiscoveryManager.getInstance().shutdownComponent()；</p>\n</li>\n<li>\n<p>Eviction 服务剔除<br>\n在默认的情况下，当Eureka客户端连续90秒没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。</p>\n</li>\n</ul>\n<h2><a id="Eureka_26"></a>Eureka的高可用架构</h2>\n<p>如图为Eureka的高级架构图，该图片来自于Eureka开源代码的文档，地址为https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance 。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601011708827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>从图可以看出在这个体系中，有2个角色，即Eureka Server和Eureka Client。而Eureka Client又分为Applicaton Service和Application Client，即服务提供者何服务消费者。 每个区域有一个Eureka集群，并且每个区域至少有一个eureka服务器可以处理区域故障，以防服务器瘫痪。</p>\n<p>Eureka Client向Eureka Serve注册，并将自己的一些客户端信息发送Eureka Serve。然后，Eureka Client通过向Eureka Serve发送心跳（每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次）。根据这些注册表信息，Application Client可以远程调用Applicaton Service来消费服务。</p>\n<h2><a id="Register_37"></a>Register服务注册</h2>\n<p>服务注册，即Eureka Client向Eureka Server提交自己的服务信息，包括IP地址、端口、service ID等信息。如果Eureka Client没有写service ID，则默认为 ${spring.application.name}。</p>\n<p>服务注册其实很简单，在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。现在来简单的阅读下源码。在Maven的依赖包下，找到eureka-client-1.6.2.jar包。在com.netflix.discovery包下有个DiscoveryClient类，该类包含了Eureka Client向Eureka Server的相关方法。其中DiscoveryClient实现了EurekaClient接口，并且它是一个单例模式，而EurekaClient继承了LookupService接口。它们之间的关系如图所示。</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjExMTEwOTE2NDAy?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>在DiscoveryClient类有一个服务注册的方法register()，该方法是通过Http请求向Eureka Client注册。其代码如下：</p>\n<pre><code>boolean register() throws Throwable {\n        logger.info(PREFIX + appPathIdentifier + ": registering service...");\n        EurekaHttpResponse&lt;Void&gt; httpResponse;\n        try {\n            httpResponse = eurekaTransport.registrationClient.register(instanceInfo);\n        } catch (Exception e) {\n            logger.warn("{} - registration failed {}", PREFIX + appPathIdentifier, e.getMessage(), e);\n            throw e;\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info("{} - registration status: {}", PREFIX + appPathIdentifier, httpResponse.getStatusCode());\n        }\n        return httpResponse.getStatusCode() == 204;\n    }\n\n</code></pre>\n<p>在DiscoveryClient类继续追踪register()方法，它被InstanceInfoReplicator 类的run()方法调用，其中InstanceInfoReplicator实现了Runnable接口，run()方法代码如下：</p>\n<pre><code> public void run() {\n        try {\n            discoveryClient.refreshInstanceInfo();\n\n            Long dirtyTimestamp = instanceInfo.isDirtyWithTime();\n            if (dirtyTimestamp != null) {\n                discoveryClient.register();\n                instanceInfo.unsetIsDirty(dirtyTimestamp);\n            }\n        } catch (Throwable t) {\n            logger.warn("There was a problem with the instance info replicator", t);\n        } finally {\n            Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);\n            scheduledPeriodicRef.set(next);\n        }\n    }\n\n</code></pre>\n<p>而InstanceInfoReplicator类是在DiscoveryClient初始化过程中使用的，其中有一个initScheduledTasks()方法。该方法主要开启了获取服务注册列表的信息，如果需要向Eureka Server注册，则开启注册，同时开启了定时向Eureka Server服务续约的定时任务，具体代码如下：</p>\n<pre><code>private void initScheduledTasks() {\n       ...//省略了任务调度获取注册列表的代码\n        if (clientConfig.shouldRegisterWithEureka()) {\n         ... \n            // Heartbeat timer\n            scheduler.schedule(\n                    new TimedSupervisorTask(\n                            "heartbeat",\n                            scheduler,\n                            heartbeatExecutor,\n                            renewalIntervalInSecs,\n                            TimeUnit.SECONDS,\n                            expBackOffBound,\n                            new HeartbeatThread()\n                    ),\n                    renewalIntervalInSecs, TimeUnit.SECONDS);\n\n            // InstanceInfo replicator\n            instanceInfoReplicator = new InstanceInfoReplicator(\n                    this,\n                    instanceInfo,\n                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),\n                    2); // burstSize\n\n            statusChangeListener = new ApplicationInfoManager.StatusChangeListener() {\n                @Override\n                public String getId() {\n                    return "statusChangeListener";\n                }\n\n                @Override\n                public void notify(StatusChangeEvent statusChangeEvent) {\n                 \n                    instanceInfoReplicator.onDemandUpdate();\n                }\n            };\n          ...\n    }\n\n</code></pre>\n<p>然后在来看Eureka server端的代码，在Maven的eureka-core:1.6.2的jar包下。打开com.netflix.eureka包，很轻松的就发现了又一个EurekaBootStrap的类，BootStrapContext具有最先初始化的权限，所以先看这个类。</p>\n<pre><code>protected void initEurekaServerContext() throws Exception {\n \n ...//省略代码\n   PeerAwareInstanceRegistry registry;\n        if (isAws(applicationInfoManager.getInfo())) {\n           ...//省略代码，如果是AWS的代码\n        } else {\n            registry = new PeerAwareInstanceRegistryImpl(\n                    eurekaServerConfig,\n                    eurekaClient.getEurekaClientConfig(),\n                    serverCodecs,\n                    eurekaClient\n            );\n        }\n\n        PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(\n                registry,\n                eurekaServerConfig,\n                eurekaClient.getEurekaClientConfig(),\n                serverCodecs,\n                applicationInfoManager\n        );\n }\n</code></pre>\n<p>其中PeerAwareInstanceRegistryImpl和PeerEurekaNodes两个类看其命名，应该和服务注册以及Eureka Server高可用有关。先追踪PeerAwareInstanceRegistryImpl类，在该类有个register()方法，该方法提供了注册，并且将注册后信息同步到其他的Eureka Server服务。代码如下：</p>\n<pre><code>public void register(final InstanceInfo info, final boolean isReplication) {\n        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;\n        if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) {\n            leaseDuration = info.getLeaseInfo().getDurationInSecs();\n        }\n        super.register(info, leaseDuration, isReplication);\n        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);\n    }\n</code></pre>\n<p>其中 super.register(info, leaseDuration, isReplication)方法，点击进去到子类AbstractInstanceRegistry可以发现更多细节，其中注册列表的信息被保存在一个Map中。replicateToPeers()方法，即同步到其他Eureka Server的其他Peers节点，追踪代码，发现它会遍历循环向所有的Peers节点注册，最终执行类PeerEurekaNodes的register()方法，该方法通过执行一个任务向其他节点同步该注册信息，代码如下：</p>\n<pre><code>  public void register(final InstanceInfo info) throws Exception {\n        long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);\n        batchingDispatcher.process(\n                taskId("register", info),\n                new InstanceReplicationTask(targetHost, Action.Register, info, null, true) {\n                    public EurekaHttpResponse&lt;Void&gt; execute() {\n                        return replicationClient.register(info);\n                    }\n                },\n                expiryTime\n        );\n    }\n\n</code></pre>\n<p>经过一系列的源码追踪，可以发现PeerAwareInstanceRegistryImpl的register()方法实现了服务的注册，并且向其他Eureka Server的Peer节点同步了该注册信息，那么register()方法被谁调用了呢？之前在Eureka Client的分析可以知道，Eureka Client是通过 http来向Eureka Server注册的，那么Eureka Server肯定会提供一个注册的接口给Eureka Client调用，那么PeerAwareInstanceRegistryImpl的register()方法肯定最终会被暴露的Http接口所调用。在Idea开发工具，按住alt+鼠标左键，可以很快定位到ApplicationResource类的addInstance ()方法，即服务注册的接口，其代码如下：</p>\n<pre><code>\n@POST\n    @Consumes({"application/json", "application/xml"})\n    public Response addInstance(InstanceInfo info,\n                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {\n       \n    ...//省略代码                 \n               registry.register(info, "true".equals(isReplication));\n        return Response.status(204).build();  // 204 to be backwards compatible\n    }\n\n</code></pre>\n<h2><a id="Renew_212"></a>Renew服务续约</h2>\n<p>服务续约和服务注册非常类似，通过之前的分析可以知道，服务注册在Eureka Client程序启动之后开启，并同时开启服务续约的定时任务。在eureka-client-1.6.2.jar的DiscoveryClient的类下有renew()方法，其代码如下：</p>\n<pre><code>  /**\n     * Renew with the eureka service by making the appropriate REST call\n     */\n    boolean renew() {\n        EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;\n        try {\n            httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);\n            logger.debug("{} - Heartbeat status: {}", PREFIX + appPathIdentifier, httpResponse.getStatusCode());\n            if (httpResponse.getStatusCode() == 404) {\n                REREGISTER_COUNTER.increment();\n                logger.info("{} - Re-registering apps/{}", PREFIX + appPathIdentifier, instanceInfo.getAppName());\n                return register();\n            }\n            return httpResponse.getStatusCode() == 200;\n        } catch (Throwable e) {\n            logger.error("{} - was unable to send heartbeat!", PREFIX + appPathIdentifier, e);\n            return false;\n        }\n    }\n\n</code></pre>\n<p>另外服务端的续约接口在eureka-core:1.6.2.jar的 com.netflix.eureka包下的InstanceResource类下，接口方法为renewLease()，它是REST接口。为了减少类篇幅，省略了大部分代码的展示。其中有个registry.renew()方法，即服务续约，代码如下:</p>\n<pre><code>@PUT\npublic Response renewLease(...参数省略）{\n     ...  代码省略\n    boolean isSuccess=registry.renew(app.getName(),id, isFromReplicaNode);\n       ...  代码省略\n }\n\n</code></pre>\n<p>读者可以跟踪registry.renew的代码一直深入研究。在这里就不再多讲述。另外服务续约有2个参数是可以配置，即Eureka Client发送续约心跳的时间参数和Eureka Server在多长时间内没有收到心跳将实例剔除的时间参数，在默认的情况下这两个参数分别为30秒和90秒，官方给的建议是不要修改，如果有特殊要求还是可以调整的，只需要分别在Eureka Client和Eureka Server修改以下参数：</p>\n<pre><code>eureka.instance.leaseRenewalIntervalInSeconds\neureka.instance.leaseExpirationDurationInSeconds\n\n</code></pre>\n<p>最后，服务注册列表的获取、服务下线和服务剔除就不在这里进行源码跟踪解读，因为和服务注册和续约类似，有兴趣的朋友可以自己看下源码，深入理解。总的来说，通过读源码，可以发现，整体架构与前面小节的eureka 的高可用架构图完全一致。</p>\n<h2><a id="Eureka_Client_263"></a>Eureka Client注册一个实例为什么这么慢</h2>\n<ul>\n<li>Eureka Client一启动（不是启动完成），不是立即向Eureka Server注册，它有一个延迟向服务端注册的时间，通过跟踪源码，可以发现默认的延迟时间为40秒，源码在eureka-client-1.6.2.jar的DefaultEurekaClientConfig类下，代码如下：</li>\n</ul>\n<pre><code>public int getInitialInstanceInfoReplicationIntervalSeconds() {\n    return configInstance.getIntProperty(\n        namespace + INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40).get();\n }\n</code></pre>\n<ul>\n<li>\n<p>Eureka Server的响应缓存<br>\nEureka Server维护每30秒更新的响应缓存,可通过更改配置eureka.server.responseCacheUpdateIntervalMs来修改。 所以即使实例刚刚注册，它也不会出现在调用/ eureka / apps REST端点的结果中。</p>\n</li>\n<li>\n<p>Eureka Server刷新缓存<br>\nEureka客户端保留注册表信息的缓存。 该缓存每30秒更新一次（如前所述）。 因 此，客户端决定刷新其本地缓存并发现其他新注册的实例可能需要30秒。</p>\n</li>\n<li>\n<p>LoadBalancer Refresh<br>\nRibbon的负载平衡器从本地的Eureka Client获取服务注册列表信息。Ribbon本身还维护本地缓存，以避免为每个请求调用本地客户端。 此缓存每30秒刷新一次（可由ribbon.ServerListRefreshInterval配置）。 所以，可能需要30多秒才能使用新注册的实例。</p>\n</li>\n</ul>\n<p>综上几个因素，一个新注册的实例，特别是启动较快的实例（默认延迟40秒注册），不能马上被Eureka Server发现。另外，刚注册的Eureka Client也不能立即被其他服务调用，因为调用方因为各种缓存没有及时的获取到新的注册列表。</p>\n<h2><a id="Eureka__286"></a>Eureka 的自我保护模式</h2>\n<p>当一个新的Eureka Server出现时，它尝试从相邻节点获取所有实例注册表信息。如果从Peer节点获取信息时出现问题，Eureka Serve会尝试其他的Peer节点。如果服务器能够成功获取所有实例，则根据该信息设置应该接收的更新阈值。如果有任何时间，Eureka Serve接收到的续约低于为该值配置的百分比（默认为15分钟内低于85％），则服务器开启自我保护模式，即不再剔除注册列表的信息。</p>\n<p>这样做的好处就是，如果是Eureka Server自身的网络问题，导致Eureka Client的续约不上，Eureka Client的注册列表信息不再被删除，也就是Eureka Client还可以被其他服务消费。</p>\n<h3><a id="_292"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_300"></a>参考资料</h2>\n<p>http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter</p>\n<p>https://github.com/Netflix/eureka/wiki</p>\n<p>https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</p>\n<p>http://xujin.org/sc/sc-eureka-register/</p>\n<p>http://blog.abhijitsarkar.org/technical/netflix-eureka/</p>\n<p>http://nobodyiam.com/2016/06/25/dive-into-eureka/</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/72804324', 'title': 'JSON Web Tokens介绍', 'readNum': '50074', 'commentNum': '2', 'publishTime': '2017-05-29 22:18:07', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://blog.csdn.net/forezp/article/details/72804324<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/architecture/2017/08/11/jwt.html" rel="nofollow">https://www.fangzhipeng.com/architecture/2017/08/11/jwt.html</a></strong></p>\n<h2><a id="JWT_7"></a>什么是JWT</h2>\n<p>这篇文章选择性翻译于https://jwt.io/introduction/</p>\n<h3><a id="JWT_11"></a>JWT简介</h3>\n<p>JSON Web Token（JWT）是一种开放标准（RFC 7519），它定义了一种紧凑且字自包含的标准，用于将各方之间的信息地传输为JSON对象。 该信息是通过数字签名进行验证。使用HMAC算法或使用RSA的公钥/私钥对JWT进行签名，所以它的安全性非常高。</p>\n<blockquote>\n<p>进一步解释它的特点或者概念：<br>\n•\t紧凑型（compact）：由于是加密后的字符串，JWT数据体积非常的小，可通过 POST参数或HTTP请求头发送。 另外，数据体积小意味着传输速度很快。<br>\n•\t自包含(self-contained)：JWT包含了用户的所有信心，所以避免了每次查询数据库，降低了服务器的负载。</p>\n</blockquote>\n<h3><a id="JWT_19"></a>JWT应用场景</h3>\n<p>一般什么时候应该使用JWT呢？，一般使用在以下场景：</p>\n<blockquote>\n<p>•\t验证：这是使用JWT的最常见的场景。 一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。 单点登录是一个广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。<br>\n•\t信息交换：JWT是在各方之间安全传输信息的好方法，因为它们可以被签名，例如使用公钥/私钥对. 另外，当使用标题和有效载荷计算签名时，还可以验证内容是否未被篡改。</p>\n</blockquote>\n<h3><a id="JWT_26"></a>JWT结构</h3>\n<p>JWT由三个部分组成，分别为“.”分隔，三部分组成如下：</p>\n<ul>\n<li>Header（头）</li>\n<li>Payload（有效载荷）</li>\n<li>Signature（签名）<br>\n因此，JWT通常格式如下：</li>\n</ul>\n<blockquote>\n<p>xxxxx.yyyyy.zzzzz</p>\n</blockquote>\n<p>现在，依次对这三个组成部分，分开讲解：</p>\n<p>####1.\tHeader<br>\n标题通常由两部分组成：令牌的类型，即JWT，以及使用的哈希算法，如HMAC SHA256或RSA。<br>\n比如：</p>\n<pre><code>{\n  “alg”：“HS256”，\n  “typ”：“JWT”\n}\n</code></pre>\n<p>将header进行Base64 编码作为JWT的第一部分。</p>\n<h4><a id="2\tPayload_52"></a>2.\tPayload</h4>\n<p>这是JWT的第二部分，包含了用户的一些信息和Cliam(声明、权利)，有三种类型的Cliam：保留，公开和私人声明。<br>\n一个典型的payload应该如下：</p>\n<pre><code>{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "admin": true\n}\n</code></pre>\n<p>将payload进行Base64 编码作为JWT的第二部分。</p>\n<h4><a id="3\tSignature_65"></a>3.\tSignature</h4>\n<pre><code>要创建签名部分，需要使用到用Base64编码后header和payloader，以及秘钥，将它们签名，一个典型的格式如下： \n</code></pre>\n<pre><code>HMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),\n  secret)\n</code></pre>\n<h3><a id="JWT_75"></a>JWT是如何使用的</h3>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTI5MjIxNTE3NjEw?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>来说下最常见的应用场景，即认证方面，如图所示。客户端通过用户名密码向服务器请求获取某用户的信息，包括用户一些额外信息，比如权限，这些信息经过加密以JWT形式返回。获取到该JWT的客户端，在以后的每次请求中，都需要携带该JWT，这样做的好处就是每次不需要查询数据库获取该用户的信息，在微服务这样的分布式系统中，可以实现单点登录。</p>\n<h3><a id="_82"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71189836', 'title': 'SpringBoot非官方教程 | 第二十六篇： sprinboot整合elk，搭建实时日志平台', 'readNum': '70931', 'commentNum': '10', 'publishTime': '2017-05-04 22:48:57', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="https://blog.csdn.net/forezp/article/details/71189836">https://blog.csdn.net/forezp/article/details/71189836</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>这篇文章主要介绍springboot整合elk.</p>\n<h2><a id="elk__8"></a>elk 简介</h2>\n<ul>\n<li>\n<p>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>\n</li>\n<li>\n<p>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</p>\n</li>\n<li>\n<p>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</p>\n</li>\n</ul>\n<h2><a id="elk_16"></a>elk下载安装</h2>\n<p>elk下载地址：<a href="https://www.elastic.co/downloads/" rel="nofollow">https://www.elastic.co/downloads/</a></p>\n<p>建议在 linux上运行，elk在windows上支持得不好，另外需要jdk1.8 的支持，需要提前安装好jdk.</p>\n<p>下载完之后： 安装，以logstash为栗子：</p>\n<blockquote>\n<p>cd /usr/local/</p>\n<p>mkdir logstash</p>\n<p>tar -zxvf logstash-5.3.2.tar.gz</p>\n<p>mv logstash-5.3.2 /usr/local/logstash</p>\n</blockquote>\n<h2><a id="_Elasticsearch_36"></a>配置、启动 Elasticsearch</h2>\n<p>打开Elasticsearch的配置文件：</p>\n<pre><code>vim config/elasticsearch.yml\n</code></pre>\n<p>修改配置:</p>\n<pre><code>network.host=localhost\nnetwork.port=9200\n\n</code></pre>\n<p>它默认就是这个配置，没有特殊要求，在本地不需要修改。</p>\n<p>启动Elasticsearch</p>\n<pre><code>./bin/elasticsearch\n\n</code></pre>\n<p>启动成功，访问localhost:9200,网页显示：</p>\n<pre><code>{\n  "name" : "56IrTCM",\n  "cluster_name" : "elasticsearch",\n  "cluster_uuid" : "e4ja7vS2TIKI1BsggEAa6Q",\n  "version" : {\n    "number" : "5.2.2",\n    "build_hash" : "f9d9b74",\n    "build_date" : "2017-02-24T17:26:45.835Z",\n    "build_snapshot" : false,\n    "lucene_version" : "6.4.1"\n  },\n  "tagline" : "You Know, for Search"\n}\n</code></pre>\n<h2><a id="_logstash_77"></a>配置、启动 logstash</h2>\n<p>在 logstash的主目录下：</p>\n<pre><code>vim config/log4j_to_es.conf \n\n</code></pre>\n<p>修改 log4j_to_es.conf 如下：</p>\n<pre><code>input {\n  log4j {\n    mode =&gt; "server"\n    host =&gt; "localhost"\n    port =&gt; 4560\n  }\n}\nfilter {\n  #Only matched data are send to output.\n}\noutput {\n    elasticsearch {\n    action =&gt; "index"          #The operation on ES\n    hosts  =&gt; "localhost:9200"   #ElasticSearch host, can be array.\n    index  =&gt; "applog"         #The index to write data to.\n  }\n}\n\n</code></pre>\n<p>修改完配置后启动：</p>\n<pre><code>./bin/logstash -f config/log4j_to_es.conf \n\n</code></pre>\n<p>终端显示如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190620230927817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>访问localhost:9600</p>\n<pre><code>{"host":"Pc-20130412.local","version":"5.3.2","http_address":"127.0.0.1:9600","id":"e6bb985c-c688-49a4-\na55b-4d362bb4136f","name":"Pc-20130412.local","build_date":\n"2017-04-24T16:32:22Z","build_sha":"242159a5eea55fe213fe5c8\n52d36455e24252c82","build_snapshot":false}\n</code></pre>\n<p>证明logstash启动成功。</p>\n<h2><a id="kibana_133"></a>配置、启动kibana</h2>\n<p>到kibana的安装目录：</p>\n<pre><code>./bin/kibana \n</code></pre>\n<p>默认配置即可。</p>\n<p>访问localhost:5601，网页显示：<br>\n<img src="https://img-blog.csdnimg.cn/20190620231006352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>证明启动成功。</p>\n<h2><a id="springboot_149"></a>创建springboot工程</h2>\n<p>起步依赖如下：</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n\t\t\t&lt;exclusions&gt;\n\t\t\t\t&lt;exclusion&gt;\n\t\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t\t&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n\t\t\t\t&lt;/exclusion&gt;\n\t\t\t&lt;/exclusions&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.3.8.RELEASE&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<p>log4j的配置，／src/resources/log4j.properties如下：</p>\n<pre><code>\nlog4j.rootLogger=INFO,console\n\n# for package com.demo.elk, log would be sent to socket appender.\nlog4j.logger.com.forezp=DEBUG, socket\n\n# appender socket\nlog4j.appender.socket=org.apache.log4j.net.SocketAppender\nlog4j.appender.socket.Port=4560\nlog4j.appender.socket.RemoteHost=localhost\nlog4j.appender.socket.layout=org.apache.log4j.PatternLayout\nlog4j.appender.socket.layout.ConversionPattern=%d [%-5p] [%l] %m%n\nlog4j.appender.socket.ReconnectionDelay=10000\n\n# appender console\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.target=System.out\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d [%-5p] [%l] %m%n\n\n</code></pre>\n<p>打印log测试：</p>\n<pre><code>@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootElkApplicationTests {\n\n\t@Test\n\tpublic void contextLoads() {\n\t}\n\n\tprivate Logger logger = Logger.getLogger(getClass());\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\tfor(int i=0;i&lt;100;i++) {\n\t\t\tlogger.info("输出info  ");\n\t\t\tlogger.debug("输出debug+skkkw嗡嗡嗡kw");\n\t\t\tlogger.error("输出error  嗡嗡嗡我");\n\t\t}\n\t}\n\n\n}\n</code></pre>\n<h2><a id="kibana__236"></a>在kibana 实时监控日志</h2>\n<p>打开localhost:5601:</p>\n<p>Management=&gt;index pattrns=&gt;add new:<br>\n<img src="https://img-blog.csdnimg.cn/2019062023104261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>点击discovery:</p>\n<p><img src="https://img-blog.csdnimg.cn/20190620231125439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_250"></a>参考资料</h2>\n<p><a href="https://my.oschina.net/itblog/blog/547250" rel="nofollow">https://my.oschina.net/itblog/blog/547250</a></p>\n<h2><a id="_254"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_258"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71024219', 'title': 'SpringBoot非官方教程 | 第二十四篇： springboot整合docker', 'readNum': '60008', 'commentNum': '10', 'publishTime': '2017-04-30 17:09:38', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/24/sb24-docker.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/25/sb25-2hour.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/25/sb25-2hour.html</a></strong></p>\n<p>这篇文篇介绍，怎么为 springboot程序构建一个docker镜像。docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>\n<h2><a id="_9"></a>准备工作</h2>\n<p>环境：</p>\n<ul>\n<li>linux环境或mac,不要用windows</li>\n<li>jdk 8</li>\n<li>maven 3.0</li>\n<li>docker</li>\n</ul>\n<p>对docker一无所知的看<a href="http://www.runoob.com/docker/docker-tutorial.html" rel="nofollow">docker教程</a>。</p>\n<h2><a id="springboot_21"></a>创建一个springboot工程</h2>\n<p>引入web的起步依赖，创建一个 Controler:</p>\n<pre><code>@SpringBootApplication\n@RestController\npublic class SpringbootWithDockerApplication {\n\n\t@RequestMapping("/")\n\tpublic String home() {\n\t\treturn "Hello Docker World";\n\t}\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootWithDockerApplication.class, args);\n\t}\n}\n\n</code></pre>\n<h2><a id="springboot_40"></a>将springboot工程容器化</h2>\n<p>Docker有一个简单的<a href="https://docs.docker.com/engine/reference/builder/" rel="nofollow">dockerfile</a>文件作为指定镜像的图层。让我们先创建一个 dockerFile文件：</p>\n<p>src/main/docker/Dockerfile:</p>\n<pre><code>FROM frolvlad/alpine-oraclejdk8:slim\nVOLUME /tmp\nADD springboot-with-docker-0.0.1-SNAPSHOT.jar app.jar\nRUN sh -c \'touch /app.jar\'\nENV JAVA_OPTS=""\nENTRYPOINT [ "sh", "-c", "java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar" ]\n\n</code></pre>\n<p>我们通过maven 构建docker镜像。</p>\n<p>在maven的pom目录，加上docker镜像构建的插件</p>\n<pre><code>&lt;properties&gt;\n   &lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt;\n&lt;/properties&gt;\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;0.4.11&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;\n                &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;\n                &lt;resources&gt;\n                    &lt;resource&gt;\n                        &lt;targetPath&gt;/&lt;/targetPath&gt;\n                        &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                        &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n                    &lt;/resource&gt;\n                &lt;/resources&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n\n</code></pre>\n<p>注意：${docker.image.prefix} 为你在 docker官方仓库的用户名，如果你不需要上传镜像，随便填。</p>\n<p>通过maven 命令：</p>\n<p>第一步：mvn clean</p>\n<p>第二步： mvn package docker:bulid ,如下：</p>\n<blockquote>\n<p>Step 2/6 : VOLUME /tmp<br>\n—&gt; Running in a98be3878053<br>\n—&gt; 8286e98b54c5<br>\nRemoving intermediate container a98be3878053<br>\nStep 3/6 : ADD springboot-with-docker-0.0.1-SNAPSHOT.jar app.jar<br>\n—&gt; c6ce13e50bbd<br>\nRemoving intermediate container a303a3058869<br>\nStep 4/6 : RUN sh -c ‘touch /app.jar’<br>\n—&gt; Running in cf231afe700e<br>\n—&gt; 9a0ec8936c00<br>\nRemoving intermediate container cf231afe700e<br>\nStep 5/6 : ENV JAVA_OPTS “”<br>\n—&gt; Running in e192597fc881<br>\n—&gt; 2cb0d73bbdb0<br>\nRemoving intermediate container e192597fc881<br>\nStep 6/6 : ENTRYPOINT sh -c java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar<br>\n—&gt; Running in ab85f53fcdd8<br>\n—&gt; 60fdb5c61692<br>\nRemoving intermediate container ab85f53fcdd8<br>\nSuccessfully built 60fdb5c61692<br>\n[INFO] Built forezp/springboot-with-docker<br>\n[INFO] ------------------------------------------------------------------------<br>\n[INFO] BUILD SUCCESS<br>\n[INFO] ------------------------------------------------------------------------<br>\n[INFO] Total time: 01:45 min<br>\n[INFO] Finished at: 2017-04-19T05:37:44-07:00<br>\n[INFO] Final Memory: 19M/48M<br>\n[INFO] ------------------------------------------------------------------------</p>\n</blockquote>\n<p>镜像构建成功。查看镜像：</p>\n<blockquote>\n<p>docker images</p>\n</blockquote>\n<p>显示：</p>\n<blockquote>\n<p>forezp/springboot-with-docker   latest              60fdb5c61692        About a minute ago   195 MB</p>\n</blockquote>\n<p>启动镜像：</p>\n<blockquote>\n<p>$ docker run -p 8080:8080 -t forezp/springboot-with-docker</p>\n</blockquote>\n<p>打开浏览器访问  localhost:8080;浏览器显示：Hello Docker World。<br>\n说明docker 的springboot工程已部署。</p>\n<p>停止镜像：</p>\n<blockquote>\n<p>docker stop 60fdb5c61692</p>\n</blockquote>\n<p>删除镜像：</p>\n<blockquote>\n<p>docker rm 60fdb5c61692</p>\n</blockquote>\n<h2><a id="_145"></a>参考资料</h2>\n<p><a href="https://docs.docker.com/engine/reference/builder/" rel="nofollow">https://docs.docker.com/engine/reference/builder/)</a>)</p>\n<p><a href="http://www.runoob.com/docker/docker-tutorial.html" rel="nofollow">http://www.runoob.com/docker/docker-tutorial.html</a></p>\n<h2><a id="_151"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_155"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71024169', 'title': 'SpringBoot非官方教程 | 第二十三篇： 异步方法', 'readNum': '56435', 'commentNum': '7', 'publishTime': '2017-04-30 17:06:15', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于https://www.fangzhipeng.com/springboot/2017/05/23/springboot-ansy.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/23/springboot-ansy.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/23/springboot-ansy.html</a></strong></p>\n<p>这篇文章主要介绍在springboot 使用异步方法，去请求github api.</p>\n<h2><a id="_10"></a>创建工程</h2>\n<p>在pom文件引入相关依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>创建一个接收数据的实体：</p>\n<pre><code>@JsonIgnoreProperties(ignoreUnknown=true)\npublic class User {\n\n    private String name;\n    private String blog;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getBlog() {\n        return blog;\n    }\n\n    public void setBlog(String blog) {\n        this.blog = blog;\n    }\n\n    @Override\n    public String toString() {\n        return "User [name=" + name + ", blog=" + blog + "]";\n    }\n\n}\n\n</code></pre>\n<p>创建一个请求的\u3000githib的service:</p>\n<pre><code>@Service\npublic class GitHubLookupService {\n\n    private static final Logger logger = LoggerFactory.getLogger(GitHubLookupService.class);\n\n    private final RestTemplate restTemplate;\n\n    public GitHubLookupService(RestTemplateBuilder restTemplateBuilder) {\n        this.restTemplate = restTemplateBuilder.build();\n    }\n\n    @Async\n    public Future&lt;User&gt; findUser(String user) throws InterruptedException {\n        logger.info("Looking up " + user);\n        String url = String.format("https://api.github.com/users/%s", user);\n        User results = restTemplate.getForObject(url, User.class);\n        // Artificial delay of 1s for demonstration purposes\n        Thread.sleep(1000L);\n        return new AsyncResult&lt;&gt;(results);\n    }\n\n}\n\n</code></pre>\n<p>通过，RestTemplate去请求，另外加上类@Async 表明是一个异步任务。</p>\n<p>开启异步任务：</p>\n<pre><code>\n@SpringBootApplication\n@EnableAsync\npublic class Application extends AsyncConfigurerSupport {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(2);\n        executor.setMaxPoolSize(2);\n        executor.setQueueCapacity(500);\n        executor.setThreadNamePrefix("GithubLookup-");\n        executor.initialize();\n        return executor;\n    }\n\n}\n\n</code></pre>\n<p>通过@EnableAsync开启异步任务；并且配置AsyncConfigurerSupport，比如最大的线程池为2.</p>\n<h2><a id="_127"></a>测试</h2>\n<p>测试代码如下：</p>\n<pre><code>@Component\npublic class AppRunner implements CommandLineRunner {\n\n    private static final Logger logger = LoggerFactory.getLogger(AppRunner.class);\n\n    private final GitHubLookupService gitHubLookupService;\n\n    public AppRunner(GitHubLookupService gitHubLookupService) {\n        this.gitHubLookupService = gitHubLookupService;\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        // Start the clock\n        long start = System.currentTimeMillis();\n\n        // Kick of multiple, asynchronous lookups\n        Future&lt;User&gt; page1 = gitHubLookupService.findUser("PivotalSoftware");\n        Future&lt;User&gt; page2 = gitHubLookupService.findUser("CloudFoundry");\n        Future&lt;User&gt; page3 = gitHubLookupService.findUser("Spring-Projects");\n\n        // Wait until they are all done\n        while (!(page1.isDone() &amp;&amp; page2.isDone() &amp;&amp; page3.isDone())) {\n            Thread.sleep(10); //10-millisecond pause between each check\n        }\n\n        // Print results, including elapsed time\n        logger.info("Elapsed time: " + (System.currentTimeMillis() - start));\n        logger.info("--&gt; " + page1.get());\n        logger.info("--&gt; " + page2.get());\n        logger.info("--&gt; " + page3.get());\n    }\n\n}\n\n</code></pre>\n<p>启动程序，控制台会打印：</p>\n<blockquote>\n<p>2017-04-30 13:11:10.351  INFO 1511 — [ GithubLookup-1] com.forezp.service.GitHubLookupService   : Looking up PivotalSoftware<br>\n2017-04-30 13:11:10.351  INFO 1511 — [ GithubLookup-2] com.forezp.service.GitHubLookupService   : Looking up CloudFoundry<br>\n2017-04-30 13:11:13.144  INFO 1511 — [ GithubLookup-2] com.forezp.service.GitHubLookupService   : Looking up Spring-Projects</p>\n</blockquote>\n<p>耗时：3908</p>\n<p>分析：可以卡的前面2个方法分别在GithubLookup-1 和GithubLookup-2执行，第三个在GithubLookup-2执行，注意因为在配置线程池的时候最大线程为2.如果你把线程池的个数为3的时候，耗时减少。</p>\n<p>如果去掉@Async，你会发现，执行这三个方法都在main线程中执行。耗时总结，如下：</p>\n<blockquote>\n<p>2017-04-30 13:13:00.934  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up PivotalSoftware<br>\n2017-04-30 13:13:03.571  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up CloudFoundry<br>\n2017-04-30 13:13:04.865  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up Spring-Projects</p>\n</blockquote>\n<p>耗时：5261</p>\n<p>通过这一个小的栗子，你应该对异步任务有了一定的了解。</p>\n<h2><a id="_191"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/async-method/" rel="nofollow">https://spring.io/guides/gs/async-method/</a></p>\n<h2><a id="_195"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_199"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71024153', 'title': 'SpringBoot非官方教程 | 第二十二篇： 创建含有多module的springboot工程', 'readNum': '59426', 'commentNum': '11', 'publishTime': '2017-04-30 17:02:39', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/21/sb21-modules.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/22/sprinboot22-elk.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/22/sprinboot22-elk.html</a></strong><br>\n这篇文章主要介绍如何在springboot中如何创建含有多个module的工程，栗子中含有两个 module，一个作为libarary. 工程，另外一个是主工程，调用libary .其中libary jar有一个服务，main工程调用这个服务。</p>\n<h2><a id="_8"></a>创建根工程</h2>\n<p>创建一个maven 工程,其pom文件为：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;springboot-multi-module&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;pom&lt;/packaging&gt;\n\t&lt;name&gt;springboot-multi-module&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\n\n&lt;/project&gt;\n\n</code></pre>\n<p>需要注意的是packaging标签为pom 属性。</p>\n<h2><a id="libary_34"></a>创建libary工程</h2>\n<p>libary工程为maven工程，其pom文件的packaging标签为jar 属性。创建一个service组件,它读取配置文件的 service.message属性。</p>\n<pre><code>@ConfigurationProperties("service")\npublic class ServiceProperties {\n\n    /**\n     * A message for the service.\n     */\n    private String message;\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n}\n\n</code></pre>\n<p>提供一个对外暴露的方法：</p>\n<pre><code>@Configuration\n@EnableConfigurationProperties(ServiceProperties.class)\npublic class ServiceConfiguration {\n    @Bean\n    public Service service(ServiceProperties properties) {\n        return new Service(properties.getMessage());\n    }\n}\n\n</code></pre>\n<h2><a id="springbot_73"></a>创建一个springbot工程</h2>\n<p>引入相应的依赖,创建一个web服务：</p>\n<pre><code>@SpringBootApplication\n@Import(ServiceConfiguration.class)\n@RestController\npublic class DemoApplication {\n\n    private final Service service;\n\n    @Autowired\n    public DemoApplication(Service service) {\n        this.service = service;\n    }\n\n    @GetMapping("/")\n    public String home() {\n        return service.message();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}\n\n</code></pre>\n<p>在配置文件application.properties中加入：</p>\n<pre><code>service.message=Hello World\n\n</code></pre>\n<p>打开浏览器访问：http://localhost:8080/;浏览器显示：</p>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<p>说明确实引用了libary中的方法。</p>\n<h2><a id="_115"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/multi-module/" rel="nofollow">https://spring.io/guides/gs/multi-module/</a></p>\n<h2><a id="_120"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_124"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-2_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71024024', 'title': 'SpringBoot非官方教程 | 第二十一篇： springboot集成JMS', 'readNum': '55154', 'commentNum': '8', 'publishTime': '2017-04-30 16:58:03', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springboot/2017/05/21/sb21-modules.html<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/21/sb21-modules.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/21/sb21-modules.html</a></strong></p>\n<p>springboot对JMS提供了很好的支持，对其做了起步依赖。</p>\n<h2><a id="_9"></a>构架工程</h2>\n<p>创建一个springboot工程，在其pom文件加入：</p>\n<pre><code>\n\t&lt;dependency&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;\n\t&lt;/dependency&gt;\n</code></pre>\n<h2><a id="_21"></a>添加配置</h2>\n<pre><code>spring.mail.host=smtp.163.com\nspring.mail.username=miles02@163.com\nspring.mail.password=\nspring.mail.port=25\nspring.mail.protocol=smtp\nspring.mail.default-encoding=UTF-8\n\n</code></pre>\n<p>在password 中填写自己的邮箱密码。</p>\n<h2><a id="_35"></a>测试发邮件</h2>\n<p>测试代码清单如下：</p>\n<pre><code>package com.forezp;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSenderImpl;\nimport org.springframework.mail.javamail.MimeMessageHelper;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport javax.mail.internet.MimeMessage;\nimport java.io.File;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootJmsApplicationTests {\n\n\t@Test\n\tpublic void contextLoads() {\n\t}\n\n\n\t@Autowired\n\tprivate JavaMailSenderImpl mailSender;\n\n\t/**\n\t * 发送包含简单文本的邮件\n\t */\n\t@Test\n\tpublic void sendTxtMail() {\n\t\tSimpleMailMessage simpleMailMessage = new SimpleMailMessage();\n\t\t// 设置收件人，寄件人\n\t\tsimpleMailMessage.setTo(new String[] {"miles02@163.com"});\n\t\tsimpleMailMessage.setFrom("miles02@163.com");\n\t\tsimpleMailMessage.setSubject("Spring Boot Mail 邮件测试【文本】");\n\t\tsimpleMailMessage.setText("这里是一段简单文本。");\n\t\t// 发送邮件\n\t\tmailSender.send(simpleMailMessage);\n\n\t\tSystem.out.println("邮件已发送");\n\t}\n\n\t/**\n\t * 发送包含HTML文本的邮件\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void sendHtmlMail() throws Exception {\n\t\tMimeMessage mimeMessage = mailSender.createMimeMessage();\n\t\tMimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage);\n\t\tmimeMessageHelper.setTo("miles02@163.com");\n\t\tmimeMessageHelper.setFrom("miles02@163.com");\n\t\tmimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【HTML】");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append("&lt;html&gt;&lt;head&gt;&lt;/head&gt;");\n\t\tsb.append("&lt;body&gt;&lt;h1&gt;spring 邮件测试&lt;/h1&gt;&lt;p&gt;hello!this is spring mail test。&lt;/p&gt;&lt;/body&gt;");\n\t\tsb.append("&lt;/html&gt;");\n\n\t\t// 启用html\n\t\tmimeMessageHelper.setText(sb.toString(), true);\n\t\t// 发送邮件\n\t\tmailSender.send(mimeMessage);\n\n\t\tSystem.out.println("邮件已发送");\n\n\t}\n\n\t/**\n\t * 发送包含内嵌图片的邮件\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void sendAttachedImageMail() throws Exception {\n\t\tMimeMessage mimeMessage = mailSender.createMimeMessage();\n\t\t// multipart模式\n\t\tMimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);\n\t\tmimeMessageHelper.setTo("miles02@163.com");\n\t\tmimeMessageHelper.setFrom("miles02@163.com");\n\t\tmimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【图片】");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append("&lt;html&gt;&lt;head&gt;&lt;/head&gt;");\n\t\tsb.append("&lt;body&gt;&lt;h1&gt;spring 邮件测试&lt;/h1&gt;&lt;p&gt;hello!this is spring mail test。&lt;/p&gt;");\n\t\t// cid为固定写法，imageId指定一个标识\n\t\tsb.append("&lt;img src=\\"cid:imageId\\"/&gt;&lt;/body&gt;");\n\t\tsb.append("&lt;/html&gt;");\n\n\t\t// 启用html\n\t\tmimeMessageHelper.setText(sb.toString(), true);\n\n\t\t// 设置imageId\n\t\tFileSystemResource img = new FileSystemResource(new File("E:/1.jpg"));\n\t\tmimeMessageHelper.addInline("imageId", img);\n\n\t\t// 发送邮件\n\t\tmailSender.send(mimeMessage);\n\n\t\tSystem.out.println("邮件已发送");\n\t}\n\n\t/**\n\t * 发送包含附件的邮件\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void sendAttendedFileMail() throws Exception {\n\t\tMimeMessage mimeMessage = mailSender.createMimeMessage();\n\t\t// multipart模式\n\t\tMimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true, "utf-8");\n\t\tmimeMessageHelper.setTo("miles02@163.com");\n\t\tmimeMessageHelper.setFrom("miles02@163.com");\n\t\tmimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【附件】");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append("&lt;html&gt;&lt;head&gt;&lt;/head&gt;");\n\t\tsb.append("&lt;body&gt;&lt;h1&gt;spring 邮件测试&lt;/h1&gt;&lt;p&gt;hello!this is spring mail test。&lt;/p&gt;&lt;/body&gt;");\n\t\tsb.append("&lt;/html&gt;");\n\n\t\t// 启用html\n\t\tmimeMessageHelper.setText(sb.toString(), true);\n\t\t// 设置附件\n\t\tFileSystemResource img = new FileSystemResource(new File("E:/1.jpg"));\n\t\tmimeMessageHelper.addAttachment("image.jpg", img);\n\n\t\t// 发送邮件\n\t\tmailSender.send(mimeMessage);\n\n\t\tSystem.out.println("邮件已发送");\n\t}\n}\n\n\n</code></pre>\n<p>测试已全部通过，没有坑。</p>\n<h3><a id="_179"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_186"></a>参考资料</h2>\n<p><a href="http://blog.720ui.com/2017/springboot_07_othercore_javamail/" rel="nofollow">http://blog.720ui.com/2017/springboot_07_othercore_javamail/</a></p>\n<h2><a id="_190"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:34'}
2020-02-05 20:12:34 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:41] - MainThread - INFO - 翻页：4 nextUrl：https://blog.csdn.net/forezp/article/list/4
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023783', 'title': 'SpringBoot非官方教程 | 第十八篇： 定时任务（Scheduling Tasks）', 'readNum': '59715', 'commentNum': '4', 'publishTime': '2017-04-30 16:46:41', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/18/sb18-scheduling.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/18/sb18-scheduling.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/18/sb18-scheduling.html</a></strong></p>\n<p>这篇文章将介绍怎么通过spring去做调度任务。</p>\n<h2><a id="_9"></a>构建工程</h2>\n<p>创建一个Springboot工程，在它的程序入口加上@EnableScheduling,开启调度任务。</p>\n<pre><code>@SpringBootApplication\n@EnableScheduling\npublic class SpringbootSchedulingTasksApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootSchedulingTasksApplication.class, args);\n\t}\n}\n\n</code></pre>\n<h2><a id="_25"></a>创建定时任务</h2>\n<p>创建一个定时任务，每过5s在控制台打印当前时间。</p>\n<pre><code>@Component\npublic class ScheduledTasks {\n\n    private static final Logger log = LoggerFactory.getLogger(ScheduledTasks.class);\n\n    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");\n\n    @Scheduled(fixedRate = 5000)\n    public void reportCurrentTime() {\n        log.info("The time is now {}", dateFormat.format(new Date()));\n    }\n}\n</code></pre>\n<p>通过在方法上加@Scheduled注解，表明该方法是一个调度任务。</p>\n<ul>\n<li>@Scheduled(fixedRate = 5000) ：上一次开始执行时间点之后5秒再执行</li>\n<li>@Scheduled(fixedDelay = 5000) ：上一次执行完毕时间点之后5秒再执行</li>\n<li>@Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</li>\n<li>@Scheduled(cron="  /5   ") ：通过cron表达式定义规则，什么是cro表达式，自行搜索引擎。</li>\n</ul>\n<h2><a id="_52"></a>测试</h2>\n<p>启动springboot工程，控制台没过5s就打印出了当前的时间。</p>\n<blockquote>\n<p>2017-04-29 17:39:37.672  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:37<br>\n2017-04-29 17:39:42.671  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:42<br>\n2017-04-29 17:39:47.672  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:47<br>\n2017-04-29 17:39:52.675  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:52</p>\n</blockquote>\n<h2><a id="_62"></a>总结</h2>\n<p>在springboot创建定时任务比较简单，只需2步：</p>\n<ul>\n<li>1.在程序的入口加上@EnableScheduling注解。</li>\n<li>2.在定时方法上加@Scheduled注解。</li>\n</ul>\n<h2><a id="_69"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/scheduling-tasks/" rel="nofollow">https://spring.io/guides/gs/scheduling-tasks/</a></p>\n<h2><a id="_73"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_76"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023868', 'title': 'SpringBoot非官方教程 | 第二十篇： 处理表单提交', 'readNum': '65579', 'commentNum': '0', 'publishTime': '2017-04-30 16:54:28', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/20/sb20-form.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/20/sb20-form.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/20/sb20-form.html</a></strong><br>\n这篇文件主要介绍通过springboot 去创建和提交一个表单。</p>\n<h2><a id="_9"></a>创建工程</h2>\n<p>涉及了 web，加上spring-boot-starter-web和spring-boot-starter-thymeleaf的起步依赖。</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n\t\t\t&lt;/dependency&gt;\n\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<h2><a id="_36"></a>创建实体</h2>\n<p>代码清单如下：</p>\n<pre><code>\npublic class Greeting {\n\n    private long id;\n    private String content;\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n}\n\n</code></pre>\n<h2><a id="Controller_68"></a>创建Controller</h2>\n<pre><code>@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greetingForm(Model model) {\n        model.addAttribute("greeting", new Greeting());\n        return "greeting";\n    }\n\n    @PostMapping("/greeting")\n    public String greetingSubmit(@ModelAttribute Greeting greeting) {\n        return "result";\n    }\n\n}\n\n</code></pre>\n<h2><a id="_89"></a>页面展示层</h2>\n<p>src/main/resources/templates/greeting.html</p>\n<pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html xmlns:th="http://www.thymeleaf.org"&gt;\n&lt;head&gt;\n    &lt;title&gt;Getting Started: Handling Form Submission&lt;/title&gt;\n    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t&lt;h1&gt;Form&lt;/h1&gt;\n    &lt;form action="#" th:action="@{/greeting}" th:object="${greeting}" method="post"&gt;\n    \t&lt;p&gt;Id: &lt;input type="text" th:field="*{id}" /&gt;&lt;/p&gt;\n        &lt;p&gt;Message: &lt;input type="text" th:field="*{content}" /&gt;&lt;/p&gt;\n        &lt;p&gt;&lt;input type="submit" value="Submit" /&gt; &lt;input type="reset" value="Reset" /&gt;&lt;/p&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>src/main/resources/templates/result.html</p>\n<pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html xmlns:th="http://www.thymeleaf.org"&gt;\n&lt;head&gt;\n    &lt;title&gt;Getting Started: Handling Form Submission&lt;/title&gt;\n    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t&lt;h1&gt;Result&lt;/h1&gt;\n    &lt;p th:text="\'id: \' + ${greeting.id}" /&gt;\n    &lt;p th:text="\'content: \' + ${greeting.content}" /&gt;\n    &lt;a href="/greeting"&gt;Submit another message&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>启动工程，访问ttp://localhost:8080/greeting:</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL2hhbmRsaW5nLWZvcm0tc3VibWlzc2lvbi9pbWFnZXMvZm9ybS5wbmc?x-oss-process=image/format,png" alt=""></p>\n<p>点击submit:</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL2hhbmRsaW5nLWZvcm0tc3VibWlzc2lvbi9pbWFnZXMvcmVzdWx0LnBuZw?x-oss-process=image/format,png" alt=""></p>\n<h2><a id="_139"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/handling-form-submission/" rel="nofollow">https://spring.io/guides/gs/handling-form-submission/</a></p>\n<h2><a id="_144"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_147"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023817', 'title': 'SpringBoot非官方教程 | 第十九篇： 验证表单信息', 'readNum': '58557', 'commentNum': '8', 'publishTime': '2017-04-30 16:50:05', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/19/sb19.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/19/sb19.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/19/sb19.html</a></strong><br>\n这篇文篇主要简述如何在springboot中验证表单信息。在springmvc工程中，需要检查表单信息，表单信息验证主要通过注解的形式。</p>\n<h2><a id="_9"></a>构建工程</h2>\n<p>创建一个springboot工程，由于用到了 web 、thymeleaf、validator、el，引入相应的起步依赖和依赖，代码清单如下：</p>\n<pre><code>\n&lt;dependencies&gt; \n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<h2><a id="PresonFormObject_43"></a>创建一个PresonForm的Object类</h2>\n<pre><code>package com.forezp.entity;\n\nimport javax.validation.constraints.Min;\nimport javax.validation.constraints.NotNull;\nimport javax.validation.constraints.Size;\n/**\n * Created by fangzhipeng on 2017/4/19.\n */\npublic class PersonForm {\n\n    @NotNull\n    @Size(min=2, max=30)\n    private String name;\n\n    @NotNull\n    @Min(18)\n    private Integer age;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Person(Name: " + this.name + ", Age: " + this.age + ")";\n    }\n}\n\n\n</code></pre>\n<p>这个实体类，在2个属性:name,age.它们各自有验证的注解：</p>\n<ul>\n<li>@Size(min=2, max=30) name的长度为2-30个字符</li>\n<li>@NotNull 不为空</li>\n<li>@Min(18)age不能小于18</li>\n</ul>\n<h2><a id="_web_Controller_94"></a>创建 web Controller</h2>\n<pre><code>@Controller\npublic class WebController extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/results").setViewName("results");\n    }\n\n    @GetMapping("/")\n    public String showForm(PersonForm personForm) {\n        return "form";\n    }\n\n    @PostMapping("/")\n    public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) {\n\n        if (bindingResult.hasErrors()) {\n            return "form";\n        }\n\n        return "redirect:/results";\n    }\n}\n\n</code></pre>\n<h2><a id="form_123"></a>创建form表单</h2>\n<p>src/main/resources/templates/form.html:</p>\n<pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;form action="#" th:action="@{/}" th:object="${personForm}" method="post"&gt;\n            &lt;table&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;Name:&lt;/td&gt;\n                    &lt;td&gt;&lt;input type="text" th:field="*{name}" /&gt;&lt;/td&gt;\n                    &lt;td th:if="${#fields.hasErrors(\'name\')}" th:errors="*{name}"&gt;Name Error&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;Age:&lt;/td&gt;\n                    &lt;td&gt;&lt;input type="text" th:field="*{age}" /&gt;&lt;/td&gt;\n                    &lt;td th:if="${#fields.hasErrors(\'age\')}" th:errors="*{age}"&gt;Age Error&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;&lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/table&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2><a id="_155"></a>注册成功的页面</h2>\n<p>src/main/resources/templates/results.html:</p>\n<pre><code>\nhtml&gt;\n\t&lt;body&gt;\n\t\tCongratulations! You are old enough to sign up for this site.\n\t&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2><a id="_170"></a>演示</h2>\n<p>启动工程，访问http://localhost:8080/：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL3ZhbGlkYXRpbmctZm9ybS1pbnB1dC9pbWFnZXMvdmFsaWQtMDEucG5n?x-oss-process=image/format,png" alt=""></p>\n<p>如果你输入A和15，点击 submit:</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL3ZhbGlkYXRpbmctZm9ybS1pbnB1dC9pbWFnZXMvdmFsaWQtMDIucG5n?x-oss-process=image/format,png" alt=""></p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL3ZhbGlkYXRpbmctZm9ybS1pbnB1dC9pbWFnZXMvdmFsaWQtMDMucG5n?x-oss-process=image/format,png" alt=""></p>\n<p>如果name 输入N, age为空：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL3ZhbGlkYXRpbmctZm9ybS1pbnB1dC9pbWFnZXMvdmFsaWQtMDQucG5n?x-oss-process=image/format,png" alt=""></p>\n<p>如果输入：forezp. 18</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL3ZhbGlkYXRpbmctZm9ybS1pbnB1dC9pbWFnZXMvdmFsaWQtMDUucG5n?x-oss-process=image/format,png" alt=""></p>\n<h2><a id="_190"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/validating-form-input/" rel="nofollow">https://spring.io/guides/gs/validating-form-input/</a></p>\n<h2><a id="_194"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_197"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023724', 'title': 'SpringBoot非官方教程 | 第十六篇：用restTemplate消费服务', 'readNum': '56915', 'commentNum': '4', 'publishTime': '2017-04-30 16:39:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/16/sb16-restTemplate.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/16/sb16-restTemplate.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/16/sb16-restTemplate.html</a></strong></p>\n<p>这篇文章主要介绍怎么用消费一个 Restful的web服务。我将用restTemplate去消费一个服务： http://gturnquist-quoters.cfapps.io/api/random.</p>\n<h2><a id="_8"></a>构架工程</h2>\n<p>创建一个springboot工程，去消费RESTFUL的服务。这个服务是 http:///gturnquist-quoters.cfapps.io/api/random ，它会随机返回Json字符串。<br>\n在Spring项目中，它提供了一个非常简便的类，叫RestTemplate，它可以很简便的消费服务。</p>\n<h2><a id="_14"></a>消费服务</h2>\n<p>通过RestTemplate消费服务，需要先context中注册一个RestTemplate bean。代码如下：</p>\n<pre><code>\n@Bean\n\tpublic RestTemplate restTemplate(RestTemplateBuilder builder) {\n\t\treturn builder.build();\n\t}\n\n\t@Bean\n\tpublic CommandLineRunner run(RestTemplate restTemplate) throws Exception {\n\t\treturn args -&gt; {\n\t\t\tString quote = restTemplate.getForObject(\n\t\t\t\t\t"http://gturnquist-quoters.cfapps.io/api/random", String.class);\n\t\t\tlog.info(quote.toString());\n\t\t};\n\t}\n</code></pre>\n<p>运行程序，控制台打印：</p>\n<blockquote>\n<p>{<br>\n“type”: “success”,<br>\n“value”: {<br>\n“id”: 6,<br>\n“quote”: “It embraces convention over configuration, providing an experience on par with frameworks that excel at early stage development, such as Ruby on Rails.”<br>\n}<br>\n}</p>\n</blockquote>\n<h2><a id="_46"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/consuming-rest/" rel="nofollow">https://spring.io/guides/gs/consuming-rest/</a></p>\n<h3><a id="_50"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_58"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023752', 'title': 'SpringBoot非官方教程 | 第十七篇：上传文件', 'readNum': '58453', 'commentNum': '15', 'publishTime': '2017-04-30 16:42:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/17/sb17-upload.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/17/sb17-upload.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/17/sb17-upload.html</a></strong></p>\n<p>这篇文章主要介绍，如何在springboot工程作为服务器，去接收通过http 上传的multi-file的文件。</p>\n<h2><a id="_11"></a>构建工程</h2>\n<p>为例创建一个springmvc工程你需要spring-boot-starter-thymeleaf和 spring-boot-starter-web的起步依赖。为例能够上传文件在服务器，你需要在web.xml中加入标签做相关的配置，但在sringboot 工程中，它已经为你自动做了，所以不需要你做任何的配置。</p>\n<pre><code>\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<h2><a id="controller_37"></a>创建文件上传controller</h2>\n<p>直接贴代码：</p>\n<pre><code>\n@Controller\npublic class FileUploadController {\n\n    private final StorageService storageService;\n\n    @Autowired\n    public FileUploadController(StorageService storageService) {\n        this.storageService = storageService;\n    }\n\n    @GetMapping("/")\n    public String listUploadedFiles(Model model) throws IOException {\n\n        model.addAttribute("files", storageService\n                .loadAll()\n                .map(path -&gt;\n                        MvcUriComponentsBuilder\n                                .fromMethodName(FileUploadController.class, "serveFile", path.getFileName().toString())\n                                .build().toString())\n                .collect(Collectors.toList()));\n\n        return "uploadForm";\n    }\n\n    @GetMapping("/files/{filename:.+}")\n    @ResponseBody\n    public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) {\n\n        Resource file = storageService.loadAsResource(filename);\n        return ResponseEntity\n                .ok()\n                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\""+file.getFilename()+"\\"")\n                .body(file);\n    }\n\n    @PostMapping("/")\n    public String handleFileUpload(@RequestParam("file") MultipartFile file,\n                                   RedirectAttributes redirectAttributes) {\n\n        storageService.store(file);\n        redirectAttributes.addFlashAttribute("message",\n                "You successfully uploaded " + file.getOriginalFilename() + "!");\n\n        return "redirect:/";\n    }\n\n    @ExceptionHandler(StorageFileNotFoundException.class)\n    public ResponseEntity handleStorageFileNotFound(StorageFileNotFoundException exc) {\n        return ResponseEntity.notFound().build();\n    }\n\n}\n\n</code></pre>\n<p>这个类通过@Controller注解，表明自己上一个Spring mvc的c。每个方法通过<br>\n@GetMapping 或者@PostMapping注解表明自己的 http方法。</p>\n<ul>\n<li>GET / 获取已经上传的文件列表</li>\n<li>GET /files/{filename}  下载已经存在于服务器的文件</li>\n<li>POST / 上传文件给服务器</li>\n</ul>\n<h2><a id="_html_105"></a>创建一个简单的 html模板</h2>\n<p>为了展示上传文件的过程，我们做一个界面：<br>\n在src/main/resources/templates/uploadForm.html</p>\n<pre><code>&lt;html xmlns:th="http://www.thymeleaf.org"&gt;\n&lt;body&gt;\n\n\t&lt;div th:if="${message}"&gt;\n\t\t&lt;h2 th:text="${message}"/&gt;\n\t&lt;/div&gt;\n\n\t&lt;div&gt;\n\t\t&lt;form method="POST" enctype="multipart/form-data" action="/"&gt;\n\t\t\t&lt;table&gt;\n\t\t\t\t&lt;tr&gt;&lt;td&gt;File to upload:&lt;/td&gt;&lt;td&gt;&lt;input type="file" name="file" /&gt;&lt;/td&gt;&lt;/tr&gt;\n\t\t\t\t&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="submit" value="Upload" /&gt;&lt;/td&gt;&lt;/tr&gt;\n\t\t\t&lt;/table&gt;\n\t\t&lt;/form&gt;\n\t&lt;/div&gt;\n\n\t&lt;div&gt;\n\t\t&lt;ul&gt;\n\t\t\t&lt;li th:each="file : ${files}"&gt;\n\t\t\t\t&lt;a th:href="${file}" th:text="${file}" /&gt;\n\t\t\t&lt;/li&gt;\n\t\t&lt;/ul&gt;\n\t&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2><a id="_139"></a>上传文件大小限制</h2>\n<p>如果需要限制上传文件的大小也很简单，只需要在springboot 工程的src/main/resources/application.properties 加入以下：</p>\n<pre><code>spring.http.multipart.max-file-size=128KB\nspring.http.multipart.max-request-size=128KB\n\n</code></pre>\n<h2><a id="_150"></a>测试</h2>\n<p>测试情况如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601115517883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_157"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/uploading-files/" rel="nofollow">https://spring.io/guides/gs/uploading-files/</a></p>\n<h2><a id="_161"></a>源码下载</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_165"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023692', 'title': 'SpringBoot非官方教程 | 第十五篇：Springboot整合RabbitMQ', 'readNum': '67764', 'commentNum': '19', 'publishTime': '2017-04-30 16:34:51', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/15/sb15-rabbitmq.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/15/sb15-rabbitmq.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/15/sb15-rabbitmq.html</a></strong></p>\n<p>这篇文章带你了解怎么整合RabbitMQ服务器，并且通过它怎么去发送和接收消息。我将构建一个springboot工程，通过RabbitTemplate去通过MessageListenerAdapter去订阅一个POJO类型的消息。</p>\n<h2><a id="_8"></a>准备工作</h2>\n<ul>\n<li>15min</li>\n<li>IDEA</li>\n<li>maven 3.0</li>\n</ul>\n<p>在开始构建项目之前，机器需要安装rabbitmq，你可以去官网下载，http://www.rabbitmq.com/download.html ，如果你是用的Mac（程序员都应该用mac吧），你可以这样下载：</p>\n<pre><code>brew install rabbitmq\n\n</code></pre>\n<p>安装完成后开启服务器：</p>\n<pre><code>rabbitmq-server\n</code></pre>\n<p>开启服务器成功，你可以看到以下信息：</p>\n<pre><code>            RabbitMQ 3.1.3. Copyright (C) 2007-2013 VMware, Inc.\n##  ##      Licensed under the MPL.  See http://www.rabbitmq.com/\n##  ##\n##########  Logs: /usr/local/var/log/rabbitmq/rabbit@localhost.log\n######  ##        /usr/local/var/log/rabbitmq/rabbit@localhost-sasl.log\n##########\n            Starting broker... completed with 6 plugins.\n\n\n</code></pre>\n<h2><a id="_39"></a>构建工程</h2>\n<p>构架一个SpringBoot工程，其pom文件依赖加上spring-boot-starter-amqp的起步依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id="_51"></a>创建消息接收者</h2>\n<p>在任何的消息队列程序中，你需要创建一个消息接收者，用于响应发送的消息。</p>\n<pre><code>\n@Component\npublic class Receiver {\n\n    private CountDownLatch latch = new CountDownLatch(1);\n\n    public void receiveMessage(String message) {\n        System.out.println("Received &lt;" + message + "&gt;");\n        latch.countDown();\n    }\n\n    public CountDownLatch getLatch() {\n        return latch;\n    }\n\n}\n\n</code></pre>\n<p>消息接收者是一个简单的POJO类，它定义了一个方法去接收消息，当你注册它去接收消息，你可以给它取任何的名字。其中，它有CountDownLatch这样的一个类，它是用于告诉发送者消息已经收到了，你不需要在应用程序中具体实现它，只需要latch.countDown()就行了。</p>\n<h2><a id="_77"></a>创建消息监听，并发送一条消息</h2>\n<p>在spring程序中，RabbitTemplate提供了发送消息和接收消息的所有方法。你只需简单的配置下就行了：</p>\n<ul>\n<li>需要一个消息监听容器</li>\n<li>声明一个quene,一个exchange,并且绑定它们</li>\n<li>一个组件去发送消息</li>\n</ul>\n<p>代码清单如下：</p>\n<pre><code>package com.forezp;\n\nimport com.forezp.message.Receiver;\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.core.TopicExchange;\nimport org.springframework.amqp.rabbit.connection.ConnectionFactory;\nimport org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;\nimport org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\n\n\n@SpringBootApplication\npublic class SpringbootRabbitmqApplication {\n\n\t final static String queueName = "spring-boot";\n\n\t@Bean\n\tQueue queue() {\n\t\treturn new Queue(queueName, false);\n\t}\n\n\t@Bean\n\tTopicExchange exchange() {\n\t\treturn new TopicExchange("spring-boot-exchange");\n\t}\n\n\t@Bean\n\tBinding binding(Queue queue, TopicExchange exchange) {\n\t\treturn BindingBuilder.bind(queue).to(exchange).with(queueName);\n\t}\n\n\t@Bean\n\tSimpleMessageListenerContainer container(ConnectionFactory connectionFactory,\n\t\t\t\t\t\t\t\t\t\t\t MessageListenerAdapter listenerAdapter) {\n\t\tSimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\n\t\tcontainer.setConnectionFactory(connectionFactory);\n\t\tcontainer.setQueueNames(queueName);\n\t\tcontainer.setMessageListener(listenerAdapter);\n\t\treturn container;\n\t}\n\n\t@Bean\n\tMessageListenerAdapter listenerAdapter(Receiver receiver) {\n\t\treturn new MessageListenerAdapter(receiver, "receiveMessage");\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootRabbitmqApplication.class, args);\n\t}\n}\n\n\n</code></pre>\n<p>创建一个测试方法：</p>\n<pre><code>\n@Component\npublic class Runner implements CommandLineRunner {\n\n    private final RabbitTemplate rabbitTemplate;\n    private final Receiver receiver;\n    private final ConfigurableApplicationContext context;\n\n    public Runner(Receiver receiver, RabbitTemplate rabbitTemplate,\n            ConfigurableApplicationContext context) {\n        this.receiver = receiver;\n        this.rabbitTemplate = rabbitTemplate;\n        this.context = context;\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println("Sending message...");\n        rabbitTemplate.convertAndSend(Application.queueName, "Hello from RabbitMQ!");\n        receiver.getLatch().await(10000, TimeUnit.MILLISECONDS);\n        context.close();\n    }\n\n}\n\n</code></pre>\n<p>启动程序，你会发现控制台打印：</p>\n<pre><code>Sending message...\nReceived &lt;Hello from RabbitMQ!&gt;\n\n</code></pre>\n<h2><a id="_186"></a>总结</h2>\n<p>恭喜！你刚才已经学会了如何通过spring raabitmq去构建一个消息发送和订阅的程序。 这仅仅是一个好的开始，你可以通过spring-rabbitmq做更多的事，<a href="http://docs.spring.io/spring-amqp/reference/html/_introduction.html#quick-tour" rel="nofollow">点击这里</a>。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h2><a id="_194"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/messaging-rabbitmq/" rel="nofollow">https://spring.io/guides/gs/messaging-rabbitmq/</a></p>\n<h3><a id="_196"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023652', 'title': 'SpringBoot非官方教程 | 第十四篇：在springboot中用redis实现消息队列', 'readNum': '68342', 'commentNum': '4', 'publishTime': '2017-04-30 16:29:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/14/sb14-redis-mq.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/14/sb14-redis-mq.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/14/sb14-redis-mq.html</a></strong><br>\n这篇文章主要讲述如何在springboot中用reids实现消息队列。</p>\n<h2><a id="_8"></a>准备阶段</h2>\n<ul>\n<li>安装redis,可参考我的另一篇文章，<a href="http://blog.csdn.net/forezp/article/details/61471712">5分钟带你入门Redis</a>。</li>\n<li>java 1.8</li>\n<li>maven 3.0</li>\n<li>idea</li>\n</ul>\n<h2><a id="_15"></a>环境依赖</h2>\n<p>创建一个新的springboot工程，在其pom文件,加入spring-boot-starter-data-redis依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id="_27"></a>创建一个消息接收者</h2>\n<p>REcevier类，它是一个普通的类，需要注入到springboot中。</p>\n<pre><code>public class Receiver {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Receiver.class);\n\n    private CountDownLatch latch;\n\n    @Autowired\n    public Receiver(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    public void receiveMessage(String message) {\n        LOGGER.info("Received &lt;" + message + "&gt;");\n        latch.countDown();\n    }\n}\n\n</code></pre>\n<h2><a id="_50"></a>注入消息接收者</h2>\n<pre><code>@Bean\n\tReceiver receiver(CountDownLatch latch) {\n\t\treturn new Receiver(latch);\n\t}\n\n\t@Bean\n\tCountDownLatch latch() {\n\t\treturn new CountDownLatch(1);\n\t}\n\n\t@Bean\n\tStringRedisTemplate template(RedisConnectionFactory connectionFactory) {\n\t\treturn new StringRedisTemplate(connectionFactory);\n\t}\n\n</code></pre>\n<h2><a id="_70"></a>注入消息监听容器</h2>\n<p>在spring data redis中，利用redis发送一条消息和接受一条消息，需要三样东西：</p>\n<ul>\n<li>一个连接工厂</li>\n<li>一个消息监听容器</li>\n<li>Redis template</li>\n</ul>\n<p>上述1、3步已经完成，所以只需注入消息监听容器即可：</p>\n<pre><code>@Bean\n\tRedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,\n\t\t\t\t\t\t\t\t\t\t\tMessageListenerAdapter listenerAdapter) {\n\n\t\tRedisMessageListenerContainer container = new RedisMessageListenerContainer();\n\t\tcontainer.setConnectionFactory(connectionFactory);\n\t\tcontainer.addMessageListener(listenerAdapter, new PatternTopic("chat"));\n\n\t\treturn container;\n\t}\n\n\t@Bean\n\tMessageListenerAdapter listenerAdapter(Receiver receiver) {\n\t\treturn new MessageListenerAdapter(receiver, "receiveMessage");\n\t}\n\n\n</code></pre>\n<h2><a id="_100"></a>测试</h2>\n<p>在springboot入口的main方法：</p>\n<pre><code>public static void main(String[] args) throws Exception{\n\t\tApplicationContext ctx =  SpringApplication.run(SpringbootRedisApplication.class, args);\n\n\t\tStringRedisTemplate template = ctx.getBean(StringRedisTemplate.class);\n\t\tCountDownLatch latch = ctx.getBean(CountDownLatch.class);\n\n\t\tLOGGER.info("Sending message...");\n\t\ttemplate.convertAndSend("chat", "Hello from Redis!");\n\n\t\tlatch.await();\n\n\t\tSystem.exit(0);\n\t}\n\n</code></pre>\n<p>先用redisTemplate发送一条消息，接收者接收到后，打印出来。启动springboot程序，控制台打印：</p>\n<blockquote>\n<p>2017-04-20 17:25:15.536  INFO 39148 — [           main] com.forezp.SpringbootRedisApplication    : Sending message…<br>\n2017-04-20 17:25:15.544  INFO 39148 — [    container-2] com.forezp.message.Receiver              : 》Received &lt;Hello from Redis!&gt;</p>\n</blockquote>\n<p>测试通过，接收者确实接收到了发送者的消息。</p>\n<h2><a id="_129"></a>源码下载：</h2>\n<p><a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_133"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_141"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/messaging-redis/" rel="nofollow">messaging-redis</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023614', 'title': 'SpringBoot非官方教程 | 第十三篇：springboot集成spring cache', 'readNum': '62094', 'commentNum': '16', 'publishTime': '2017-04-30 16:23:06', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/13/sb13-springcache.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/13/sb13-springcache.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/13/sb13-springcache.html</a></strong></p>\n<p>本文介绍如何在springboot中使用默认的spring cache，</p>\n<h2><a id="_9"></a>声明式缓存</h2>\n<p>Spring 定义 CacheManager 和 Cache 接口用来统一不同的缓存技术。例如 JCache、 EhCache、 Hazelcast、 Guava、 Redis 等。在使用 Spring 集成 Cache 的时候，我们需要注册实现的 CacheManager 的 Bean。</p>\n<p>Spring Boot 为我们自动配置了 JcacheCacheConfiguration、 EhCacheCacheConfiguration、HazelcastCacheConfiguration、GuavaCacheConfiguration、RedisCacheConfiguration、SimpleCacheConfiguration 等。</p>\n<h2><a id="_ConcurrenMapCacheManager_15"></a>默认使用 ConcurrenMapCacheManager</h2>\n<p>在我们不使用其他第三方缓存依赖的时候，springboot自动采用ConcurrenMapCacheManager作为缓存管理器。</p>\n<h2><a id="_19"></a>环境依赖</h2>\n<p>在pom文件引入spring-boot-starter-cache环境依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id="book_31"></a>创建一个book数据访问层</h2>\n<h3><a id="_33"></a>先创建一个实体类</h3>\n<pre><code>\npublic class Book {\n\n   private String isbn;\n   private String title;\n\n   public Book(String isbn, String title) {\n       this.isbn = isbn;\n       this.title = title;\n   }\n ....getter\n ....setter  \n\n}\n</code></pre>\n<h3><a id="_53"></a>创建一个数据访问接口</h3>\n<pre><code>\npublic interface BookRepository {\n\n    Book getByIsbn(String isbn);\n\n}\n</code></pre>\n<p>这个你可以写一个很复杂的数据查询操作，比如操作mysql、nosql等等。为了演示这个栗子，我只做了一下线程的延迟操作，当作是查询数据库的时间。</p>\n<p>实现接口类：</p>\n<pre><code>@Component\npublic class SimpleBookRepository implements BookRepository {\n\n    @Override\n    \n    public Book getByIsbn(String isbn) {\n        simulateSlowService();\n        return new Book(isbn, "Some book");\n    }\n\n    // Don\'t do this at home\n    private void simulateSlowService() {\n        try {\n            long time = 3000L;\n            Thread.sleep(time);\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n}\n\n</code></pre>\n<h3><a id="_93"></a>测试类</h3>\n<pre><code>@Component\npublic class AppRunner implements CommandLineRunner {\n\n    private static final Logger logger = LoggerFactory.getLogger(AppRunner.class);\n\n    private final BookRepository bookRepository;\n\n    public AppRunner(BookRepository bookRepository) {\n        this.bookRepository = bookRepository;\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        logger.info(".... Fetching books");\n        logger.info("isbn-1234 --&gt;" + bookRepository.getByIsbn("isbn-1234"));\n        logger.info("isbn-4567 --&gt;" + bookRepository.getByIsbn("isbn-4567"));\n        logger.info("isbn-1234 --&gt;" + bookRepository.getByIsbn("isbn-1234"));\n        logger.info("isbn-4567 --&gt;" + bookRepository.getByIsbn("isbn-4567"));\n        logger.info("isbn-1234 --&gt;" + bookRepository.getByIsbn("isbn-1234"));\n        logger.info("isbn-1234 --&gt;" + bookRepository.getByIsbn("isbn-1234"));\n    }\n\n}\n</code></pre>\n<p>启动程序，你会发现程序在控制台依次打印了：</p>\n<blockquote>\n<p>2014-06-05 12:15:35.783  … : … Fetching books</p>\n<p>2014-06-05 12:15:40.783  … : isbn-1234 --&gt; &gt;Book{isbn=‘isbn-1234’, title=‘Some book’}</p>\n</blockquote>\n<p>2014-06-05 12:15:43.784  … : isbn-1234 --&gt;Book{isbn=‘isbn-1234’, title=‘Some book’}</p>\n<blockquote></blockquote>\n<p>2014-06-05 12:15:46.786  … : isbn-1234 --&gt;Book{isbn=‘isbn-1234’, title=‘Some book’}</p>\n<p>你会发现程序依次3s打印一行日志。这时还没开启缓存技术。</p>\n<h2><a id="_135"></a>开启缓存技术</h2>\n<p>在程序的入口中加入@ EnableCaching开启缓存技术：</p>\n<pre><code>@SpringBootApplication\n@EnableCaching\npublic class DemoApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n}\n</code></pre>\n<p>在需要缓存的地方加入@Cacheable注解，比如在getByIsbn（）方法上加入@Cacheable(“books”)，这个方法就开启了缓存策略，当缓存有这个数据的时候，会直接返回数据，不会等待去查询数据库。</p>\n<pre><code>@Component\npublic class SimpleBookRepository implements BookRepository {\n\n    @Override\n    @Cacheable("books")\n    public Book getByIsbn(String isbn) {\n        simulateSlowService();\n        return new Book(isbn, "Some book");\n    }\n\n    // Don\'t do this at home\n    private void simulateSlowService() {\n        try {\n            long time = 3000L;\n            Thread.sleep(time);\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n}\n</code></pre>\n<p>这时再启动程序，你会发现程序打印：</p>\n<blockquote>\n<p>isbn-1234 --&gt;Book{isbn=‘isbn-1234’, title=‘Some book’}<br>\n2017-04-23 18:17:09.479  INFO 8054 — [           main] forezp.AppRunner                         : isbn-4567 --&gt;Book{isbn=‘isbn-4567’, title=‘Some book’}<br>\n2017-04-23 18:17:09.480  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 --&gt;Book{isbn=‘isbn-1234’, title=‘Some book’}<br>\n2017-04-23 18:17:09.480  INFO 8054 — [           main] forezp.AppRunner                         : isbn-4567 --&gt;Book{isbn=‘isbn-4567’, title=‘Some book’}<br>\n2017-04-23 18:17:09.481  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 --&gt;Book{isbn=‘isbn-1234’, title=‘Some book’}<br>\n2017-04-23 18:17:09.481  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 --&gt;Book{isbn=‘isbn-1234’, title=‘Some book’}</p>\n</blockquote>\n<p>只有打印前面2个数据，程序等了3s，之后的数据瞬间打印在控制台上了，这说明缓存起了作用。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h2><a id="_191"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/caching/" rel="nofollow">caching</a></p>\n<p><a href="http://blog.720ui.com/2017/springboot_02_data_cache_concurrenmapcache/" rel="nofollow">Spring Boot 揭秘与实战（二） 数据缓存篇 - 快速入门</a></p>\n<h3><a id="_197"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:35 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023579', 'title': 'SpringBoot非官方教程 | 第十二篇：springboot集成apidoc', 'readNum': '61033', 'commentNum': '9', 'publishTime': '2017-04-30 16:18:51', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/12/sb12-apidoc.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/12/sb12-apidoc.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/12/sb12-apidoc.html</a></strong></p>\n<p>首先声明下，apidoc是基于注释来生成文档的，它不基于任何框架，而且支持大多数编程语言，为了springboot系列的完整性，所以标了个题。</p>\n<h2><a id="apidoc_9"></a>一、apidoc简介</h2>\n<p>apidoc通过在你代码的注释来生成api文档的。它对代码没有侵入性，只需要你写好相关的注释即可，并且它仅通过写简单的配置就可以生成高颜值的api接口页面。它基于node.js，所以你需要安装node.js环境。node.js安装，<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" rel="nofollow">点击这里</a>。这里就不介绍。</p>\n<h2><a id="_13"></a>二、准备工作</h2>\n<p>安装完node.js安装api.doc,它的项目源码：<a href="https://github.com/apidoc/apidoc">https://github.com/apidoc/apidoc</a> 。</p>\n<p>通过命令安装：</p>\n<blockquote>\n<p>npm install apidoc -g</p>\n</blockquote>\n<h2><a id="_21"></a>三、注释怎么写</h2>\n<ul>\n<li>@api</li>\n</ul>\n<pre><code>@api {method} path [title]\n\nmethod：请求方法，\npath：请求路径 \ntitle(可选)：标题\n</code></pre>\n<ul>\n<li>@apiDescription</li>\n</ul>\n<pre><code>@apiDescription text\ntext说明\n</code></pre>\n<ul>\n<li>@apiError</li>\n</ul>\n<pre><code>@apiError [(group)] [{type}] field [description]\n\n（group）（可选）：参数将以这个名称分组，不设置的话，默认是Error 4xx \n{type}（可选）：返回值类型，例如：{Boolean}, {Number}, {String}, {Object}, {String[]} \nfield：返回值字段名称 \ndescriptionoptional（可选）：返回值字段说明\n\n</code></pre>\n<ul>\n<li>@apiGroup</li>\n</ul>\n<pre><code>@apiGroup name\nname：组名称，也是导航的标题\n\n</code></pre>\n<p>更多注释，参见官方文档：<a href="http://apidocjs.com/#params" rel="nofollow">http://apidocjs.com/#params</a></p>\n<h2><a id="_59"></a>四、写给栗子</h2>\n<h3><a id="_61"></a>首先写配置文件</h3>\n<p>在项目的主目录新建一个apidoc.json文件：</p>\n<pre><code>{\n  "name": "example",\n  "version": "0.1.0",\n  "description": "A basic apiDoc example"\n}\n\n</code></pre>\n<p>更多配置参考：<a href="http://apidocjs.com/#configuration" rel="nofollow">http://apidocjs.com/#configuration</a></p>\n<h3><a id="_76"></a>写个注释:</h3>\n<pre><code>\n    /**\n     * @api {POST} /register 注册用户\n     * @apiGroup Users\n     * @apiVersion 0.0.1\n     * @apiDescription 用于注册用户\n     * @apiParam {String} account 用户账户名\n     * @apiParam {String} password 密码\n     * @apiParam {String} mobile 手机号\n     * @apiParam {int} vip = 0  是否注册Vip身份 0 普通用户 1 Vip用户\n     * @apiParam {String} [recommend] 邀请码\n     * @apiParamExample {json} 请求样例：\n     *                ?account=sodlinken&amp;password=11223344&amp;mobile=13739554137&amp;vip=0&amp;recommend=\n     * @apiSuccess (200) {String} msg 信息\n     * @apiSuccess (200) {int} code 0 代表无错误 1代表有错误\n     * @apiSuccessExample {json} 返回样例:\n     *                {"code":"0","msg":"注册成功"}\n     */\n\n</code></pre>\n<h3><a id="apidoc_100"></a>用apidoc命令生成文档界面</h3>\n<p>先cd到工程的外层目录，并在外层目建个输出文档的目录，我建的是docapi。</p>\n<p>输命令：</p>\n<blockquote>\n<p>apidoc -i chapter4/ -o apidoc/</p>\n</blockquote>\n<p>-i 输入目录 -o 输出目录</p>\n<p>chapter4是我的工程名。</p>\n<p>可以看到在apidoc目录生成了很多文件:</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601115346503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">打开index.html,可以看到文档页面:</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601115404919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_117"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_125"></a>五、参考资料</h2>\n<p><a href="https://github.com/apidoc/apidoc">apidoc</a></p>\n<p><a href="http://apidocjs.com/" rel="nofollow">apidocjs.com</a></p>\n<p><a href="http://blog.csdn.net/soslinken/article/details/50468896">使用apidoc 生成Restful web Api文档</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:35'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023510', 'title': 'SpringBoot非官方教程 | 第十篇： 用spring Restdocs创建API文档', 'readNum': '72234', 'commentNum': '11', 'publishTime': '2017-04-30 16:08:34', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/10/sb10-springrestdocs.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/10/sb10-springrestdocs.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/10/sb10-springrestdocs.html</a></strong><br>\n这篇文章将带你了解如何用spring官方推荐的restdoc去生成api文档。本文创建一个简单的springboot工程，将http接口通过Api文档暴露出来。只需要通过 JUnit单元测试和Spring的MockMVC就可以生成文档。</p>\n<h2><a id="_7"></a>准备工作</h2>\n<ul>\n<li>你需要15min</li>\n<li>Jdk 1.8</li>\n<li>maven 3.0+</li>\n<li>idea</li>\n</ul>\n<h4><a id="_14"></a>创建工程</h4>\n<p>引入依赖，其pom文件：</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n</code></pre>\n<p>通过@SpringBootApplication,开启springboot</p>\n<pre><code>@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n</code></pre>\n<p>在springboot通常创建一个controller:</p>\n<pre><code>@RestController\npublic class HomeController {\n\n    @GetMapping("/")\n    public Map&lt;String, Object&gt; greeting() {\n        return Collections.singletonMap("message", "Hello World");\n    }\n\n}\n</code></pre>\n<p>启动工程，访问localhost:8080，浏览器显示：</p>\n<blockquote>\n<p>{“message”:“Hello World”}</p>\n</blockquote>\n<p>证明接口已经写好了，但是如何通过restdoc生存api文档呢</p>\n<h2><a id="Restdocapi_70"></a>Restdoc,通过单元测试生成api文档</h2>\n<p>restdocs是通过单元测试生存snippets文件，然后snippets根据插件生成htm文档的。</p>\n<p>建一个单元测试类：</p>\n<pre><code>@RunWith(SpringRunner.class)\n@WebMvcTest(HomeController.class)\n@AutoConfigureRestDocs(outputDir = "target/snippets")\npublic class WebLayerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void shouldReturnDefaultMessage() throws Exception {\n        this.mockMvc.perform(get("/")).andDo(print()).andExpect(status().isOk())\n                .andExpect(content().string(containsString("Hello World")))\n                .andDo(document("home"));\n    }\n}\n\n</code></pre>\n<p>其中，@ AutoConfigureRestDocs注解开启了生成snippets文件，并指定了存放位置。</p>\n<p>启动单元测试，测试通过，你会发现在target文件下生成了一个snippets文件夹，其目录结构如下：</p>\n<pre><code>└── target\n    └── snippets\n        └── home\n            └── httpie-request.adoc\n            └── curl-request.adoc\n            └── http-request.adoc\n            └── http-response.adoc\n\n</code></pre>\n<p>默认情况下，snippets是Asciidoctor格式的文件，包括request和reponse，另外其他两种httpie和curl两种流行的命令行的http请求模式。</p>\n<p>到目前为止，只生成了Snippets文件，需要用Snippets文件生成文档。</p>\n<h4><a id="Snippets_113"></a>怎么用Snippets</h4>\n<p>创建一个新文件src/main/asciidoc/index.adoc ：</p>\n<pre><code>= 用 Spring REST Docs 构建文档\n\nThis is an example output for a service running at http://localhost:8080:\n\n.request\ninclude::{snippets}/home/http-request.adoc[]\n\n.response\ninclude::{snippets}/home/http-response.adoc[]\n\n这个例子非常简单，通过单元测试和一些简单的配置就能够得到api文档了。\n\n</code></pre>\n<p>adoc的书写格式，参考:<a href="http://docs.spring.io/spring-restdocs/docs/current/reference/html5/" rel="nofollow">http://docs.spring.io/spring-restdocs/docs/current/reference/html5/</a>，这里不多讲解。</p>\n<p>需要使用asciidoctor-maven-plugin插件，在其pom文件加上：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;\n    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;generate-docs&lt;/id&gt;\n            &lt;phase&gt;prepare-package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process-asciidoc&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;sourceDocumentName&gt;index.adoc&lt;/sourceDocumentName&gt;\n                &lt;backend&gt;html&lt;/backend&gt;\n                &lt;attributes&gt;\n                    &lt;snippets&gt;${project.build.directory}/snippets&lt;/snippets&gt;\n                &lt;/attributes&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n\n</code></pre>\n<p>这时只需要通过mvnw package命令就可以生成文档了。<br>\n在/target/generated-docs下有个index.html，打开这个html,显示如下，界面还算简洁：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601115220644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="_165"></a>结语</h2>\n<p>通过单元测试，生存adoc文件，再用adoc文件生存html，只需要简单的几步就可以生成一个api文档的html文件，这个html文件你可以通网站发布出去。整个过程很简单，对代码无任何影响。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_171"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_179"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/testing-restdocs/" rel="nofollow">restdocs</a></p>\n<p><a href="http://docs.spring.io/spring-restdocs/docs/current/reference/html5/" rel="nofollow">http://docs.spring.io/spring-restdocs/docs/current/reference/html5/</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/71023536', 'title': 'SpringBoot非官方教程 | 第十一篇：springboot集成swagger2，构建优雅的Restful API', 'readNum': '83197', 'commentNum': '22', 'publishTime': '2017-04-30 16:13:56', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/11/sb11-swagger2.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/11/sb11-swagger2.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/11/sb11-swagger2.html</a></strong></p>\n<p>swagger,中文“拽”的意思。它是一个功能强大的api框架，它的集成非常简单，不仅提供了在线文档的查阅，而且还提供了在线文档的测试。另外swagger很容易构建restful风格的api，简单优雅帅气，正如它的名字。</p>\n<p>一、引入依赖</p>\n<pre><code>\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.springfox&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;2.6.1&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.springfox&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;2.6.1&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>二、写配置类</p>\n<pre><code>@Configuration\n@EnableSwagger2\npublic class Swagger2 {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage("com.forezp.controller"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title("springboot利用swagger构建api文档")\n                .description("简单优雅的restfun风格，http://blog.csdn.net/forezp")\n                .termsOfServiceUrl("http://blog.csdn.net/forezp")\n                .version("1.0")\n                .build();\n    }\n}\n\n\n</code></pre>\n<p>通过@Configuration注解，表明它是一个配置类，@EnableSwagger2开启swagger2。apiINfo()配置一些基本的信息。apis()指定扫描的包会生成文档。</p>\n<p>三、写生产文档的注解</p>\n<p>swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。</p>\n<ul>\n<li>@Api：修饰整个类，描述Controller的作用</li>\n<li>@ApiOperation：描述一个类的一个方法，或者说一个接口</li>\n<li>@ApiParam：单个参数描述</li>\n<li>@ApiModel：用对象来接收参数</li>\n<li>@ApiProperty：用对象接收参数时，描述对象的一个字段</li>\n<li>@ApiResponse：HTTP响应其中1个描述</li>\n<li>@ApiResponses：HTTP响应整体描述</li>\n<li>@ApiIgnore：使用该注解忽略这个API</li>\n<li>@ApiError ：发生错误返回的信息</li>\n<li>@ApiParamImplicitL：一个请求参数</li>\n<li>@ApiParamsImplicit 多个请求参数</li>\n</ul>\n<p>现在通过一个栗子来说明：</p>\n<pre><code>package com.forezp.controller;\n\nimport com.forezp.entity.Book;\nimport io.swagger.annotations.ApiImplicitParam;\nimport io.swagger.annotations.ApiImplicitParams;\nimport io.swagger.annotations.ApiOperation;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.*;\nimport springfox.documentation.annotations.ApiIgnore;\n\nimport java.util.*;\n\n/**\n * 用户创建某本图书\tPOST\t/books/\n * 用户修改对某本图书\tPUT\t/books/:id/\n * 用户删除对某本图书\tDELETE\t/books/:id/\n * 用户获取所有的图书 GET /books\n *  用户获取某一图书  GET /Books/:id\n * Created by fangzhipeng on 2017/4/17.\n * 官方文档：http://swagger.io/docs/specification/api-host-and-base-path/\n */\n@RestController\n@RequestMapping(value = "/books")\npublic class BookContrller {\n\n    Map&lt;Long, Book&gt; books = Collections.synchronizedMap(new HashMap&lt;Long, Book&gt;());\n\n    @ApiOperation(value="获取图书列表", notes="获取图书列表")\n    @RequestMapping(value={""}, method= RequestMethod.GET)\n    public List&lt;Book&gt; getBook() {\n        List&lt;Book&gt; book = new ArrayList&lt;&gt;(books.values());\n        return book;\n    }\n\n    @ApiOperation(value="创建图书", notes="创建图书")\n    @ApiImplicitParam(name = "book", value = "图书详细实体", required = true, dataType = "Book")\n    @RequestMapping(value="", method=RequestMethod.POST)\n    public String postBook(@RequestBody Book book) {\n        books.put(book.getId(), book);\n        return "success";\n    }\n    @ApiOperation(value="获图书细信息", notes="根据url的id来获取详细信息")\n    @ApiImplicitParam(name = "id", value = "ID", required = true, dataType = "Long",paramType = "path")\n    @RequestMapping(value="/{id}", method=RequestMethod.GET)\n    public Book getBook(@PathVariable Long id) {\n        return books.get(id);\n    }\n\n    @ApiOperation(value="更新信息", notes="根据url的id来指定更新图书信息")\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = "id", value = "图书ID", required = true, dataType = "Long",paramType = "path"),\n            @ApiImplicitParam(name = "book", value = "图书实体book", required = true, dataType = "Book")\n    })\n    @RequestMapping(value="/{id}", method= RequestMethod.PUT)\n    public String putUser(@PathVariable Long id, @RequestBody Book book) {\n        Book book1 = books.get(id);\n        book1.setName(book.getName());\n        book1.setPrice(book.getPrice());\n        books.put(id, book1);\n        return "success";\n    }\n    @ApiOperation(value="删除图书", notes="根据url的id来指定删除图书")\n    @ApiImplicitParam(name = "id", value = "图书ID", required = true, dataType = "Long",paramType = "path")\n    @RequestMapping(value="/{id}", method=RequestMethod.DELETE)\n    public String deleteUser(@PathVariable Long id) {\n        books.remove(id);\n        return "success";\n    }\n\n    @ApiIgnore//使用该注解忽略这个API\n    @RequestMapping(value = "/hi", method = RequestMethod.GET)\n    public String  jsonTest() {\n        return " hi you!";\n    }\n}\n\n</code></pre>\n<p>通过相关注解，就可以让swagger2生成相应的文档。如果你不需要某接口生成文档，只需要在加@ApiIgnore注解即可。需要说明的是，如果请求参数在url上，@ApiImplicitParam 上加paramType = “path” 。</p>\n<p>启动工程，访问：http://localhost:8080/swagger-ui.html ，就看到swagger-ui:</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601115259789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>整个集成过程非常简单，但是我看了相关的资料，swagger没有做安全方面的防护，可能需要我们自己做相关的工作。</p>\n<h3><a id="_164"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_172"></a>四、参考资料</h3>\n<p><a href="http://swagger.io/docs/" rel="nofollow">swagger.io</a></p>\n<p><a href="http://blog.didispace.com/springbootswagger2/" rel="nofollow">Spring Boot中使用Swagger2构建强大的RESTful API文档</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70991675', 'title': 'SpringBoot非官方教程 | 第九篇： springboot整合Redis', 'readNum': '69207', 'commentNum': '24', 'publishTime': '2017-04-30 00:11:55', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/09/sb9-redis.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/09/sb9-redis.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/09/sb9-redis.html</a></strong></p>\n<p>这篇文章主要介绍springboot整合redis，至于没有接触过redis的同学可以看下这篇文章：<a href="http://blog.csdn.net/forezp/article/details/61471712">5分钟带你入门Redis</a>。</p>\n<h2><a id="_8"></a>引入依赖：</h2>\n<p>在pom文件中添加redis依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id="_21"></a>配置数据源</h2>\n<pre><code>spring.redis.host=localhost\nspring.redis.port=6379\n#spring.redis.password=\nspring.redis.database=1\nspring.redis.pool.max-active=8\nspring.redis.pool.max-wait=-1\nspring.redis.pool.max-idle=500\nspring.redis.pool.min-idle=0\nspring.redis.timeout=0\n\n</code></pre>\n<p>如果你的redis有密码，配置下即可。经过上述两步的操作，你可以访问redis数据了。</p>\n<h2><a id="dao_38"></a>数据访问层dao</h2>\n<p>通过redisTemplate来访问redis.</p>\n<pre><code>@Repository\npublic class RedisDao {\n\n    @Autowired\n    private StringRedisTemplate template;\n\n    public  void setKey(String key,String value){\n        ValueOperations&lt;String, String&gt; ops = template.opsForValue();\n        ops.set(key,value,1, TimeUnit.MINUTES);//1分钟过期\n    }\n\n    public String getValue(String key){\n        ValueOperations&lt;String, String&gt; ops = this.template.opsForValue();\n        return ops.get(key);\n    }\n}\n\n</code></pre>\n<h2><a id="_62"></a>单元测试</h2>\n<pre><code>@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootRedisApplicationTests {\n\n\tpublic static Logger logger= LoggerFactory.getLogger(SpringbootRedisApplicationTests.class);\n\t@Test\n\tpublic void contextLoads() {\n\t}\n\n\t@Autowired\n\tRedisDao redisDao;\n\t@Test\n\tpublic void testRedis(){\n\t\tredisDao.setKey("name","forezp");\n\t\tredisDao.setKey("age","11");\n\t\tlogger.info(redisDao.getValue("name"));\n\t\tlogger.info(redisDao.getValue("age"));\n\t}\n}\n\n</code></pre>\n<p>启动单元测试，你发现控制台打印了：</p>\n<blockquote>\n<p>forezp</p>\n<p>11</p>\n</blockquote>\n<p>单元测试通过；</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h2><a id="_99"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/messaging-redis/" rel="nofollow">messaging-redis</a></p>\n<h3><a id="_104"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70941577', 'title': 'SpringBoot非官方教程 | 第八篇：springboot整合mongodb', 'readNum': '78857', 'commentNum': '13', 'publishTime': '2017-04-28 22:17:51', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/08/sb8-mongodb.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/08/sb8-mongodb.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/08/sb8-mongodb.html</a></strong><br>\n这篇文章主要介绍springboot如何整合mongodb。</p>\n<h2><a id="_8"></a>准备工作</h2>\n<ul>\n<li><a href="http://www.runoob.com/mongodb/mongodb-window-install.html" rel="nofollow">安装 MongoDB</a></li>\n<li>jdk 1.8</li>\n<li>maven 3.0</li>\n<li>idea</li>\n</ul>\n<h2><a id="_15"></a>环境依赖</h2>\n<p>在pom文件引入spring-boot-starter-data-mongodb依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\n</code></pre>\n<p>##数据源配置</p>\n<p>如果mongodb端口是默认端口，并且没有设置密码，可不配置，sprinboot会开启默认的。</p>\n<pre><code>spring.data.mongodb.uri=mongodb://localhost:27017/springboot-db\n\n</code></pre>\n<p>mongodb设置了密码，这样配置：</p>\n<pre><code>spring.data.mongodb.uri=mongodb://name:pass@localhost:27017/dbname\n</code></pre>\n<h2><a id="_44"></a>定义一个简单的实体</h2>\n<p>mongodb</p>\n<pre><code>\npackage com.forezp.entity;\n\nimport org.springframework.data.annotation.Id;\n\n\npublic class Customer {\n\n    @Id\n    public String id;\n\n    public String firstName;\n    public String lastName;\n\n    public Customer() {}\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                "Customer[id=%s, firstName=\'%s\', lastName=\'%s\']",\n                id, firstName, lastName);\n    }\n\n}\n\n</code></pre>\n<h2><a id="dao_82"></a>数据操作dao层</h2>\n<pre><code>public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; {\n\n    public Customer findByFirstName(String firstName);\n    public List&lt;Customer&gt; findByLastName(String lastName);\n\n}\n\n</code></pre>\n<p>写一个接口，继承MongoRepository，这个接口有了几本的CURD的功能。如果你想自定义一些查询，比如根据firstName来查询，获取根据lastName来查询，只需要定义一个方法即可。注意firstName严格按照存入的mongodb的字段对应。在典型的java的应用程序，写这样一个接口的方法，需要自己实现，但是在springboot中，你只需要按照格式写一个接口名和对应的参数就可以了，因为springboot已经帮你实现了。</p>\n<h2><a id="_97"></a>测试</h2>\n<pre><code>@SpringBootApplication\npublic class SpringbootMongodbApplication  implements CommandLineRunner {\n\n\n\t@Autowired\n\tprivate CustomerRepository repository;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootMongodbApplication.class, args);\n\t}\n\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\trepository.deleteAll();\n\n\t\t// save a couple of customers\n\t\trepository.save(new Customer("Alice", "Smith"));\n\t\trepository.save(new Customer("Bob", "Smith"));\n\n\t\t// fetch all customers\n\t\tSystem.out.println("Customers found with findAll():");\n\t\tSystem.out.println("-------------------------------");\n\t\tfor (Customer customer : repository.findAll()) {\n\t\t\tSystem.out.println(customer);\n\t\t}\n\t\tSystem.out.println();\n\n\t\t// fetch an individual customer\n\t\tSystem.out.println("Customer found with findByFirstName(\'Alice\'):");\n\t\tSystem.out.println("--------------------------------");\n\t\tSystem.out.println(repository.findByFirstName("Alice"));\n\n\t\tSystem.out.println("Customers found with findByLastName(\'Smith\'):");\n\t\tSystem.out.println("--------------------------------");\n\t\tfor (Customer customer : repository.findByLastName("Smith")) {\n\t\t\tSystem.out.println(customer);\n\t\t}\n\t}\n\n\t\n</code></pre>\n<p>在springboot的应用程序，加入测试代码。启动程序，控制台打印了：</p>\n<blockquote>\n<p>Customers found with findAll():<br>\n-------------------------------<br>\nCustomer[id=58f880f589ffb696b8a6077e, firstName=‘Alice’, lastName=‘Smith’]<br>\nCustomer[id=58f880f589ffb696b8a6077f, firstName=‘Bob’, lastName=‘Smith’]<br>\nCustomer found with findByFirstName(‘Alice’):<br>\n--------------------------------<br>\nCustomer[id=58f880f589ffb696b8a6077e, firstName=‘Alice’, lastName=‘Smith’]<br>\nCustomers found with findByLastName(‘Smith’):<br>\n--------------------------------<br>\nCustomer[id=58f880f589ffb696b8a6077e, firstName=‘Alice’, lastName=‘Smith’]<br>\nCustomer[id=58f880f589ffb696b8a6077f, firstName=‘Bob’, lastName=‘Smith’]</p>\n</blockquote>\n<p>测试通过。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_166"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_174"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/accessing-data-mongodb/" rel="nofollow">accessing-data-mongodb</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70768477', 'title': 'SpringBoot非官方教程 | 第六篇：springboot整合mybatis', 'readNum': '76749', 'commentNum': '51', 'publishTime': '2017-04-25 23:25:54', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/06/sb6-mybatis.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/06/sb6-mybatis.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/06/sb6-mybatis.html</a></strong></p>\n<p>本文主要讲解如何在springboot下整合mybatis，并访问数据库。由于mybatis这个框架太过于流行，所以我就不讲解了。</p>\n<h2><a id="_9"></a>引入依赖</h2>\n<p>在pom文件引入mybatis-spring-boot-starter的依赖：</p>\n<pre><code>       &lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;artifactId&gt;\n\t\t\t&lt;version&gt;1.3.0&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>引入数据库连接依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;runtime&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;druid&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.0.29&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n</code></pre>\n<h2><a id="_37"></a>引入数据源</h2>\n<p>application.properties配置文件中引入数据源：</p>\n<pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n</code></pre>\n<p>这样，springboot就可以访问数据了。</p>\n<h2><a id="_50"></a>创建数据库表</h2>\n<p>建表语句：</p>\n<pre><code>-- create table `account`\n# DROP TABLE `account` IF EXISTS\nCREATE TABLE `account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `money` double DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nINSERT INTO `account` VALUES (\'1\', \'aaa\', \'1000\');\nINSERT INTO `account` VALUES (\'2\', \'bbb\', \'1000\');\nINSERT INTO `account` VALUES (\'3\', \'ccc\', \'1000\');\n\n</code></pre>\n<h2><a id="_70"></a>具体实现</h2>\n<p>这篇文篇通过注解的形式实现。</p>\n<h3><a id="_73"></a>创建实体：</h3>\n<pre><code>public class Account {\n   private int id ;\n   private String name ;\n   private double money;\n   \n setter...\n getter...\n}\n\n</code></pre>\n<h3><a id="dao_87"></a>dao层</h3>\n<pre><code>@Mapper\npublic interface AccountMapper {\n\n    @Insert("insert into account(name, money) values(#{name}, #{money})")\n    int add(@Param("name") String name, @Param("money") double money);\n\n    @Update("update account set name = #{name}, money = #{money} where id = #{id}")\n    int update(@Param("name") String name, @Param("money") double money, @Param("id") int  id);\n\n    @Delete("delete from account where id = #{id}")\n    int delete(int id);\n\n    @Select("select id, name as name, money as money from account where id = #{id}")\n    Account findAccount(@Param("id") int id);\n\n    @Select("select id, name as name, money as money from account")\n    List&lt;Account&gt; findAccountList();\n}\n</code></pre>\n<h2><a id="service_110"></a>service层</h2>\n<pre><code>@Service\npublic class AccountService {\n    @Autowired\n    private AccountMapper accountMapper;\n\n    public int add(String name, double money) {\n        return accountMapper.add(name, money);\n    }\n    public int update(String name, double money, int id) {\n        return accountMapper.update(name, money, id);\n    }\n    public int delete(int id) {\n        return accountMapper.delete(id);\n    }\n    public Account findAccount(int id) {\n        return accountMapper.findAccount(id);\n    }\n    public List&lt;Account&gt; findAccountList() {\n        return accountMapper.findAccountList();\n    }\n}\n\n</code></pre>\n<h2><a id="controllerrestful_API_137"></a>controller层，构建restful API</h2>\n<pre><code>\npackage com.forezp.web;\n\nimport com.forezp.entity.Account;\nimport com.forezp.service.AccountService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n/**\n * Created by fangzhipeng on 2017/4/20.\n */\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @Autowired\n    AccountService accountService;\n\n    @RequestMapping(value = "/list", method = RequestMethod.GET)\n    public List&lt;Account&gt; getAccounts() {\n        return accountService.findAccountList();\n    }\n\n    @RequestMapping(value = "/{id}", method = RequestMethod.GET)\n    public Account getAccountById(@PathVariable("id") int id) {\n        return accountService.findAccount(id);\n    }\n\n    @RequestMapping(value = "/{id}", method = RequestMethod.PUT)\n    public String updateAccount(@PathVariable("id") int id, @RequestParam(value = "name", required = true) String name,\n                                @RequestParam(value = "money", required = true) double money) {\n        int t= accountService.update(name,money,id);\n        if(t==1) {\n            return "success";\n        }else {\n            return "fail";\n        }\n\n    }\n\n    @RequestMapping(value = "/{id}", method = RequestMethod.DELETE)\n    public String delete(@PathVariable(value = "id")int id) {\n        int t= accountService.delete(id);\n        if(t==1) {\n            return "success";\n        }else {\n            return "fail";\n        }\n\n    }\n\n    @RequestMapping(value = "", method = RequestMethod.POST)\n    public String postAccount(@RequestParam(value = "name") String name,\n                              @RequestParam(value = "money") double money) {\n\n       int t= accountService.add(name,money);\n       if(t==1) {\n           return "success";\n       }else {\n           return "fail";\n       }\n\n    }\n\n\n}\n</code></pre>\n<p>通过postman测试通过。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_215"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_222"></a>参考资料</h2>\n<p><a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#properties" rel="nofollow">mybatis</a></p>\n<p><a href="http://blog.720ui.com/2016/springboot_02_data_mybatis/" rel="nofollow">MyBatis整合</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70833629', 'title': 'SpringBoot非官方教程 | 第七篇：springboot开启声明式事务', 'readNum': '79325', 'commentNum': '27', 'publishTime': '2017-04-26 23:12:18', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springboot/2017/05/07/sb7-tracstion.html<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/07/sb7-tracstion.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/07/sb7-tracstion.html</a></strong></p>\n<p>springboot开启事务很简单，只需要一个注解@Transactional 就可以了。因为在springboot中已经默认对jpa、jdbc、mybatis开启了事事务，引入它们依赖的时候，事物就默认开启。当然，如果你需要用其他的orm，比如beatlsql，就需要自己配置相关的事物管理器。</p>\n<h2><a id="_9"></a>准备阶段</h2>\n<p>以上一篇文章的代码为例子，即springboot整合mybatis，上一篇文章是基于注解来实现mybatis的数据访问层，这篇文章基于xml的来实现，并开启声明式事务。</p>\n<h2><a id="_14"></a>环境依赖</h2>\n<p>在pom文件中引入mybatis启动依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>引入mysql 依赖</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;runtime&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;druid&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.0.29&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id="_42"></a>初始化数据库脚本</h2>\n<pre><code>-- create table `account`\n# DROP TABLE `account` IF EXISTS\nCREATE TABLE `account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `money` double DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nINSERT INTO `account` VALUES (\'1\', \'aaa\', \'1000\');\nINSERT INTO `account` VALUES (\'2\', \'bbb\', \'1000\');\nINSERT INTO `account` VALUES (\'3\', \'ccc\', \'1000\');\n\n</code></pre>\n<h2><a id="_59"></a>配置数据源</h2>\n<pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nmybatis.mapper-locations=classpath*:mybatis/*Mapper.xml\nmybatis.type-aliases-package=com.forezp.entity\n\n</code></pre>\n<p>通过配置mybatis.mapper-locations来指明mapper的xml文件存放位置，我是放在resources/mybatis文件下的。mybatis.type-aliases-package来指明和数据库映射的实体的所在包。</p>\n<p>经过以上步骤，springboot就可以通过mybatis访问数据库来。</p>\n<h2><a id="_75"></a>创建实体类</h2>\n<pre><code>\npublic class Account {\n    private int id ;\n    private String name ;\n    private double money;\n    \n    getter..\n    setter..\n    \n  }\n</code></pre>\n<h2><a id="dao__90"></a>数据访问dao 层</h2>\n<p>接口：</p>\n<pre><code>public interface AccountMapper2 {\n   int update( @Param("money") double money, @Param("id") int  id);\n}\n\n\n</code></pre>\n<p>mapper:</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;\n&lt;mapper namespace="com.forezp.dao.AccountMapper2"&gt;\n\n\n    &lt;update id="update"&gt;\n        UPDATE account set money=#{money} WHERE id=#{id}\n    &lt;/update&gt;\n&lt;/mapper&gt;\n\n</code></pre>\n<h2><a id="service_119"></a>service层</h2>\n<pre><code>@Service\npublic class AccountService2 {\n\n    @Autowired\n    AccountMapper2 accountMapper2;\n\n    @Transactional\n    public void transfer() throws RuntimeException{\n        accountMapper2.update(90,1);//用户1减10块 用户2加10块\n        int i=1/0;\n        accountMapper2.update(110,2);\n    }\n}\n\n</code></pre>\n<p>@Transactional，声明事务，并设计一个转账方法，用户1减10块，用户2加10块。在用户1减10 ，之后，抛出异常，即用户2加10块钱不能执行，当加注解@Transactional之后，两个人的钱都没有增减。当不加@Transactional，用户1减了10，用户2没有增加，即没有操作用户2 的数据。可见@Transactional注解开启了事物。</p>\n<h2><a id="_139"></a>结语</h2>\n<p>springboot 开启事物很简单，只需要加一行注解就可以了，前提你用的是jdbctemplate, jpa, mybatis，这种常见的orm。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h2><a id="_145"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/managing-transactions/" rel="nofollow">managing-transactions/</a></p>\n<h3><a id="_149"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70662983', 'title': 'SpringBoot非官方教程 | 第五篇：springboot整合 beatlsql', 'readNum': '63674', 'commentNum': '26', 'publishTime': '2017-04-24 21:01:48', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/05/sb5-beatlsql.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/05/sb5-beatlsql.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/05/sb5-beatlsql.html</a></strong></p>\n<p>BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自动能生成大量常用的SQL的应用。</p>\n<h2><a id="beatlsql__10"></a>beatlsql 优点</h2>\n<ul>\n<li>\n<p>开发效率</p>\n<ul>\n<li>无需注解，自动使用大量内置SQL，轻易完成增删改查功能，节省50%的开发工作量</li>\n<li>数据模型支持Pojo，也支持Map/List这种快速模型，也支持混合模型</li>\n<li>SQL 模板基于Beetl实现，更容易写和调试，以及扩展</li>\n</ul>\n</li>\n<li>\n<p>维护性</p>\n<ul>\n<li>SQL 以更简洁的方式，Markdown方式集中管理，同时方便程序开发和数据库SQL调试。</li>\n<li>可以自动将sql文件映射为dao接口类</li>\n<li>灵活直观的支持支持一对一，一对多，多对多关系映射而不引入复杂的OR Mapping概念和技术。</li>\n<li>具备Interceptor功能，可以调试，性能诊断SQL，以及扩展其他功能</li>\n</ul>\n</li>\n<li>\n<p>其他</p>\n<ul>\n<li>内置支持主从数据库支持的开源工具</li>\n<li>支持跨数据库平台，开发者所需工作减少到最小，目前跨数据库支持mysql,postgres,oracle,sqlserver,h2,sqllite,DB2.</li>\n</ul>\n</li>\n</ul>\n<h2><a id="_26"></a>引入依赖</h2>\n<pre><code>\n&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n\t\t\t&lt;optional&gt;true&lt;/optional&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;com.ibeetl&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;beetl&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;2.3.2&lt;/version&gt;\n\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;com.ibeetl&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;beetlsql&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;2.3.1&lt;/version&gt;\n\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;5.0.5&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n</code></pre>\n<p>这几个依赖都是必须的。</p>\n<h2><a id="_58"></a>整合阶段</h2>\n<p>由于springboot没有对 beatlsql的快速启动装配，所以需要我自己导入相关的bean，包括数据源，包扫描，事物管理器等。</p>\n<p>在application加入以下代码：</p>\n<pre><code>\n@Bean(initMethod = "init", name = "beetlConfig")\n\tpublic BeetlGroupUtilConfiguration getBeetlGroupUtilConfiguration() {\n\t\tBeetlGroupUtilConfiguration beetlGroupUtilConfiguration = new BeetlGroupUtilConfiguration();\n\t\tResourcePatternResolver patternResolver = ResourcePatternUtils.getResourcePatternResolver(new DefaultResourceLoader());\n\t\ttry {\n\t\t\t// WebAppResourceLoader 配置root路径是关键\n\t\t\tWebAppResourceLoader webAppResourceLoader = new WebAppResourceLoader(patternResolver.getResource("classpath:/templates").getFile().getPath());\n\t\t\tbeetlGroupUtilConfiguration.setResourceLoader(webAppResourceLoader);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t//读取配置文件信息\n\t\treturn beetlGroupUtilConfiguration;\n\n\t}\n\n\t@Bean(name = "beetlViewResolver")\n\tpublic BeetlSpringViewResolver getBeetlSpringViewResolver(@Qualifier("beetlConfig") BeetlGroupUtilConfiguration beetlGroupUtilConfiguration) {\n\t\tBeetlSpringViewResolver beetlSpringViewResolver = new BeetlSpringViewResolver();\n\t\tbeetlSpringViewResolver.setContentType("text/html;charset=UTF-8");\n\t\tbeetlSpringViewResolver.setOrder(0);\n\t\tbeetlSpringViewResolver.setConfig(beetlGroupUtilConfiguration);\n\t\treturn beetlSpringViewResolver;\n\t}\n\n\t//配置包扫描\n\t@Bean(name = "beetlSqlScannerConfigurer")\n\tpublic BeetlSqlScannerConfigurer getBeetlSqlScannerConfigurer() {\n\t\tBeetlSqlScannerConfigurer conf = new BeetlSqlScannerConfigurer();\n\t\tconf.setBasePackage("com.forezp.dao");\n\t\tconf.setDaoSuffix("Dao");\n\t\tconf.setSqlManagerFactoryBeanName("sqlManagerFactoryBean");\n\t\treturn conf;\n\t}\n\n\t@Bean(name = "sqlManagerFactoryBean")\n\t@Primary\n\tpublic SqlManagerFactoryBean getSqlManagerFactoryBean(@Qualifier("datasource") DataSource datasource) {\n\t\tSqlManagerFactoryBean factory = new SqlManagerFactoryBean();\n\n\t\tBeetlSqlDataSource source = new BeetlSqlDataSource();\n\t\tsource.setMasterSource(datasource);\n\t\tfactory.setCs(source);\n\t\tfactory.setDbStyle(new MySqlStyle());\n\t\tfactory.setInterceptors(new Interceptor[]{new DebugInterceptor()});\n\t\tfactory.setNc(new UnderlinedNameConversion());//开启驼峰\n\t\tfactory.setSqlLoader(new ClasspathLoader("/sql"));//sql文件路径\n\t\treturn factory;\n\t}\n\n\n\t//配置数据库\n\t@Bean(name = "datasource")\n\tpublic DataSource getDataSource() {\n\t\treturn DataSourceBuilder.create().url("jdbc:mysql://127.0.0.1:3306/test").username("root").password("123456").build();\n\t}\n\n\t//开启事务\n\t@Bean(name = "txManager")\n\tpublic DataSourceTransactionManager getDataSourceTransactionManager(@Qualifier("datasource") DataSource datasource) {\n\t\tDataSourceTransactionManager dsm = new DataSourceTransactionManager();\n\t\tdsm.setDataSource(datasource);\n\t\treturn dsm;\n\t}\n</code></pre>\n<p>在resouces包下，加META_INF文件夹，文件夹中加入spring-devtools.properties:</p>\n<pre><code>restart.include.beetl=/beetl-2.3.2.jar\nrestart.include.beetlsql=/beetlsql-2.3.1.jar\n\n</code></pre>\n<p>在templates下加一个index.btl文件。</p>\n<p>加入jar和配置beatlsql的这些bean，以及resources这些配置之后，springboot就能够访问到数据库类。</p>\n<h2><a id="restful_145"></a>举个restful的栗子</h2>\n<h3><a id="_147"></a>初始化数据库的表</h3>\n<pre><code># DROP TABLE `account` IF EXISTS\nCREATE TABLE `account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `money` double DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nINSERT INTO `account` VALUES (\'1\', \'aaa\', \'1000\');\nINSERT INTO `account` VALUES (\'2\', \'bbb\', \'1000\');\nINSERT INTO `account` VALUES (\'3\', \'ccc\', \'1000\');\n</code></pre>\n<h3><a id="bean_162"></a>bean</h3>\n<pre><code>public class Account {\n    private int id ;\n    private String name ;\n    private double money;\n\n    getter...\n    \n    setter...\n    \n  }  \n</code></pre>\n<h3><a id="dao_177"></a>数据访问dao层</h3>\n<pre><code>public interface AccountDao extends BaseMapper&lt;Account&gt; {\n\n    @SqlStatement(params = "name")\n    Account selectAccountByName(String name);\n}\n\n</code></pre>\n<p>接口继承BaseMapper，就能获取单表查询的一些性质，当你需要自定义sql的时候，只需要在resouses/sql/account.md文件下书写文件：</p>\n<pre><code>\nselectAccountByName\n===\n*根据name获account\n\n    select * from account where name= #name#\n\n  \n</code></pre>\n<p>其中“=== ”上面是唯一标识，对应于接口的方法名，“* ”后面是注释，在下面就是自定义的sql语句，具体的见官方文档。</p>\n<h3><a id="web_203"></a>web层</h3>\n<p>这里省略了service层，实际开发补上。</p>\n<pre><code>\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @Autowired\n    AccountDao accountDao;\n\n    @RequestMapping(value = "/list",method = RequestMethod.GET)\n    public  List&lt;Account&gt; getAccounts(){\n       return accountDao.all();\n    }\n\n    @RequestMapping(value = "/{id}",method = RequestMethod.GET)\n    public  Account getAccountById(@PathVariable("id") int id){\n        return accountDao.unique(id);\n    }\n\n    @RequestMapping(value = "",method = RequestMethod.GET)\n    public  Account getAccountById(@RequestParam("name") String name){\n        return accountDao.selectAccountByName(name);\n    }\n\n    @RequestMapping(value = "/{id}",method = RequestMethod.PUT)\n    public  String updateAccount(@PathVariable("id")int id , @RequestParam(value = "name",required = true)String name,\n    @RequestParam(value = "money" ,required = true)double money){\n        Account account=new Account();\n        account.setMoney(money);\n        account.setName(name);\n        account.setId(id);\n        int t=accountDao.updateById(account);\n        if(t==1){\n            return account.toString();\n        }else {\n            return "fail";\n        }\n    }\n\n    @RequestMapping(value = "",method = RequestMethod.POST)\n    public  String postAccount( @RequestParam(value = "name")String name,\n                                 @RequestParam(value = "money" )double money) {\n        Account account = new Account();\n        account.setMoney(money);\n        account.setName(name);\n        KeyHolder t = accountDao.insertReturnKey(account);\n        if (t.getInt() &gt; 0) {\n            return account.toString();\n        } else {\n            return "fail";\n        }\n    }\n}\n</code></pre>\n<p>通过postman 测试，代码已全部通过。</p>\n<p>个人使用感受，使用bealsql做了一些项目的试验，但是没有真正用于真正的生产环境，用起来非常的爽。但是springboot没有提供自动装配的直接支持，需要自己注解bean。另外使用这个orm的人不太多，有木有坑不知道，在我使用的过程中没有遇到什么问题。另外它的中文文档比较友好。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_269"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_277"></a>参考资料</h2>\n<p><a href="http://www.ibeetl.com/guide/#beetlsql" rel="nofollow">BeetlSQL2.8中文文档</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70545038', 'title': 'SpringBoot非官方教程 | 第四篇：SpringBoot 整合JPA', 'readNum': '74983', 'commentNum': '30', 'publishTime': '2017-04-23 20:37:15', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/04/sb4-jpaJ.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/04/sb4-jpaJ.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/04/sb4-jpaJ.html</a></strong></p>\n<p>JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>\n<p>JPA 的目标之一是制定一个可以由很多供应商实现的API，并且开发人员可以编码来实现该API，而不是使用私有供应商特有的API。</p>\n<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。</p>\n<h2><a id="_13"></a>添加相关依赖</h2>\n<p>添加spring-boot-starter-jdbc依赖：</p>\n<pre><code>\n&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-jpa\n\t\t\t&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>添加mysql连接类和连接池类：</p>\n<pre><code>\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;runtime&lt;/scope&gt;\n\t\t&lt;/dependency&gt; \n\n</code></pre>\n<h2><a id="applicationproperties_38"></a>配置数据源，在application.properties文件配置：</h2>\n<pre><code>spring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8\n    username: root\n    password: 123456\n\n  jpa:\n    hibernate:\n      ddl-auto: update  # 第一次简表create  后面用update\n    show-sql: true\n\n</code></pre>\n<p>注意，如果通过jpa在数据库中建表，将jpa.hibernate,ddl-auto改为create，建完表之后，要改为update,要不然每次重启工程会删除表并新建。</p>\n<h2><a id="_57"></a>创建实体类</h2>\n<p>通过@Entity 表明是一个映射的实体类，  @Id表明id， @GeneratedValue 字段自动生成</p>\n<pre><code>@Entity\npublic class Account {\n    @Id\n    @GeneratedValue\n    private int id ;\n    private String name ;\n    private double money;\n\n...  省略getter setter\n}\n\n</code></pre>\n<h2><a id="Dao_74"></a>Dao层</h2>\n<p>数据访问层，通过编写一个继承自 JpaRepository 的接口就能完成数据访问,其中包含了几本的单表查询的方法，非常的方便。值得注意的是，这个Account 对象名，而不是具体的表名，另外Interger是主键的类型，一般为Integer或者Long</p>\n<pre><code>public interface AccountDao  extends JpaRepository&lt;Account,Integer&gt; {\n}\n\n\n</code></pre>\n<h2><a id="Web_86"></a>Web层</h2>\n<p>在这个栗子中我简略了service层的书写，在实际开发中，不可省略。新写一个controller，写几个restful api来测试数据的访问。</p>\n<pre><code>@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @Autowired\n    AccountDao accountDao;\n\n    @RequestMapping(value = "/list", method = RequestMethod.GET)\n    public List&lt;Account&gt; getAccounts() {\n        return accountDao.findAll();\n    }\n\n    @RequestMapping(value = "/{id}", method = RequestMethod.GET)\n    public Account getAccountById(@PathVariable("id") int id) {\n        return accountDao.findOne(id);\n    }\n\n    @RequestMapping(value = "/{id}", method = RequestMethod.PUT)\n    public String updateAccount(@PathVariable("id") int id, @RequestParam(value = "name", required = true) String name,\n                                @RequestParam(value = "money", required = true) double money) {\n        Account account = new Account();\n        account.setMoney(money);\n        account.setName(name);\n        account.setId(id);\n        Account account1 = accountDao.saveAndFlush(account);\n\n        return account1.toString();\n\n    }\n\n    @RequestMapping(value = "", method = RequestMethod.POST)\n    public String postAccount(@RequestParam(value = "name") String name,\n                              @RequestParam(value = "money") double money) {\n        Account account = new Account();\n        account.setMoney(money);\n        account.setName(name);\n        Account account1 = accountDao.save(account);\n        return account1.toString();\n\n    }\n\n\n}\n\n\n</code></pre>\n<p>通过postman请求测试，代码已经全部通过测试。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_142"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_150"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/accessing-data-jpa/" rel="nofollow">accessing-data-jpa</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70477821', 'title': 'SpringBoot非官方教程 | 第三篇：SpringBoot用JdbcTemplates访问Mysql', 'readNum': '98900', 'commentNum': '37', 'publishTime': '2017-04-22 22:31:56', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于https://www.fangzhipeng.com/springboot/2017/05/03/sb3-Jdbc.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/03/sb3-Jdbc.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/03/sb3-Jdbc.html</a></strong></p>\n<p>本文介绍springboot通过jdbc访问关系型mysql,通过spring的JdbcTemplate去访问。</p>\n<h2><a id="_10"></a>准备工作</h2>\n<ul>\n<li>jdk 1.8</li>\n<li>maven 3.0</li>\n<li>idea</li>\n<li>mysql</li>\n</ul>\n<p>初始化mysql:</p>\n<pre><code>-- create table `account`\nDROP TABLE `account` IF EXISTS\nCREATE TABLE `account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `money` double DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nINSERT INTO `account` VALUES (\'1\', \'aaa\', \'1000\');\nINSERT INTO `account` VALUES (\'2\', \'bbb\', \'1000\');\nINSERT INTO `account` VALUES (\'3\', \'ccc\', \'1000\');\n\n</code></pre>\n<h2><a id="_34"></a>创建工程</h2>\n<h3><a id="_36"></a>引入依赖：</h3>\n<p>在pom文件引入spring-boot-starter-jdbc的依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>引入mysql连接类和连接池：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;runtime&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;druid&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;1.0.29&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>开启web:</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<h3><a id="_74"></a>配置相关文件</h3>\n<p>在application.properties文件配置mysql的驱动类，数据库地址，数据库账号、密码信息。</p>\n<pre><code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\n\n</code></pre>\n<p>通过引入这些依赖和配置一些基本信息，springboot就可以访问数据库类。</p>\n<h2><a id="_89"></a>具体编码</h2>\n<h3><a id="_91"></a>实体类</h3>\n<pre><code>public class Account {\n    private int id ;\n    private String name ;\n    private double money;\n\n....省略了getter. setter\n\n}\n</code></pre>\n<h3><a id="dao_104"></a>dao层</h3>\n<pre><code>public interface IAccountDAO {\n    int add(Account account);\n\n    int update(Account account);\n\n    int delete(int id);\n\n    Account findAccountById(int id);\n\n    List&lt;Account&gt; findAccountList();\n}\n\n\n</code></pre>\n<p>具体的实现类：</p>\n<pre><code>\npackage com.forezp.dao.impl;\n\nimport com.forezp.dao.IAccountDAO;\nimport com.forezp.entity.Account;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n/**\n * Created by fangzhipeng on 2017/4/20.\n */\n@Repository\npublic class AccountDaoImpl implements IAccountDAO {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public int add(Account account) {\n        return jdbcTemplate.update("insert into account(name, money) values(?, ?)",\n              account.getName(),account.getMoney());\n\n    }\n\n    @Override\n    public int update(Account account) {\n        return jdbcTemplate.update("UPDATE  account SET NAME=? ,money=? WHERE id=?",\n                account.getName(),account.getMoney(),account.getId());\n    }\n\n    @Override\n    public int delete(int id) {\n        return jdbcTemplate.update("DELETE from TABLE account where id=?",id);\n    }\n\n    @Override\n    public Account findAccountById(int id) {\n        List&lt;Account&gt; list = jdbcTemplate.query("select * from account where id = ?", new Object[]{id}, new BeanPropertyRowMapper(Account.class));\n        if(list!=null &amp;&amp; list.size()&gt;0){\n            Account account = list.get(0);\n            return account;\n        }else{\n            return null;\n        }\n    }\n\n    @Override\n    public List&lt;Account&gt; findAccountList() {\n        List&lt;Account&gt; list = jdbcTemplate.query("select * from account", new Object[]{}, new BeanPropertyRowMapper(Account.class));\n        if(list!=null &amp;&amp; list.size()&gt;0){\n            return list;\n        }else{\n            return null;\n        }\n    }\n}\n\n</code></pre>\n<h3><a id="service_187"></a>service层</h3>\n<pre><code>public interface IAccountService {\n\n\n    int add(Account account);\n\n    int update(Account account);\n\n    int delete(int id);\n\n    Account findAccountById(int id);\n\n    List&lt;Account&gt; findAccountList();\n\n}\n\n</code></pre>\n<p>具体实现类：</p>\n<pre><code>@Service\npublic class AccountService implements IAccountService {\n    @Autowired\n    IAccountDAO accountDAO;\n    @Override\n    public int add(Account account) {\n        return accountDAO.add(account);\n    }\n\n    @Override\n    public int update(Account account) {\n        return accountDAO.update(account);\n    }\n\n    @Override\n    public int delete(int id) {\n        return accountDAO.delete(id);\n    }\n\n    @Override\n    public Account findAccountById(int id) {\n        return accountDAO.findAccountById(id);\n    }\n\n    @Override\n    public List&lt;Account&gt; findAccountList() {\n        return accountDAO.findAccountList();\n    }\n}\n\n\n</code></pre>\n<h2><a id="restful_api_243"></a>构建一组restful api来展示</h2>\n<pre><code>package com.forezp.web;\n\nimport com.forezp.entity.Account;\nimport com.forezp.service.IAccountService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n/**\n * Created by fangzhipeng on 2017/4/20.\n */\n\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @Autowired\n    IAccountService accountService;\n\n    @RequestMapping(value = "/list",method = RequestMethod.GET)\n    public  List&lt;Account&gt; getAccounts(){\n       return accountService.findAccountList();\n    }\n\n    @RequestMapping(value = "/{id}",method = RequestMethod.GET)\n    public  Account getAccountById(@PathVariable("id") int id){\n        return accountService.findAccountById(id);\n    }\n\n    @RequestMapping(value = "/{id}",method = RequestMethod.PUT)\n    public  String updateAccount(@PathVariable("id")int id , @RequestParam(value = "name",required = true)String name,\n    @RequestParam(value = "money" ,required = true)double money){\n        Account account=new Account();\n        account.setMoney(money);\n        account.setName(name);\n        account.setId(id);\n        int t=accountService.update(account);\n        if(t==1){\n            return account.toString();\n        }else {\n            return "fail";\n        }\n    }\n\n    @RequestMapping(value = "",method = RequestMethod.POST)\n    public  String postAccount( @RequestParam(value = "name")String name,\n                                 @RequestParam(value = "money" )double money){\n        Account account=new Account();\n        account.setMoney(money);\n        account.setName(name);\n        int t= accountService.add(account);\n        if(t==1){\n            return account.toString();\n        }else {\n            return "fail";\n        }\n\n    }\n\n}\n\n\n</code></pre>\n<p>可以通过postman来测试，具体的我已经全部测试通过，没有任何问题。注意restful构建api的风格。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h2><a id="_315"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/relational-data-access/" rel="nofollow">relational-data-access</a></p>\n<h3><a id="_319"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:36 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70437576', 'title': 'SpringBoot非官方教程 | 第二篇：Spring Boot配置文件详解', 'readNum': '105672', 'commentNum': '64', 'publishTime': '2017-04-22 15:04:35', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springboot/2017/05/02/sb2-config-file.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/02/sb2-config-file.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/02/sb2-config-file.html</a></strong></p>\n<p>springboot采纳了建立生产就绪Spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。在一般情况下，我们不需要做太多的配置就能够让spring boot正常运行。在一些特殊的情况下，我们需要做修改一些配置，或者需要有自己的配置属性。</p>\n<h2><a id="_10"></a>一、自定义属性</h2>\n<p>当我们创建一个springboot项目的时候，系统默认会为我们在src/main/java/resources目录下创建一个application.properties。个人习惯，我会将application.properties改为application.yml文件，两种文件格式都支持。</p>\n<p>在application.yml自定义一组属性：</p>\n<pre><code>my:\n name: forezp\n age: 12\n\n</code></pre>\n<p>如果你需要读取配置文件的值只需要加@Value("${属性名}")：</p>\n<pre><code>@RestController\npublic class MiyaController {\n\n    @Value("${my.name}")\n    private String name;\n    @Value("${my.age}")\n    private int age;\n\n    @RequestMapping(value = "/miya")\n    public String miya(){\n        return name+":"+age;\n    }\n\n}\n</code></pre>\n<p>启动工程，访问：localhost:8080/miya,浏览器显示：</p>\n<blockquote>\n<p>forezp:12</p>\n</blockquote>\n<h2><a id="_46"></a>二、将配置文件的属性赋给实体类</h2>\n<p>当我们有很多配置属性的时候，这时我们会把这些属性作为字段来创建一个javabean，并将属性值赋予给他们,比如：</p>\n<pre><code>my:\n name: forezp\n age: 12\n number:  ${random.int}\n uuid : ${random.uuid}\n max: ${random.int(10)}\n value: ${random.value}\n greeting: hi,i\'m  ${my.name}\n\n</code></pre>\n<p>其中配置文件中用到了${random} ，它可以用来生成各种不同类型的随机值。</p>\n<p>怎么讲这些属性赋于给一个javabean 呢，首先创建一个javabean ：</p>\n<pre><code>@ConfigurationProperties(prefix = "my")\n@Component\npublic class ConfigBean {\n\n    private String name;\n    private int age;\n    private int number;\n    private String uuid;\n    private int max;\n    private String value;\n    private String greeting;\n    \n    省略了getter setter....\n\n</code></pre>\n<p>需要加个注解@ConfigurationProperties，并加上它的prrfix。另外@Component可加可不加。另外spring-boot-configuration-processor依赖可加可不加，具体原因不详。</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n\t\t\t&lt;optional&gt;true&lt;/optional&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>另外需要在应用类或者application类，加EnableConfigurationProperties注解。</p>\n<pre><code>\n@RestController\n@EnableConfigurationProperties({ConfigBean.class})\npublic class LucyController {\n    @Autowired\n    ConfigBean configBean;\n\n    @RequestMapping(value = "/lucy")\n    public String miya(){\n        return configBean.getGreeting()+" &gt;&gt;&gt;&gt;"+configBean.getName()+" &gt;&gt;&gt;&gt;"+ configBean.getUuid()+" &gt;&gt;&gt;&gt;"+configBean.getMax();\n    }\n    \n\n</code></pre>\n<p>启动工程，访问localhost:8080/lucy,我们会发现配置文件信息读到了。</p>\n<h2><a id="_113"></a>三、自定义配置文件</h2>\n<p>上面介绍的是我们都把配置文件写到application.yml中。有时我们不愿意把配置都写到application配置文件中，这时需要我们自定义配置文件，比如test.properties:</p>\n<pre><code>com.forezp.name=forezp\ncom.forezp.age=12\n\n</code></pre>\n<p>怎么将这个配置文件信息赋予给一个javabean呢？</p>\n<pre><code>@Configuration\n@PropertySource(value = "classpath:test.properties")\n@ConfigurationProperties(prefix = "com.forezp")\npublic class User {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n\n</code></pre>\n<p>在最新版本的springboot，需要加这三个注解。@Configuration<br>\n@PropertySource(value = “classpath:test.properties”)<br>\n@ConfigurationProperties(prefix = “com.forezp”);在1.4版本需要<br>\nPropertySource加上location。</p>\n<pre><code>@RestController\n@EnableConfigurationProperties({ConfigBean.class,User.class})\npublic class LucyController {\n    @Autowired\n    ConfigBean configBean;\n\n    @RequestMapping(value = "/lucy")\n    public String miya(){\n        return configBean.getGreeting()+" &gt;&gt;&gt;&gt;"+configBean.getName()+" &gt;&gt;&gt;&gt;"+ configBean.getUuid()+" &gt;&gt;&gt;&gt;"+configBean.getMax();\n    }\n\n    @Autowired\n    User user;\n    @RequestMapping(value = "/user")\n    public String user(){\n        return user.getName()+user.getAge();\n    }\n\n}\n\n</code></pre>\n<p>启动工程，打开localhost:8080/user;浏览器会显示：</p>\n<blockquote>\n<p>forezp12</p>\n</blockquote>\n<h2><a id="_181"></a>四、多个环境配置文件</h2>\n<p>在现实的开发环境中，我们需要不同的配置环境；格式为application-{profile}.properties，其中{profile}对应你的环境标识，比如：</p>\n<ul>\n<li>application-test.properties：测试环境</li>\n<li>application-dev.properties：开发环境</li>\n<li>application-prod.properties：生产环境</li>\n</ul>\n<p>怎么使用？只需要我们在application.yml中加：</p>\n<pre><code> spring:\n  profiles:\n    active: dev\n \n</code></pre>\n<p>其中application-dev.yml:</p>\n<pre><code> server:\n  port: 8082\n \n</code></pre>\n<p>启动工程，发现程序的端口不再是8080,而是8082。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h3><a id="_209"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_217"></a>五、参考文献</h2>\n<p><a href="https://www.gitbook.com/book/qbgbook/spring-boot-reference-guide-zh/details" rel="nofollow">spring-boot-reference-guide-zh</a></p>\n<p><a href="http://tengj.top/2017/02/28/springboot2/" rel="nofollow">pring Boot干货系列：（二）配置文件解析</a></p>\n<p><a href="http://blog.didispace.com/springbootproperties/" rel="nofollow">Spring Boot属性配置文件详解</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:36'}
2020-02-05 20:12:37 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70341651', 'title': 'SpringBoot非官方教程 | 第一篇：构建第一个SpringBoot工程', 'readNum': '112113', 'commentNum': '57', 'publishTime': '2017-04-22 00:03:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springboot/2017/05/01/springboot1.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springboot/2017/05/01/springboot1.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/01/springboot1.html</a></strong></p>\n<h2><a id="_7"></a>简介</h2>\n<p>spring boot 它的设计目的就是为例简化开发，开启了各种自动装配，你不想写各种配置文件，引入相关的依赖就能迅速搭建起一个web工程。它采用的是建立生产就绪的应用程序观点，优先于配置的惯例。</p>\n<p>可能你有很多理由不放弃SSM,SSH，但是当你一旦使用了springboot ,你会觉得一切变得简单了，配置变的简单了、编码变的简单了，部署变的简单了，感觉自己健步如飞，开发速度大大提高了。就好比，当你用了IDEA，你会觉得再也回不到Eclipse时代一样。另，本系列教程全部用的IDEA作为开发工具。</p>\n<h2><a id="_12"></a>建构工程</h2>\n<p>你需要：</p>\n<ul>\n<li>15分钟</li>\n<li>jdk 1.8或以上</li>\n<li>maven 3.0+</li>\n<li>Idea</li>\n</ul>\n<p>打开Idea-&gt; new Project -&gt;Spring Initializr -&gt;填写group、artifact -&gt;钩上web(开启web功能）-&gt;点下一步就行了。</p>\n<h2><a id="_24"></a>工程目录</h2>\n<p>创建完工程，工程的目录结构如下：</p>\n<pre><code>- src\n\t-main\n\t\t-java\n\t\t\t-package\n\t\t\t\t-SpringbootApplication\n\t\t-resouces\n\t\t\t- statics\n\t\t\t- templates\n\t\t\t- application.yml\n\t-test\n- pom\n\n\n</code></pre>\n<ul>\n<li>pom文件为基本的依赖管理文件</li>\n<li>resouces 资源文件\n<ul>\n<li>statics 静态资源</li>\n<li>templates 模板资源</li>\n<li>application.yml 配置文件</li>\n</ul>\n</li>\n<li>SpringbootApplication程序的入口。</li>\n</ul>\n<p>pom.xml的依赖：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;springboot-first-application&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;springboot-first-application&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>其中spring-boot-starter-web不仅包含spring-boot-starter,还自动开启了web功能。</p>\n<h2><a id="_111"></a>功能演示</h2>\n<p>说了这么多，你可能还体会不到，举个栗子，比如你引入了Thymeleaf的依赖，spring boot 就会自动帮你引入SpringTemplateEngine，当你引入了自己的SpringTemplateEngine，spring boot就不会帮你引入。它让你专注于你的自己的业务开发，而不是各种配置。</p>\n<p>再举个栗子,建个controller：</p>\n<pre><code>import org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping("/")\n    public String index() {\n        return "Greetings from Spring Boot!";\n    }\n\n}\n\n</code></pre>\n<p>启动SpringbootFirstApplication的main方法，打开浏览器localhost:8080,浏览器显示：</p>\n<blockquote>\n<p>Greetings from Spring Boot!</p>\n</blockquote>\n<h4><a id="_137"></a>神奇之处：</h4>\n<ul>\n<li>你没有做任何的web.xml配置。</li>\n<li>你没有做任何的sping mvc的配置; springboot为你做了。</li>\n<li>你没有配置tomcat ;springboot内嵌tomcat.</li>\n</ul>\n<h4><a id="springboot__143"></a>启动springboot 方式</h4>\n<p>cd到项目主目录:</p>\n<pre><code>mvn clean  \nmvn package  编译项目的jar\n</code></pre>\n<ul>\n<li>mvn spring-boot: run  启动</li>\n<li>cd 到target目录，java -jar  项目.jar</li>\n</ul>\n<h2><a id="springbootbean_155"></a>来看看springboot在启动的时候为我们注入了哪些bean</h2>\n<p>在程序入口加入：</p>\n<pre><code>@SpringBootApplication\npublic class SpringbootFirstApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootFirstApplication.class, args);\n\t}\n\n\t@Bean\n\tpublic CommandLineRunner commandLineRunner(ApplicationContext ctx) {\n\t\treturn args -&gt; {\n\n\t\t\tSystem.out.println("Let\'s inspect the beans provided by Spring Boot:");\n\n\t\t\tString[] beanNames = ctx.getBeanDefinitionNames();\n\t\t\tArrays.sort(beanNames);\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tSystem.out.println(beanName);\n\t\t\t}\n\n\t\t};\n\t}\n\n}\n\n\n</code></pre>\n<p>程序输出：</p>\n<blockquote>\n<p>Let’s inspect the beans provided by Spring Boot:<br>\nbasicErrorController<br>\nbeanNameHandlerMapping<br>\nbeanNameViewResolver<br>\ncharacterEncodingFilter<br>\ncommandLineRunner<br>\nconventionErrorViewResolver<br>\ndefaultServletHandlerMapping<br>\ndefaultViewResolver<br>\ndispatcherServlet<br>\ndispatcherServletRegistration<br>\nduplicateServerPropertiesDetector<br>\nembeddedServletContainerCustomizerBeanPostProcessor<br>\nerror<br>\nerrorAttributes<br>\nerrorPageCustomizer<br>\nerrorPageRegistrarBeanPostProcessor</p>\n</blockquote>\n<blockquote>\n<p>…<br>\n…</p>\n</blockquote>\n<p>在程序启动的时候，springboot自动诸如注入了40-50个bean.</p>\n<h2><a id="_212"></a>单元测试</h2>\n<p>通过@RunWith() @SpringBootTest开启注解：</p>\n<pre><code>@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class HelloControllerIT {\n\n    @LocalServerPort\n    private int port;\n\n    private URL base;\n\n    @Autowired\n    private TestRestTemplate template;\n\n    @Before\n    public void setUp() throws Exception {\n        this.base = new URL("http://localhost:" + port + "/");\n    }\n\n    @Test\n    public void getHello() throws Exception {\n        ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(),\n                String.class);\n        assertThat(response.getBody(), equalTo("Greetings from Spring Boot!"));\n    }\n}\n\n</code></pre>\n<p>运行它会先开启sprigboot工程，然后再测试，测试通过 <sup>.</sup></p>\n<p>源码下载：<a href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>\n<h2><a id="_247"></a>结语</h2>\n<p>市面上有很多springboot的书，有很多springboot的博客，为什么我还要写这样一个系列？到目前为止，我没有看过一本springboot的书，因为还没来得及看，看的都是官方指南，当然也参考了很多的博客，他们都写的非常的棒！在看官方指南和博客的时候，发现他们有很多不同之处，所以我打算写一个来源于官方，通过自己理解加整合写一个系列，所以取名叫《springboot 非官方教程》。我相信我写的可能跟其他人的写的会不太一样。另外，最主要的原因还是提高自己，怀着一个乐于分享的心，将自己的理解分享给更多需要的人。</p>\n<h3><a id="_251"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_259"></a>参考资料</h2>\n<p><a href="https://spring.io/guides/gs/spring-boot/" rel="nofollow">Building an Application with Spring Boot</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:37'}
2020-02-05 20:12:37 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70305336', 'title': '如何用Redlock实现分布式锁', 'readNum': '79622', 'commentNum': '12', 'publishTime': '2017-04-20 21:16:16', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttp://blog.csdn.net/forezp/article/details/70305336<br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/architecture/2017/08/10/redlock-lock.html" rel="nofollow">https://www.fangzhipeng.com/architecture/2017/08/10/redlock-lock.html</a></strong></p>\n<p>之前写过一篇文章<a href="http://blog.csdn.net/forezp/article/details/68957681">《如何在springcloud分布式系统中实现分布式锁？》</a>，由于自己仅仅是阅读了相关的书籍，和查阅了相关的资料，就认为那样的是可行的。那篇文章实现的大概思路是用setNx命令和setEx配合使用。 setNx是一个耗时操作，因为它需要查询这个键是否存在，就算redis的百万的qps，在高并发的场景下，这种操作也是有问题的。关于redis实现分布式锁，redis官方推荐使用redlock。</p>\n<h2><a id="redlock_8"></a>一、redlock简介</h2>\n<p>在不同进程需要互斥地访问共享资源时，分布式锁是一种非常有用的技术手段。实现高效的分布式锁有三个属性需要考虑：</p>\n<ul>\n<li>安全属性：互斥，不管什么时候，只有一个客户端持有锁</li>\n<li>效率属性A:不会死锁</li>\n<li>效率属性B：容错，只要大多数redis节点能够正常工作，客户端端都能获取和释放锁。</li>\n</ul>\n<p>Redlock是redis官方提出的实现分布式锁管理器的算法。这个算法会比一般的普通方法更加安全可靠。关于这个算法的讨论可以看下<a href="https://github.com/antirez/redis-doc/blob/master/topics/distlock.md">官方文档</a>。</p>\n<h2><a id="java_redlock_19"></a>二、怎么用java使用 redlock</h2>\n<p>在pom文件引入redis和redisson依赖：</p>\n<pre><code>&lt;!-- redis--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;!-- redisson--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.redisson&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;redisson&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;3.3.2&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>AquiredLockWorker接口类，，主要是用于获取锁后需要处理的逻辑：</p>\n<pre><code>/**\n * Created by fangzhipeng on 2017/4/5.\n * 获取锁后需要处理的逻辑\n */\npublic interface AquiredLockWorker&lt;T&gt; {\n     T invokeAfterLockAquire() throws Exception;\n}\n\n</code></pre>\n<p>DistributedLocker 获取锁管理类：</p>\n<pre><code>\n/**\n * Created by fangzhipeng on 2017/4/5.\n * 获取锁管理类\n */\npublic interface DistributedLocker {\n\n     /**\n      * 获取锁\n      * @param resourceName  锁的名称\n      * @param worker 获取锁后的处理类\n      * @param &lt;T&gt;\n      * @return 处理完具体的业务逻辑要返回的数据\n      * @throws UnableToAquireLockException\n      * @throws Exception\n      */\n     &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws UnableToAquireLockException, Exception;\n\n     &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception;\n\n}\n</code></pre>\n<p>UnableToAquireLockException ，不能获取锁的异常类：</p>\n<pre><code>/**\n * Created by fangzhipeng on 2017/4/5.\n * 异常类\n */\npublic class UnableToAquireLockException extends RuntimeException {\n\n    public UnableToAquireLockException() {\n    }\n\n    public UnableToAquireLockException(String message) {\n        super(message);\n    }\n\n    public UnableToAquireLockException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n</code></pre>\n<p>RedissonConnector 连接类：</p>\n<pre><code>/**\n * Created by fangzhipeng on 2017/4/5.\n * 获取RedissonClient连接类\n */\n@Component\npublic class RedissonConnector {\n    RedissonClient redisson;\n    @PostConstruct\n    public void init(){\n        redisson = Redisson.create();\n    }\n\n    public RedissonClient getClient(){\n        return redisson;\n    }\n\n}\n\n</code></pre>\n<p>RedisLocker 类，实现了DistributedLocker：</p>\n<pre><code>import org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by fangzhipeng on 2017/4/5.\n */\n@Component\npublic class RedisLocker  implements DistributedLocker{\n\n    private final static String LOCKER_PREFIX = "lock:";\n\n    @Autowired\n    RedissonConnector redissonConnector;\n    @Override\n    public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws InterruptedException, UnableToAquireLockException, Exception {\n\n        return lock(resourceName, worker, 100);\n    }\n\n    @Override\n    public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception {\n        RedissonClient redisson= redissonConnector.getClient();\n        RLock lock = redisson.getLock(LOCKER_PREFIX + resourceName);\n      // Wait for 100 seconds seconds and automatically unlock it after lockTime seconds\n        boolean success = lock.tryLock(100, lockTime, TimeUnit.SECONDS);\n        if (success) {\n            try {\n                return worker.invokeAfterLockAquire();\n            } finally {\n                lock.unlock();\n            }\n        }\n        throw new UnableToAquireLockException();\n    }\n}\n\n</code></pre>\n<p>测试类：</p>\n<pre><code>  @Autowired\n    RedisLocker distributedLocker;\n    @RequestMapping(value = "/redlock")\n    public String testRedlock() throws Exception{\n\n        CountDownLatch startSignal = new CountDownLatch(1);\n        CountDownLatch doneSignal = new CountDownLatch(5);\n        for (int i = 0; i &lt; 5; ++i) { // create and start threads\n            new Thread(new Worker(startSignal, doneSignal)).start();\n        }\n        startSignal.countDown(); // let all threads proceed\n        doneSignal.await();\n        System.out.println("All processors done. Shutdown connection");\n        return "redlock";\n    }\n\n     class Worker implements Runnable {\n        private final CountDownLatch startSignal;\n        private final CountDownLatch doneSignal;\n\n        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n            this.startSignal = startSignal;\n            this.doneSignal = doneSignal;\n        }\n\n        public void run() {\n            try {\n                startSignal.await();\n                distributedLocker.lock("test",new AquiredLockWorker&lt;Object&gt;() {\n\n                    @Override\n                    public Object invokeAfterLockAquire() {\n                        doTask();\n                        return null;\n                    }\n\n                });\n            }catch (Exception e){\n\n            }\n        }\n\n        void doTask() {\n            System.out.println(Thread.currentThread().getName() + " start");\n            Random random = new Random();\n            int _int = random.nextInt(200);\n            System.out.println(Thread.currentThread().getName() + " sleep " + _int + "millis");\n            try {\n                Thread.sleep(_int);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + " end");\n            doneSignal.countDown();\n        }\n    }\n\n</code></pre>\n<p>运行测试类：</p>\n<blockquote>\n<p>Thread-48 start<br>\nThread-48 sleep 99millis<br>\nThread-48 end<br>\nThread-49 start<br>\nThread-49 sleep 118millis<br>\nThread-49 end<br>\nThread-52 start<br>\nThread-52 sleep 141millis<br>\nThread-52 end<br>\nThread-50 start<br>\nThread-50 sleep 28millis<br>\nThread-50 end<br>\nThread-51 start<br>\nThread-51 sleep 145millis<br>\nThread-51 end</p>\n</blockquote>\n<p>从运行结果上看，在异步任务的情况下，确实是获取锁之后才能运行线程。不管怎么样，这是redis官方推荐的一种方案，可靠性比较高。有什么问题欢迎留言。</p>\n<h3><a id="_254"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_262"></a>三、参考资料</h2>\n<p><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p>\n<p><a href="http://ifeve.com/redis-lock/" rel="nofollow">《Redis官方文档》用Redis构建分布式锁</a></p>\n<p><a href="https://dzone.com/articles/java-distributed-in-memory-data-model-powered-by-r" rel="nofollow">A Look at the Java Distributed In-Memory Data Model (Powered by Redis)</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:37'}
2020-02-05 20:12:37 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70233227', 'title': '史上最简单的SpringCloud教程 | 第十三篇: 断路器聚合监控(Hystrix Turbine)', 'readNum': '86847', 'commentNum': '26', 'publishTime': '2017-04-18 21:54:21', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/13/sc-f13-turbine.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041125</p>\n<p>上一篇文章讲述了如何利用Hystrix Dashboard去监控断路器的Hystrix command。当我们有很多个服务的时候，这就需要聚合所以服务的Hystrix Dashboard的数据了。这就需要用到Spring Cloud的另一个组件了，即Hystrix Turbine。</p>\n<h2><a id="Hystrix_Turbine_14"></a>一、Hystrix Turbine简介</h2>\n<p>看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。</p>\n<h2><a id="_18"></a>二、准备工作</h2>\n<p>本文使用的工程为上一篇文章的工程，在此基础上进行改造。因为我们需要多个服务的Dashboard，所以需要再建一个服务，取名为service-lucy，它的基本配置同service-hi，具体见<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter13">源码</a>,在这里就不详细说明。</p>\n<h2><a id="serviceturbine_22"></a>三、创建service-turbine</h2>\n<p>引入相应的依赖：</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-netflix-turbine&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<p>在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。</p>\n<pre><code>\n@SpringBootApplication\n@EnableTurbine\npublic class ServiceTurbineApplication {\n\n\tpublic static void main(String[] args) {\n\n\t\t\tnew SpringApplicationBuilder(ServiceTurbineApplication.class).web(true).run(args);\n\t}\n}\n\n</code></pre>\n<p>配置文件application.yml：</p>\n<pre><code>spring:\n  application.name: service-turbine\nserver:\n  port: 8769\nsecurity.basic.enabled: false\nturbine:\n  aggregator:\n    clusterConfig: default   # 指定聚合哪些集群，多个使用","分割，默认为default。可使用http://.../turbine.stream?cluster={clusterConfig之一}访问\n  appConfig: service-hi,service-lucy  ### 配置Eureka中的serviceId列表，表明监控哪些服务\n  clusterNameExpression: new String("default")\n  # 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称\n  # 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default\n  # 3. 当clusterNameExpression: metadata[\'cluster\']时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n      \n     \n\n</code></pre>\n<p>配置文件注解写的很清楚。</p>\n<h2><a id="Turbine_93"></a>四、Turbine演示</h2>\n<p>依次开启eureka-server、service-hi、service-lucy、service-turbine工程。</p>\n<p>打开浏览器输入：http://localhost:8769/turbine.stream,界面如下：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTM1NzM1NDc0?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>依次请求：</p>\n<blockquote>\n<p>http://localhost:8762/hi?name=forezp</p>\n</blockquote>\n<p>http://localhost:8763/hi?name=forezp</p>\n<p>打开:http://localhost:8763/hystrix,输入监控流http://localhost:8769/turbine.stream</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTQwMDI5NTQw?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>点击monitor stream 进入页面：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTQwMjU2NzU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>可以看到这个页面聚合了2个service的hystrix dashbord数据。</p>\n<p>源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter13">https://github.com/forezp/SpringCloudLearning/tree/master/chapter13</a></p>\n<h3><a id="_120"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_128"></a>五、参考文献</h2>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard" rel="nofollow">hystrix_dashboard</a></p>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_turbine" rel="nofollow">turbine</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:37'}
2020-02-05 20:12:37 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70245644', 'title': '史上最简单的 SpringCloud 教程 | 第十四篇: 服务注册(consul)', 'readNum': '118749', 'commentNum': '49', 'publishTime': '2017-04-19 21:37:35', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springcloud/2017/06/14/sc14-consul.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/14/sc14-consul.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/14/sc14-consul.html</a></strong></p>\n<p>这篇文章主要介绍 spring cloud consul 组件，它是一个提供服务发现和配置的工具。consul具有分布式、高可用、高扩展性。</p>\n<h2><a id="consul__8"></a>一、consul 简介</h2>\n<p>consul 具有以下性质：</p>\n<ul>\n<li>服务发现：consul通过http 方式注册服务，并且服务与服务之间相互感应。</li>\n<li>服务健康监测</li>\n<li>key/value 存储</li>\n<li>多数据中心</li>\n</ul>\n<p>consul可运行在mac windows linux 等机器上。</p>\n<h2><a id="consul_19"></a>二、consul安装</h2>\n<p>linux</p>\n<pre><code>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!\n$ git clone https://github.com/hashicorp/consul.git\n$ cd consul\n$ make bootstrap\n$ make bootstrap\n\n</code></pre>\n<p>windows下安装：<br>\n见<a href="http://blog.csdn.net/forezp/article/details/70188595">consul怎么在windows下安装</a></p>\n<h2><a id="_35"></a>三、构建工程</h2>\n<p>构建一个consul-miya的springboot工程，导入依赖pring-cloud-starter-consul-discovery，其依赖文件：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;consul-miya&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;consul-miya&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RELEASE&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在其入口文件ConsulMiyaApplication加入注解@EnableDiscoveryClient，开启服务发现：</p>\n<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\n@RestController\npublic class ConsulMiyaApplication {\n\n\t@RequestMapping("/hi")\n\tpublic String home() {\n\t\treturn "hi ,i\'m miya";\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew SpringApplicationBuilder(ConsulMiyaApplication.class).web(true).run(args);\n\t}\n}\n</code></pre>\n<p>在其配置文件application.yml指定consul服务的端口为8500：</p>\n<pre><code>spring:\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        healthCheckPath: ${management.contextPath}/health\n        healthCheckInterval: 15s\n        instance-id: consul-miya\n  application:\n    name: consul-miya\nserver:\n  port: 8502\n\n\n\n</code></pre>\n<p>启动工程，访问localhost:8500,可以发现consul-miya被注册了。</p>\n<p>源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter14">https://github.com/forezp/SpringCloudLearning/tree/master/chapter14</a></p>\n<h3><a id="_155"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h4><a id="_163"></a>四、参考资料</h4>\n<p><a href="https://github.com/HashiCorp/consul">HashiCorp/consul</a></p>\n<p><a href="https://github.com/spring-cloud/spring-cloud-consul/blob/master/docs/src/main/asciidoc/spring-cloud-consul.adoc#install-consul">Spring Cloud Consul</a></p>\n<p><a href="https://www.consul.io/docs/upgrading.html" rel="nofollow">consul.io</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:37'}
2020-02-05 20:12:37 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70217283', 'title': '史上最简单的SpringCloud教程 | 第十二篇: 断路器监控(Hystrix Dashboard)', 'readNum': '95092', 'commentNum': '63', 'publishTime': '2017-04-17 23:01:06', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n首发于：https://www.fangzhipeng.com/springcloud/2017/06/12/sc12-hystix-dashbd.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html</a></strong></p>\n<p>最新Finchley版本，请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/12/sc-f12-dash.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041113</p>\n<p>在我的第四篇文章<a href="http://blog.csdn.net/forezp/article/details/69934399">断路器</a>讲述了如何使用断路器，并简单的介绍了下Hystrix Dashboard组件，这篇文章更加详细的介绍Hystrix Dashboard。</p>\n<h2><a id="Hystrix_Dashboard_13"></a>一、Hystrix Dashboard简介</h2>\n<p>在微服务架构中为例保证程序的可用性，防止程序出错导致网络阻塞，出现了断路器模型。断路器的状况反应了一个程序的可用性和健壮性，它是一个重要指标。Hystrix Dashboard是作为断路器状态的一个组件，提供了数据监控和友好的图形化界面。</p>\n<h2><a id="_17"></a>二、准备工作</h2>\n<p>本文的的工程栗子，来源于<a href="http://blog.csdn.net/forezp/article/details/69696915">第一篇文章</a>的栗子，在它的基础上进行改造。</p>\n<h2><a id="servicehi_22"></a>三、开始改造service-hi</h2>\n<p>在pom的工程文件引入相应的依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n</code></pre>\n<p>其中，这三个依赖是必须的，缺一不可。</p>\n<p>在程序的入口ServiceHiApplication类，加上@EnableHystrix注解开启断路器，这个是必须的，并且需要在程序中声明断路点HystrixCommand；加上@EnableHystrixDashboard注解，开启HystrixDashboard</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@RestController\n@EnableHystrix\n@EnableHystrixDashboard\npublic class ServiceHiApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceHiApplication.class, args);\n\t}\n\n\t@Value("${server.port}")\n\tString port;\n\t@RequestMapping("/hi")\n\t@HystrixCommand(fallbackMethod = "hiError")\n\tpublic String home(@RequestParam String name) {\n\t\treturn "hi "+name+",i am from port:" +port;\n\t}\n\n\tpublic String hiError(String name) {\n\t\treturn "hi,"+name+",sorry,error!";\n\t}\n}\n\n</code></pre>\n<p>运行程序： 依次开启eureka-server 和service-hi.</p>\n<h2><a id="Hystrix_Dashboard_76"></a>四、Hystrix Dashboard图形展示</h2>\n<p>打开http://localhost:8762/hystrix.stream，可以看到一些具体的数据：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTExOTA5MTEw?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>打开locahost:8762/hystrix 可以看见以下界面：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTEwNzM5NTQx?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>在界面依次输入：locahost:8762/hystrix.stream 、2000 、miya<br>\n；点确定。</p>\n<p>在另一个窗口输入： http://localhost:8762/hi?name=forezp</p>\n<p>重新刷新hystrix.stream网页，你会看到良好的图形化界面：</p>\n<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDE2MTExMjQzMjYy?x-oss-process=image/format,png" alt="这里写图片描述"></p>\n<p>源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter12">https://github.com/forezp/SpringCloudLearning/tree/master/chapter12</a></p>\n<h2><a id="_100"></a>五、参考资料</h2>\n<p><a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-dashboard">hystrix-dashboard</a></p>\n<h3><a id="_103"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:37'}
2020-02-05 20:12:38 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70198541', 'title': 'Python爬虫，看看我最近博客都写了啥，带你制作高逼格的数据聚合云图', 'readNum': '50406', 'commentNum': '3', 'publishTime': '2017-04-16 21:49:12', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/70198541">http://blog.csdn.net/forezp/article/details/70198541</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>今天一时兴起，想用python爬爬自己的博客，通过数据聚合，制作高逼格的云图(对词汇出现频率视觉上的展示)，看看最近我到底写了啥文章。</p>\n<h2><a id="_6"></a>一、直接上几张我的博客数据的云图</h2>\n<h4><a id="11__8"></a>1.1 爬取文章的标题的聚合</h4>\n<p><img src="https://img-blog.csdnimg.cn/20190601121426899.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121442781.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121502362.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h4><a id="12__18"></a>1.2 爬取文章的摘要的聚合</h4>\n<p><img src="https://img-blog.csdnimg.cn/20190601121518779.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112154136.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h4><a id="13__24"></a>1.3 爬取文章的标题+摘要的聚合</h4>\n<p><img src="https://img-blog.csdnimg.cn/20190601121557665.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121613347.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><strong>我最近写了SpringCloud系列教程，还有一些微服务架构方面，从云图上看，基本吻合。你若不信，可以进我的博客看看，数据还是非常准确的</strong></p>\n<h2><a id="_33"></a>二、技术栈</h2>\n<ul>\n<li>开发工具: pycharm</li>\n<li>爬虫技术：bs64、requsts、jieba</li>\n<li>分析工具：wordArt</li>\n</ul>\n<h2><a id="_39"></a>三、爬虫构架设计</h2>\n<p><img src="https://img-blog.csdnimg.cn/20190601121627537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>整个爬虫架构非常简单：</p>\n<ul>\n<li>爬取我的博客：<a href="http://blog.csdn.net/forezp">http://blog.csdn.net/forezp</a></li>\n<li>获取数据</li>\n<li>将数据用“结巴”库，分词。</li>\n<li>将得到的数据在在artword上制作云图。</li>\n<li>将制作出来的云图展示给用户。</li>\n</ul>\n<h2><a id="_53"></a>四、具体实现</h2>\n<p>先根据博客地址爬去数据：</p>\n<pre><code>url = \'http://blog.csdn.net/forezp\'\n\ntitles=set()\n\ndef download(url):\n    if url is None:\n        return None\n    try:\n        response = requests.get(url, headers={\n            \'User-Agent\': \'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\',\n        })\n        if (response.status_code == 200):\n            return response.content\n        return None\n    except:\n        return None\n\n</code></pre>\n<p>解析标题</p>\n<pre><code>def parse_title(html):\n    if html is None:\n        return None\n    soup = BeautifulSoup(html, "html.parser")\n    links = soup.find_all(\'a\', href=re.compile(r\'/forezp/article/details\'))\n    for link in links:\n\n        titles.add(link.get_text())\n\n</code></pre>\n<p>解析摘要：</p>\n<pre><code>\ndef parse_descrtion(html):\n    if html is None:\n        return None\n    soup=BeautifulSoup(html, "html.parser")\n    disciptions=soup.find_all(\'div\',attrs={\'class\': \'article_description\'})\n    for link in disciptions:\n\n        titles.add(link.get_text())\n\n</code></pre>\n<p>用“结巴”分词，"激8"分词怎么用，看这里：<a href="https://github.com/fxsjy/jieba/">https://github.com/fxsjy/jieba/</a></p>\n<pre><code>def jiebaSet():\n    strs=\'\'\n    if titles.__len__()==0:\n        return\n    for item in titles:\n        strs=strs+item;\n\n\n    tags = jieba.analyse.extract_tags(strs, topK=100, withWeight=True)\n    for item in tags:\n        print(item[0] + \'\\t\' + str(int(item[1] * 1000)))\n</code></pre>\n<p>因为数据比较少，所以我直接打印在控制台，并把它复制下来，更好的方法是存在mongodb中。</p>\n<p>制作云图：<br>\n用 artword在线工具，地址：<a href="https://wordart.com" rel="nofollow">https://wordart.com</a></p>\n<p>首先：<br>\n导入从控制台复制过来的数据：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121652472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>令人尴尬的是，这个网站在绘制图的时候不支持中文，需要你从c:/windows/fonts下选择一个支持中文的字体，mac 用户从windows拷下文件夹也可以，或者在网上下。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601121718145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>然后点击Visulize就可以生成高逼格的云图了。讲解完毕，有什么需要改进的请大家留言。</p>\n<p>源码下载：<a href="https://github.com/forezp/ZhihuSpiderMan/tree/master/blogspider">https://github.com/forezp/ZhihuSpiderMan/tree/master/blogspider</a></p>\n<h3><a id="_139"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h4><a id="_146"></a>五、文章参考</h4>\n<p><a href="http://www.jianshu.com/p/4fb27471295f" rel="nofollow">超简单：快速制作一款高逼格词云图</a></p>\n<h3><a id="_150"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/68951699">如何爬取百万知乎用户信息，并做了简单的分析</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:38'}
2020-02-05 20:12:38 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70188595', 'title': 'consul怎么在windows下安装', 'readNum': '75320', 'commentNum': '14', 'publishTime': '2017-04-15 23:37:54', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/70188595">http://blog.csdn.net/forezp/article/details/70188595</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>去官网下载：<a href="https://www.consul.io/downloads.html" rel="nofollow">https://www.consul.io/downloads.html</a><br>\n解压：<br>\n<img src="http://upload-images.jianshu.io/upload_images/2279594-24b004549def507f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>\n<p>设置环境变量：</p>\n<pre><code>计算机  右键  属性 高级属性设置环境变量设置\n\n在path下加上：E:\\programfiles\\consul；\n</code></pre>\n<p>cmd启动：</p>\n<blockquote>\n<p>consul agent -dev</p>\n</blockquote>\n<p><img src="https://img-blog.csdnimg.cn/20190601121817913.png" alt="在这里插入图片描述"><br>\n可以看到启动成功。</p>\n<p>打开网址：<a href="http://localhost:8500" rel="nofollow">http://localhost:8500</a>  ，可以看到界面，相关服务发现的界面。</p>\n<h3><a id="_23"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:38'}
2020-02-05 20:12:38 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70198649', 'title': '史上最简单的SpringCloud教程 | 第十一篇: docker部署spring cloud项目', 'readNum': '179248', 'commentNum': '95', 'publishTime': '2017-04-16 22:02:22', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springcloud/2017/06/11/sc11-docker.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html</a></strong></p>\n<h2><a id="docker_6"></a>一、docker简介</h2>\n<p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。<br>\nDocker通常用于如下场景：</p>\n<ul>\n<li>web应用的自动化打包和发布；</li>\n<li>自动化测试和持续集成、发布；</li>\n<li>在服务型环境中部署和调整数据库或其他的后台应用；</li>\n<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>\n</ul>\n<p>Docker 的优点</p>\n<ul>\n<li>\n<p>1、简化程序：<br>\nDocker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的\t任务，在Docker容器的处理下，只需要数秒就能完成。</p>\n</li>\n<li>\n<p>2、避免选择恐惧症：<br>\n如果你有选择恐惧症，还是资深患者。Docker 帮你\t打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p>\n</li>\n<li>\n<p>3、节省开支：<br>\n一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>\n</li>\n</ul>\n<p>上面文字参考了相关文章；另，关于docker 的安装和基本的使用见<a href="http://www.runoob.com/docker/docker-tutorial.html" rel="nofollow">相关教程</a>。</p>\n<h2><a id="_29"></a>二、准备工作</h2>\n<p>环境条件：</p>\n<ul>\n<li>linux系统，不建议windows</li>\n<li>docker最新版本</li>\n<li>jdk 1.8</li>\n<li>maven3.0</li>\n</ul>\n<p>本文采用的工程来自第一篇文章的工程，采用maven的方式去构建项目，并采用docker-maven-plugin去构建docker镜像。</p>\n<h2><a id="_40"></a>三、改造工程、构建镜像</h2>\n<h5><a id="eurekaserver_42"></a>改造eureka-server工程</h5>\n<p>在pom文件加上插件：</p>\n<pre><code>&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t\t&lt;!-- tag::plugin[] --&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;com.spotify&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;0.4.3&lt;/version&gt;\n\t\t\t\t&lt;configuration&gt;\n\t\t\t\t\t&lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;\n\t\t\t\t\t&lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;\n\t\t\t\t\t&lt;resources&gt;\n\t\t\t\t\t\t&lt;resource&gt;\n\t\t\t\t\t\t\t&lt;targetPath&gt;/&lt;/targetPath&gt;\n\t\t\t\t\t\t\t&lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n\t\t\t\t\t\t\t&lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n\t\t\t\t\t\t&lt;/resource&gt;\n\t\t\t\t\t&lt;/resources&gt;\n\t\t\t\t&lt;/configuration&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t\t&lt;!-- end::plugin[] --&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n</code></pre>\n<p>Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。</p>\n<ul>\n<li>imageName指定了镜像的名字，本例为 forep/eureka-server</li>\n<li>dockerDirectory指定 Dockerfile 的位置</li>\n<li>resources是指那些需要和 Dockerfile 放在一起，在构建镜像时使用的文件，一般应用 jar 包需要纳入。</li>\n</ul>\n<p>修改下配置文件：</p>\n<pre><code>server:\n  port: 8761\neureka:\n  instance:\n    prefer-ip-address: true\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n\n\n</code></pre>\n<h4><a id="dockerfile_98"></a>编写dockerfile文件：</h4>\n<pre><code>FROM frolvlad/alpine-oraclejdk8:slim\nVOLUME /tmp\nADD eureka-server-0.0.1-SNAPSHOT.jar app.jar\n#RUN bash -c \'touch /app.jar\'\nENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]\nEXPOSE 8761\n\n</code></pre>\n<h4><a id="docker_file_110"></a>docker file编写指令：</h4>\n<ul>\n<li>FROM</li>\n</ul>\n<pre><code>\tFROM &lt;image&gt;\n\tFROM &lt;image&gt;:&lt;tag&gt;\n\tFROM &lt;image&gt; &lt;digest&gt;\n\n</code></pre>\n<p>FROM指令必须指定且需要在Dockerfile其他指令的前面，指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。后续的指令都依赖于该指令指定的image。当在同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令。</p>\n<ul>\n<li>VOLUME</li>\n</ul>\n<p>格式为：</p>\n<pre><code>\t VOLUME ["/data"]\n</code></pre>\n<p>使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。</p>\n<ul>\n<li>ADD</li>\n</ul>\n<p>从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包</p>\n<ul>\n<li>ENTRYPOINT</li>\n</ul>\n<p>指定Docker容器启动时执行的命令，可以多次设置，但是只有最后一个有效。</p>\n<ul>\n<li>EXPOSE</li>\n</ul>\n<p>为Docker容器设置对外的端口号。在启动时，可以使用-p选项或者-P选项。</p>\n<h4><a id="_143"></a>构建镜像</h4>\n<p>执行构建docker镜像maven命令：</p>\n<pre><code>mvn clean\nmvn package docker:build\n\n</code></pre>\n<p><img src="https://img-blog.csdnimg.cn/20190601114057480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>构建eureka-server镜像成功。</p>\n<h4><a id="servicehi_158"></a>同理构建service-hi镜像</h4>\n<ul>\n<li>pom文件导入同eurek-server</li>\n<li>修改下配置文件：</li>\n</ul>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://eureka-server:8761/eureka/ # 这个需要改为eureka-server\nserver:\n  port: 8763\nspring:\n  application:\n    name: service-hi\n\n</code></pre>\n<p>在这里说下：defaultZone发现服务的host改为镜像名。</p>\n<ul>\n<li>\n<p>dockefile 编写同eureka-server</p>\n</li>\n<li>\n<p>构建镜像：</p>\n</li>\n</ul>\n<pre><code>mvn clean\nmvn package docker:build\n\n</code></pre>\n<p><img src="https://img-blog.csdnimg.cn/20190601114116418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>这时我们运行docke的eureka-server 和service-hi镜像：</p>\n<pre><code>docker run -p 8761: 8761 -t forezp/eureka-server\ndocker run -p 8763: 8763 -t forezp/service-hi\n\n</code></pre>\n<p>访问localhost:8761</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601114134655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="dockercompose_202"></a>四、采用docker-compose启动镜像</h2>\n<p>Compose 是一个用于定义和运行多容器的Docker应用的工具。使用Compose，你可以在一个配置文件（yaml格式）中配置你应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。下面我们进入Compose的实战吧。</p>\n<p>采用docker-compose的方式编排镜像，启动镜像：</p>\n<pre><code>version: \'3\'\nservices:\n  eureka-server:\n    image: forezp/eureka-server\n    restart: always\n    ports:\n      - 8761:8761\n\n  service-hi:\n    image: forezp/service-hi\n    restart: always\n    ports:\n      - 8763:8763\n</code></pre>\n<p>输入命令： docker-compose up</p>\n<p><img src="https://img-blog.csdnimg.cn/201906011142016.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>发现2个镜像按照指定的顺序启动了。</p>\n<p>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11</a></p>\n<h2><a id="dockercompose_234"></a>五、采用docker-compose编排并启动镜像</h2>\n<p>docker-compose也可以构建镜像，现在我们采用docker-compose的方式构建镜像。</p>\n<p>现在以eureka-server为例：<br>\n将Dockerfile移到eureka-server的主目录，改写ADD的相对路径：</p>\n<pre><code>\nFROM frolvlad/alpine-oraclejdk8:slim\nVOLUME /tmp\nADD ./target/eureka-server-0.0.1-SNAPSHOT.jar app.jar\n#RUN bash -c \'touch /app.jar\'\nENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]\nEXPOSE 8761\n</code></pre>\n<p>同理修改service-hi目录；</p>\n<p>编写构建镜像docker-compose-dev文件：</p>\n<pre><code>version: \'3\'\nservices:\n  eureka-server:\n    build: eureka-server\n    ports:\n      - 8761:8761\n\n  service-hi:\n    build: service-hi\n    ports:\n      - 8763:8763\n\n\n</code></pre>\n<p>命令构建镜像并启动：</p>\n<pre><code>docker-compose -f docker-compose.yml -f docker-compose-dev.yml up \n\n</code></pre>\n<p><img src="https://img-blog.csdnimg.cn/20190601114221265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11-2">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11-2</a></p>\n<h3><a id="_282"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h2><a id="_290"></a>六、参考文献</h2>\n<p><a href="http://www.runoob.com/docker/docker-tutorial.html" rel="nofollow">docker教程</a></p>\n<p><a href="https://yq.aliyun.com/articles/47344" rel="nofollow">用 Docker 构建、运行、发布一个 Spring Boot 应用</a></p>\n<p><a href="https://github.com/docker/compose">docker-compose</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:38'}
2020-02-05 20:12:38 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70183572', 'title': '史上最简单的SpringCloud教程 | 第十篇: 高可用的服务注册中心', 'readNum': '212538', 'commentNum': '136', 'publishTime': '2017-04-15 11:55:45', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于https://www.fangzhipeng.com/springcloud/2017/06/10/sc-ha-eureka.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/13/sc13-turbine.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/10/sc-f10-eureka.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041101</p>\n<p>文章 <a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a> 介绍了服务注册与发现，其中服务注册中心Eureka Server，是一个实例，当成千上万个服务向它注册的时候，它的负载是非常高的，这在生产环境上是不太合适的，这篇文章主要介绍怎么将Eureka Server集群化。</p>\n<h3><a id="_16"></a>一、准备工作</h3>\n<blockquote>\n<p>Eureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behaviour, so all you need to do to make it work is add a valid serviceUrl to a peer, e.g.</p>\n<p>摘自官网</p>\n</blockquote>\n<p>Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。</p>\n<p>这篇文章我们基于<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter1">第一篇文章的工程</a>，来做修改。</p>\n<h3><a id="_26"></a>二、改造工作</h3>\n<p>在eureka-server工程中resources文件夹下，创建配置文件application-peer1.yml:</p>\n<pre><code>server:\n  port: 8761\n\nspring:\n  profiles: peer1\neureka:\n  instance:\n    hostname: peer1\n  client:\n    serviceUrl:\n      defaultZone: http://peer2:8769/eureka/\n\n</code></pre>\n<p>并且创建另外一个配置文件application-peer2.yml：</p>\n<pre><code>\nserver:\n  port: 8769\n\nspring:\n  profiles: peer2\neureka:\n  instance:\n    hostname: peer2\n  client:\n    serviceUrl:\n      defaultZone: http://peer1:8761/eureka/\n\n</code></pre>\n<p>这时eureka-server就已经改造完毕。</p>\n<blockquote>\n<p>ou could use this configuration to test the peer awareness on a single host (there’s not much value in doing that in production) by manipulating /etc/hosts to resolve the host names.</p>\n</blockquote>\n<p>按照官方文档的指示，需要改变etc/hosts，linux系统通过vim /etc/hosts ,加上：</p>\n<pre><code>127.0.0.1 peer1\n127.0.0.1 peer2\n</code></pre>\n<p>windows电脑，在c:/windows/systems/drivers/etc/hosts 修改。</p>\n<p>这时需要改造下service-hi:</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://peer1:8761/eureka/\nserver:\n  port: 8762\nspring:\n  application:\n    name: service-hi\n\n</code></pre>\n<h3><a id="_90"></a>三、启动工程</h3>\n<p>启动eureka-server：</p>\n<blockquote>\n<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer1</p>\n</blockquote>\n<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer2</p>\n<blockquote></blockquote>\n<p>启动service-hi:</p>\n<blockquote>\n<p>java -jar service-hi-0.0.1-SNAPSHOT.jar</p>\n</blockquote>\n<p>访问：localhost:8761,如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/201906011140051.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>你会发现注册了service-hi，并且有个peer2节点，同理访问localhost:8769你会发现有个peer1节点。</p>\n<p>client只向8761注册，但是你打开8769，你也会发现，8769也有 client的注册信息。</p>\n<p>个人感受：这是通过看官方文档的写的demo ，但是需要手动改host是不是不符合Spring Cloud 的高上大？</p>\n<blockquote>\n<h3><a id="Prefer_IP_Address_117"></a>Prefer IP Address</h3>\n</blockquote>\n<p>In some cases, it is preferable for Eureka to advertise the IP Adresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and when the application registers with eureka, it will use its IP Address rather than its hostname.</p>\n<blockquote>\n<p>摘自官网</p>\n</blockquote>\n<p>eureka.instance.preferIpAddress=true是通过设置ip让eureka让其他服务注册它。也许能通过去改变去通过改变host的方式。</p>\n<p>此时的架构图：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060111401711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>Eureka-eserver peer1 8761,Eureka-eserver peer2 8769相互感应，当有服务注册时，两个Eureka-eserver是对等的，它们都存有相同的信息，这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。</p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter10">https://github.com/forezp/SpringCloudLearning/tree/master/chapter10</a></p>\n<h3><a id="_134"></a>四、参考文献</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_high_availability_zones_and_regions" rel="nofollow">high_availability_zones</a></p>\n<h3><a id="_139"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_147"></a>相关文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:38'}
2020-02-05 20:12:38 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70162074', 'title': '史上最简单的SpringCloud教程 | 第九篇: 服务链路追踪(Spring Cloud Sleuth)', 'readNum': '172959', 'commentNum': '185', 'publishTime': '2017-04-13 21:03:29', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springcloud/2017/06/09/sc09-sleuth.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/09/sc09-sleuth.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/09/sc09-sleuth.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/09/sc-f9-sleuth.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041078</p>\n<p>这篇文章主要讲述服务追踪组件zipkin，Spring Cloud Sleuth集成了zipkin组件。</p>\n<h3><a id="_13"></a>一、简介</h3>\n<blockquote>\n<p>Add sleuth to the classpath of a Spring Boot application (see below for Maven and Gradle examples), and you will see the correlation data being collected in logs, as long as you are logging requests.</p>\n<p>------  <a href="https://github.com/spring-cloud/spring-cloud-sleuth">摘自官网</a></p>\n</blockquote>\n<p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p>\n<h3><a id="_21"></a>二、服务追踪分析</h3>\n<p>微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113719553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113740407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_34"></a>三、术语</h3>\n<ul>\n<li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址)<br>\nspan在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li>\n<li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li>\n<li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束\n<ul>\n<li>cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始</li>\n<li>sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟</li>\n<li>ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间</li>\n<li>cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间<br>\n将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li>\n</ul>\n</li>\n</ul>\n<p>将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113806205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_54"></a>四、构建工程</h3>\n<p>基本知识讲解完毕，下面我们来实战，本文的案例主要有三个工程组成:一个server-zipkin,它的主要作用使用ZipkinServer 的功能，收集调用数据，并展示；一个service-hi,对外暴露hi接口；一个service-miya,对外暴露miya接口；这两个service可以相互调用；并且只有调用了，server-zipkin才会收集数据的，这就是为什么叫服务追踪了。</p>\n<h4><a id="41_serverzipkin_58"></a>4.1 构建server-zipkin</h4>\n<p>建一个spring-boot工程取名为server-zipkin，在其pom引入依赖：</p>\n<pre><code>\n&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Camden.SR6&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n</code></pre>\n<p>在其程序入口类, 加上注解@EnableZipkinServer，开启ZipkinServer的功能：</p>\n<pre><code>@SpringBootApplication\n@EnableZipkinServer\npublic class ServerZipkinApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServerZipkinApplication.class, args);\n\t}\n}\n\n\n</code></pre>\n<p>在配置文件application.yml指定服务端口为：</p>\n<pre><code>server.port=9411\n</code></pre>\n<h4><a id="42_servicehi_125"></a>4.2 创建service-hi</h4>\n<p>在其pom引入起步依赖spring-cloud-starter-zipkin，代码如下：</p>\n<pre><code>&lt;dependencies&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;!--compile(\'org.springframework.cloud:spring-cloud-starter-zipkin\')--&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\n</code></pre>\n<p>在其配置文件application.yml指定zipkin server的地址，头通过配置“spring.zipkin.base-url”指定：</p>\n<pre><code>\nserver.port=8988\nspring.zipkin.base-url=http://localhost:9411\nspring.application.name=service-hi\n\n</code></pre>\n<p>通过引入spring-cloud-starter-zipkin依赖和设置spring.zipkin.base-url就可以了。</p>\n<p>对外暴露接口：</p>\n<pre><code>@SpringBootApplication\n@RestController\npublic class ServiceHiApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceHiApplication.class, args);\n\t}\n\n\tprivate static final Logger LOG = Logger.getLogger(ServiceHiApplication.class.getName());\n\n\n\t@Autowired\n\tprivate RestTemplate restTemplate;\n\n\t@Bean\n\tpublic RestTemplate getRestTemplate(){\n\t\treturn new RestTemplate();\n\t}\n\n\t@RequestMapping("/hi")\n\tpublic String callHome(){\n\t\tLOG.log(Level.INFO, "calling trace service-hi  ");\n\t\treturn restTemplate.getForObject("http://localhost:8989/miya", String.class);\n\t}\n\t@RequestMapping("/info")\n\tpublic String info(){\n\t\tLOG.log(Level.INFO, "calling trace service-hi ");\n\n\t\treturn "i\'m service-hi";\n\n\t}\n\n\t@Bean\n\tpublic AlwaysSampler defaultSampler(){\n\t\treturn new AlwaysSampler();\n\t}\n}\n\n\n\n</code></pre>\n<h4><a id="43_servicemiya_222"></a>4.3 创建service-miya</h4>\n<p>创建过程痛service-hi，引入相同的依赖，配置下spring.zipkin.base-url。</p>\n<p>对外暴露接口：</p>\n<pre><code>\n@SpringBootApplication\n@RestController\npublic class ServiceMiyaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceMiyaApplication.class, args);\n\t}\n\n\tprivate static final Logger LOG = Logger.getLogger(ServiceMiyaApplication.class.getName());\n\n\n\t@RequestMapping("/hi")\n\tpublic String home(){\n\t\tLOG.log(Level.INFO, "hi is being called");\n\t\treturn "hi i\'m miya!";\n\t}\n\n\t@RequestMapping("/miya")\n\tpublic String info(){\n\t\tLOG.log(Level.INFO, "info is being called");\n\t\treturn restTemplate.getForObject("http://localhost:8988/info",String.class);\n\t}\n\n\t@Autowired\n\tprivate RestTemplate restTemplate;\n\n\t@Bean\n\tpublic RestTemplate getRestTemplate(){\n\t\treturn new RestTemplate();\n\t}\n}\n\n</code></pre>\n<h4><a id="44__264"></a>4.4 启动工程，演示追踪</h4>\n<p>依次启动上面的三个工程，打开浏览器访问：http://localhost:9411/，会出现以下界面：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113829177.png" alt="在这里插入图片描述"></p>\n<p>访问：http://localhost:8989/miya，浏览器出现：</p>\n<blockquote>\n<p>i’m service-hi</p>\n</blockquote>\n<p>再打开http://localhost:9411/的界面，点击Dependencies,可以发现服务的依赖关系：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113845599.png" alt="在这里插入图片描述"></p>\n<p>点击find traces,可以看到具体服务相互调用的数据：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113900392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter9">https://github.com/forezp/SpringCloudLearning/tree/master/chapter9</a></p>\n<h3><a id="_288"></a>五、参考资料</h3>\n<p><a href="https://github.com/spring-cloud/spring-cloud-sleuth">spring-cloud-sleuth</a></p>\n<p><a href="https://yq.aliyun.com/articles/60165" rel="nofollow">利用Zipkin对Spring Cloud应用进行服务追踪分析</a></p>\n<p><a href="http://blog.csdn.net/u010257992/article/details/52474639"> Spring Cloud Sleuth使用简介</a></p>\n<h3><a id="_296"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:38'}
2020-02-05 20:12:38 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70148235', 'title': '史上最简单的SpringCloud教程 | 第八篇: 消息总线(Spring Cloud Bus)', 'readNum': '276253', 'commentNum': '211', 'publishTime': '2017-04-12 22:15:48', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n原文首发于：https://www.fangzhipeng.com/springcloud/2017/06/08/sc08-bus.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/08/sc08-bus.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/08/sc08-bus.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/08/sc-f8-bus.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041062</p>\n<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。</p>\n<h3><a id="_14"></a>一、准备工作</h3>\n<p>本文还是基于上一篇文章来实现。按照官方文档，我们只需要在配置文件中配置 spring-cloud-starter-bus-amqp ；这就是说我们需要装rabbitMq，点击<a href="http://www.rabbitmq.com/" rel="nofollow">rabbitmq</a>下载。至于怎么使用 rabbitmq，搜索引擎下。</p>\n<h3><a id="configclient_18"></a>二、改造config-client</h3>\n<p>在pom文件加上起步依赖spring-cloud-starter-bus-amqp，完整的配置文件如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;config-client&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;config-client&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-retry&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在配置文件application.properties中加上RabbitMq的配置，包括RabbitMq的地址、端口，用户名、密码，代码如下：</p>\n<pre><code>\nspring.rabbitmq.host=localhost\nspring.rabbitmq.port=5672\n# spring.rabbitmq.username=\n# spring.rabbitmq.password=\n\n</code></pre>\n<p>如果rabbitmq有用户名密码，输入即可。</p>\n<p>依次启动eureka-server、confg-cserver,启动两个config-client，端口为：8881、8882。</p>\n<p>访问http://localhost:8881/hi  或者http://localhost:8882/hi 浏览器显示：</p>\n<blockquote>\n<p>foo version 3</p>\n</blockquote>\n<p>这时我们去<a href="https://github.com/forezp/SpringcloudConfig/blob/master/respo/config-client-dev.properties">代码仓库</a>将foo的值改为“foo version 4”，即改变配置文件foo的值。如果是传统的做法，需要重启服务，才能达到配置文件的更新。此时，我们只需要发送post请求：http://localhost:8881/bus/refresh，你会发现config-client会重新读取配置文件</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113603550.png" alt="在这里插入图片描述"></p>\n<p>重新读取配置文件：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113618101.png" alt="在这里插入图片描述"></p>\n<p>这时我们再访问http://localhost:8881/hi  或者http://localhost:8882/hi 浏览器显示：</p>\n<blockquote>\n<p>foo version 4</p>\n</blockquote>\n<p>另外，/bus/refresh接口可以指定服务，即使用"destination"参数，比如 “/bus/refresh?destination=customers:**” 即刷新服务名为customers的所有服务，不管ip。</p>\n<h3><a id="_162"></a>三、分析</h3>\n<p>此时的架构图：<br>\n<img src="https://img-blog.csdnimg.cn/20190601113642611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>当git文件更改的时候，通过pc端用post 向端口为8882的config-client发送请求/bus/refresh／；此时8882端口会发送一个消息，由消息总线向其他服务传递，从而使整个微服务集群都达到更新配置文件。</p>\n<h3><a id="_170"></a>四、其他扩展（可忽视）</h3>\n<p>可以用作自定义的Message Broker,只需要spring-cloud-starter-bus-amqp, 然后再配置文件写上配置即可，同上。</p>\n<p>Tracing Bus Events：<br>\n需要设置：spring.cloud.bus.trace.enabled=true，如果那样做的话，那么Spring Boot TraceRepository（如果存在）将显示每个服务实例发送的所有事件和所有的ack,比如：（来自官网）</p>\n<pre><code>{\n  "timestamp": "2015-11-26T10:24:44.411+0000",\n  "info": {\n    "signal": "spring.cloud.bus.ack",\n    "type": "RefreshRemoteApplicationEvent",\n    "id": "c4d374b7-58ea-4928-a312-31984def293b",\n    "origin": "stores:8081",\n    "destination": "*:**"\n  }\n  },\n  {\n  "timestamp": "2015-11-26T10:24:41.864+0000",\n  "info": {\n    "signal": "spring.cloud.bus.sent",\n    "type": "RefreshRemoteApplicationEvent",\n    "id": "c4d374b7-58ea-4928-a312-31984def293b",\n    "origin": "customers:9000",\n    "destination": "*:**"\n  }\n  },\n  {\n  "timestamp": "2015-11-26T10:24:41.862+0000",\n  "info": {\n    "signal": "spring.cloud.bus.ack",\n    "type": "RefreshRemoteApplicationEvent",\n    "id": "c4d374b7-58ea-4928-a312-31984def293b",\n    "origin": "customers:9000",\n    "destination": "*:**"\n  }\n}\n\n</code></pre>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter8">https://github.com/forezp/SpringCloudLearning/tree/master/chapter8</a></p>\n<h3><a id="_213"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_221"></a>五、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_bus" rel="nofollow">spring_cloud_bus</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:38'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70037513', 'title': '史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)', 'readNum': '283139', 'commentNum': '138', 'publishTime': '2017-04-10 21:24:15', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/07/sc07-config.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/07/sc07-config.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/07/sc07-config.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041045</p>\n<p>上一篇文章讲述了一个服务如何从配置中心读取文件，配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用，架构图如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113441210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_15"></a>一、准备工作</h3>\n<p>继续使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。</p>\n<p>在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-eureka-server，代码如下:</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;eureka-server&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;eureka-server&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n</code></pre>\n<p>在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置，代码如下：</p>\n<pre><code>server:\n  port: 8889\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n</code></pre>\n<p>入口类：</p>\n<pre><code>@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaServerApplication.class, args);\n\t}\n}\n\n</code></pre>\n<h3><a id="configserver_131"></a>二、改造config-server</h3>\n<p>在其pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-eureka，代码如下:</p>\n<pre><code>&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n</code></pre>\n<p>配置文件application.yml，指定服务注册地址为http://localhost:8889/eureka/，其他配置同上一篇文章，完整的配置如下：</p>\n<pre><code>spring.application.name=config-server\nserver.port=8888\n\nspring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/\nspring.cloud.config.server.git.searchPaths=respo\nspring.cloud.config.label=master\nspring.cloud.config.server.git.username= your username\nspring.cloud.config.server.git.password= your password\neureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/\n</code></pre>\n<p>最后需要在程序的启动类Application加上@EnableEureka的注解。</p>\n<h3><a id="configclient_171"></a>三、改造config-client</h3>\n<p>将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-eureka，代码如下：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n</code></pre>\n<p>配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为http://localhost:8889/eureka/</p>\n<pre><code>spring.application.name=config-client\nspring.cloud.config.label=master\nspring.cloud.config.profile=dev\n#spring.cloud.config.uri= http://localhost:8888/\n\neureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/\nspring.cloud.config.discovery.enabled=true\nspring.cloud.config.discovery.serviceId=config-server\nserver.port=8881\n\n\n</code></pre>\n<ul>\n<li>spring.cloud.config.discovery.enabled 是从配置中心读取文件。</li>\n<li>spring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。</li>\n</ul>\n<p>这时发现，在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。</p>\n<p>依次启动eureka-servr,config-server,config-client<br>\n访问网址：http://localhost:8889/</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113504267.png" alt="在这里插入图片描述"></p>\n<p>访问http://localhost:8881/hi，浏览器显示：</p>\n<blockquote>\n<p>foo version 3</p>\n</blockquote>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter7">https://github.com/forezp/SpringCloudLearning/tree/master/chapter7</a></p>\n<h3><a id="_232"></a>四、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config" rel="nofollow">spring_cloud_config</a></p>\n<h3><a id="_237"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69939114', 'title': '史上最简单的SpringCloud教程 | 第五篇: 路由网关(zuul)', 'readNum': '335978', 'commentNum': '182', 'publishTime': '2017-04-09 23:25:01', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/05/sc05-zuul.html<br>\n本文出自<a href="https://www.fangzhipeng.com/" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/05/sc05-zuul.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/05/sc05-zuul.html</a></strong></p>\n<p>最新Finchley版本，请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041012</p>\n<p>在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113319320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>\n<strong>注意：A服务和B服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。</strong></p>\n<p>在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。</p>\n<h3><a id="Zuul_18"></a>一、Zuul简介</h3>\n<p>Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。</p>\n<p>zuul有以下功能：</p>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n<h3><a id="_35"></a>二、准备工作</h3>\n<p>继续使用上一节的工程。在原有的工程上，创建一个新的工程。</p>\n<h3><a id="servicezuul_39"></a>三、创建service-zuul工程</h3>\n<p>其pom.xml文件如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;service-zuul&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;service-zuul&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：</p>\n<pre><code>@EnableZuulProxy\n@EnableEurekaClient\n@SpringBootApplication\npublic class ServiceZuulApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceZuulApplication.class, args);\n\t}\n}\n\n\n</code></pre>\n<p>加上配置文件application.yml加上以下的配置代码：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8769\nspring:\n  application:\n    name: service-zuul\nzuul:\n  routes:\n    api-a:\n      path: /api-a/**\n      serviceId: service-ribbon\n    api-b:\n      path: /api-b/**\n      serviceId: service-feign\n\n</code></pre>\n<p>首先指定服务注册中心的地址为http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；</p>\n<p>依次运行这五个工程;打开浏览器访问：http://localhost:8769/api-a/hi?name=forezp ;浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>打开浏览器访问：http://localhost:8769/api-b/hi?name=forezp ;浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>这说明zuul起到了路由的作用</p>\n<h3><a id="_182"></a>四、服务过滤</h3>\n<p>zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；</p>\n<pre><code>@Component\npublic class MyFilter extends ZuulFilter{\n\n    private static Logger log = LoggerFactory.getLogger(MyFilter.class);\n    @Override\n    public String filterType() {\n        return "pre";\n    }\n\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n        log.info(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString()));\n        Object accessToken = request.getParameter("token");\n        if(accessToken == null) {\n            log.warn("token is empty");\n            ctx.setSendZuulResponse(false);\n            ctx.setResponseStatusCode(401);\n            try {\n                ctx.getResponse().getWriter().write("token is empty");\n            }catch (Exception e){}\n\n            return null;\n        }\n        log.info("ok");\n        return null;\n    }\n}\n\n</code></pre>\n<ul>\n<li>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\n<ul>\n<li>pre：路由之前</li>\n<li>routing：路由之时</li>\n<li>post： 路由之后</li>\n<li>error：发送错误调用</li>\n</ul>\n</li>\n<li>filterOrder：过滤的顺序</li>\n<li>shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</li>\n<li>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</li>\n</ul>\n<p>这时访问：http://localhost:8769/api-a/hi?name=forezp ；网页显示：</p>\n<blockquote>\n<p>token is empty</p>\n</blockquote>\n<p>访问 http://localhost:8769/api-a/hi?name=forezp&amp;token=22 ；<br>\n网页显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter5">https://github.com/forezp/SpringCloudLearning/tree/master/chapter5</a></p>\n<h3><a id="_248"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_256"></a>五、参考资料：</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_router_and_filter_zuul" rel="nofollow">router_and_filter_zuul</a></p>\n<h3><a id="_260"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/70037291', 'title': '史上最简单的SpringCloud教程 | 第六篇: 分布式配置中心(Spring Cloud Config)', 'readNum': '432411', 'commentNum': '409', 'publishTime': '2017-04-10 21:18:06', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/06/sc06-config.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/06/sc06-config.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/06/sc06-config.html</a></strong></p>\n<p>最新Finchley版本：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81041028</p>\n<p>在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。</p>\n<h3><a id="_13"></a>一、简介</h3>\n<p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>\n<h3><a id="Config_Server_17"></a>二、构建Config Server</h3>\n<p>创建一个spring-boot项目，取名为config-server,其pom.xml:</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;config-server&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;config-server&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Camden.SR6&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能，代码如下：</p>\n<pre><code>\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ConfigServerApplication.class, args);\n\t}\n}\n\n</code></pre>\n<p>需要在程序的配置文件application.properties文件配置以下：</p>\n<pre><code>spring.application.name=config-server\nserver.port=8888\n\n\nspring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/\nspring.cloud.config.server.git.searchPaths=respo\nspring.cloud.config.label=master\nspring.cloud.config.server.git.username=your username\nspring.cloud.config.server.git.password=your password\n\n\n</code></pre>\n<ul>\n<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>\n<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>\n<li>spring.cloud.config.label：配置仓库的分支</li>\n<li>spring.cloud.config.server.git.username：访问git仓库的用户名</li>\n<li>spring.cloud.config.server.git.password：访问git仓库的用户密码</li>\n</ul>\n<p>如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写，本例子是公开仓库，放心使用。</p>\n<p>远程仓库https://github.com/forezp/SpringcloudConfig/ 中有个文件config-client-dev.properties文件中有一个属性：</p>\n<blockquote>\n<p>foo = foo version 3</p>\n</blockquote>\n<p>启动程序：访问http://localhost:8888/foo/dev</p>\n<pre><code>{"name":"foo","profiles":["dev"],"label":"master",\n"version":"792ffc77c03f4b138d28e89b576900ac5e01a44b","state":null,"propertySources":[]}\n\n</code></pre>\n<p>证明配置服务中心可以从远程程序获取配置信息。</p>\n<p>http请求地址和资源文件映射如下:</p>\n<ul>\n<li>/{application}/{profile}[/{label}]</li>\n<li>/{application}-{profile}.yml</li>\n<li>/{label}/{application}-{profile}.yml</li>\n<li>/{application}-{profile}.properties</li>\n<li>/{label}/{application}-{profile}.properties</li>\n</ul>\n<h3><a id="config_client_164"></a>三、构建一个config client</h3>\n<p>重新创建一个springboot项目，取名为config-client,其pom文件：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;config-client&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;config-client&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>其配置文件<strong>bootstrap.properties</strong>：</p>\n<pre><code>spring.application.name=config-client\nspring.cloud.config.label=master\nspring.cloud.config.profile=dev\nspring.cloud.config.uri= http://localhost:8888/\nserver.port=8881\n\n</code></pre>\n<ul>\n<li>\n<p>spring.cloud.config.label 指明远程仓库的分支</p>\n</li>\n<li>\n<p>spring.cloud.config.profile</p>\n<ul>\n<li>dev开发环境配置文件</li>\n<li>test测试环境</li>\n<li>pro正式环境</li>\n</ul>\n</li>\n<li>\n<p>spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。</p>\n</li>\n</ul>\n<p>程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值，代码如下：</p>\n<pre><code>@SpringBootApplication\n@RestController\npublic class ConfigClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ConfigClientApplication.class, args);\n\t}\n\n\t@Value("${foo}")\n\tString foo;\n\t@RequestMapping(value = "/hi")\n\tpublic String hi(){\n\t\treturn foo;\n\t}\n}\n\n\n</code></pre>\n<p>打开网址访问：http://localhost:8881/hi，网页显示：</p>\n<blockquote>\n<p>foo version 3</p>\n</blockquote>\n<p>这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的,如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113404425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter6">https://github.com/forezp/SpringCloudLearning/tree/master/chapter6</a></p>\n<h3><a id="_307"></a>四、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config" rel="nofollow">spring_cloud_config</a></p>\n<h3><a id="_312"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69934399', 'title': '史上最简单的SpringCloud教程 | 第四篇:断路器（Hystrix）', 'readNum': '332524', 'commentNum': '359', 'publishTime': '2017-04-09 21:14:05', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/04/sc04-hystrix.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/04/sc04-hystrix.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/04/sc04-hystrix.html</a></strong></p>\n<p>最新Finchley版本：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81040990</p>\n<p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>\n<p>为了解决这个问题，业界提出了断路器模型。</p>\n<h3><a id="_16"></a>一、断路器简介</h3>\n<blockquote>\n<p>Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls.</p>\n<p>. ----摘自官网</p>\n</blockquote>\n<p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113135437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113151940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。</p>\n<h3><a id="_32"></a>二、准备工作</h3>\n<p>这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。</p>\n<h3><a id="ribbon_36"></a>三、在ribbon使用断路器</h3>\n<p>改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix：</p>\n<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix\npublic class ServiceRibbonApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceRibbonApplication.class, args);\n\t}\n\n\t@Bean\n\t@LoadBalanced\n\tRestTemplate restTemplate() {\n\t\treturn new RestTemplate();\n\t}\n\n}\n\n</code></pre>\n<p>改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为"hi,"+name+",sorry,error!"，代码如下：</p>\n<pre><code>@Service\npublic class HelloService {\n\n    @Autowired\n    RestTemplate restTemplate;\n\n    @HystrixCommand(fallbackMethod = "hiError")\n    public String hiService(String name) {\n        return restTemplate.getForObject("http://SERVICE-HI/hi?name="+name,String.class);\n    }\n\n    public String hiError(String name) {\n        return "hi,"+name+",sorry,error!";\n    }\n}\n\n\n</code></pre>\n<p>启动：service-ribbon 工程，当我们访问http://localhost:8764/hi?name=forezp,浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>此时关闭 service-hi 工程，当我们再访问http://localhost:8764/hi?name=forezp，浏览器会显示：</p>\n<blockquote>\n<p>hi ,forezp,orry,error!</p>\n</blockquote>\n<p>这就说明当 service-hi 工程不可用的时候，service-ribbon调用 service-hi的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞。</p>\n<h3><a id="Feign_103"></a>四、Feign中使用断路器</h3>\n<p>Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：</p>\n<blockquote>\n<p>feign.hystrix.enabled=true</p>\n</blockquote>\n<p>基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类就行了：</p>\n<pre><code>@FeignClient(value = "service-hi",fallback = SchedualServiceHiHystric.class)\npublic interface SchedualServiceHi {\n    @RequestMapping(value = "/hi",method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = "name") String name);\n}\n\n</code></pre>\n<p>SchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中，代码如下：</p>\n<pre><code>@Component\npublic class SchedualServiceHiHystric implements SchedualServiceHi {\n    @Override\n    public String sayHiFromClientOne(String name) {\n        return "sorry "+name;\n    }\n}\n\n</code></pre>\n<p>启动四servcie-feign工程，浏览器打开http://localhost:8765/hi?name=forezp,注意此时service-hi工程没有启动，网页显示：</p>\n<blockquote>\n<p>sorry forezp</p>\n</blockquote>\n<p>打开service-hi工程，再次访问，浏览器显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>这证明断路器起到作用了。</p>\n<p>五、Hystrix Dashboard (断路器：Hystrix 仪表盘)</p>\n<p>基于service-ribbon 改造，Feign的改造和这一样。</p>\n<p>首选在pom.xml引入spring-cloud-starter-hystrix-dashboard的起步依赖：</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>在主程序启动类中加入@EnableHystrixDashboard注解，开启hystrixDashboard：</p>\n<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix\n@EnableHystrixDashboard\npublic class ServiceRibbonApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceRibbonApplication.class, args);\n\t}\n\n\t@Bean\n\t@LoadBalanced\n\tRestTemplate restTemplate() {\n\t\treturn new RestTemplate();\n\t}\n\n}\n</code></pre>\n<p>打开浏览器：访问http://localhost:8764/hystrix,界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113211133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>点击monitor stream，进入下一个界面，访问：http://localhost:8764/hi?name=forezp</p>\n<p>此时会出现监控界面：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113227909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter4">https://github.com/forezp/SpringCloudLearning/tree/master/chapter4</a></p>\n<h3><a id="_201"></a>六、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients" rel="nofollow">circuit_breaker_hystrix</a></p>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign-hystrix" rel="nofollow">feign-hystrix</a></p>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard" rel="nofollow">hystrix_dashboard</a></p>\n<h3><a id="_209"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69808079', 'title': '史上最简单的SpringCloud教程 | 第三篇: 服务消费者（Feign）', 'readNum': '444083', 'commentNum': '246', 'publishTime': '2017-04-09 11:53:43', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/03/sc03-feign.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/03/sc03-feign.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/03/sc03-feign.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81040965</p>\n<p>上一篇文章，讲述了如何通过RestTemplate+Ribbon去消费服务，这篇文章主要讲述如何通过Feign去消费服务。</p>\n<h3><a id="Feign_14"></a>一、Feign简介</h3>\n<p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>\n<p>简而言之：</p>\n<ul>\n<li>Feign 采用的是基于接口的注解</li>\n<li>Feign 整合了ribbon</li>\n</ul>\n<h3><a id="_23"></a>二、准备工作</h3>\n<p>继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.</p>\n<h3><a id="feign_27"></a>三、创建一个feign的服务</h3>\n<p>新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;service-feign&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;service-feign&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n</code></pre>\n<p>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ ，代码如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8765\nspring:\n  application:\n    name: service-feign\n\n</code></pre>\n<p>在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能：</p>\n<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class ServiceFeignApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceFeignApplication.class, args);\n\t}\n}\n\n\n</code></pre>\n<p>定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口，代码如下：</p>\n<pre><code>\n/**\n * Created by fangzhipeng on 2017/4/6.\n */\n@FeignClient(value = "service-hi")\npublic interface SchedualServiceHi {\n    @RequestMapping(value = "/hi",method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = "name") String name);\n}\n\n\n</code></pre>\n<p>在Web层的controller层，对外暴露一个"/hi"的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务。代码如下：</p>\n<pre><code>@RestController\npublic class HiController {\n\n    @Autowired\n    SchedualServiceHi schedualServiceHi;\n    @RequestMapping(value = "/hi",method = RequestMethod.GET)\n    public String sayHi(@RequestParam String name){\n        return schedualServiceHi.sayHiFromClientOne(name);\n    }\n}\n\n\n</code></pre>\n<p>启动程序，多次访问http://localhost:8765/hi?name=forezp,浏览器交替显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n<p>hi forezp,i am from port:8763</p>\n</blockquote>\n<p>Feign源码解析：http://blog.csdn.net/forezp/article/details/73480304</p>\n<p>本文源码下载：<br>\n<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter3">https://github.com/forezp/SpringCloudLearning/tree/master/chapter3</a></p>\n<h3><a id="_193"></a>五、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign" rel="nofollow">spring-cloud-feign</a></p>\n<h3><a id="_197"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<h3><a id="_203"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69788938', 'title': '史上最简单的SpringCloud教程 | 第二篇: 服务消费者（rest+ribbon）', 'readNum': '493980', 'commentNum': '412', 'publishTime': '2017-04-08 23:25:26', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/02/sc02-rest-ribbon.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/02/sc02-rest-ribbon.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/02/sc02-rest-ribbon.html</a></strong></p>\n<p>最新Finchley版本：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81040946</p>\n<p>在上一篇文章，讲了服务的注册和发现。在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。</p>\n<h3><a id="ribbon_13"></a>一、ribbon简介</h3>\n<blockquote>\n<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>\n<p>-----摘自官网</p>\n</blockquote>\n<p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。</p>\n<p>ribbon 已经默认实现了这些配置bean：</p>\n<ul>\n<li>\n<p>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</p>\n</li>\n<li>\n<p>IRule ribbonRule: ZoneAvoidanceRule</p>\n</li>\n<li>\n<p>IPing ribbonPing: NoOpPing</p>\n</li>\n<li>\n<p>ServerList ribbonServerList: ConfigurationBasedServerList</p>\n</li>\n<li>\n<p>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</p>\n</li>\n<li>\n<p>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</p>\n</li>\n</ul>\n<h3><a id="_37"></a>二、准备工作</h3>\n<p>这一篇文章基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时你会发现：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。访问localhost:8761如图所示：</p>\n<p>如何一个工程启动多个实例，请看这篇文章:https://blog.csdn.net/forezp/article/details/76408139</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601113035445.png" alt="在这里插入图片描述"></p>\n<h4><a id="_45"></a>三、建一个服务消费者</h4>\n<p>重新新建一个spring-boot工程，取名为：service-ribbon;<br>\n在它的pom.xml文件分别引入起步依赖spring-cloud-starter-eureka、spring-cloud-starter-ribbon、spring-boot-starter-web，代码如下：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;service-ribbon&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;service-ribbon&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>在工程的配置文件指定服务的注册中心地址为http://localhost:8761/eureka/，程序名称为 service-ribbon，程序端口为8764。配置文件application.yml如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8764\nspring:\n  application:\n    name: service-ribbon\n</code></pre>\n<p>在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。</p>\n<pre><code>@SpringBootApplication\n@EnableDiscoveryClient\npublic class ServiceRibbonApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceRibbonApplication.class, args);\n\t}\n\n\t@Bean\n\t@LoadBalanced\n\tRestTemplate restTemplate() {\n\t\treturn new RestTemplate();\n\t}\n\n}\n\n</code></pre>\n<p>写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下：</p>\n<pre><code>@Service\npublic class HelloService {\n\n    @Autowired\n    RestTemplate restTemplate;\n\n    public String hiService(String name) {\n        return restTemplate.getForObject("http://SERVICE-HI/hi?name="+name,String.class);\n    }\n\n}\n\n</code></pre>\n<p>写一个controller，在controller中用调用HelloService 的方法，代码如下：</p>\n<pre><code>\n/**\n * Created by fangzhipeng on 2017/4/6.\n */\n@RestController\npublic class HelloControler {\n\n    @Autowired\n    HelloService helloService;\n    @RequestMapping(value = "/hi")\n    public String hi(@RequestParam String name){\n        return helloService.hiService(name);\n    }\n\n\n}\n\n</code></pre>\n<p>在浏览器上多次访问http://localhost:8764/hi?name=forezp，浏览器交替显示：</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n<p>hi forezp,i am from port:8763</p>\n</blockquote>\n<p>这说明当我们通过调用restTemplate.getForObject(“http://SERVICE-HI/hi?name=”+name,String.class)方法时，已经做了负载均衡，访问了不同的端口的服务实例。</p>\n<h3><a id="_218"></a>四、此时的架构</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190601113059775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<ul>\n<li>一个服务注册中心，eureka server,端口为8761</li>\n<li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li>\n<li>sercvice-ribbon端口为8764,向服务注册中心注册</li>\n<li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li>\n</ul>\n<p>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter2">https://github.com/forezp/SpringCloudLearning/tree/master/chapter2</a></p>\n<h3><a id="_229"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_237"></a>五、参考资料</h3>\n<p>本文参考了以下：</p>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-ribbon" rel="nofollow">spring-cloud-ribbon</a></p>\n<p><a href="http://blog.csdn.net/liaokailin/article/details/51469834">springcloud ribbon with eureka</a></p>\n<p><a href="http://blog.didispace.com/springcloud2/" rel="nofollow">服务消费者</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69696915', 'title': '史上最简单的 SpringCloud 教程 | 第一篇： 服务的注册与发现（Eureka）', 'readNum': '827491', 'commentNum': '294', 'publishTime': '2017-04-08 18:16:57', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\nhttps://www.fangzhipeng.com/springcloud/2017/06/01/sc01-eureka.html<br>\n本文出自<a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a></p>\n</blockquote>\n<p><strong><a href="https://www.fangzhipeng.com/share/2017/10/01/resource-sharing.html" rel="nofollow">点击获取SpringCloud 、Spring Boot视频</a></strong></p>\n<p><strong>个人博客纯净版：<a href="https://www.fangzhipeng.com/springcloud/2017/06/01/sc01-eureka.html" rel="nofollow">https://www.fangzhipeng.com/springcloud/2017/06/01/sc01-eureka.html</a></strong></p>\n<p>最新Finchley版本请访问：<br>\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html<br>\n或者<br>\nhttp://blog.csdn.net/forezp/article/details/81040925</p>\n<h3><a id="spring_cloud_13"></a>一、spring cloud简介</h3>\n<p>spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解，如果不了解的话可以看这篇文章：<a href="http://blog.csdn.net/forezp/article/details/61472783">2小时学会springboot</a>。另外对于“微服务架构” 不了解的话，可以通过搜索引擎搜索“微服务架构”了解下。</p>\n<h3><a id="_17"></a>二、创建服务注册中心</h3>\n<p>在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。</p>\n<p><strong>2.1 首先创建一个maven主工程。</strong></p>\n<p>**2.2 然后创建2个model工程:**一个model工程作为服务注册中心，即Eureka Server,另一个作为Eureka Client。</p>\n<p>下面以创建server为例子，详细说明创建过程：</p>\n<p>右键工程-&gt;创建model-&gt; 选择spring initialir 如下图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112843367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>\n下一步-&gt;选择cloud discovery-&gt;eureka server ,然后一直下一步就行了。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112901492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>创建完后的工程的pom.xml文件如下：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;eurekaserver&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;eurekaserver&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;!--eureka server --&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;!-- spring boot test--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p><strong>2.3  启动一个服务注册中心</strong>，只需要一个注解@EnableEurekaServer，这个注解需要在springboot工程的启动application类上加：</p>\n<pre><code>\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaserverApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaserverApplication.class, args);\n\t}\n}\n\n</code></pre>\n<p>**2.4 **eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件application.yml：</p>\n<pre><code>server:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n      \n</code></pre>\n<p>通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server.</p>\n<p><strong>2.5</strong> eureka server 是有界面的，启动工程,打开浏览器访问：<br>\nhttp://localhost:8761 ,界面如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112929314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<blockquote>\n<p>No application available 没有服务被发现 ……<sup>_</sup><br>\n因为没有注册服务当然不可能有服务被发现了。</p>\n</blockquote>\n<h3><a id="_eureka_client_162"></a>三、创建一个服务提供者 (eureka client)</h3>\n<p>当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。</p>\n<p>创建过程同server类似,创建完pom.xml如下：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n\t&lt;groupId&gt;com.forezp&lt;/groupId&gt;\n\t&lt;artifactId&gt;service-hi&lt;/artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\t&lt;packaging&gt;jar&lt;/packaging&gt;\n\n\t&lt;name&gt;service-hi&lt;/name&gt;\n\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n\t&lt;/parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n\t\t&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t&lt;/properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\t&lt;/dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;Dalston.RC1&lt;/version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;/type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;/scope&gt;\n\t\t\t&lt;/dependency&gt;\n\t\t&lt;/dependencies&gt;\n\t&lt;/dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t&lt;/plugins&gt;\n\t&lt;/build&gt;\n\n\t&lt;repositories&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;spring-milestones&lt;/id&gt;\n\t\t\t&lt;name&gt;Spring Milestones&lt;/name&gt;\n\t\t\t&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n\t\t\t&lt;snapshots&gt;\n\t\t\t\t&lt;enabled&gt;false&lt;/enabled&gt;\n\t\t\t&lt;/snapshots&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/repositories&gt;\n\n\n&lt;/project&gt;\n\n\n</code></pre>\n<p>通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</p>\n<pre><code>@SpringBootApplication\n@EnableEurekaClient\n@RestController\npublic class ServiceHiApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ServiceHiApplication.class, args);\n\t}\n\n\t@Value("${server.port}")\n\tString port;\n\t@RequestMapping("/hi")\n\tpublic String home(@RequestParam String name) {\n\t\treturn "hi "+name+",i am from port:" +port;\n\t}\n\n}\n\n\n</code></pre>\n<p>仅仅@EnableEurekaClient是不够的，还需要在配置文件中注明自己的服务注册中心的地址，application.yml配置文件如下：</p>\n<pre><code>eureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8762\nspring:\n  application:\n    name: service-hi\n\n\n</code></pre>\n<p>需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。<br>\n启动工程，打开http://localhost:8761 ，即eureka server 的网址：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601112955184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862</p>\n<p>这时打开 http://localhost:8762/hi?name=forezp ，你会在浏览器上看到 :</p>\n<blockquote>\n<p>hi forezp,i am from port:8762</p>\n</blockquote>\n<p>源码下载：<a href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter1">https://github.com/forezp/SpringCloudLearning/tree/master/chapter1</a></p>\n<h3><a id="_302"></a>更多阅读</h3>\n<p><a href="https://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/70341818">SpringBoot教程汇总</a></p>\n<p><a href="https://blog.csdn.net/forezp/article/details/85163411">Java面试题系列汇总</a></p>\n<h3><a id="_310"></a>四、参考资料</h3>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-eureka-server" rel="nofollow">springcloud eureka server 官方文档</a></p>\n<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_service_discovery_eureka_clients" rel="nofollow">springcloud eureka client 官方文档</a></p>\n<h3><a id="_317"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69056017', 'title': '如何使用MongoDB+Springboot实现分布式ID?', 'readNum': '67543', 'commentNum': '11', 'publishTime': '2017-04-04 11:13:31', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/69056017">http://blog.csdn.net/forezp/article/details/69056017</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n</blockquote>\n<h3><a id="_5"></a>一、背景</h3>\n<p>如何实现分布式id，搜索相关的资料，一般会给出这几种方案：</p>\n<ul>\n<li>使用数据库自增Id</li>\n<li>使用reids的incr命令</li>\n<li>使用UUID</li>\n<li>Twitter的snowflake算法</li>\n<li>利用zookeeper生成唯一ID</li>\n<li>MongoDB的ObjectId</li>\n</ul>\n<p>另外，在我通过爬取知乎用户id发现，知乎的用户id是32位的，初步断定知乎采用的是md5加密，然后全部转换成小写。至于如何爬取知乎用户信息，见我之前分享的文章。本文采取的技术方案采取的是mogoodb的objectId。</p>\n<h3><a id="mongodbID_17"></a>二.mongodb如何实现分布式ID</h3>\n<p>MongoDB的ObjectId设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成它。MongoDB 从一开始就设计用来作为分布式数据库，处理多个节点是一个核心要求。使其在分片环境中要容易生成得多。</p>\n<p>它的格式：<br>\n<img src="http://upload-images.jianshu.io/upload_images/2279594-fa59770ee4c176cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="mongo.png"></p>\n<ul>\n<li>\n<p>前4 个字节是从标准纪元开始的时间戳，单位为秒。时间戳，与随后的5 个字节组合起来，提供了秒级别的唯一性。由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。</p>\n</li>\n<li>\n<p>接下来的3 字节是所在主机的唯一标识符。通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。<br>\n为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的，接下来的两字节来自产生ObjectId 的进程标识符（PID）。</p>\n</li>\n<li>\n<p>前9 字节保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。</p>\n</li>\n<li>\n<p>后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId。</p>\n</li>\n</ul>\n<h3><a id="_32"></a>三、编码</h3>\n<p>在springboot中引入mongodb:</p>\n<pre><code>\n\t   &lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;!-- 开启web--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t\n\n       &lt;!--mongodb --&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n</code></pre>\n<p>创建一个实体类：</p>\n<pre><code>public class Customer {\n\n    @Id\n    public String id;\n\n    public String firstName;\n    public String lastName;\n\n    public Customer() {}\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                "Customer[id=%s, firstName=\'%s\', lastName=\'%s\']",\n                id, firstName, lastName);\n    }\n\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n}\n\n\n</code></pre>\n<p>创建mongodb 接口类：</p>\n<pre><code>/**\n * Created by fangzhipeng on 2017/4/1.\n */\n\n\npublic interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; {\n\n    public Customer findByFirstName(String firstName);\n    public List&lt;Customer&gt; findByLastName(String lastName);\n\n}\n\n</code></pre>\n<p>测试类：</p>\n<pre><code>\n @Autowired\n    CustomerRepository customerRepository;\n\n\n@Test\npublic void mongodbIdTest(){\nCustomer customer=new Customer("lxdxil","dd");\n        customer=customerRepository.save(customer);\n        logger.info( "mongodbId:"+customer.getId());\n}\n \n</code></pre>\n<h3><a id="_148"></a>四、参考资料</h3>\n<p><a href="https://spring.io/guides/gs/accessing-data-mongodb/" rel="nofollow">Accessing Data with MongoDB</a></p>\n<p><a href="http://www.cnblogs.com/xjk15082/archive/2011/09/18/2180792.html" rel="nofollow">MongoDB深究之ObjectId</a></p>\n<p><a href="http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" rel="nofollow">MongoDB 教程</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:39 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/69196483', 'title': '漫谈《大型网站技术架构》', 'readNum': '49045', 'commentNum': '1', 'publishTime': '2017-04-04 20:37:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/69196483">http://blog.csdn.net/forezp/article/details/69196483</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>本文的内容来自阿里巴巴员工李智慧的著作《大型网站技术架构 核心原理与案例分析》，这本书很值得一看，故整理之。</p>\n<h3><a id="_7"></a>一、大型网站的架构演化</h3>\n<h4><a id="11__9"></a>1.1 大型网站软件的特点</h4>\n<ul>\n<li>高并发、大流量</li>\n<li>高可用：系统7*24小时不间断提供服务</li>\n<li>海量数据</li>\n<li>用户分布广泛</li>\n<li>安全环境恶劣</li>\n<li>需求变更快，发布频繁</li>\n<li>渐进式发展</li>\n</ul>\n<h4><a id="12__19"></a>1.2 大型网站架构演化发展历程</h4>\n<ul>\n<li>**初始阶段的网站架构：**例如 LAMP 架构</li>\n<li>**应用和数据服务分离：**三台服务器：应用服务器，文件服务器和数据库服务器</li>\n<li>**使用缓存改善网站性能：**分为两种，缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器的远程缓存</li>\n<li>**使用应用服务器集群改善网站并发处理能力：**通过负载均衡调度服务器来分发请求到应用服务器集群中的任何一台机器</li>\n<li><strong>数据库读写分离：</strong>  主写从读。</li>\n<li>**使用反向代理和 CDN 加速网站响应：**这两者基本原理都是缓存。反向代理部署在网站的中心机房，CDN 部署在网络提供商的机房。</li>\n<li><strong>使用分布式文件系统和分布式数据库系统：</strong> 将不同的业务分布，将不同的业务的数据库部署在不同的机器上。</li>\n<li><strong>使用 NoSQL 和搜索引擎：</strong> 源自互联网技术，对可伸缩的分布式有更好的支持。</li>\n<li>**业务拆分：**将整个网站通过分而治之的手段将网站业务分成不同的产品线。</li>\n<li><strong>分布式服务：</strong> 比如最近流行的微服务，横行、纵向切片，将服务集群化，相互关联化。</li>\n</ul>\n<p><img src="https://img-blog.csdnimg.cn/20190601121935209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h4><a id="13__33"></a>1.3 大型网站架构演化的价值观</h4>\n<ul>\n<li>大型网站架构的核心价值是随网站所需灵活应对</li>\n<li>驱动大型网站技术发展的主要力量是网站的业务发展</li>\n</ul>\n<h4><a id="14__38"></a>1.4 网站架构设计误区</h4>\n<ul>\n<li>一味追随大公司的解决方案</li>\n<li>为了技术而技术</li>\n<li>企图用技术解决所有问题</li>\n</ul>\n<h3><a id="_44"></a>二、大型网站架构模式</h3>\n<h4><a id="21__46"></a>2.1 网站架构模式</h4>\n<ul>\n<li>分层</li>\n<li>分割</li>\n<li>分布式\n<ul>\n<li>分布式应用和服务</li>\n<li>分布式静态资源</li>\n<li>分布式数据和存储</li>\n<li>分布式计算</li>\n</ul>\n</li>\n<li>集群</li>\n<li>缓存\n<ul>\n<li>Cdn</li>\n<li>反向代理</li>\n<li>本地缓存</li>\n<li>分布式缓存</li>\n</ul>\n</li>\n<li>异步\n<ul>\n<li>提供系统可用性</li>\n<li>加快网站响应速度</li>\n<li>消除高并发访问高峰</li>\n</ul>\n</li>\n<li>冗余 服务器冗余运行，数据库冗余备份</li>\n<li>自动化</li>\n<li>安全 ： 防止XSS攻击、sql注入</li>\n</ul>\n<h3><a id="_70"></a>三、大型网站核心架构要素</h3>\n<ul>\n<li>性能</li>\n<li>可用性</li>\n<li>伸缩性 不断地向服务器集群加服务器</li>\n<li>扩张性</li>\n</ul>\n<h3><a id="_77"></a>四、瞬时响应：网站的高性能架构</h3>\n<h4><a id="41__79"></a>4.1 网站性能测试</h4>\n<ul>\n<li>不同视角下网站的性能\n<ul>\n<li>用户视角网站性能 响应时间</li>\n<li>开发人员视角的网站性能 响应时间、并发亮</li>\n<li>运维人员视角的网站性能  资源</li>\n</ul>\n</li>\n<li>性能测试指标\n<ul>\n<li>响应时间</li>\n<li>并发数</li>\n<li>吞吐量 qps tps hps</li>\n<li>性能计数器</li>\n</ul>\n</li>\n<li>性能测试方法\n<ul>\n<li>性能测试</li>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</li>\n<li>性能测试报告</li>\n<li>性能优化策略\n<ul>\n<li>性能分析</li>\n<li>性能优化</li>\n</ul>\n</li>\n</ul>\n<h4><a id="42_web_100"></a>4.2 web前端性能优化</h4>\n<ul>\n<li>浏览器访问优化\n<ul>\n<li>减少http请求</li>\n<li>使用浏览器缓存</li>\n<li>启用压缩</li>\n<li>css放在网页最上面 js最下面</li>\n<li>减少cookie传输</li>\n</ul>\n</li>\n<li>CDN加速。（content distribute network)</li>\n<li>反向代理</li>\n</ul>\n<h4><a id="43__111"></a>4.3 应用服务器性能优化</h4>\n<ul>\n<li>分布式缓存\n<ul>\n<li>缓存的基本原理</li>\n<li>合理的使用缓存\n<ul>\n<li>频繁修改数据</li>\n<li>没有热点的访问</li>\n<li>数据不一致与脏读</li>\n<li>缓存可用性</li>\n<li>缓存预热</li>\n<li>缓存穿透 缓存不存在，直接访问数据库</li>\n</ul>\n</li>\n<li>分布式缓存架构</li>\n<li>Memcached</li>\n</ul>\n</li>\n<li>异步操作</li>\n<li>使用集群</li>\n<li>代码优化\n<ul>\n<li>多线程</li>\n<li>资源复用</li>\n<li>数据结构</li>\n<li>垃圾回收</li>\n</ul>\n</li>\n</ul>\n<h4><a id="44__132"></a>4.4 存储性能优化</h4>\n<ul>\n<li>机械硬盘 vs. 固态硬盘</li>\n<li>B+ 树 vs. LSM 树</li>\n<li>RAID vs. HDFS</li>\n</ul>\n<h3><a id="_138"></a>五、万无一失：网站的高可用架构</h3>\n<h4><a id="51__140"></a>5.1 网站可用性的度量和考核</h4>\n<ul>\n<li>网站可行性度量</li>\n<li>网站可用性考核</li>\n</ul>\n<h4><a id="52__146"></a>5.2 高可用的网站架构</h4>\n<h4><a id="53__149"></a>5.3 高可用的应用</h4>\n<ul>\n<li>通过负载均衡进行无状态服务的失效转移</li>\n<li>应用服务器集群的session管理\n<ul>\n<li>session复制</li>\n<li>session绑定</li>\n<li>利用cookie记录 session</li>\n<li>session服务器</li>\n</ul>\n</li>\n</ul>\n<h4><a id="54__158"></a>5.4 高可用的应用</h4>\n<ul>\n<li>分级管理</li>\n<li>超时设置</li>\n<li>异步调用</li>\n<li>服务降级 随机拒绝访问（twitter)</li>\n<li>幂等性设计</li>\n</ul>\n<h4><a id="55__166"></a>5.5 高可用的数据</h4>\n<ul>\n<li>CAP原理\n<ul>\n<li>数据持久性</li>\n<li>数据可访问性</li>\n<li>数据一致性\n<ul>\n<li>数据强一致性</li>\n<li>数据用户一致性</li>\n<li>数据最终一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据备份</li>\n<li>失效转移\n<ul>\n<li>失效确认</li>\n<li>访问转移</li>\n<li>数据恢复</li>\n</ul>\n</li>\n</ul>\n<h4><a id="56__181"></a>5.6 高可用软件质量保障</h4>\n<ul>\n<li>网站发布</li>\n<li>自动化测试</li>\n<li>预发布验证</li>\n<li>代码控制\n<ul>\n<li>主干开发，分支发布</li>\n<li>分支开发，主干发布</li>\n</ul>\n</li>\n<li>自动化发布</li>\n<li>灰度发布</li>\n</ul>\n<h4><a id="57__192"></a>5.7 网站运行监控</h4>\n<ul>\n<li>监控数据采集\n<ul>\n<li>用户行为日志收集</li>\n<li>服务器性能检测</li>\n<li>运行数据报告</li>\n</ul>\n</li>\n<li>监控管理\n<ul>\n<li>系统报警</li>\n<li>失效转移</li>\n<li>自动优雅降级</li>\n</ul>\n</li>\n</ul>\n<h3><a id="_205"></a>六、永无止尽：网站的伸缩性架构</h3>\n<h4><a id="61__207"></a>6.1 网站伸缩性设计</h4>\n<ul>\n<li>不同功能进行物理分离实现伸缩</li>\n<li>单一功能通过集群实现伸缩</li>\n</ul>\n<h4><a id="62__212"></a>6.2 应用服务器集群伸缩设计</h4>\n<ul>\n<li>http重定向负载均衡</li>\n<li>Dns域名解析负载均衡</li>\n<li>反向代理负载均衡</li>\n<li>ip负载均衡</li>\n<li>数据链路层负载均衡</li>\n<li>负载均衡算法\n<ul>\n<li>轮询</li>\n<li>加权轮询</li>\n<li>随机</li>\n<li>最少链接</li>\n<li>原地址散列</li>\n</ul>\n</li>\n</ul>\n<h4><a id="63__226"></a>6.3 分布式缓存集群的伸缩性设计</h4>\n<ul>\n<li>Memcached分布式缓存集群的访问模型</li>\n<li>Memcached分布式缓存集群的伸缩性挑战</li>\n<li>分布式缓存的一致性hash算法</li>\n</ul>\n<h4><a id="64__232"></a>6.4 数据存储服务器集群的伸缩性设计</h4>\n<ul>\n<li>关系数据库集群的伸缩性设计</li>\n<li>Nosql数据库的伸缩性设计</li>\n</ul>\n<h3><a id="_238"></a>七、随机应变：网站的可扩展性架构</h3>\n<h4><a id="71__240"></a>7.1 构建可扩展性的网站架构</h4>\n<h4><a id="72__242"></a>7.2 利用分布式消息队列降低系统耦合性</h4>\n<ul>\n<li>事件驱动架构</li>\n<li>分布式消息队列</li>\n</ul>\n<h4><a id="73__247"></a>7.3 利用分布式服务打造可复用的业务平台</h4>\n<ul>\n<li>web service与企业级分布式服务</li>\n<li>大型网站分布式服务的需求与特点\n<ul>\n<li>负载均衡</li>\n<li>失效转移</li>\n<li>高效的远程通信</li>\n<li>整合异构系统</li>\n<li>对应用最少侵入</li>\n<li>版本控制</li>\n<li>实时监控</li>\n</ul>\n</li>\n<li>分布式服务框架设计</li>\n</ul>\n<h4><a id="74__260"></a>7.4 可扩展的数据结构</h4>\n<h4><a id="75__262"></a>7.5 利用开放平台建设网站生态圈</h4>\n<ul>\n<li>api接口</li>\n<li>协议转移</li>\n<li>安全</li>\n<li>审计</li>\n<li>路由</li>\n<li>流程</li>\n</ul>\n<h3><a id="8_272"></a>8、固若金汤：网站的安全架构</h3>\n<h4><a id="81__274"></a>8.1 道高一尺魔高一丈的网站应用攻击与防御</h4>\n<ul>\n<li>xss攻击\n<ul>\n<li>消毒</li>\n<li>httponly</li>\n</ul>\n</li>\n<li>注入攻击\n<ul>\n<li>开源</li>\n<li>错误回显</li>\n<li>盲注</li>\n<li>消毒</li>\n<li>参数绑定</li>\n</ul>\n</li>\n<li>csrf攻击\n<ul>\n<li>表单token</li>\n<li>验证码</li>\n<li>referer check</li>\n</ul>\n</li>\n<li>其他攻击和漏洞\n<ul>\n<li>error code</li>\n<li>html注释</li>\n<li>文件上传</li>\n<li>路径遍历</li>\n</ul>\n</li>\n<li>web应用防火墙</li>\n<li>网站安全漏洞扫描</li>\n</ul>\n<h4><a id="82__297"></a>8.2 信息加密技术及密钥安全管理</h4>\n<ul>\n<li>单向散列加密</li>\n<li>对称加密</li>\n<li>非对称加密</li>\n<li>密钥安全管理</li>\n</ul>\n<h4><a id="83__304"></a>8.3 信息过滤与反垃圾</h4>\n<ul>\n<li>文本匹配</li>\n<li>分类算法</li>\n<li>黑名单</li>\n</ul>\n<h4><a id="84__310"></a>8.4 电子商务风险控制</h4>\n<ul>\n<li>风险\n<ul>\n<li>账号风险</li>\n<li>买家风险</li>\n<li>卖家风险</li>\n<li>交易风险</li>\n</ul>\n</li>\n<li>风控\n<ul>\n<li>规则引擎</li>\n<li>统计模型</li>\n</ul>\n</li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:39'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-3_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/68957681', 'title': '如何在springcloud分布式系统中实现分布式锁？', 'readNum': '82785', 'commentNum': '19', 'publishTime': '2017-04-03 11:01:42', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/68957681">http://blog.csdn.net/forezp/article/details/68957681</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n</blockquote>\n<p>最近在看分布式锁的资料，看了 Josial L的《Redis in Action》的分布式锁的章节。实现思路是利用springcloud结合redis实现分布式锁。</p>\n<p>注意：这篇文章有问题，请看这一篇http://blog.csdn.net/forezp/article/details/70305336</p>\n<h3><a id="_8"></a>一、简介</h3>\n<p>一般来说，对数据进行加锁时，程序先通过acquire获取锁来对数据进行排他访问，然后对数据进行一些列的操作，最后需要释放锁。Redis 本身用 watch命令进行了加锁，这个锁是乐观锁。使用 watch命令对于频繁访问的键会引起性能的问题。</p>\n<h3><a id="redis_12"></a>二、redis命令介绍</h3>\n<ul>\n<li>SETNX命令（SET if Not eXists）</li>\n</ul>\n<blockquote>\n<p>当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。</p>\n</blockquote>\n<ul>\n<li>SETEX命令</li>\n</ul>\n<blockquote>\n<p>设置超时时间</p>\n</blockquote>\n<ul>\n<li>GET命令</li>\n</ul>\n<blockquote>\n<p>返回 key 所关联的字符串值，如果 key 不存在那么返回特殊值 nil 。</p>\n</blockquote>\n<ul>\n<li>DEL命令</li>\n</ul>\n<blockquote>\n<p>删除给定的一个或多个 key ,不存在的 key 会被忽略。</p>\n</blockquote>\n<h3><a id="_30"></a>三、实现思路</h3>\n<p>由于redis的setnx命令天生就适合用来实现锁的功能，这个命令只有在键不存在的情况下为键设置值。获取锁之后，其他程序再设置值就会失败，即获取不到锁。获取锁失败。只需不断的尝试获取锁，直到成功获取锁，或者到设置的超时时间为止。</p>\n<p>另外为了防治死锁，即某个程序获取锁之后，程序出错，没有释放，其他程序无法获取锁，从而导致整个分布式系统无法获取锁而导致一系列问题，甚至导致系统无法正常运行。这时需要给锁设置一个超时时间，即setex命令，锁超时后，从而其它程序就可以获取锁了。</p>\n<h4><a id="_36"></a>四、编码实现</h4>\n<p>本文采用springboot结合redis 取实现的，所以你需要装一个redis。</p>\n<ol>\n<li>首先引入创建springboot工程，引入redis 。</li>\n</ol>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;/scope&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;!-- 开启web--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\t\t\n\t\t&lt;!-- redis--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\n</code></pre>\n<p>2.创建一个锁类</p>\n<pre><code>\n/**\n * 全局锁，包括锁的名称\n * Created by fangzhipeng on 2017/4/1.\n */\npublic class Lock {\n    private String name;\n    private String value;\n\n    public Lock(String name, String value) {\n        this.name = name;\n        this.value = value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n}\n\n</code></pre>\n<p>3.创建分布式锁的具体方法,思路已经说清楚了，代码注释也写好了，就不讲解了。</p>\n<pre><code>import org.apache.commons.lang.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.data.redis.core.ValueOperations;\nimport org.springframework.stereotype.Component;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by fangzhipeng on 2017/4/1.\n */\n@Component\npublic class DistributedLockHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(DistributedLockHandler.class);\n    private final static long LOCK_EXPIRE = 30 * 1000L;//单个业务持有锁的时间30s，防止死锁\n    private final static long LOCK_TRY_INTERVAL = 30L;//默认30ms尝试一次\n    private final static long LOCK_TRY_TIMEOUT = 20 * 1000L;//默认尝试20s\n\n    @Autowired\n    private StringRedisTemplate template;\n\n    /**\n     * 尝试获取全局锁\n     *\n     * @param lock 锁的名称\n     * @return true 获取成功，false获取失败\n     */\n    public boolean tryLock(Lock lock) {\n        return getLock(lock, LOCK_TRY_TIMEOUT, LOCK_TRY_INTERVAL, LOCK_EXPIRE);\n    }\n\n    /**\n     * 尝试获取全局锁\n     *\n     * @param lock    锁的名称\n     * @param timeout 获取超时时间 单位ms\n     * @return true 获取成功，false获取失败\n     */\n    public boolean tryLock(Lock lock, long timeout) {\n        return getLock(lock, timeout, LOCK_TRY_INTERVAL, LOCK_EXPIRE);\n    }\n\n    /**\n     * 尝试获取全局锁\n     *\n     * @param lock        锁的名称\n     * @param timeout     获取锁的超时时间\n     * @param tryInterval 多少毫秒尝试获取一次\n     * @return true 获取成功，false获取失败\n     */\n    public boolean tryLock(Lock lock, long timeout, long tryInterval) {\n        return getLock(lock, timeout, tryInterval, LOCK_EXPIRE);\n    }\n\n    /**\n     * 尝试获取全局锁\n     *\n     * @param lock           锁的名称\n     * @param timeout        获取锁的超时时间\n     * @param tryInterval    多少毫秒尝试获取一次\n     * @param lockExpireTime 锁的过期\n     * @return true 获取成功，false获取失败\n     */\n    public boolean tryLock(Lock lock, long timeout, long tryInterval, long lockExpireTime) {\n        return getLock(lock, timeout, tryInterval, lockExpireTime);\n    }\n\n\n    /**\n     * 操作redis获取全局锁\n     *\n     * @param lock           锁的名称\n     * @param timeout        获取的超时时间\n     * @param tryInterval    多少ms尝试一次\n     * @param lockExpireTime 获取成功后锁的过期时间\n     * @return true 获取成功，false获取失败\n     */\n    public boolean getLock(Lock lock, long timeout, long tryInterval, long lockExpireTime) {\n        try {\n            if (StringUtils.isEmpty(lock.getName()) || StringUtils.isEmpty(lock.getValue())) {\n                return false;\n            }\n            long startTime = System.currentTimeMillis();\n            do{\n                if (!template.hasKey(lock.getName())) {\n                    ValueOperations&lt;String, String&gt; ops = template.opsForValue();\n                    ops.set(lock.getName(), lock.getValue(), lockExpireTime, TimeUnit.MILLISECONDS);\n                    return true;\n                } else {//存在锁\n                    logger.debug("lock is exist!！！");\n                }\n                if (System.currentTimeMillis() - startTime &gt; timeout) {//尝试超过了设定值之后直接跳出循环\n                    return false;\n                }\n                Thread.sleep(tryInterval);\n            }\n            while (template.hasKey(lock.getName())) ;\n        } catch (InterruptedException e) {\n            logger.error(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n\n    /**\n     * 释放锁\n     */\n    public void releaseLock(Lock lock) {\n        if (!StringUtils.isEmpty(lock.getName())) {\n            template.delete(lock.getName());\n        }\n    }\n\n}\n\n\n</code></pre>\n<p>4.用法：</p>\n<pre><code>@Autowired\nDistributedLockHandler distributedLockHandler;\nLock lock=new Lock("lockk","sssssssss);\nif(distributedLockHandler.tryLock(lock){\n\tdoSomething();\n\tdistributedLockHandler.releaseLock();\n}\n</code></pre>\n<h3><a id="_229"></a>五、注意点</h3>\n<p>在使用全局锁时为了防止死锁采用 setex命令，这种命令需要根据具体的业务具体设置锁的超时时间。另外一个就是锁的粒度性。比如在redis实战中有个案列，为了实现买卖市场交易的功能，把整个交易市场都锁住了，导致了性能不足的情况，改进方案只对买卖的商品进行加锁而不是整个市场。</p>\n<h3><a id="_233"></a>六、参考资料</h3>\n<p>Josiah.L 《reids in action》</p>\n<p><a href="http://blog.csdn.net/ugg/article/details/41894947">基于Redis实现分布式锁</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:41] - MainThread - INFO - 翻页：5 nextUrl：https://blog.csdn.net/forezp/article/list/5
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/67632333', 'title': '我是如何根据豆瓣api来理解Restful API设计的', 'readNum': '42686', 'commentNum': '1', 'publishTime': '2017-03-28 10:01:25', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h3><a id="1REST_0"></a>1.什么是REST</h3>\n<p>REST全称是Representational State Transfer,表述状态转移的意思。它是在Roy Fielding博士论文首次提出。REST本身没有创造新的技术、组件或服务，它的理念就是在现有的技术之上，更好的使用现有的 web规范。用REST规范的web服务器，能够更好的展现资源，客户端能够更好的使用资源。每个资源都由URI/ID标识。REST本身跟http无关，但是目前http是与它相关的唯一实例。REST有着优雅、简洁的特性，本文是根据豆瓣api来谈谈自己对restful的一些理解。</p>\n<h3><a id="2URI_4"></a>2.URI规范</h3>\n<ul>\n<li>URI(Uniform Resource Identifiers) 统一资源标示符</li>\n<li>URL(Uniform Resource Locator) 统一资源定位符</li>\n</ul>\n<p>URI 的格式：</p>\n<pre><code>\nURI的格式定义如下：  \nURI = scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]  \n\n\n</code></pre>\n<ul>\n<li>uri代表的是一种资源，要做到优雅、简洁。</li>\n<li>最好在api地址标明版本</li>\n</ul>\n<p>比如</p>\n<pre><code>https://api.douban.com/v2\n</code></pre>\n<ul>\n<li>关于分隔符“／”，比如：</li>\n</ul>\n<pre><code>"/"分隔符一般用来对资源层级的划分,比如：\n\nhttps://api.douban.com/v2/book/1220562\n\n表述了豆瓣api，version2下的图书仓库下的编号为1220562的图书。\n\n</code></pre>\n<ul>\n<li>URI尽量使用“-”代替下划线“_“。</li>\n<li>URI统一使用小写字母</li>\n<li>URI不包含文件扩展名</li>\n<li>使用？用来过滤资源，比如？limit=10 :指定返回10条记录。</li>\n<li>不使用无意义的字符串、数字，要做到简洁。</li>\n</ul>\n<h3><a id="3method_43"></a>3.正确使用method</h3>\n<ul>\n<li>get -只用做资源的读取。</li>\n<li>post-通过用作创建一个新的资源。</li>\n<li>delete-通过用作资源的删除。</li>\n<li>put -通过用作更新资源或者创建资源</li>\n<li>head-只获取某个资源的头部信息。</li>\n</ul>\n<p>比如 <a href="https://developers.douban.com/wiki/?title=book_v2" rel="nofollow">豆瓣图书api</a>：</p>\n\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>method</th>\n<th>api</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>获取图书信息</td>\n<td>get</td>\n<td>/v2/book/:id</td>\n</tr>\n<tr>\n<td>用户收藏某本图书</td>\n<td>post</td>\n<td>/v2/book/:id/collection</td>\n</tr>\n<tr>\n<td>用户修改对某本图书的收藏</td>\n<td>put</td>\n<td>/v2/book/:id/collection</td>\n</tr>\n<tr>\n<td>用户删除对某个图书的收藏</td>\n<td>delete</td>\n<td>/v2/book/:id/collection</td>\n</tr>\n</tbody>\n</table><ul>\n<li>另外，在一些不符合curd的情况下，使用\u3000post。</li>\n<li>把动作转换成资源</li>\n</ul>\n<p>比如，上述接口中，用户收藏某本书对外暴露的接口是"/v2/book/:id/collection",收藏动作通过post方法来展现，而不直接写着api中，collection “收藏”，名次，动作直接转换成了资源。</p>\n<p>###4.选择合适的状态码</p>\n<p>http请求需要返回状态码，约定俗成的状态码能够帮助开发团队提高沟通效率。</p>\n<ul>\n<li>2xx: 请求正常处理并返回</li>\n<li>3xx: 重定向</li>\n<li>4xx: 客户端请求有错误</li>\n<li>5xx: 服务端请求有错误</li>\n</ul>\n<p>比如豆瓣api返回的状态码说明：</p>\n\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>ok</td>\n<td>请求成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>created</td>\n<td>创建成功</td>\n</tr>\n<tr>\n<td>202</td>\n<td>accepted</td>\n<td>更新成功</td>\n</tr>\n<tr>\n<td>400</td>\n<td>bad request</td>\n<td>请求不存在</td>\n</tr>\n<tr>\n<td>401</td>\n<td>unauthorized</td>\n<td>未授权</td>\n</tr>\n<tr>\n<td>403</td>\n<td>forbidden</td>\n<td>禁止访问</td>\n</tr>\n<tr>\n<td>404</td>\n<td>not found</td>\n<td>资源不存在</td>\n</tr>\n<tr>\n<td>500</td>\n<td>internal server error</td>\n<td>内部错误</td>\n</tr>\n</tbody>\n</table><h3><a id="5_89"></a>5.使用通用的错误码</h3>\n<p>通用错误码，具体产品由具体产品api给出。比如豆瓣api:</p>\n\n<table>\n<thead>\n<tr>\n<th>错误码</th>\n<th>错误信息</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>999</td>\n<td>unknow_v2_error</td>\n<td>未知错误</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>need_permission</td>\n<td>需要权限</td>\n</tr>\n<tr>\n<td>1001</td>\n<td>uri_not_found</td>\n<td>资源不存在</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table><p>太多了，只列出几条，具体见豆瓣 api。</p>\n<h3><a id="6__102"></a>6. 安全</h3>\n<p>这部分内容不属于这篇文章，但是稍微说明下：</p>\n<ul>\n<li>使用https</li>\n<li>使用jwt验证</li>\n<li>使用参数签名，防止参数被篡改。</li>\n<li>使用权限验证，shiro ,或者自己建数据库（用户、角色、权限）</li>\n</ul>\n<h3><a id="7api_112"></a>7.api文档</h3>\n<p>接口文档的编写至关重要，最好是写一个在线接口文档。接口文档能够方便团队查阅，减少不必要的沟通。如果对外公开api，api文档的质量直接反应了一个公司的技术水平，甚至一个公司的文化气质。</p>\n<h3><a id="8_117"></a>8.参考资料</h3>\n<p>本文参考了以下的资料:</p>\n<p><a href="https://developers.douban.com/wiki/?title=book_v2" rel="nofollow">豆瓣api</a></p>\n<p><a href="http://mccxj.github.io/blog/20130530_introduce-to-rest.html" rel="nofollow">理解restful架构</a></p>\n<p><a href="https://www.tutorialspoint.com/restful/restful_introduction.htm" rel="nofollow">restful introduction</a></p>\n<p><a href="http://cizixs.com/2016/12/12/restful-api-design-guide" rel="nofollow">跟着github学习restful api设计</a></p>\n<p><a href="http://wangwei.info/about-rest-api/" rel="nofollow">REST接口设计规范</a></p>\n<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" rel="nofollow">restful api 设计指南</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/68488589', 'title': '《阿里巴巴Java开发手册》阅读笔记', 'readNum': '41639', 'commentNum': '1', 'publishTime': '2017-03-30 15:41:20', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>\n<p>2.POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</p>\n<blockquote>\n<p>反例： 定义为基本数据类型 boolean isSuccess； 的属性，它的方法也是 isSuccess()， RPC框架在反向解析的时候， “以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。</p>\n</blockquote>\n<p>3.任何运算符左右必须加一个空格。</p>\n<blockquote>\n<p>说明： 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p>\n</blockquote>\n<p>4.单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p>\n<blockquote>\n<p>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</p>\n<p>2） 运算符与下文一起换行。</p>\n</blockquote>\n<blockquote>\n<p>3） 方法调用的点符号与下文一起换行。</p>\n</blockquote>\n<blockquote>\n<p>4） 在多个参数超长，逗号后进行换行。</p>\n</blockquote>\n<blockquote>\n<p>5） 在括号前不要换行，见反例</p>\n</blockquote>\n<p>5.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。同理getter setter</p>\n<p>6.类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*<em>内容</em>/格式，不得使用//xxx 方式。</p>\n<blockquote>\n<p>说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>\n</blockquote>\n<p>7.应用中不可直接使用日志系统（Log4j、 Logback） 中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>\n<p>8.可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别， error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别</p>\n<p>9.字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：</p>\n<blockquote>\n<p>1） 不是频繁修改的字段。<br>\n2） 不是 varchar 超长字段，更不能是 text 字段。</p>\n</blockquote>\n<p>10.单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>\n<blockquote>\n<p>说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>\n</blockquote>\n<p>11.如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p>\n<blockquote>\n<p>正例： where a=? and b=? order by c; 索引： a_b_c</p>\n</blockquote>\n<p>12.利用延迟关联或者子查询优化超多分页场景。</p>\n<blockquote>\n<p>正例： 先快速定位需要获取的 id 段，然后再关联：<br>\nSELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where <a href="http://a.id=b.id" rel="nofollow">a.id=b.id</a></p>\n</blockquote>\n<p>13.不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<blockquote>\n<p>说明： （概念解释） 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群； 级联更新是强阻塞，存在数据库更新风暴的风险； 外键影响数据库的插入速度。</p>\n</blockquote>\n<p>14.禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>\n<p>15.数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>\n<p>16.在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p>\n<blockquote>\n<p>说明： 1） 增加查询分析器解析成本。 2） 增减字段容易与 resultMap 配置不一致。</p>\n</blockquote>\n<p>17.POJO 类的 boolean 属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p>\n<blockquote>\n<p>说明： 参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。</p>\n</blockquote>\n<p>18.xml 配置中参数注意使用： #{}， #param# 不要使用${} 此种方式容易出现 SQL 注入。</p>\n<p>19.分层领域模型规约：</p>\n<ul>\n<li>DO（Data Object） ：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>\n<li>DTO（Data Transfer Object） ：数据传输对象， Service 和 Manager 向外传输的对象。</li>\n<li>BO（Business Object） ：业务对象。 可以由 Service 层输出的封装业务逻辑的对象。</li>\n<li>QUERY：数据查询对象，各层接收上层的查询请求。 注：超过 2 个参数的查询封装，禁止<br>\n使用 Map 类来传输。</li>\n<li>VO（View Object） ：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>\n</ul>\n<p>20.用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</p>\n<p>21.表单、 AJAX 提交必须执行 CSRF 安全过滤。</p>\n<blockquote>\n<p>说明： CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。</p>\n</blockquote>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/68951699', 'title': '如何爬取了知乎用户信息，并做了简单的分析', 'readNum': '48933', 'commentNum': '19', 'publishTime': '2017-04-02 13:05:47', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/68951699">http://blog.csdn.net/forezp/article/details/68951699</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h3><a id="_4"></a>一、使用的技术栈：</h3>\n<ul>\n<li>爬虫：python27 +requests+json+bs4+time</li>\n<li>分析工具： ELK套件</li>\n<li>开发工具：pycharm</li>\n</ul>\n<h3><a id="_10"></a>二、数据成果</h3>\n<h3><a id="_13"></a>三、简单的可视化分析</h3>\n<p>1.性别分布</p>\n<ul>\n<li>0 绿色代表的是男性 ^ . ^</li>\n<li>1 代表的是女性</li>\n<li>-1 性别不确定</li>\n</ul>\n<p>可见知乎的用户男性颇多。</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112202078.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>2.粉丝最多的top30</p>\n<p>粉丝最多的前三十名：依次是张佳玮、李开复、黄继新等等，去知乎上查这些人，也差不多这个排名，说明爬取的数据具有一定的说服力。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122035638.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>3.写文章最多的top30<br>\n<img src="https://img-blog.csdnimg.cn/20190601122050991.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_39"></a>四、爬虫架构</h3>\n<p>爬虫架构图如下：<br>\n<img src="https://img-blog.csdnimg.cn/20190601122107670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>说明：</p>\n<ul>\n<li>选择一个活跃的用户（比如李开复）的url作为入口url.并将已爬取的url存在set中。</li>\n<li>抓取内容，并解析该用户的关注的用户的列表url，添加这些url到另一个set中，并用已爬取的url作为过滤。</li>\n<li>解析该用户的个人信息，并存取到本地磁盘。</li>\n<li>logstash取实时的获取本地磁盘的用户数据，并给elsticsearch</li>\n<li>kibana和elasticsearch配合，将数据转换成用户友好的可视化图形。</li>\n</ul>\n<h4><a id="_52"></a>五.编码</h4>\n<p>爬取一个url:</p>\n<pre><code>def download(url):\n    if url is None:\n        return None\n    try:\n        response = requests.get(url, headers={\n            \'User-Agent\': \'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\',\n            \'authorization\': \'your authorization \'\n        })\n        print (response.content)\n        if (response.status_code == 200):\n            return response.content\n        return None\n    except:\n        return None\n\n</code></pre>\n<p>解析内容：</p>\n<pre><code>def parse(response):\n    try:\n        print (response)\n        json_body = json.loads(response);\n        json_data = json_body[\'data\']\n        for item in json_data:\n            if (not old_url_tokens.__contains__(item[\'url_token\'])):\n                if(new_url_tokens.__len__()&lt;2000):\n                   new_url_tokens.add(item[\'url_token\'])\n            if (not saved_users_set.__contains__(item[\'url_token\'])):\n                jj=json.dumps(item)\n                save(item[\'url_token\'],jj )\n                saved_users_set.add(item[\'url_token\'])\n\n        if (not json_body[\'paging\'][\'is_end\']):\n            next_url = json_body[\'paging\'][\'next\']\n            response2 = download(next_url)\n            parse(response2)\n\n    except:\n        print (\'parse fail\')\n\n</code></pre>\n<p>存本地文件：</p>\n<pre><code>def save(url_token, strs):\n    f = file("\\\\Users\\\\forezp\\\\Downloads\\\\zhihu\\\\user_" + url_token + ".txt", "w+")\n    f.writelines(strs)\n    f.close()\n\n</code></pre>\n<p>代码说明：</p>\n<ul>\n<li>需要修改获取requests请求头的authorization。</li>\n<li>需要修改你的文件存储路径。</li>\n</ul>\n<p>源码下载：<a href="https://github.com/forezp/ZhihuSpiderMan">点击这里</a>，记得star哦！</p>\n<h3><a id="authorization_117"></a>六.如何获取authorization</h3>\n<ul>\n<li>打开chorme，打开https://www.zhihu.com/，</li>\n<li>登陆，首页随便找个用户，进入他的个人主页，F12(或鼠标右键，点检查)</li>\n<li>点击关注，刷新页面，见图：</li>\n</ul>\n<p><img src="https://img-blog.csdnimg.cn/20190601122124676.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="_127"></a>七、可改进的地方</h3>\n<ul>\n<li>可增加线程池，提高爬虫效率</li>\n<li>存储url的时候我才用的set(),并且采用缓存策略，最多只存2000个url，防止内存不够，其实可以存在redis中。</li>\n<li>存储爬取后的用户我说采取的是本地文件的方式，更好的方式应该是存在mongodb中。</li>\n<li>对爬取的用户应该有一个信息的过滤，比如用户的粉丝数需要大与100或者参与话题数大于10等才存储。防止抓取了过多的僵尸用户。</li>\n</ul>\n<h3><a id="ELK_134"></a>八.关于ELK套件</h3>\n<p>关于elk的套件安装就不讨论了，具体见官网就行了。网站：<a href="https://www.elastic.co/" rel="nofollow">https://www.elastic.co/</a></p>\n<p>另外logstash的配置文件如下：</p>\n<pre><code>\ninput {\n  # For detail config for log4j as input,\n  # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html\n\n    file {\n        path =&gt; "/Users/forezp/Downloads/zhihu/*"\n    }\n\n\n}\nfilter {\n  #Only matched data are send to output.\n}\noutput {\n  # For detail config for elasticsearch as output,\n  # See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html\n elasticsearch {\n    action =&gt; "index"          #The operation on ES\n    hosts  =&gt; "localhost:9200"   #ElasticSearch host, can be array.\n    index  =&gt; "zhihu"         #The index to write data to.\n  }\n}\n\n</code></pre>\n<h3><a id="_167"></a>九、结语</h3>\n<p>从爬取的用户数据可分析的地方很多，比如地域、学历、年龄等等，我就不一一列举了。另外，我觉得爬虫是一件非常有意思的事情，在这个内容消费升级的年代，如何在广阔的互联网的数据海洋中挖掘有价值的数据，是一件值得思考和需不断践行的事情。最后，本文仅用作交流学习。如果知乎告知我侵权，我会立刻删除本文。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/67632323', 'title': '常见的安全算法', 'readNum': '39476', 'commentNum': '0', 'publishTime': '2017-03-28 10:00:36', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。</p>\n<h2><a id="_2"></a>一、数字摘要算法</h2>\n<blockquote>\n<p>数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容"摘要"成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是"真身"的"指纹"了。</p>\n</blockquote>\n<h3><a id="1_Md5_7"></a>1. Md5</h3>\n<p>MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。</p>\n<pre><code>import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * Message Digest Algorithm 5(信息摘要算法5)\n */\npublic class MD5Util {\n\t/**\n\t * Constructs the MD5Util object and sets the string whose MD5Util is to be\n\t * computed.\n\t * \n\t * @param inStr\n\t *    the &lt;code&gt;String&lt;/code&gt; whose MD5Util is to be computed\n\t */\n\t\n\t\n\tpublic final static String COMMON_KEY="zhongzhuoxin#@!321";\n\tpublic MD5Util() {\n\n\t}\n\n\tpublic final static String str2MD5(String inStr) {\n\t\tchar hexDigits[] = { \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\',\n\t\t\t\t\'a\', \'b\', \'c\', \'d\', \'e\', \'f\' };\n\t\ttry {\n\t\t\tbyte[] strTemp = inStr.getBytes("UTF-8");\n\t\t\tMessageDigest mdTemp = MessageDigest.getInstance("MD5");\n\t\t\tmdTemp.update(strTemp);\n\t\t\tbyte[] md = mdTemp.digest();\n\t\t\tint j = md.length;\n\t\t\tchar str[] = new char[j * 2];\n\t\t\tint k = 0;\n\t\t\tfor (int i = 0; i &lt; j; i++) {\n\t\t\t\tbyte byte0 = md[i];\n\t\t\t\tstr[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];\n\t\t\t\tstr[k++] = hexDigits[byte0 &amp; 0xf];\n\t\t\t}\n\t\t\treturn new String(str);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\t//--MD5Util\n\tprivate static final char HEX_DIGITS[] = { \'0\', \'1\', \'2\', \'3\', \'4\', \'5\',\n\t\t\t\'6\', \'7\', \'8\', \'9\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\' };\n\n\tpublic static String toHexString(byte[] b) { // String to byte\n\t\tStringBuilder sb = new StringBuilder(b.length * 2);\n\t\tfor (int i = 0; i &lt; b.length; i++) {\n\t\t\tsb.append(HEX_DIGITS[(b[i] &amp; 0xf0) &gt;&gt;&gt; 4]);\n\t\t\tsb.append(HEX_DIGITS[b[i] &amp; 0x0f]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String AndroidMd5(String s) {\n\t\ttry {\n\t\t\t// Create MD5Util Hash\n\t\t\tMessageDigest digest = MessageDigest\n\t\t\t\t\t.getInstance("MD5");\n\t\t\tdigest.update(s.getBytes());\n\t\t\tbyte messageDigest[] = digest.digest();\n\n\t\t\treturn toHexString(messageDigest);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn "";\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tString m = MD5Util.str2MD5("swwwwwwwwwwdkinner");\n\n\t\tSystem.out.print(m.length() + "    ");\n\t\tSystem.out.println(m);\n\n\t}\n}\n\n</code></pre>\n<p>###2.SHA</p>\n<p>SHA的全称是Secure Hash Algorithm，即安全散列算法。 1993年，安全散列算法(SHA)由美国国家标准和技术协会（NIST)提出，并作为联邦信息处理标准(FIPS PUB 180)公布， 1995年又发布了一个修订版FIPS PUB 180-1，通常称之为SHA-1。 SHA-1是基于MD4算法的，现在已成为公认的最安全的散列算法之一，并被广泛使用。SHA-1算法生成的摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。</p>\n<pre><code>\n\nimport com.google.common.base.Strings;\n\nimport java.security.MessageDigest;\n\n/**\n * SHA的全称是Secure Hash Algorithm，即安全散列算法\n * Created by fangzhipeng on 2017/3/21.\n */\npublic class SHAUtil {\n\n    /**\n     * 定义加密方式\n     */\n    private final static String KEY_SHA = "SHA";\n    private final static String KEY_SHA1 = "SHA-1";\n    /**\n     * 全局数组\n     */\n    private final static String[] hexDigits = { "0", "1", "2", "3", "4", "5",\n            "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" };\n\n    /**\n     * 构造函数\n     */\n    public SHAUtil() {\n\n    }\n\n    /**\n     * SHA 加密\n     * @param data 需要加密的字节数组\n     * @return 加密之后的字节数组\n     * @throws Exception\n     */\n    public static byte[] encryptSHA(byte[] data) throws Exception {\n        // 创建具有指定算法名称的信息摘要\n//        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);\n        MessageDigest sha = MessageDigest.getInstance(KEY_SHA1);\n        // 使用指定的字节数组对摘要进行最后更新\n        sha.update(data);\n        // 完成摘要计算并返回\n        return sha.digest();\n    }\n\n    /**\n     * SHA 加密\n     * @param data 需要加密的字符串\n     * @return 加密之后的字符串\n     * @throws Exception\n     */\n    public static String encryptSHA(String data) throws Exception {\n        // 验证传入的字符串\n        if (Strings.isNullOrEmpty(data)) {\n            return "";\n        }\n        // 创建具有指定算法名称的信息摘要\n        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);\n        // 使用指定的字节数组对摘要进行最后更新\n        sha.update(data.getBytes());\n        // 完成摘要计算\n        byte[] bytes = sha.digest();\n        // 将得到的字节数组变成字符串返回\n        return byteArrayToHexString(bytes);\n    }\n\n    /**\n     * 将一个字节转化成十六进制形式的字符串\n     * @param b 字节数组\n     * @return 字符串\n     */\n    private static String byteToHexString(byte b) {\n        int ret = b;\n        //System.out.println("ret = " + ret);\n        if (ret &lt; 0) {\n            ret += 256;\n        }\n        int m = ret / 16;\n        int n = ret % 16;\n        return hexDigits[m] + hexDigits[n];\n    }\n\n    /**\n     * 转换字节数组为十六进制字符串\n     * @param bytes 字节数组\n     * @return 十六进制字符串\n     */\n    private static String byteArrayToHexString(byte[] bytes) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; bytes.length; i++) {\n            sb.append(byteToHexString(bytes[i]));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 测试方法\n     * @param args\n     */\n    public static void main(String[] args) throws Exception {\n        String key = "123";\n        System.out.println(encryptSHA(key));\n    }\n}\n\n</code></pre>\n<h2><a id="_212"></a>二、对称加密</h2>\n<blockquote>\n<p>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密，这就要求加密和解密方事先都必须知道加密的密钥。</p>\n</blockquote>\n<h3><a id="1_DES_216"></a>1. DES算法</h3>\n<p>1973 年，美国国家标准局(NBS)在认识到建立数据保护标准既明显又急迫的情况下，开始征集联邦数据加密标准的方案。 1975 年3月17日， NBS公布了IBM公司提供的密码算法，以标准建议的形式在全国范围内征求意见。经过两年多的公开讨论之后， 1977 年7月15日， NBS宣布接受这建议，作为联邦信息处理标准46 号数据加密标准(Data Encryptin Standard)，即DES正式颁布，供商业界和非国防性政府部门使用。DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES<br>\n运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，因此演变出了3DES算法。 3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形</p>\n<pre><code>\n\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n/**\n * Data Encryptin Standard\n * 数据加密标准\n */\npublic class DESUtil {\n\n\n    private final static String DES = "DES";\n\n    /**\n     * Description 根据键值进行加密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws Exception\n     */\n    public static String encrypt(String data, String key) throws Exception {\n        byte[] bt = encrypt(data.getBytes(), key.getBytes());\n        String strs = new BASE64Encoder().encode(bt);\n        return strs;\n    }\n\n    /**\n     * Description 根据键值进行解密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws IOException\n     * @throws Exception\n     */\n    public static String decrypt(String data, String key) throws Exception,\n            Exception {\n        if (data == null)\n            return null;\n        BASE64Decoder decoder = new BASE64Decoder();\n        byte[] buf = decoder.decodeBuffer(data);\n        byte[] bt = decrypt(buf, key.getBytes());\n        return new String(bt);\n    }\n\n    /**\n     * Description 根据键值进行加密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws Exception\n     */\n    private static byte[] encrypt(byte[] data, byte[] key) throws Exception {\n        // 生成一个可信任的随机数源\n        SecureRandom sr = new SecureRandom();\n\n        // 从原始密钥数据创建DESKeySpec对象\n        DESKeySpec dks = new DESKeySpec(key);\n\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\n        SecretKey securekey = keyFactory.generateSecret(dks);\n\n        // Cipher对象实际完成加密操作\n        Cipher cipher = Cipher.getInstance(DES);\n\n        // 用密钥初始化Cipher对象\n        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);\n\n        return cipher.doFinal(data);\n    }\n\n\n    /**\n     * Description 根据键值进行解密\n     *\n     * @param data\n     * @param key  加密键byte数组\n     * @return\n     * @throws Exception\n     */\n    private static byte[] decrypt(byte[] data, byte[] key) throws Exception {\n        // 生成一个可信任的随机数源\n        SecureRandom sr = new SecureRandom();\n\n        // 从原始密钥数据创建DESKeySpec对象\n        DESKeySpec dks = new DESKeySpec(key);\n\n        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);\n        SecretKey securekey = keyFactory.generateSecret(dks);\n\n        // Cipher对象实际完成解密操作\n        Cipher cipher = Cipher.getInstance(DES);\n\n        // 用密钥初始化Cipher对象\n        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);\n\n        return cipher.doFinal(data);\n    }\n\n    public static void main(String[]args)throws Exception{\n       String  sStr=encrypt("122222112222:12343232323:jajwwwwslwskwkkwksk","wew2323w233321ws233w");\n       System.out.println(sStr);\n       String mStr=decrypt(sStr,"wew2323w233321ws233w");\n       System.out.println(mStr);\n    }\n}\n\n</code></pre>\n<h3><a id="2_AES_345"></a>2. AES</h3>\n<p>AES的全称是Advanced Encryption Standard，即高级加密标准，该算法由比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，又称Rijndael加密算法，是美国联邦政府采用的一种对称加密标准，这个标准用来替代原先的DES算法，已经广为全世界所使用，已然成为对称加密算法中最流行的算法之一。AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优<br>\n点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。</p>\n<pre><code>\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Base64;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n/**\n * Created by fangzhipeng on 2017/3/21.\n */\npublic class AESUtil {\n\n    static  byte[]  key = "w@#$4@#$s^&amp;3*&amp;^4".getBytes();\n    final static String algorithm="AES";\n\n    public static String encrypt(String data){\n\n        byte[] dataToSend = data.getBytes();\n        Cipher c = null;\n        try {\n            c = Cipher.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        SecretKeySpec k =  new SecretKeySpec(key, algorithm);\n        try {\n            c.init(Cipher.ENCRYPT_MODE, k);\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        byte[] encryptedData = "".getBytes();\n        try {\n            encryptedData = c.doFinal(dataToSend);\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        byte[] encryptedByteValue =     Base64.getEncoder().encode(encryptedData);\n        return  new String(encryptedByteValue);//.toString();\n    }\n\n    public static String decrypt(String data){\n\n        byte[] encryptedData  =  Base64.getDecoder().decode(data);\n        Cipher c = null;\n        try {\n            c = Cipher.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        SecretKeySpec k =\n                new SecretKeySpec(key, algorithm);\n        try {\n            c.init(Cipher.DECRYPT_MODE, k);\n        } catch (InvalidKeyException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n        byte[] decrypted = null;\n        try {\n            decrypted = c.doFinal(encryptedData);\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return new String(decrypted);\n    }\n\n    public static void main(String[] args){\n        String password=encrypt("12233440988:1239874389888:dd333");\n        System.out.println(password);\n        System.out.println(decrypt(password));\n    }\n}\n\n\n</code></pre>\n<p>##三、非对称加密</p>\n<blockquote>\n<p>非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。</p>\n</blockquote>\n<h3><a id="RSA_461"></a>RSA</h3>\n<p>RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发的， RSA取名来自开发他们三者的名字。 RSA是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。 RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p>\n<pre><code>\n/**\n * Created by fangzhipeng on 2017/3/21.\n * RSA ：RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发   *  的， RSA取名来\n *  自开发他们三者的名字。\n * 参考：http://blog.csdn.net/wangqiuyun/article/details/42143957\n */\n\nimport java.io.*;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\npublic class RSAUtil {\n\n\n    /**\n     * 字节数据转字符串专用集合\n     */\n    private static final char[] HEX_CHAR = { \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\',\n            \'7\', \'8\', \'9\', \'a\', \'b\', \'c\', \'d\', \'e\', \'f\' };\n\n    /**\n     * 随机生成密钥对\n     */\n    public static void genKeyPair(String filePath) {\n        // KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象\n        KeyPairGenerator keyPairGen = null;\n        try {\n            keyPairGen = KeyPairGenerator.getInstance("RSA");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        // 初始化密钥对生成器，密钥大小为96-1024位\n        keyPairGen.initialize(1024,new SecureRandom());\n        // 生成一个密钥对，保存在keyPair中\n        KeyPair keyPair = keyPairGen.generateKeyPair();\n        // 得到私钥\n        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n        // 得到公钥\n        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n        try {\n            // 得到公钥字符串\n            // 得到私钥字符串\n            String privateKeyString =new String( Base64.getEncoder().encode(privateKey.getEncoded()));\n            String publicKeyString =new String( Base64.getEncoder().encode(publicKey.getEncoded()));\n            // 将密钥对写入到文件\n\n            File file1=new File(filePath + "publicKey.keystore");\n            File file2=new File(filePath + "privateKey.keystore");\n            if(!file1.exists()) {\n                file1.createNewFile();\n            }\n            if(!file2.exists()) {\n                file2.createNewFile();\n            }\n            FileWriter pubfw = new FileWriter(filePath + "/publicKey.keystore");\n            FileWriter prifw = new FileWriter(filePath + "/privateKey.keystore");\n            BufferedWriter pubbw = new BufferedWriter(pubfw);\n            BufferedWriter pribw = new BufferedWriter(prifw);\n            pubbw.write(publicKeyString);\n            pribw.write(privateKeyString);\n            pubbw.flush();\n            pubbw.close();\n            pubfw.close();\n            pribw.flush();\n            pribw.close();\n            prifw.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 从文件中输入流中加载公钥\n     *\n     * @param\n     *\n     * @throws Exception\n     *             加载公钥时产生的异常\n     */\n    public static String loadPublicKeyByFile(String path) throws Exception {\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(path\n                    + "/publicKey.keystore"));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                sb.append(readLine);\n            }\n            br.close();\n            return sb.toString();\n        } catch (IOException e) {\n            throw new Exception("公钥数据流读取错误");\n        } catch (NullPointerException e) {\n            throw new Exception("公钥输入流为空");\n        }\n    }\n\n    /**\n     * 从字符串中加载公钥\n     *\n     * @param publicKeyStr\n     *            公钥数据字符串\n     * @throws Exception\n     *             加载公钥时产生的异常\n     */\n    public static RSAPublicKey loadPublicKeyByStr(String publicKeyStr)\n            throws Exception {\n        try {\n            byte[] buffer = Base64.getDecoder().decode(publicKeyStr);\n            KeyFactory keyFactory = KeyFactory.getInstance("RSA");\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);\n            return (RSAPublicKey) keyFactory.generatePublic(keySpec);\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此算法");\n        } catch (InvalidKeySpecException e) {\n            throw new Exception("公钥非法");\n        } catch (NullPointerException e) {\n            throw new Exception("公钥数据为空");\n        }\n    }\n\n    /**\n     * 从文件中加载私钥\n     *\n     * @param\n     *\n     * @return 是否成功\n     * @throws Exception\n     */\n    public static String loadPrivateKeyByFile(String path) throws Exception {\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(path\n                    + "/privateKey.keystore"));\n            String readLine = null;\n            StringBuilder sb = new StringBuilder();\n            while ((readLine = br.readLine()) != null) {\n                sb.append(readLine);\n            }\n            br.close();\n            return sb.toString();\n        } catch (IOException e) {\n            throw new Exception("私钥数据读取错误");\n        } catch (NullPointerException e) {\n            throw new Exception("私钥输入流为空");\n        }\n    }\n\n    public static RSAPrivateKey loadPrivateKeyByStr(String privateKeyStr)\n            throws Exception {\n        try {\n            byte[] buffer = Base64.getDecoder().decode(privateKeyStr);\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer);\n            KeyFactory keyFactory = KeyFactory.getInstance("RSA");\n            return (RSAPrivateKey) keyFactory.generatePrivate(keySpec);\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此算法");\n        } catch (InvalidKeySpecException e) {\n            throw new Exception("私钥非法");\n        } catch (NullPointerException e) {\n            throw new Exception("私钥数据为空");\n        }\n    }\n\n    /**\n     * 公钥加密过程\n     *\n     * @param publicKey\n     *            公钥\n     * @param plainTextData\n     *            明文数据\n     * @return\n     * @throws Exception\n     *             加密过程中的异常信息\n     */\n    public static byte[] encrypt(RSAPublicKey publicKey, byte[] plainTextData)\n            throws Exception {\n        if (publicKey == null) {\n            throw new Exception("加密公钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            // cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n            byte[] output = cipher.doFinal(plainTextData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此加密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("加密公钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("明文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("明文数据已损坏");\n        }\n    }\n\n    /**\n     * 私钥加密过程\n     *\n     * @param privateKey\n     *            私钥\n     * @param plainTextData\n     *            明文数据\n     * @return\n     * @throws Exception\n     *             加密过程中的异常信息\n     */\n    public static byte[] encrypt(RSAPrivateKey privateKey, byte[] plainTextData)\n            throws Exception {\n        if (privateKey == null) {\n            throw new Exception("加密私钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n            byte[] output = cipher.doFinal(plainTextData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此加密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("加密私钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("明文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("明文数据已损坏");\n        }\n    }\n\n    /**\n     * 私钥解密过程\n     *\n     * @param privateKey\n     *            私钥\n     * @param cipherData\n     *            密文数据\n     * @return 明文\n     * @throws Exception\n     *             解密过程中的异常信息\n     */\n    public static byte[] decrypt(RSAPrivateKey privateKey, byte[] cipherData)\n            throws Exception {\n        if (privateKey == null) {\n            throw new Exception("解密私钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            // cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            byte[] output = cipher.doFinal(cipherData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此解密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("解密私钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("密文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("密文数据已损坏");\n        }\n    }\n\n    /**\n     * 公钥解密过程\n     *\n     * @param publicKey\n     *            公钥\n     * @param cipherData\n     *            密文数据\n     * @return 明文\n     * @throws Exception\n     *             解密过程中的异常信息\n     */\n    public static byte[] decrypt(RSAPublicKey publicKey, byte[] cipherData)\n            throws Exception {\n        if (publicKey == null) {\n            throw new Exception("解密公钥为空, 请设置");\n        }\n        Cipher cipher = null;\n        try {\n            // 使用默认RSA\n            cipher = Cipher.getInstance("RSA");\n            // cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());\n            cipher.init(Cipher.DECRYPT_MODE, publicKey);\n            byte[] output = cipher.doFinal(cipherData);\n            return output;\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception("无此解密算法");\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return null;\n        } catch (InvalidKeyException e) {\n            throw new Exception("解密公钥非法,请检查");\n        } catch (IllegalBlockSizeException e) {\n            throw new Exception("密文长度非法");\n        } catch (BadPaddingException e) {\n            throw new Exception("密文数据已损坏");\n        }\n    }\n\n    /**\n     * 字节数据转十六进制字符串\n     *\n     * @param data\n     *            输入数据\n     * @return 十六进制内容\n     */\n    public static String byteArrayToString(byte[] data) {\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; data.length; i++) {\n            // 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移\n            stringBuilder.append(HEX_CHAR[(data[i] &amp; 0xf0) &gt;&gt;&gt; 4]);\n            // 取出字节的低四位 作为索引得到相应的十六进制标识符\n            stringBuilder.append(HEX_CHAR[(data[i] &amp; 0x0f)]);\n            if (i &lt; data.length - 1) {\n                stringBuilder.append(\' \');\n            }\n        }\n        return stringBuilder.toString();\n    }\n\n\n\n    public static void main(String[] args) throws Exception {\n        String filepath="F:/temp/";\n        File file=new File(filepath);\n        if(!file.exists()){\n            file.mkdir();\n        }\n        genKeyPair(filepath);\n        System.out.println("--------------公钥加密私钥解密过程-------------------");\n        String plainText="1223333323:8783737321232:dewejj28i33e92hhsxxxx";\n        //公钥加密过程\n        byte[] cipherData=encrypt(loadPublicKeyByStr(loadPublicKeyByFile(filepath)),plainText.getBytes());\n        String cipher=new String(Base64.getEncoder().encode(cipherData));\n        //私钥解密过程\n        byte[] res=decrypt(loadPrivateKeyByStr(loadPrivateKeyByFile(filepath)), Base64.getDecoder().decode(cipher));\n        String restr=new String(res);\n        System.out.println("原文："+plainText);\n        System.out.println("加密密文："+cipher);\n        System.out.println("解密："+restr);\n        System.out.println();\n    }\n}\n\n</code></pre>\n<p>注： 文字部分复制了《大型电商分布式系统实践 第一版 讲师 陈康贤》的第三课。代码来源于自己的整理，全部测试通过，应该没有坑。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61472783', 'title': 'SpringBoot非官方教程 | 第二十五篇：2小时学会springboot', 'readNum': '223261', 'commentNum': '75', 'publishTime': '2017-03-12 00:23:51', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="https://www.fangzhipeng.com/springboot/2017/05/25/sb25-2hour.html" rel="nofollow">https://www.fangzhipeng.com/springboot/2017/05/25/sb25-2hour.html</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h3><a id="spring_boot_6"></a>一.什么是spring boot</h3>\n<blockquote>\n<p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p>\n<p>摘自官网</p>\n<p>翻译：采纳了建立生产就绪Spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。</p>\n</blockquote>\n<p>spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。</p>\n<h3><a id="sping__boot__17"></a>二、搭建第一个sping  boot 程序</h3>\n<p>可以在start.spring.io上建项目，也可以用idea构建。本案列采用idea.</p>\n<p>具体步骤：</p>\n<pre><code>new prpject -&gt; spring initializr -&gt;{name :firstspringboot , type: mavenproject,packaging:jar ,..}  -&gt;{spring version :1.5.2  web: web } -&gt; ....\n\n</code></pre>\n<p>应用创建成功后，会生成相应的目录和文件。</p>\n<p>其中有一个Application类,它是程序的入口:</p>\n<pre><code>@SpringBootApplication\npublic class FirstspringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(FirstspringbootApplication.class, args);\n\t}\n}\n</code></pre>\n<p>在resources文件下下又一个application.yml文件，它是程序的配置文件。默认为空，写点配置 ,程序的端口为8080,context-path为  /springboot：</p>\n<pre><code>server:\n  port: 8080\n  context-path: /springboot\n\n</code></pre>\n<p>写一个HelloController：</p>\n<pre><code>@RestController     //等同于同时加上了@Controller和@ResponseBody\npublic class HelloController {\n   \n    //访问/hello或者/hi任何一个地址，都会返回一样的结果\n    @RequestMapping(value = {"/hello","/hi"},method = RequestMethod.GET)\n    public String say(){\n        return "hi you!!!";\n    }\n}\n\n</code></pre>\n<p>运行 Application的main(),呈现会启动，由于springboot自动内置了servlet容器，所以不需要类似传统的方式，先部署到容器再启动容器。只需要运行main()即可，这时打开浏览器输入网址：localhost:8080/springboot/hi  ，就可以在浏览器上看到: <em>hi you!!!</em></p>\n<h3><a id="_68"></a>三.属性配置</h3>\n<p>在appliction.yml文件添加属性：</p>\n<pre><code>server:\n  port: 8080\n  context-path: /springboot\n\ngirl:\n  name: B\n  age: 18\n  content: content:${name},age:${age}\n  \n</code></pre>\n<p>在java文件中，获取name属性，如下：</p>\n<pre><code>@Value("${name}")\n private String name;\n</code></pre>\n<p>也可以通过ConfigurationProperties注解，将属性注入到bean中，通过Component注解将bean注解到spring容器中：</p>\n<pre><code>@ConfigurationProperties(prefix="girl")\n@Component\npublic class GirlProperties {\n\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n</code></pre>\n<p>另外可以通过配置文件制定不同环境的配置文，具体见源码：</p>\n<pre><code>spring:\n  profiles:\n    active: prod\n\n</code></pre>\n<h3><a id="jpa_127"></a>四.通过jpa方式操作数据库</h3>\n<p>导入jar ，在pom.xml中添加依赖:</p>\n<pre><code>&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\t\t&lt;/dependency&gt;\n</code></pre>\n<p>在appilication.yml中添加数据库配置：</p>\n<pre><code>spring:\n  profiles:\n    active: prod\n    \n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/dbgirl?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8\n    username: root\n    password: 123\n\n  jpa:\n    hibernate:\n      ddl-auto: create\n    show-sql: true\n</code></pre>\n<p>这些都是数据库常见的一些配置没什么可说的，其中ddl_auto: create 代表在数据库创建表，update 代表更新，首次启动需要create ,如果你想通过hibernate 注解的方式创建数据库的表的话，之后需要改为 update.</p>\n<p>创建一个实体girl，这是基于hibernate的:</p>\n<pre><code>@Entity\npublic class Girl {\n\n    @Id\n    @GeneratedValue\n    private Integer id;\n    private String cupSize;\n    private Integer age;\n\n    public Girl() {\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getCupSize() {\n        return cupSize;\n    }\n\n    public void setCupSize(String cupSize) {\n        this.cupSize = cupSize;\n    }\n}\n</code></pre>\n<p>创建Dao接口, springboot 将接口类会自动注解到spring容器中，不需要我吗做任何配置，只需要继承JpaRepository 即可：</p>\n<pre><code>//其中第二个参数为Id的类型\npublic interface GirlRep extends JpaRepository&lt;Girl,Integer&gt;{\n   }\n</code></pre>\n<p>创建一个GirlController，写一个获取所有girl的api和添加girl的api ，自己跑一下就可以了:</p>\n<pre><code>\n@RestController\npublic class GirlController {\n\n    @Autowired\n    private GirlRep girlRep;\n\n    /**\n     * 查询所有女生列表\n     * @return\n     */\n    @RequestMapping(value = "/girls",method = RequestMethod.GET)\n    public List&lt;Girl&gt; getGirlList(){\n        return girlRep.findAll();\n    }\n\n    /**\n     * 添加一个女生\n     * @param cupSize\n     * @param age\n     * @return\n     */\n    @RequestMapping(value = "/girls",method = RequestMethod.POST)\n    public Girl addGirl(@RequestParam("cupSize") String cupSize,\n                        @RequestParam("age") Integer age){\n        Girl girl = new Girl();\n        girl.setAge(age);\n        girl.setCupSize(cupSize);\n        return girlRep.save(girl);\n    }\n    \n   } \n</code></pre>\n<p>如果需要事务的话，在service层加@Transaction注解即可。已经凌晨了，我要睡了.</p>\n<p>源码；<a href="http://download.csdn.net/detail/forezp/9778235">http://download.csdn.net/detail/forezp/9778235</a></p>\n<h2><a id="_256"></a>参考资料</h2>\n<p>说明：本文部分内容均来自慕课网。@慕课网：<a href="http://www.imooc.com" rel="nofollow">http://www.imooc.com</a> @廖师兄</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:40 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61472644', 'title': 'Linux基础之常用命令篇', 'readNum': '37973', 'commentNum': '0', 'publishTime': '2017-03-12 00:23:29', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>最近一段时间工作实在是太忙了，所以好久没有写文章了，趁着周末把linux 的相关知识，整理了下。这一篇文件主要记录了一些linux的基础命令。需要读者有linux服务器或者有mac电脑去练习。<sup>`</sup>.</p>\n<p>###一、命令的基本格式</p>\n<blockquote>\n<p>[root@localhost~]</p>\n<p>root为用户名</p>\n<p>～表示当前所在位置</p>\n<p>localhost主机名</p>\n<p>‘#’超级用户</p>\n<p>\'$"  普通用户</p>\n</blockquote>\n<p>命令的基本格式：</p>\n<blockquote>\n<p>命令  [选项]  [参数]</p>\n</blockquote>\n<h3><a id="_20"></a>二、查询目录的内容</h3>\n<p>命令格式：</p>\n<pre><code>ls [选项][文件或目录]\n</code></pre>\n<blockquote>\n<p>选项：</p>\n<p>-a 所有文件</p>\n<p>-l  查看详情</p>\n<p>-d查看目录属性</p>\n<p>-h显示文件大小</p>\n</blockquote>\n<p>###三、文件处理命令</p>\n<p>1、建立目录</p>\n<pre><code>mkdir -p [目录名]\n\n</code></pre>\n<blockquote>\n<p>-p表述递归建文件夹</p>\n</blockquote>\n<p>举例：</p>\n<pre><code>mkdir japan\n\nmkdir -p japan/cangjk\n</code></pre>\n<p>2.切换目录</p>\n<pre><code>cd [目录]\n\n</code></pre>\n<p>简化操作：</p>\n<blockquote>\n<p>cd~  进入当前用户目录</p>\n<p>cd- 上次目录</p>\n<p>cd… 进入上一级目录</p>\n<p>pwd查看当前目录所在位置</p>\n</blockquote>\n<p>3.删除目录</p>\n<pre><code>rmdir [目录]  \n</code></pre>\n<blockquote>\n<p>删除所有文件</p>\n</blockquote>\n<pre><code>rm -rf [目录]\n</code></pre>\n<blockquote>\n<p>删除目录所有文件</p>\n</blockquote>\n<p>4.复制目录</p>\n<pre><code>cp[选项][原文件目录][目标目录]\n</code></pre>\n<blockquote>\n<p>选项：</p>\n<p>-r复制目录</p>\n<p>-p连文件属性一起复制</p>\n<p>-a 相当于-pdr</p>\n</blockquote>\n<p>5.剪切、改名</p>\n<pre><code>mv[原文件目录][目标文件目录]\n</code></pre>\n<p>6.常见目录作用</p>\n<blockquote>\n<p>/ 根目录</p>\n<p>/bin 命令保存目录</p>\n<p>/boot  启动目录</p>\n<p>/dev  设备文件命令</p>\n<p>/etc  配置文件保存目录</p>\n<p>/home  家目录</p>\n<p>/lib  系统库保存命令</p>\n<p>/mnt  系统挂载目录</p>\n</blockquote>\n<h3><a id="_132"></a>三、文件搜索命令</h3>\n<p>1.locate</p>\n<pre><code>locate [文件名]\n\n</code></pre>\n<blockquote>\n<p>在系统数据库中查找文件的</p>\n</blockquote>\n<blockquote>\n<p>新建的文件，要执行updatedb操作之后才能搜到</p>\n</blockquote>\n<p>2.命令搜索</p>\n<pre><code>whereis [选项] [命令名]\n\n或者\n\nwhich [选项][命令名]\n</code></pre>\n<blockquote>\n<p>选项：</p>\n<p>-b 只查找可执行文件</p>\n<p>-m 只查找帮助文件</p>\n</blockquote>\n<p>3.文件搜索</p>\n<pre><code>find [搜索范围][选项][条件]\n</code></pre>\n<p>直接举例子：</p>\n<pre><code>find  /  -name install.log  \n在根目录下查找名为install.log文件\n\n</code></pre>\n<pre><code>find /root  -inname install.log\n忽略大小写查找文件\n</code></pre>\n<pre><code>find /var/log -mtime +10\n\n其中-mtime 文件修改时间\n-atime 文件访问时间\n-ctime 改变文件属性时间\n\n+10 10天前\n10  10天\n-10 10天内\n</code></pre>\n<pre><code>find /etc -size +20M\n\n查找文件大于20M的文件\n\n</code></pre>\n<h3><a id="_203"></a>四、压缩与解压缩命令</h3>\n<p>常见压缩格式：.zip  、 .gz 、 .bz2、<br>\n.tar.gz  、 .tar.bz2</p>\n<p>1.zip格式</p>\n<pre><code>//压缩文件\nzip [压缩文件名][原文件]\n//压缩目录\nzip -r  [压缩文件名][原文件]\n\n</code></pre>\n<p>举例子：</p>\n<pre><code>touch jp/cangls\n\ntouch jp/longls\n\nzip -r jp.zip jp\n\n</code></pre>\n<pre><code>#解压：\nunzip [压缩文件名]\n</code></pre>\n<ol start="2">\n<li>gz格式</li>\n</ol>\n<pre><code># 压缩为gz格式，原文件不保留\ngzip [原文件]\n\n#压缩.gz格式，原文件保留\n\ngzip -c 原文件 &gt; 压缩文件\n# 压缩目录：\ngzip -r  目录\n\n</code></pre>\n<p>解压：</p>\n<pre><code>guzip [文件]\n\nguzip -r [目录]\n\n</code></pre>\n<p>3.tar</p>\n<pre><code># 打包\ntar -cvf  打包文件名 原文件\n\n# 解压\n\ntar -xvf jp.tar\n</code></pre>\n<p>4.tar.gz</p>\n<pre><code>#打包\ntar -zcvf 压缩包名.tar.gz  原文件\n\n#解压\ntar -zxvf  压缩包名.tar.gz\n  \n</code></pre>\n<h3><a id="_279"></a>五、关机和重启</h3>\n<pre><code>shutdown [选项][时间]\n\n#选项：\n-c 取消前一个关机命令\n-h 关机\n-r 重启\n\n\ninit 6重启\n\ninit 0关机\n\nlogout退出登陆\n</code></pre>\n<p>###六、查看用户信息</p>\n<pre><code>w\nwho\nlast\nlastlog\n</code></pre>\n<p>###七、shell基础</p>\n<p>1.什么是shell<br>\nshell是命令行解释器。</p>\n<p>2.echo 输出命令</p>\n<pre><code>echo[选项][输出内容]\n\n</code></pre>\n<p>选项：</p>\n<blockquote>\n<p>-e:支持转义</p>\n</blockquote>\n<p>３.创建一个脚本</p>\n<p><a href="http://xn--hello-ll6hz28e.sh" rel="nofollow">创建hello.sh</a></p>\n<blockquote>\n<p>vim <a href="http://hello.sh" rel="nofollow">hello.sh</a><br>\n进入编辑：</p>\n</blockquote>\n<pre><code>   #!/bin/bash\n   # the first program\necho "hello world!"\n</code></pre>\n<p>执行：</p>\n<pre><code>chmod 755 hello.sh\n\n./hello.sh    \n</code></pre>\n<p>或者：</p>\n<pre><code>bash hello.sh\n</code></pre>\n<p>###八、历史命令</p>\n<pre><code>history 查看历史命令\nhistory [选项][历史保存文件]\n选项：\n-c清空历史\n-w把缓存中的历史写入历史命令保存文件\n</code></pre>\n<p>###九、输出重定向</p>\n<pre><code>命令&gt;文件   以覆盖的方式，把正确的命令输出到指定文件\n命令&gt;&gt;文件  以追加的方式，把正确的命令输出到指定文件、\n错误命令 2&gt; 文件  以覆盖的方式把错误的命令覆盖到指定文件\n错误命令 2&gt;&gt; 文件  以追击的方式把错误的命令覆盖到指定文件\n\n 命令&gt;&gt;文件 2&gt;&amp;1  同时追加正确命令和错误命令到 指定文件\n命令 &gt;&gt;文件1 2&gt;&gt;文件2   把正确的命令输出到文件1错误的文件2\n\n</code></pre>\n<p>举个例子:</p>\n<pre><code>#/bin/bash\nwhile command\ndo\ncurl -d "userid=123343,action=getuserinfo" https://app.testasss.com.cn/ &gt;test.txt\ntime=$(date)\ncat=$(cat test.txt |cut -d \\: -f 3|cut -d \\" -f 2)\necho "$time $cat" &gt;&gt;test.log\nsleep 15s\ndone\n</code></pre>\n<p>###十、网络相关</p>\n<p>1.ifconfig查看ip</p>\n<p>举个例子：</p>\n<pre><code>ifconfig&gt;&gt; ip.log\ncat ip.log\n</code></pre>\n<p>2.查看网络状态</p>\n<pre><code>netstat [选项]\n\n</code></pre>\n<p>选项：</p>\n<blockquote>\n<p>-t: 列出tcp 协议端口<br>\n-u: 列出upd协议端口<br>\n-n  ip地址个端口号<br>\n-l 列出监听状态的<br>\n-a 所有</p>\n</blockquote>\n<p>3.查看路由列表</p>\n<pre><code>netstat -rn\n或者\nroute -n\n</code></pre>\n<p>4.查看某域名与自己的电脑的网络状态</p>\n<pre><code>ping www.baodu.com\n</code></pre>\n<p>###十一、vi编辑器<br>\nvi的升级版是vim</p>\n<p>1.vim的操作模式</p>\n<pre><code>commond mode  命令模式\ninser tmode  编辑模式\nlastline mode  底行模式\n\n</code></pre>\n<p>2.模式切换<br>\ni  进入编辑模式<br>\nesc  进入命令行模式</p>\n<p>3.命令模式</p>\n<pre><code>vim [文件]         进入文件或者创建文件（文件不存在的情况下）\nvim + [文件名]   进入文件尾部\nvim +/[字符串] [文件名]  光标定位到文件第一次出现该字符串的位置\n</code></pre>\n<p>4.底行模式</p>\n<pre><code>:w  保存\n:q 退出\n:! 强制\n:15  定位的第15行\n/[字符串]  光标位置向后搜索该字符串\n?[字符串]  光标位置向前搜索该字符串\ndd  删除光标所在行\n\nctr+f   向下翻页\nctr+b  向上翻页\n\n</code></pre>\n<p>###十二、常用操作快捷键</p>\n<pre><code>ctr+c  终止当前命令\nctr+l 清屏  相当于 clear\nctr+a  光标移到行首\nctr+e  光标移到行尾\nctr+u  把光标所在位置删除到行首\nctr+z  把命令放入后台\nctr+r  在历史命令中搜索\n</code></pre>\n<h3><a id="_471"></a>十三、其他</h3>\n<p>常用工具：</p>\n<pre><code>Vmware  虚拟机\ncentos.iso   centos系统镜像 ,绝大多数服务器是这个系统\nSecureCRT  远程登陆工具\nXshell 远程登陆工具\nwinscp copy文件工具\n\n</code></pre>\n<p>我的springCloud专栏：<a href="http://blog.csdn.net/column/details/15197.html">http://blog.csdn.net/column/details/15197.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:40'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61472405', 'title': '深入浅出工厂设计模式', 'readNum': '36002', 'commentNum': '1', 'publishTime': '2017-03-12 00:22:47', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/61472405">http://blog.csdn.net/forezp/article/details/61472405</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>##工厂设计模式</p>\n<p>###一.什么是工厂设计模式</p>\n<blockquote>\n<p>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。因为工厂模式就相当于创建实例对象的new，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。工厂模式最直接的作用就是将创建对象和对象的业务逻辑相分离。</p>\n</blockquote>\n<p>工厂模式最常见的三种：</p>\n<ul>\n<li>简单工厂模式</li>\n<li>工厂方法模式</li>\n<li>抽象工厂</li>\n</ul>\n<h3><a id="_18"></a>二、简单工厂模式</h3>\n<p>以下是我看《headefirst设计模式》的工厂模式的笔记。非常有意思，但是篇幅有点长，所以打算总结下，写个简洁版的。</p>\n<p>假如你有个pizza店，你可以为客人做很多 pizza。</p>\n<p>首先，你需要很多pizza对象，定义一个pizza抽象类：</p>\n<pre><code>public abstract class Pizza {\n    abstract void prepared();\n    abstract void bake();\n    abstract void cut();\n    abstract void box();\n}\n\n\n</code></pre>\n<p>中式 pizza:</p>\n<pre><code>public class ChineasePizza extends Pizza {\n    @Override\n    public void prepared() {\n\n    }\n\n    @Override\n    public void bake() {\n\n    }\n\n    @Override\n    public void cut() {\n\n    }\n\n    @Override\n    public void box() {\n\n    }\n}\n</code></pre>\n<p>美式pizza:</p>\n<pre><code>public class AmericanPizza extends Pizza {\n    @Override\n    public void prepared() {\n\n    }\n\n    @Override\n    public void bake() {\n\n    }\n\n    @Override\n    public void cut() {\n\n    }\n\n    @Override\n    public void box() {\n\n    }\n}\n\n\n</code></pre>\n<p>当我需要为客人准备一份pizza，我们可能会需要这样写：</p>\n<pre><code>public Pizza orderPizza(String type){\n        Pizza pizza = null;\n        if(type.equals("c")){\n            pizza=new ChineasePizza();\n        }else if(type.equals("a")){\n            pizza=new AmericanPizza();\n        }else if(type.equals("e")){\n            pizza=new EnglishPizza();\n        }else {\n            pizza=new ChineasePizza();\n        }\n        pizza.prepared();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n\n</code></pre>\n<p>当你有很多种pizza的时候，这个else if()特别的长：</p>\n<pre><code> if(type.equals("c")){\n            pizza=new ChineasePizza();\n        }else if(type.equals("a")){\n            pizza=new AmericanPizza();\n        }else if(type.equals("e")){\n            pizza=new EnglishPizza();\n        }else if(...){\n        ....\n        }else {\n            pizza=new ChineasePizza();\n        }\n\n\n</code></pre>\n<p>你需要创建一个工厂来管理这些pizza的创建实例:</p>\n<pre><code>\npublic class SimplePizzaFactory {\n\n    public Pizza createPizza(String type) {\n\n        Pizza pizza = null;\n        if(type.equals("c")){\n            pizza=new ChineasePizza();\n        }else if(type.equals("a")){\n            pizza=new AmericanPizza();\n        }else if(type.equals("e")){\n            pizza=new EnglishPizza();\n        }else {\n            pizza=new ChineasePizza();\n        }\n\n        return pizza;\n    }\n}\n\n</code></pre>\n<p>有了工厂之后的你代码应该这样写：</p>\n<pre><code>public class PizzaStore {\n\n    private SimplePizzaFactory simplePizzaFactory;\n    public PizzaStore(SimplePizzaFactory simplePizzaFactory){\n        this.simplePizzaFactory=simplePizzaFactory;\n    }\n\n    public Pizza orderPizza(String type) {\n       Pizza pizza= simplePizzaFactory.createPizza(type);\n        pizza.prepared();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n}\n\n</code></pre>\n<p>就是简单的工厂模式，工厂处理创建对象的细节。工厂模式将创建对象和对象的业务逻辑相分离，降低了代码的耦合性，提高了代码的可读性。</p>\n<h3><a id="_180"></a>三、工厂方法模式</h3>\n<p>当你需要开很多pizza店的时候，你可能需要创建的pizztore抽象类,这个抽象类只专注于卖pizza的业务逻辑，不专注pizza是怎么来的：</p>\n<pre><code>public abstract class APizzaStore {\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza= createPizza(type);\n        pizza.prepared();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n    abstract Pizza createPizza(String type);\n}\n\n\n</code></pre>\n<p>它的子类需要专注于pizza 是怎么来的，你需要在北京开一家pizza店：</p>\n<pre><code>public class BeijingtPizzaStore extends APizzaStore{\n\n    @Override\n    Pizza createPizza(String type) {\n        Pizza pizza;\n        if(type.equals("a")){\n            pizza=new AmericanPizza();\n        }else {\n            pizza=new ChineasePizza();\n        }\n        return pizza;\n    }\n}\n</code></pre>\n<p>你在北京卖pizza之需要：</p>\n<pre><code>BeijingtPizzaStore bps=new BeijingtPizzaStore();\nbps.orderPizza();\n\n</code></pre>\n<p>同理,你需要在深圳开pizza店：</p>\n<pre><code> public class ShenZhengPizzaStore extends APizzaStore {\n    @Override\n    Pizza createPizza(String type) {\n        return null;\n    }\n}\n\n</code></pre>\n<p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。超类的代码和子类的对象创建代码就解耦了。</p>\n<h3><a id="_240"></a>四、抽象工厂模式</h3>\n<p>你制造pizza的时候，需要很多原料，这时需要一个工厂来制造：</p>\n<pre><code>public interface IngredientFactory {\n    Dauch createDauch();\n    Sauce createSauch();\n    Cheese createCheese();\n}\n\n\n</code></pre>\n<p>创建一个中国原料工厂：</p>\n<pre><code>public class ChineaseIngredientFactory implements IngredientFactory {\n    @Override\n    public Dauch createDauch() {\n        return new Dauch();\n    }\n\n    @Override\n    public Sauce createSauch() {\n        return new Sauce();\u3000//这里我简便的写，其实也可以说Sauch的子类。\n    }\n\n    @Override\n    public Cheese createCheese() {\n        return new Cheese();\n    }\n}\n\n\n</code></pre>\n<p>同理也可以创建美国原料工厂：</p>\n<p>这时我们可以重做pizza:</p>\n<pre><code>\npublic abstract class Pizza {    \n                                 \n    String name;                 \n    Dauch dauch;                 \n    Sauce sauch;            \n    Cheese  cheese ;     \n                                 \n    abstract void prepared();    \n    abstract void bake();        \n    abstract void cut();         \n    abstract void box();         \n}                                \n                                 \n                                                                                  \n</code></pre>\n<p>中国式pizza:</p>\n<pre><code>public class ChineasePizza extends Pizza {\n    \n    private ChineaseIngredientFactory ingredientFactory;\n    \n    public ChineasePizza(ChineaseIngredientFactory ingredientFactory){\n        this.ingredientFactory=ingredientFactory;\n    }\n    @Override\n    public void prepared() {\n        dauch=ingredientFactory.createDauch();\n        sauch=ingredientFactory.createSauch();\n        cheese=ingredientFactory.createCheese();\n        //TODO\n        \n    }\n\n    @Override\n    public void bake() {\n        //TODO\n    }\n\n    @Override\n    public void cut() {\n        //TODO\n    }\n\n    @Override\n    public void box() {\n        //TODO\n    }\n}\n\n\n</code></pre>\n<p>这时候我们再看，利用抽象工厂模式，可以为pizza创建原料，pizza只关注于它自身的业务逻辑，而不用关注pizza原料从哪里来，这样的pizza和pizza原料的解耦。</p>\n<blockquote>\n<p>通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口写代码，我们的代码将实际工厂解耦，以便在不同的工厂，制造出不同的产品。</p>\n</blockquote>\n<p>到此为止，三种工厂模式已经讲解完毕，<a href="http://download.csdn.net/detail/forezp/9757759">源码下载</a>。</p>\n<h3><a id="_346"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61472038', 'title': 'Spring详解篇之 AOP面向切面编程', 'readNum': '35170', 'commentNum': '0', 'publishTime': '2017-03-12 00:21:42', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h3><a id="_0"></a>一、概述</h3>\n<p>Aop(aspect oriented programming面向切面编程），是spring框架的另一个特征。AOP包括切面、连接点、通知（advice）、切入点（pointCut) 。</p>\n<p>1.aop几个概念：</p>\n<ul>\n<li>横切关注点： 对哪些方面进行拦截，拦截后怎么处理。</li>\n<li>切面(aspect):切面是横切关注点的抽象。</li>\n<li>连接点(joinpoint)：被拦截的方法</li>\n<li>切入点(pointcut):对连接点进行拦截的定义。</li>\n<li>通知(advice)：拦截到连接点之后要执行的代码</li>\n<li>目标对象：代理的目标对象</li>\n<li>织入</li>\n<li>引入</li>\n</ul>\n<p>2.主要功能：</p>\n<ul>\n<li>日志记录</li>\n<li>性能统计</li>\n<li>安全控制</li>\n<li>事物处理</li>\n<li>异常处理</li>\n</ul>\n<p>3.advice类型：</p>\n<ul>\n<li>前置通知(before advice)</li>\n<li>返回后通知(after  returning advice)</li>\n<li>抛出异常后通知(after throwing advice)</li>\n<li>后通知(after advice)</li>\n<li>环绕通知(around advice)</li>\n</ul>\n<p>4.Spring对AOP的支持</p>\n<p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。</p>\n<p>二、基于xml配置的aop</p>\n<p>在spring基于schemel中，aop需要声明一个切面aspect,一个pointcut,一个advisor.<br>\n举个例子：</p>\n<p>切面：</p>\n<pre><code>public class MoocAspect {\n   \n   public void before() {\n   \tSystem.out.println("MoocAspect before.");\n   }\n   \n   }\n\n</code></pre>\n<p>切点：</p>\n<pre><code>public class AspectBiz {\n   \n   public void biz() {\n   \tSystem.out.println("AspectBiz biz.");\n//\t\tthrow new RuntimeException();\n   }\n\n</code></pre>\n<p>配置文件：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n   xmlns:aop="http://www.springframework.org/schema/aop"\n   xsi:schemaLocation="http://www.springframework.org/schema/beans \n       http://www.springframework.org/schema/beans/spring-beans.xsd  \n       http://www.springframework.org/schema/aop \n       http://www.springframework.org/schema/aop/spring-aop-4.0.xsd"&gt;\n\n   &lt;bean id="moocAspect" class="com.imooc.aop.schema.advice.MoocAspect"&gt;&lt;/bean&gt;\n   \n   &lt;bean id="aspectBiz" class="com.imooc.aop.schema.advice.biz.AspectBiz"&gt;&lt;/bean&gt;\n   \n   &lt;aop:config&gt;\n   \t&lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt;\n   \t\t&lt;aop:pointcut expression="execution(* com.imooc.aop.schema.advice.biz.*Biz.*(..))" id="moocPiontcut"/&gt;\n   \t\t&lt;aop:before method="before" pointcut-ref="moocPiontcut"/&gt;\n   \t\t\t&lt;/aop:aspect&gt;\n   &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestAOPSchemaAdvice extends UnitTestBase {\n   \n   public TestAOPSchemaAdvice() {\n   \tsuper("classpath:spring-aop-schema-advice.xml");\n   }\n   \n   @Test\n   public void testBiz() {\n   \tAspectBiz biz = super.getBean("aspectBiz");\n   \tbiz.biz();\n   }\n}\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>MoocAspect before.</p>\n</blockquote>\n<blockquote>\n<p>AspectBiz biz.</p>\n</blockquote>\n<p>这是 机遇 schemel配置使用aop，其实在spring 1.2版本是有api的，基于api配置aop很麻烦，但是也也应该了解下</p>\n<h3><a id="spring_apiaop_123"></a>三、基于spring api方式配置aop</h3>\n<p>直接上代码：</p>\n<p>接口中有两个方法，一个基于aop,会被拦截 ，另外一个不会被拦截。</p>\n<pre><code>public interface IAopService {\n\n\tpublic void withAop() throws Exception;\n\n\tpublic void withoutAop() throws Exception;\n\n}\n\n</code></pre>\n<p>实现类：</p>\n<pre><code>public class AopServiceImpl implements IAopService {\n\n\tprivate String name="forezp";\n\n\tpublic void withAop() throws Exception {\n\n\t\tSystem.out.println("with aop run: " + name);\n\n\t\tif (name.trim().length() == 0)\n\t\t\tthrow new AccountException("name cannot be null");\n\t}\n\n\tpublic void withoutAop() throws Exception {\n\t\tSystem.out.println("without aop");\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n}\n\n</code></pre>\n<p>方法前拦截器，实现MethodBeforeAdvice,在制定方法前会被调用。</p>\n<pre><code>\npublic class MethodBeforeInterceptor implements MethodBeforeAdvice {\n\n\tpublic void before(Method method, Object[] args, Object instance)\n\t\t\tthrows Throwable {\n\n\t\tSystem.out.println("method invoke:" + method.getName());\n\n\t\tif (instance instanceof AopServiceImpl) {\n\n\t\t\tString name = ((AopServiceImpl) instance).getName();\n\n\t\t\tif (name == null)\n\t\t\t\tthrow new NullPointerException("name cannot be null");\n\t\t}\n\n\t}\n\n}\n</code></pre>\n<p>返回后拦截器，执行指定方法后会被调用。</p>\n<pre><code>public class MethodAfterInterceptor implements AfterReturningAdvice {\n\n\tpublic void afterReturning(Object value, Method method, Object[] args,\n\t\t\tObject instance) throws Throwable {\n\n\t\tSystem.out.println("method  " + method.getName() + "had finished and return value-" + value);\n\n\t}\n\n}\n\n\n</code></pre>\n<p>异常拦截器，当出现异常时拦截：</p>\n<pre><code>\npublic class ThrowsInterceptor implements ThrowsAdvice {\n\n\tpublic void afterThrowing(Method method, Object[] args, Object instance,\n\t\t\tAccountException ex) throws Throwable {\n\n\t\tSystem.out.println("method" + method.getName() + " throws exception:" + ex);\n\t}\n\n\tpublic void afterThrowing(NullPointerException ex) throws Throwable {\n\n\t\tSystem.out.println("the exception:" + ex);\n\t}\n\n}\n\n\n</code></pre>\n<p>三个拦截器和Servce实现类需要配置到spring中。实际上，spring无法组装，需要借助代理类，把拦截器安装到NameMatchMethodPointcutAdvisor中，把自定义的bean安装到ProxyFactoryBean中，然后组装在一起：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;\n\n\t&lt;!-- 拦截器 在 withAop() 方法前运行 --&gt;\n\t&lt;bean id="aopMethodBeforeInterceptor"\n\t\tclass="org.springframework.aop.support.NameMatchMethodPointcutAdvisor"&gt;\n\t\t&lt;property name="advice"&gt;\n\t\t\t&lt;bean\n\t\t\t\tclass="com.imooc.aop.example2.MethodBeforeInterceptor" /&gt;\n\t\t&lt;/property&gt;\n\t\t&lt;property name="mappedName" value="withAop"&gt;&lt;/property&gt;\n\t&lt;/bean&gt;\n\n\t&lt;!-- 拦截器 在 withAop() 返回后运行 --&gt;\n\t&lt;bean id="aopMethodAfterInterceptor"\n\t\tclass="org.springframework.aop.support.NameMatchMethodPointcutAdvisor"&gt;\n\t\t&lt;property name="advice"&gt;\n\t\t\t&lt;bean\n\t\t\t\tclass="com.imooc.aop.example2.MethodAfterInterceptor" /&gt;\n\t\t&lt;/property&gt;\n\t\t&lt;property name="mappedName" value="withAop"&gt;&lt;/property&gt;\n\t&lt;/bean&gt;\n\n\t&lt;!-- 拦截器 在异常抛出后运行 --&gt;\n\t&lt;bean id="aopThrowsInterceptor"\n\t\tclass="org.springframework.aop.support.NameMatchMethodPointcutAdvisor"&gt;\n\t\t&lt;property name="advice"&gt;\n\t\t\t&lt;bean\n\t\t\t\tclass="com.imooc.aop.example2.ThrowsInterceptor" /&gt;\n\t\t&lt;/property&gt;\n\t\t&lt;property name="mappedName" value="withAop"&gt;&lt;/property&gt;\n\t&lt;/bean&gt;\n\n\t&lt;bean id="aopService"\n\t\tclass="org.springframework.aop.framework.ProxyFactoryBean"&gt;\n\t\t&lt;!-- 拦截器 --&gt;\n\t\t&lt;property name="interceptorNames"&gt;\n\t\t\t&lt;list&gt;\n\t\t\t\t&lt;value&gt;aopMethodBeforeInterceptor&lt;/value&gt;\n\t\t\t\t&lt;value&gt;aopMethodAfterInterceptor&lt;/value&gt;\n\t\t\t\t&lt;value&gt;aopThrowsInterceptor&lt;/value&gt;\n\t\t\t&lt;/list&gt;\n\t\t&lt;/property&gt;\n\t\t&lt;!-- 被拦截的对象 --&gt;\n\t\t&lt;property name="target"&gt;\n\t\t\t&lt;bean\n\t\t\t\tclass="com.imooc.aop.example2.AopServiceImpl"&gt;\n\t\n\t\t\t\t\t&lt;property name="name" value="forezp"&gt;&lt;/property&gt;\n\t\t\t\n\t\t\t&lt;/bean&gt;\n\t\t&lt;/property&gt;\n\t&lt;/bean&gt;\n\n&lt;/beans&gt;\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>\n\n</code></pre>\n<blockquote>\n<p>method invoke:withAop</p>\n<p>with aop run: forezp</p>\n<p>method  withAophad finished and return value-forezp</p>\n<p>without aop</p>\n</blockquote>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61472234', 'title': '深漂一年，一位程序员的2016年终告白', 'readNum': '42646', 'commentNum': '43', 'publishTime': '2017-03-12 00:22:17', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>2016年早已离我们而去，2017年已经快过去了一个月，是时候赶在过年之前写一篇总结。记录一下过往，展望下未来。<br>\n###一、2016年我做了什么</p>\n<h4><a id="1_3"></a>1.离开了武汉</h4>\n<p>2016年，我辞去了武汉的工作，离开了生活了十几年的城市，在没有找到下家，没有找到住处的情况下，独自一人去了深圳。这是一个对我的人生有重要意义的决定。找工作，可能我比较幸运，在短短的五天之内面了七八家，拿到了三个offer，最终我选择了去一家创业公司。租房子，在朋友们的帮助下很快找到了住处。联系高中、大学朋友，迅速搭起了2个小规模的社交团体。衣食住行的问题，在很短的时间内解决掉，不得不感叹深圳确实是一个快节奏的城市。</p>\n<h4><a id="2app_7"></a>2.做了第一个开源app</h4>\n<p>除了工作之外，我也给自己制定了一些计划，之前打算做自己的 app上线到各大应用市场，后来发现方向不太对，然后把一些好的东西整理出来了，利用下班时间，在一周之内写出了自己的第一个开源项目<a href="https://github.com/forezp/banya">《瓣呀》</a>。开源之后，在短短三天之内就得到了230个star，到目前为止，开源三个月得到了551个star，这算是广大程序员对我的一个肯定。</p>\n<h3><a id="350_11"></a>3.写了50篇技术博文</h3>\n<p>写了差不多50篇技术博文，目前已经在我的csdn上全部公开，在简书上公开了差不多有30篇，在掘金上推广有15篇。取得的成就： csdn流量太小没有统计。其中简书上被推荐到简书首页上有十篇左右，被推荐到程序猿专题有25+篇，阅读量1000+的有9篇。在掘金上推荐文章15篇，阅读文章170篇，喜欢文章85篇，获得喜欢918次，获得阅读20028次。在未来的日子我会一直写文章，不仅仅局限于技术。</p>\n<h4><a id="420_16"></a>4.看了差不多20本非技术书</h4>\n<p>比如《此生未完成》，《三体》全集，《把时间当朋友》，东野圭吾系列，海明威系列，余华系列等等。另外我长期关注了虎嗅网，大多数文章都有阅读，及时了解了行业动态。其实我并不推荐零碎阅读，也不推荐像我这样随便看一些经典之作，最好的阅读方式是带着目的的去全力攻破某一学科这样的阅读方式，这不仅对个人的是提升，对自己的职业发展也是非常有利的，比如你是程序员，你可以去攻破管理学、心理学、哲学、文学、演讲等。</p>\n<h4><a id="5_20"></a>5.依然没有放弃自己的爱好</h4>\n<p>随着年龄的增长，爱好会越来越少，时间越来越少，总会放弃一些自己喜欢的事情。我是一个电影爱好者、是一个音乐爱好者也是一个健身爱好者。在大二的时候我上过中南财大蔡圣勤教授的《中外影视鉴赏》的课程，蔡老师学富五车，温婉尔雅的教学方式使我终生受益，在之后我观看了几乎所有的好电影，在豆瓣有数据记载的有800多部，其中豆瓣top250观看了200+部。音乐，在每天上下班的路上如果是一个人，那只有音乐陪伴，喜欢的音乐的孩子不会太坏，我是这一种。健身，我在健身房坚持了三年，曾经也是有胸肌有腹肌有背有腰的人，当然，现在是没有保持当年的身材，但是没有放弃治疗，每天步行回出租屋，回去做一组腹部撕裂或者平板支撑（5-10分钟）两组、俯卧撑2组，每两周爬一次山，一直希望自己稳定下来了能重回健身房。</p>\n<h3><a id="2016_24"></a>二、2016年，我的几点思考</h3>\n<p>####1.程序员眼中不应该只有代码</p>\n<p>程序员眼中不应该只有代码，只有工作，应该要懂得生活，比如怎么更好的与人相处，怎么更好的过好自己的生活，怎么把工作和生活区分，怎么对待社交，怎么做一个正能量的人。道理都懂，在这方面我做的不好。比如我认为:</p>\n<blockquote>\n<p>社交是相互的，实力相近的人才配有社交，应该放弃一些无用的社交。</p>\n</blockquote>\n<blockquote>\n<p>绝不向丑陋的人开战，要成为一个让事情变美的人之一。</p>\n</blockquote>\n<p>这些道理都是正确的，我没有做好，当然是因为没用把握好度。我是一个如此感性的人，却要做如此理性的事。</p>\n<h4><a id="2_37"></a>2.永远不要忽略自己的健康</h4>\n<p>不要透支自己的身体，尽量不熬夜，适量的运动。都说程序员是青春饭。程序员过了35岁失业了，一种情况就是自己的能力不强，另外一种情况到那时身体不行了，扛不住程序猿的工作强度。所以程序员要学会自己永葆青春。首先需要合理的睡眠时间，其次需要合理的饮食习惯，最后需要合理的运动，在未来我会出一篇这方面的文章。</p>\n<h4><a id="3_41"></a>3.把时间当朋友</h4>\n<p>先上鸡汤，跟我念三遍：</p>\n<blockquote>\n<p>七年就是一辈子</p>\n<p>一年的时间足够改变一个人</p>\n<p>静守每一寸时光</p>\n</blockquote>\n<p>时间最宝贵，但是时间也是最可怕的。所以规划时间太重要了，大到一年时间的整体方向的规划，小到每一天每一小时，每一分钟。我来说说去年一年我在工作日的时间规划：早上7:40准时起床，8:00洗漱完，看书看到8:50出门去公司，一般情况时骑共享单车、听音乐。到公司会花5-10分钟浏览简书、稀土掘金。6:30下班，步行回出租屋，健身锻炼20分钟，听歌20分钟，看书学习30分钟，开电脑学习。十一点准时睡觉。每天的学习时间大概是3-5小时。所以必须给自己一个明确的方向，比如移动端、后端、大数据、人工智能，目前大数据、人工智能、云计算是未来三大主流方向，建议选择一个方向全力攻破。当然你也可以选择自己喜欢的方向、学科，比如历史、文学、心理学、哲学等等。要努力成为一个终生学习者，并且成为一个终身学习受益者。</p>\n<h4><a id="4_53"></a>4.不要忘记梦想</h4>\n<blockquote>\n<p>大多数人25岁就已经死了，75岁才埋葬。</p>\n</blockquote>\n<p>这句话是我在网易云音乐的某首歌（稍后补上）的评论区看到的。这句话大概说的是大多数人25岁就失去了自己的梦想，没有的梦想的人就如同死去，如同行尸走肉。当然，我是赞同这种说法，任何人都需要自己的梦想，哪怕梦想很小，不值得一提。每一个靠自己劳动获得回报和成就感的人都值得被尊重，同时他们也需要对生活一丝美好的愿望。正如马云所说：梦想还是要有的，万一实现了呢。</p>\n<h4><a id="5_59"></a>5.积极的生活态度</h4>\n<p>这是最重要一点，消极的生活态度的人完成不了上面所说的任何一点。经常听别人说这样一句话：我听过很多大道理，依然过不好这一生。道理不是傻子都会懂，对待道理的态度至关重要。你的态度，决定了你的所相信的道理，决定了你的践行力。我在这方面之前是做的不好的，整个求学生涯，都是丢三落四，有着广泛的兴趣爱好，却没用一个能够登大雅之堂。我记得临近毕业吃课题组散伙饭，我的导师老王（知名楚天学者、教授）对我的评价是：聪明，大多数情况是见不着人，不知道我在干嘛，希望我毕业能够花个两三年，沉淀下自己，不要晃荡。我是把他的话每一句都记在心里，因为那几年我是错过了太多的东西（也许未来我会把那段时间写本书）。目前，我对自己对待生活的态度是满意的。</p>\n<h3><a id="2017_64"></a>三、2017年几点规划</h3>\n<p>####1.确定自己的发展方向<br>\n目前的方向是全栈（移动端+后端）.</p>\n<p>####2.继续保持一些好的习惯，并保持强大的践行力</p>\n<p>比如持续的学习，合理的时间的安排，合理的饮食习惯，合理的运动习惯，最重要的是强大的践行力，重要的事情说三遍：践行力、践行力、践行力。</p>\n<p>####3.挑起责任</p>\n<p>要挑起责任，遇到问题不逃避。</p>\n<h4><a id="4_77"></a>4.其他</h4>\n<p>严格要求自己，不仅要成为精英，也要学会怎么过好自己的生活。保持对事物足够的热情，对未知事物有足够好奇心。相信自己足够年轻，一切都来得及。</p>\n<h3><a id="2016_82"></a>四、2016年总结</h3>\n<p>写这篇文章，写了快三个小时，从腊月二十九写到了腊月三十（即除夕），最近几天我跟亲人、朋友、乡亲父老团聚，感叹时光太蹉跎，一年又一年。是时候总结下我的2016了。</p>\n<blockquote>\n<p>成功的路上依然布满荆棘，只有无畏的骑士才能看见彼岸的曙明。</p>\n</blockquote>\n<p>显然，我现在只刚刚骑上战马，也不是勇士，也没有成功。 但是我自信满满，无所畏惧。用以下16个字算是总结，也算是愿景或者个人准则：</p>\n<blockquote>\n<p>知者不惑，勇者无惧，诚者有信，仁者无敌。</p>\n</blockquote>\n<p><img src="https://img-blog.csdnimg.cn/2019060112224978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61471907', 'title': 'Spring详解篇之IoC控制反转', 'readNum': '30505', 'commentNum': '0', 'publishTime': '2017-03-12 00:21:18', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>###一.Spring概况</p>\n<ul>\n<li>spring是一个开源框架</li>\n<li>是一个轻量的控制反转和面向切面的容器框架</li>\n<li>大小和开销都是轻量的。</li>\n<li>通过控制反转技术可以达到松耦合的目的</li>\n<li>切面编程，允许通过分离应用的业务逻辑。</li>\n<li>包含并管理应用对象的配置和生命周期，是一个容器，并且能够组装。</li>\n</ul>\n<h3><a id="IoC_9"></a>二、IoC</h3>\n<p>ioc控制反转：控制权转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责和维护。ioc的目的是创建对象并且组装对象之间的关系。</p>\n<p>####1.bean容器初始化</p>\n<ul>\n<li>\n<p>–org.springframework.beans</p>\n</li>\n<li>\n<p>–org.springframework.context</p>\n</li>\n<li>\n<p>beanfactory 提供配置结构和基本功能，加载并初始化bean</p>\n</li>\n<li>\n<p>applicationContext 保存bean对象并在应用中被应用</p>\n</li>\n</ul>\n<h4><a id="2spring_21"></a>2.spring注入：</h4>\n<ul>\n<li>spring 注入是指在启动 spring容器加载bean配置的时候，完成对变量的赋值行为。</li>\n<li>常见的注入方式:设值注入、构建注入</li>\n</ul>\n<p>举个例子，构建注入</p>\n<p>dao层</p>\n<pre><code>public interface InjectionDAO {\n\t\n\tpublic void save(String arg);\n\t\n}\n\n\n\npublic class InjectionDAOImpl implements InjectionDAO {\n\t\n\tpublic void save(String arg) {\n\t\t//模拟数据库保存操作\n\t\tSystem.out.println("保存数据：" + arg);\n\t}\n\n}\n\n</code></pre>\n<p>service 层接口：</p>\n<pre><code>public interface InjectionService {\n\t\n\tpublic void save(String arg);\n\t\n}\n\n\n</code></pre>\n<p>service 层实现：</p>\n<pre><code>public class InjectionServiceImpl implements InjectionService {\n\t\n\tprivate InjectionDAO injectionDAO;\n\t\n\t//构造器注入\n\tpublic InjectionServiceImpl(InjectionDAO injectionDAO1) {\n\t\tthis.injectionDAO = injectionDAO1;\n\t}\n\t\n\t//设值注入\n\tpublic void setInjectionDAO(InjectionDAO injectionDAO) {\n\t\tthis.injectionDAO = injectionDAO;\n\t}\n\n\tpublic void save(String arg) {\n\t\t//模拟业务操作\n\t\tSystem.out.println("Service接收参数：" + arg);\n\t\targ = arg + ":" + this.hashCode();\n\t\tinjectionDAO.save(arg);\n\t}\n\n</code></pre>\n<p>在spring xml中的配置</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" &gt;\n        \n\t\t&lt;bean id="injectionService" class="com.forezp.ioc.injection.service.InjectionServiceImpl"&gt;\n        \t&lt;constructor-arg name="injectionDAO1" ref="injectionDAO"&gt;&lt;/constructor-arg&gt;\n        &lt;/bean&gt;\n\n        &lt;bean id="injectionDAO" class="com.forezp.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt;\n\n &lt;/beans&gt;\n\n\n</code></pre>\n<p>单元测试</p>\n<p>本系列文章单元测试基类</p>\n<pre><code>\npublic class UnitTestBase {\n\t\n\tprivate ClassPathXmlApplicationContext context;\n\t\n\tprivate String springXmlpath;\n\t\n\tpublic UnitTestBase() {}\n\t\n\tpublic UnitTestBase(String springXmlpath) {\n\t\tthis.springXmlpath = springXmlpath;\n\t}\n\t\n\t@Before\n\tpublic void before() {\n\t\tif (StringUtils.isEmpty(springXmlpath)) {\n\t\t\tspringXmlpath = "classpath*:spring-*.xml";\n\t\t}\n\t\ttry {\n\t\t\tcontext = new ClassPathXmlApplicationContext(springXmlpath.split("[,\\\\s]+"));\n\t\t\tcontext.start();\n\t\t} catch (BeansException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@After\n\tpublic void after() {\n\t\tcontext.destroy();\n\t}\n\t\n\t@SuppressWarnings("unchecked")\n\tprotected &lt;T extends Object&gt; T getBean(String beanId) {\n\t\ttry {\n\t\t\treturn (T)context.getBean(beanId);\n\t\t} catch (BeansException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprotected &lt;T extends Object&gt; T getBean(Class&lt;T&gt; clazz) {\n\t\ttry {\n\t\t\treturn context.getBean(clazz);\n\t\t} catch (BeansException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestInjection extends UnitTestBase {\n\t\n\tpublic TestInjection() {\n\t\tsuper("classpath:spring-injection.xml");\n\t}\n\t\n\t@Test\n\tpublic void testSetter() {\n\t\tInjectionService service = super.getBean("injectionService");\n\t\tservice.save("这是要保存的数据");\n\t}\n\t\n\t@Test\n\tpublic void testCons() {\n\t\tInjectionService service = super.getBean("injectionService");\n\t\tservice.save("这是要保存的数据");\n\t}\n\t\n}\n\n\n</code></pre>\n<p>运行打印：</p>\n<blockquote>\n<p>Service接收参数：这是要保存的数据</p>\n</blockquote>\n<blockquote>\n<p>保存数据：这是要保存的数据:1247298779</p>\n</blockquote>\n<p>这个例子说明，我们可以通过ClassPathXmlApplicationContext.getBean()获取到了service，这个service 是通过xml配置注入到容器中，并且注入的时候通过构造函数的设置了成员变量dao。</p>\n<h3><a id="bean_208"></a>三.bean的配置项</h3>\n<p>####3.1 bean常见的配置项，如下：</p>\n<ul>\n<li>Id</li>\n<li>Class</li>\n<li>Scope</li>\n<li>Constructor arguments</li>\n<li>Properties</li>\n<li>Autowiring mode</li>\n<li>lazy-initialization mode</li>\n<li>Initialization/destruction method</li>\n</ul>\n<h4><a id="32_bean_222"></a>3.2 bean的作用域</h4>\n<ul>\n<li>singleton: 单列</li>\n<li>prototype每次使用都会创建新实例</li>\n<li>request :每次http请求创建一个实例，仅在当前\u3000request有效</li>\n<li>session ： 当前session有效</li>\n</ul>\n<p>举个例子：<br>\n测试sinleton和prototype</p>\n<p>创建bean实例</p>\n<pre><code>public class BeanScope {\n\t\n\tpublic void say() {\n\t\tSystem.out.println("BeanScope say : " + this.hashCode());\n\t}\n\t\n}\n\n</code></pre>\n<p>在xml中配置,作用域为singleton</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" &gt;\n        \n        &lt;bean id="beanScope" class="com.imooc.bean.BeanScope" scope="singleton"&gt;&lt;/bean&gt;\n        \n &lt;/beans&gt;\n\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestBeanScope extends UnitTestBase {\n\t\n\tpublic TestBeanScope() {\n\t\tsuper("classpath*:spring-beanscope.xml");\n\t}\n\t\n\t@Test\n\tpublic void testSay() {\n\t\tBeanScope beanScope = super.getBean("beanScope");\n\t\tbeanScope.say();\n\t\t\n\t\tBeanScope beanScope2 = super.getBean("beanScope");\n\t\tbeanScope2.say();\n\t}\n\t\n\n}\n\n\n</code></pre>\n<p>运行单元测试：</p>\n<blockquote>\n<p>BeanScope say : 1113008012</p>\n</blockquote>\n<p>BeanScope say : 1113008012</p>\n<p>在xml中配置,作用域为prototype</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" &gt;\n        \n        &lt;bean id="beanScope" class="com.imooc.bean.BeanScope" scope="prototype"&gt;&lt;/bean&gt;\n        \n &lt;/beans&gt;\n\n\n</code></pre>\n<p>运行单元测试</p>\n<blockquote>\n<p>BeanScope say : 144724468</p>\n</blockquote>\n<p>BeanScope say : 1432645272</p>\n<p>由此可发现sington在bean容器是一个实例，而prototype创建了二个实例。</p>\n<h3><a id="bean_320"></a>四.bean的生命周期</h3>\n<p>包括以下几个方面：</p>\n<ul>\n<li>定义，在xml中配置</li>\n<li>初始化</li>\n<li>使用</li>\n<li>销毁</li>\n</ul>\n<h4><a id="_328"></a>初始化</h4>\n<p>有两种方式</p>\n<ul>\n<li>实现 InitializingBeean接口，覆盖afterPropertiesSet()</li>\n<li>配置init-method方法</li>\n</ul>\n<h4><a id="_335"></a>销毁</h4>\n<p>也有两种方式：</p>\n<ul>\n<li>实现DisposableBean接口，覆盖destroy();</li>\n<li>配置 destroy-method</li>\n</ul>\n<p>举个例子:</p>\n<p>创建bean实例：</p>\n<pre><code>public class BeanLifeCycle implements InitializingBean, DisposableBean {\n\t\n\tpublic void defautInit() {\n\t\tSystem.out.println("Bean defautInit.");\n\t}\n\t\n\tpublic void defaultDestroy() {\n\t\tSystem.out.println("Bean defaultDestroy.");\n\t}\n\n\t@Override\n\tpublic void destroy() throws Exception {\n\t\tSystem.out.println("Bean destroy.");\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tSystem.out.println("Bean afterPropertiesSet.");\n\t}\n\t\n\tpublic void start() {\n\t\tSystem.out.println("Bean start .");\n\t}\n\t\n\tpublic void stop() {\n\t\tSystem.out.println("Bean stop.");\n\t}\n\t\n}\n\n</code></pre>\n<p>bean的配置：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" \n        default-init-method="defautInit" default-destroy-method="defaultDestroy"&gt;\n        \n        &lt;bean id="beanLifeCycle" class="com.imooc.lifecycle.BeanLifeCycle"  init-method="start" destroy-method="stop"&gt;&lt;/bean&gt;\n\t\n &lt;/beans&gt;\n\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestBeanLifecycle extends UnitTestBase {\n\t\n\tpublic TestBeanLifecycle() {\n\t\tsuper("classpath:spring-lifecycle.xml");\n\t}\n\t\n\t@Test\n\tpublic void test1() {\n\t\tsuper.getBean("beanLifeCycle");\n\t}\n\t\n}\n\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>Bean afterPropertiesSet.</p>\n<p>Bean start .</p>\n</blockquote>\n<p>Bean destroy.</p>\n<blockquote>\n<p>Bean stop.</p>\n</blockquote>\n<p>同时实现两种方式的初始化方法的执行顺序： 接口实现优先于xml中的配置。</p>\n<h3><a id="beanAutowiring_428"></a>五.bean的自动装配（Autowiring）</h3>\n<ul>\n<li>No: 不做任何操作</li>\n<li>byname:根据属性名自动装配</li>\n<li>byType:如果容器存在一个与指定类型相同的bean，则自动装配，如果存在多个，则抛出异常。</li>\n<li>constructor:与 byType类似，不同之处它在于构造器的参数。</li>\n</ul>\n<p>举例子：<br>\n1.byName方式：</p>\n<p>创建一个dao:</p>\n<pre><code>public class AutoWiringDAO {\n\t\n\tpublic void say(String word) {\n\t\tSystem.out.println("AutoWiringDAO : " + word);\n\t}\n\n}\n\n\n</code></pre>\n<p>创建一个service</p>\n<pre><code>public class AutoWiringService {\n\t\n\tprivate AutoWiringDAO autoWiringDAO;\n\n\n\tpublic void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) {\n\t\tSystem.out.println("setAutoWiringDAO");\n\t\tthis.autoWiringDAO = autoWiringDAO;\n\t}\n\t\n\tpublic void say(String word) {\n\t\tthis.autoWiringDAO.say(word);\n\t}\n\n}\n\n</code></pre>\n<p>在xml中配置：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" \n        default-autowire="byName"&gt;\n        \n        &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt;\n        \n        &lt;bean id="autoWiringDAO" class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt;\n\t\n &lt;/beans&gt;\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestAutoWiring extends UnitTestBase {\n\t\n\tpublic TestAutoWiring() {\n\t\tsuper("classpath:spring-autowiring.xml");\n\t}\n\t\n\t@Test\n\tpublic void testSay() {\n\t\tAutoWiringService service = super.getBean("autoWiringService");\n\t\tservice.say(" this is a test");\n\t}\n\n}\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>setAutoWiringDAO</p>\n</blockquote>\n<p>AutoWiringDAO :  this is a test</p>\n<p>通过default-autowire=“byName”;<br>\nAutoWiringService 自动获取了autoWiringDAO的实例。</p>\n<p>2.byTYpe</p>\n<p>将在xml中配置改为byType ：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" \n        default-autowire="byName"&gt;\n        \n        &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt;\n        \n        &lt;bean id="autoWiringDAO" class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt;\n\t\n &lt;/beans&gt;\n\n</code></pre>\n<p>其他不变，运行和byName 一样。</p>\n<p>3.constructor</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd" \n        default-autowire="constructor"&gt;\n        \n        &lt;bean id="autoWiringService" class="com.imooc.autowiring.AutoWiringService" &gt;&lt;/bean&gt;\n        \n        &lt;bean id="autoWiringDAO" class="com.imooc.autowiring.AutoWiringDAO" &gt;&lt;/bean&gt;\n\t\n &lt;/beans&gt;\n\n</code></pre>\n<p>AutoWiringService 中增加构造器</p>\n<pre><code>\npublic class AutoWiringService {\n\t\n\tprivate AutoWiringDAO autoWiringDAO;\n\t\n\tpublic AutoWiringService(AutoWiringDAO autoWiringDAO) {\n\t\tSystem.out.println("AutoWiringService");\n\t\tthis.autoWiringDAO = autoWiringDAO;\n\t}\n\n\tpublic void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) {\n\t\tSystem.out.println("setAutoWiringDAO");\n\t\tthis.autoWiringDAO = autoWiringDAO;\n\t}\n\t\n\tpublic void say(String word) {\n\t\tthis.autoWiringDAO.say(word);\n\t}\n\n}\n\n\n</code></pre>\n<p>允行：</p>\n<blockquote>\n<p>AutoWiringDAO :  this is a test</p>\n</blockquote>\n<h3><a id="classPath_595"></a>六.classPath扫描与组件管理</h3>\n<p>从spring 3.0开始，spring javaConfig 项目提供了许多特性，包括使用java而不是xml</p>\n<p>1.比如注解</p>\n<blockquote>\n<p>@Configuration<br>\n@Bean<br>\n@Import<br>\n@DependsOn</p>\n<p>@Component 是一个通用注解，应用于任何bean</p>\n<p>@Reposity注解DAO</p>\n<p>@Service注解service</p>\n<p>@Controller注解controller</p>\n</blockquote>\n<p>2.spring可以自动检测类并注册bean到applicationContext中。比如<br>\n@Service  @Reposity等</p>\n<p>3.&lt; context:annoation-config /&gt;会查找applicationContext中bean的注解。</p>\n<p>扫描 ：&lt; context:component-scan&gt;  包含&lt; context:annoation-config/&gt;，通常只需要使用前者。</p>\n<pre><code>&lt;context:component-scan base-package="com.forezp" &gt; \n</code></pre>\n<p>举个例子：<br>\n通过扫描获取bean,在xml中的配置：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd" &gt;\n        \n        &lt;context:component-scan base-package="com.forezp.beanannotation"&gt;&lt;/context:component-scan&gt;\n        \n &lt;/beans&gt;\n\n</code></pre>\n<p>定义一个bean类：<br>\n其中scope 注解表示bean的作用域，默认singleton。Component默认类名并将第一个字母小写。</p>\n<pre><code>@Scope\n@Component\npublic class BeanAnnotation {\n\t\n\tpublic void say(String arg) {\n\t\tSystem.out.println("BeanAnnotation : " + arg);\n\t}\n\t\n\tpublic void myHashCode() {\n\t\tSystem.out.println("BeanAnnotation : " + this.hashCode());\n\t}\n\t\n}\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestBeanAnnotation extends UnitTestBase {\n\t\n\tpublic TestBeanAnnotation() {\n\t\tsuper("classpath*:spring-beanannotation.xml");\n\t}\n\t\n\t@Test\n\tpublic void testSay() {\n\t\tBeanAnnotation bean = super.getBean("beanAnnotation");\n\t\tbean.say("This is test.");\n\t\t\n\t\t//bean = super.getBean("bean");\n\t\t//bean.say("This is test.");\n\t}\n\n}\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>BeanAnnotation : This is test.</p>\n</blockquote>\n<h3><a id="Autowired_696"></a>七、Autowired</h3>\n<ul>\n<li>@Autowired可以用于setter方法上</li>\n<li>可以用于成员变量</li>\n<li>可以用于构造器</li>\n</ul>\n<p>举个例子：</p>\n<p>采用包扫描：</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd" &gt;\n        \n        &lt;context:component-scan base-package="com.forezp.beanannotation"&gt;&lt;/context:component-scan&gt;\n        \n &lt;/beans&gt;\n\n\n</code></pre>\n<p>采用注解：DAO层</p>\n<pre><code>@Repository\npublic class InjectionDAOImpl implements InjectionDAO {\n\t\n\tpublic void save(String arg) {\n\t\t//模拟数据库保存操作\n\t\tSystem.out.println("保存数据：" + arg);\n\t}\n\n}\n\n\n</code></pre>\n<p>service层：</p>\n<pre><code>@Service\npublic class InjectionServiceImpl implements InjectionService {\n\t\n//\t@Autowired\n\tprivate InjectionDAO injectionDAO;\n\t\n\t@Autowired\n\tpublic InjectionServiceImpl(InjectionDAO injectionDAO) {\n\t\tthis.injectionDAO = injectionDAO;\n\t}\n\t\n//\t@Autowired\n\tpublic void setInjectionDAO(InjectionDAO injectionDAO) {\n\t\tthis.injectionDAO = injectionDAO;\n\t}\n\n\n\n\tpublic void save(String arg) {\n\t\t//模拟业务操作\n\t\tSystem.out.println("Service接收参数：" + arg);\n\t\targ = arg + ":" + this.hashCode();\n\t\tinjectionDAO.save(arg);\n\t}\n\t\n}\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestInjection extends UnitTestBase {\n   \n   public TestInjection() {\n   \tsuper("classpath:spring-beanannotation.xml");\n   }\n   \n   @Test\n   public void testAutowired() {\n   \tInjectionService service = super.getBean("injectionServiceImpl");\n   \tservice.save("This is autowired.");\n   }\n}\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>Service接收参数：This is autowired.</p>\n</blockquote>\n<blockquote>\n<p>保存数据：This is autowired.:1641742937</p>\n</blockquote>\n<h3><a id="javaBean_799"></a>八、基于java的容器注解@Bean</h3>\n<ul>\n<li>@Bean 标识一个用于配置和初始化一个由springIoC容器管理的新对象的方法，类似于\u3000xml配置文件的&lt;/ bean&gt;</li>\n</ul>\n<p>举个例子：<br>\n用注解去代替xml文件</p>\n<pre><code>@Configuration\n\npublic class StoreConfig {\n\t\n\n@Bean(name = "stringStore", initMethod="init", destroyMethod="destroy")\n\tpublic Store stringStore() {\n\t\treturn new StringStore();\n\t}\n\t\n</code></pre>\n<p>javabean StringStore类</p>\n<pre><code>\npublic class StringStore implements Store&lt;String&gt; {\n\t\n\tpublic void init() {\n\t\tSystem.out.println("This is init.");\n\t}\n\t\n\tpublic void destroy() {\n\t\tSystem.out.println("This is destroy.");\n\t}\n\t\n}\n\n</code></pre>\n<p>单元测试：</p>\n<pre><code>@RunWith(BlockJUnit4ClassRunner.class)\npublic class TestJavabased extends UnitTestBase {\n\t\n\tpublic TestJavabased() {\n\t\tsuper("classpath*:spring-beanannotation.xml");\n\t}\n\t\n\t@Test\n\tpublic void test() {\n\t\tStore store = super.getBean("stringStore");\n\t\tSystem.out.println(store.getClass().getName());\n\t}\n\t\n\t}\n\n</code></pre>\n<p>另外可以用ImportResource注解类获取资源文件信息：</p>\n<pre><code>@Configuration\n@ImportResource("classpath:config.xml")\npublic class StoreConfig {\n\t\n\t\n\t@Value("${url}")\n\tprivate String url;\n\t\n\t@Value("${jdbc.username}")\n\tprivate String username;\n\t\n\t@Value("${password}")\n\tprivate String password;\n\t\n</code></pre>\n<h3><a id="JSR250_876"></a>九、JSR-250</h3>\n<ul>\n<li>spring支持jsr-250</li>\n<li>@Resource注解变量或者setter 方法</li>\n<li>Resource注解有一个name属性，默认该值作为被注入bean的名称。</li>\n</ul>\n<p>举个例子：</p>\n<p>Dao层：</p>\n<pre><code>@Repository\npublic class JsrDAO {\n\t\n\tpublic void save() {\n\t\tSystem.out.println("JsrDAO invoked.");\n\t}\n\t\n}\n\n\n</code></pre>\n<p>service层：</p>\n<pre><code>\n\n@Service\npublic class JsrServie {\n\t\n\t@Resource\n\tprivate JsrDAO jsrDAO;\n\t\n//\t@Resource\n//\tpublic void setJsrDAO(@Named("jsrDAO") JsrDAO jsrDAO) {\n\t//\tthis.jsrDAO = jsrDAO;\n\t//}\n\t\n\t@PostConstruct\n\tpublic void init() {\n\t\tSystem.out.println("JsrServie init.");\n\t}\n\t\n\t@PreDestroy\n\tpublic void destroy() {\n\t\tSystem.out.println("JsrServie destroy.");\n\t}\n\n\tpublic void save() {\n\t\tjsrDAO.save();\n\t}\n\t\n}\n\n</code></pre>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61471712', 'title': '5分钟带你入门Redis', 'readNum': '41049', 'commentNum': '5', 'publishTime': '2017-03-12 00:20:43', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/61471712">http://blog.csdn.net/forezp/article/details/61471712</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<h3><a id="1redis_5"></a>1.redis概述</h3>\n<p>redis是一个开源的，先进的 key-value 存储可用于构建高性能的存储解决方案。它支持数据结构有字符串，哈希，列表，集合，带有范围查询的排序集，位图，超文本和具有半径查询的地理空间索引。 NoSQL，Not Only [SQL]，泛指非关系型的数据库。所以redis是一种nosql。<em>敲黑板画重点：redis是一种nosql.</em></p>\n<p>redis的优点：</p>\n<ul>\n<li>异常快速</li>\n<li>支持丰富的数据类型</li>\n<li>操作都是原子的</li>\n</ul>\n<h3><a id="2_14"></a>2.下载安装</h3>\n<p>linux 系统下安装：</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n\n</code></pre>\n<p>启动服务器：</p>\n<pre><code>   $ src/redis-server\n</code></pre>\n<p>启动客户端</p>\n<pre><code>$ src/redis-cli\n</code></pre>\n<p>mac下安装:</p>\n<pre><code>brew install redis\n</code></pre>\n<p>启动：</p>\n<pre><code>redis-server\nredis-cli \n\n</code></pre>\n<p>windows下安装:</p>\n<p>由于官方并没有提供windows 版本，不过微软为了能够应用redis 到 windows服务器，由微软维护了windows版的redis，下载地址：<a href="https://github.com/MSOpenTech/redis/releases">点击进入</a>.建议下载msi 版本，直接安装即可。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122348498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>启动成功：</p>\n<pre><code>[35142] 01 May 14:36:28.939 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf\n[35142] 01 May 14:36:28.940 * Max number of open files set to 10032\n                _._\n              _.-``__ \'\'-._\n        _.-``    `.  `_.  \'\'-._           Redis 2.6.12 (00000000/0) 64 bit\n    .-`` .-```.  ```\\/    _.,_ \'\'-._\n  (    \'      ,       .-`  | `,    )     Running in stand alone mode\n  |`-._`-...-` __...-.``-._|\'` _.-\'|     Port: 6379\n  |    `-._   `._    /     _.-\'    |     PID: 35142\n    `-._    `-._  `-./  _.-\'    _.-\'\n  |`-._`-._    `-.__.-\'    _.-\'_.-\'|\n  |    `-._`-._        _.-\'_.-\'    |           http://redis.io\n    `-._    `-._`-.__.-\'_.-\'    _.-\'\n  |`-._`-._    `-.__.-\'    _.-\'_.-\'|\n  |    `-._`-._        _.-\'_.-\'    |\n    `-._    `-._`-.__.-\'_.-\'    _.-\'\n        `-._    `-.__.-\'    _.-\'\n            `-._        _.-\'\n                `-.__.-\'\n\n[35142] 01 May 14:36:28.941 # Server started, Redis version 2.6.12\n[35142] 01 May 14:36:28.941 * The server is now ready to accept connections on port 6379\n</code></pre>\n<h3><a id="3redis__84"></a>3.redis 支持的数据类型</h3>\n<h4><a id="31_86"></a>3.1字符串</h4>\n<p>启动客户端 ,存储字符串到redis.</p>\n<pre><code>redis&gt; SET name forezp\nOK\n</code></pre>\n<p>取字符串:</p>\n<pre><code> redis&gt; get name \n"forezp"\n</code></pre>\n<h4><a id="32Hashes___101"></a>3.2Hashes - 哈希值</h4>\n<pre><code>\nredis &gt; HMSET king username forezp password xxdxx age 22\nredis &gt; HGETALL king\n1) "username"\n2) "forezp "\n3) "password "\n4) "xxdxx "\n5) "age "\n6) "22"\n</code></pre>\n<h4><a id="33_Lists___115"></a>3.3 Lists - 列表</h4>\n<pre><code>redis&gt; lpush pricess jack\n(integer) 1\nredis 127.0.0.1:6379&gt; lpush pricess jolin\n(integer) 2\nredis 127.0.0.1:6379&gt; lpush pricess mayun\n(integer) 3\nredis 127.0.0.1:6379&gt; lrange pricess 0 10\n1) "jack"\n2) "jolin"\n3) "mayun"\n\n</code></pre>\n<h4><a id="34_Redis_130"></a>3.4 Redis有序集合</h4>\n<p>Redis有序集合类似Redis集合存储在设定值唯一性。不同的是，一个有序集合的每个成员带有分数，用于以便采取有序set命令，从最小的到最大的分数有关。</p>\n<pre><code>redis &gt; ZADD kindom 1 redis\n(integer) 1\nredis&gt; ZADD kindom 2 mongodb\n(integer) 1\nredis &gt; ZADD kindom 3 mysql\n(integer) 1\nredis &gt; ZADD kindom 3 mysql\n(integer) 0\nredis &gt; ZADD kindom 4 mysql\n(integer) 0\nredis &gt; ZRANGE kindom 0 10 WITHSCORES\n1) "redis"\n2) "1"\n3) "mongodb"\n4) "2"\n5) "mysql"\n6) "4"\n\n</code></pre>\n<h4><a id="35_Redis_154"></a>3.5 Redis发布订阅</h4>\n<p>开启客户端作为接受者</p>\n<pre><code>\nredis&gt; SUBSCRIBE myking messages...\n (press Ctrl-C to quit\n)1) "subscribe"\n2) "myking "\n3) (integer) 1\n\n</code></pre>\n<p>开启另一个客户端作为发送者：</p>\n<pre><code>redis &gt; PUBLISH myking "Redis is a great caching technique"\n(integer) 1\n\n</code></pre>\n<p>这样接受者就可以收到:</p>\n<pre><code>"Redis is a great caching technique"\n</code></pre>\n<h4><a id="36__180"></a>3.6 其他的一些操作</h4>\n<p>1.获取所以的key</p>\n<pre><code>redis&gt; KEYS *\n\n</code></pre>\n<p>2,判断key是否存在</p>\n<pre><code>EXISTS key\n</code></pre>\n<p>3.删除key</p>\n<pre><code>DEL key [key …]\n</code></pre>\n<p>4.获取数据类型</p>\n<pre><code>\nTYPE key\n</code></pre>\n<p>5.向尾部添加</p>\n<pre><code>APPEND key value\n\n</code></pre>\n<p>6.获取字符串长度</p>\n<pre><code>strlen key\n</code></pre>\n<p>当然这里只是介绍简单的一些操作，复杂的参考官方文档。</p>\n<h3><a id="4_javaredisjedis_223"></a>4. 在java应用中使用redis—jedis</h3>\n<p>前提是redis 已经安装，并且已经开启服务。</p>\n<p>jedis 下载地址 <a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></p>\n<blockquote>\n<p>Jedis is a blazingly small and sane <a href="http://github.com/antirez/redis">Redis</a> java client.<br>\nJedis was conceived to be EASY to use.</p>\n</blockquote>\n<blockquote>\n<p>翻译： jedis是一个非常小的java客户端，被认为是容易使用。</p>\n</blockquote>\n<p><em>怎么使用？</em></p>\n<pre><code>    public static void main(String[] args){\n\n        Jedis jedis = new Jedis("localhost");\n        System.out.println("Connection to server sucessfully");\n        //check whether server is running or not\n        System.out.println("Server is running: "+jedis.ping());\n        jedis.lpush("forezp-list", "Redis");\n        jedis.lpush("forezp-list", "Mongodb");\n        jedis.lpush("forezp-list", "Mysql");\n        // Get the stored data and print it\n        List&lt;String&gt; list = jedis.lrange("forezp-list", 0 ,5);\n        for(int i=0; i&lt;list.size(); i++) {\n            System.out.println("Stored string in redis:: "+list.get(i));\n        }\n\n    }\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>Connection to server sucessfully<br>\nServer is running: PONG<br>\nStored string in redis:: Mysql<br>\nStored string in redis:: Mongodb<br>\nStored string in redis:: Redis<br>\nStored string in redis:: Mysql<br>\nStored string in redis:: Mongodb<br>\nStored string in redis:: Redis</p>\n</blockquote>\n<p>redis 入门介绍就到这里了。另外，<em>敲黑板，划重点：</em> 遇到问题首先不要去百度搜，要去官网搜。聪明的你，是不是自己安装下 ，实践下。</p>\n<h3><a id="_269"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/61471513', 'title': 'Mybatis学习的一些细节', 'readNum': '29994', 'commentNum': '1', 'publishTime': '2017-03-12 00:20:07', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h3><a id="mybatis__0"></a>一.mybatis 基本配置</h3>\n<p>最近几天一直在学习mybatis，看了一些源码，本文讲述mybatis的一些基本配置和基本的用法和注意到一些细节。个人时间和精力有限，本文属于流水账类型，不成体系，算是自己的个人笔记吧。</p>\n<p>1.本案例所使用的数据库为mysql，数据库的脚本代码如下：</p>\n<pre><code>CREATE TABLE `message` (\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `COMMAND` varchar(16) DEFAULT NULL COMMENT \'指令名称\',\n  `DESCRIPTION` varchar(32) DEFAULT NULL COMMENT \'描述\',\n  `CONTENT` varchar(2048) DEFAULT NULL COMMENT \'内容\',\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;\n\n\nINSERT INTO `message` VALUES (1, \'查看\', \'精彩内容\', \'精彩内容\');\nINSERT INTO `message` VALUES (2, \'段子\', \'精彩段子\', \'如果你的月薪是3000块钱，请记得分成五份，一份用来买书，一份给家人，一份给女朋友买化妆品和衣服，一份请朋友们吃饭，一份作为同事的各种婚丧嫁娶的份子钱。剩下的2999块钱藏起来，不要告诉任何人\');\nINSERT INTO `message` VALUES (3, \'新闻\', \'今日头条\', \'7月17日，马来西亚一架载有298人的777客机在乌克兰靠近俄罗斯边界坠毁。另据国际文传电讯社消息，坠毁机型为一架波音777客机，机载约280名乘客和15个机组人员。\\r\\n乌克兰空管部门随后证实马航MH17航班坠毁。乌克兰内政部幕僚表示，这一航班在顿涅茨克地区上空被击落。马来西亚航空公司确认，该公司从阿姆斯特丹飞往吉隆坡的MH17航班失联，并称最后与该客机取得联系的地点在乌克兰上空。图为马航客机坠毁现场。\');\nINSERT INTO `message` VALUES (4, \'娱乐\', \'娱乐新闻\', \'昨日，邓超在微博分享了自己和孙俪的书法。夫妻同样写幸福，但差距很大。邓超自己都忍不住感慨字丑：左边媳妇写的。右边是我写的。看完我再也不幸福了。\');\nINSERT INTO `message` VALUES (5, \'电影\', \'近日上映大片\', \'《忍者神龟》[2]真人电影由美国派拉蒙影业发行，《洛杉矶之战》导演乔纳森·里贝斯曼执导。 \\r\\n片中四只神龟和老鼠老师都基于漫画和卡通重新绘制，由动作捕捉技术实现。\\r\\n其中皮特·普劳泽克饰演达芬奇(武器：武士刀)，诺尔·费舍饰演米开朗基罗(武器：双节棍)，阿伦·瑞奇森饰演拉斐尔(武器：铁叉)，杰瑞米·霍华德饰演多拉泰罗(武器：武士棍)。\\r\\n该片计划于2014年8月8日在北美上映。\');\nINSERT INTO `message` VALUES (6, \'彩票\', \'中奖号码\', \'查啥呀查，你不会中奖的！\');\n</code></pre>\n<p>2.创建实体类</p>\n<pre><code>public class Message {\n\t/**\n\t * 主键\n\t */\n\tprivate String id;\n\t/**\n\t * 指令名称\n\t */\n\tprivate String command;\n\t/**\n\t * 描述\n\t */\n\tprivate String description;\n\t/**\n\t * 内容\n\t */\n\tprivate String content;\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getCommand() {\n\t\treturn command;\n\t}\n\tpublic void setCommand(String command) {\n\t\tthis.command = command;\n\t}\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\tpublic void setContent(String content) {\n\t\tthis.content = content;\n\t}\n}\n\n\n</code></pre>\n<p>3.去<a href="http://blog.mybatis.org/" rel="nofollow">官网</a>下载mybatis ，导入相应的jar包。</p>\n<p>创建配置文件configuration.xml</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8" ?&gt;\n&lt;!DOCTYPE configuration\n   PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n   "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;\n\n&lt;configuration&gt;\n&lt;!-- \n &lt;settings&gt;\n   &lt;setting name="useGeneratedKeys" value="false"/&gt;\n   &lt;setting name="useColumnLabel" value="true"/&gt;\n &lt;/settings&gt;\n\n &lt;typeAliases&gt;\n   &lt;typeAlias alias="UserAlias" type="org.apache.ibatis.submitted.complex_property.User"/&gt;\n &lt;/typeAliases&gt; --&gt;\n \n &lt;environments default="development"&gt;\n   &lt;environment id="development"&gt;\n     &lt;transactionManager type="JDBC"&gt;\n       &lt;property name="" value=""/&gt;\n     &lt;/transactionManager&gt;\n     &lt;dataSource type="UNPOOLED"&gt;\n       &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;\n       &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/micro_message"/&gt;\n       &lt;property name="username" value="root"/&gt;\n       &lt;property name="password" value="123"/&gt;\n     &lt;/dataSource&gt;\n   &lt;/environment&gt;\n &lt;/environments&gt;\n \n &lt;mappers&gt;\n   &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt;\n   &lt;mapper resource="com/imooc/config/sqlxml/Command.xml"/&gt;\n   &lt;mapper resource="com/imooc/config/sqlxml/CommandContent.xml"/&gt;\n &lt;/mappers&gt;\n\n&lt;/configuration&gt;\n</code></pre>\n<p>这个配置文件，需要一个对象跟数据库交互,这个对象是sqlsession,下面讲述sqlsession.</p>\n<h3><a id="Sqlsession_120"></a>二.Sqlsession对象</h3>\n<p>Sqlsession的作用：</p>\n<ul>\n<li>\n<ol>\n<li>向sql 语句传入参数</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>执行 sql语句</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>获取执行sql语句的结果</li>\n</ol>\n</li>\n<li>\n<ol start="4">\n<li>事物的控制</li>\n</ol>\n</li>\n</ul>\n<p>如何获取Sqlsession：</p>\n<ul>\n<li>\n<ol>\n<li>通过获取配置文件获取数据库连接相关信息</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>通过配置信息构建 sqlSessionFactory 的对象</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>通过sqlsessionFactory大家数据库会话。</li>\n</ol>\n</li>\n</ul>\n<pre><code>public SqlSession getSqlSession() throws IOException {\n\t\t// 通过配置文件获取数据库连接信息\n\t\tReader reader = Resources.getResourceAsReader("com/forzp/config/Configuration.xml");\n\t\t// 通过配置信息构建一个SqlSessionFactory\n\t\tSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n\t\t// 通过sqlSessionFactory打开一个数据库会话\n\t\tSqlSession sqlSession = sqlSessionFactory.openSession();\n\t\treturn sqlSession;\n\t}\n\n</code></pre>\n<p>3.SQL基本配置、执行</p>\n<p>Message.xml文件配置：</p>\n<pre><code>&lt;mapper namespace="Message"&gt;\n\n  &lt;resultMap type="com.imooc.bean.Message" id="MessageResult"&gt;\n    &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt;\n    &lt;result column="COMMAND" jdbcType="VARCHAR" property="command"/&gt;\n    &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt;\n    &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt;\n  &lt;/resultMap&gt;\n\n&lt;/mapper&gt;\n\n&lt;select id="queryMessageList" parameterType="com.imooc.bean.Message" resultMap="MessageResult"&gt;\n    select &lt;include refid="columns"/&gt; from MESSAGE\n    &lt;where&gt;\n    \t&lt;if test="command != null and !"".equals(command.trim())"&gt;\n\t    \tand COMMAND=#{command}\n\t    &lt;/if&gt;\n\t    &lt;if test="description != null and !"".equals(description.trim())"&gt;\n\t    \tand DESCRIPTION like \'%\' #{description} \'%\'\n\t    &lt;/if&gt;\n    &lt;/where&gt;\n  &lt;/select&gt;\n\n</code></pre>\n<p>其中使用到了ONGL表达式:</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112250231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122550185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在configuration.xml中配置</p>\n<pre><code> &lt;mappers&gt;\n    &lt;mapper resource="com/imooc/config/sqlxml/Message.xml"/&gt;\n  \n  &lt;/mappers&gt;\n\n\n</code></pre>\n<p>执行：</p>\n<pre><code>/**\n\t * 根据查询条件查询消息列表\n\t */\n\tpublic List&lt;Message&gt; queryMessageList(String command,String description) {\n\t\tDBAccess dbAccess = new DBAccess();\n\t\tList&lt;Message&gt; messageList = new ArrayList&lt;Message&gt;();\n\t\tSqlSession sqlSession = null;\n\t\ttry {\n\t\t\tsqlSession = dbAccess.getSqlSession();\n\t\t\tMessage message = new Message();\n\t\t\tmessage.setCommand(command);\n\t\t\tmessage.setDescription(description);\n\t\t\t// 通过sqlSession执行SQL语句\n\t\t\tmessageList = sqlSession.selectList("Message.queryMessageList",message);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif(sqlSession != null) {\n\t\t\t\tsqlSession.close();\n\t\t\t}\n\t\t}\n\t\treturn messageList;\n\t}\n\n</code></pre>\n<h3><a id="log4jSQL_231"></a>三、log4j动态调试SQL</h3>\n<p>由于mybatis的sql语句写在了xml中，导致调试比较困难，不能打断点。这时需要日志去调。</p>\n<p>下载log4j jar包,并配置log4j.propertites</p>\n<pre><code>log4j.rootLogger=DEBUG,Console\nlog4j.appender.Console=org.apache.log4j.ConsoleAppender\nlog4j.appender.Console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n\nlog4j.logger.org.apache=INFO\n\n</code></pre>\n<p>log的级别：</p>\n<blockquote>\n<p>log.debug</p>\n<p><a href="http://log.info" rel="nofollow">log.info</a></p>\n</blockquote>\n<blockquote>\n<p>log.warm</p>\n</blockquote>\n<blockquote>\n<p>log.error</p>\n</blockquote>\n<p>级别从小到大，也就是og4j.rootLogger=DEBUG；可以输出所有的日志类型；og4j.rootLogger=info ，只能够输出\u3000info,warm ,error</p>\n<p>要想mybtis  显示日志，必须log4j.rootLogger=DEBUG；<br>\n项目中配置了log4j，mybatis 会自动应用log4j</p>\n<h3><a id="_260"></a>四、一些其他的知识点</h3>\n<p>mybatis sql配置文件常用的标签如下：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122609545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>mapper文件下的标签含义：</p>\n<p>nameSpace  标签区分可以用来区分sql文件</p>\n<p>parameterType\t将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</p>\n<p>resultMap\t外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</p>\n<h3><a id="sql_xml_275"></a>五、一对多sql xml的配置</h3>\n<p>java实体内Command包含了一个List contentList集合。</p>\n<pre><code>\npublic class Command {\n\t/**\n\t * 主键\n\t */\n\tprivate String id;\n\t/**\n\t * 指令名称\n\t */\n\tprivate String name;\n\t/**\n\t * 描述\n\t */\n\tprivate String description;\n\t/**\n\t * 一条指令对应的自动回复内容列表\n\t */\n\tprivate List&lt;CommandContent&gt; contentList;\n\t\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\tpublic List&lt;CommandContent&gt; getContentList() {\n\t\treturn contentList;\n\t}\n\tpublic void setContentList(List&lt;CommandContent&gt; contentList) {\n\t\tthis.contentList = contentList;\n\t}\n}\n\n</code></pre>\n<p>在mapper中配置：</p>\n<pre><code>&lt;mapper namespace="Command"&gt;\n  &lt;resultMap type="com.imooc.bean.Command" id="Command"&gt;\n    &lt;id column="C_ID" jdbcType="INTEGER" property="id"/&gt;\n    &lt;result column="NAME" jdbcType="VARCHAR" property="name"/&gt;\n    &lt;result column="DESCRIPTION" jdbcType="VARCHAR" property="description"/&gt;\n    &lt;collection property="contentList"  resultMap="CommandContent.Content"/&gt;\n  &lt;/resultMap&gt;\n  \n  &lt;select id="queryCommandList" parameterType="com.imooc.bean.Command" resultMap="Command"&gt;\n    select a.ID C_ID,a.NAME,a.DESCRIPTION,b.ID,b.CONTENT,b.COMMAND_ID\n    from COMMAND a left join COMMAND_CONTENT b\n    on a.ID=b.COMMAND_ID\n    &lt;where&gt;\n    \t&lt;if test="name != null and !"".equals(name.trim())"&gt;\n\t    \tand a.NAME=#{name}\n\t    &lt;/if&gt;\n\t    &lt;if test="description != null and !"".equals(description.trim())"&gt;\n\t    \tand a.DESCRIPTION like \'%\' #{description} \'%\'\n\t    &lt;/if&gt;\n    &lt;/where&gt;\n  &lt;/select&gt;\n  \n&lt;/mapper&gt;\n\n</code></pre>\n<p>CommandContent.xml配置</p>\n<pre><code>&lt;mapper namespace="CommandContent"&gt;\n  &lt;resultMap type="com.imooc.bean.CommandContent" id="Content"&gt;\n    &lt;id column="ID" jdbcType="INTEGER" property="id"/&gt;\n    &lt;result column="CONTENT" jdbcType="VARCHAR" property="content"/&gt;\n    &lt;result column="COMMAND_ID" jdbcType="VARCHAR" property="commandId"/&gt;\n  &lt;/resultMap&gt;\n&lt;/mapper&gt;\n\n</code></pre>\n<p>经过这样的配置，在DAO层执行，就可以取出command中的属性。</p>\n<p>六.取自增长 key</p>\n<pre><code>&lt;insert id="insert" parameterType="com.imooc.bean.Command" useGeneratedKeys="true" keyProperty="id"&gt;\n  insert into Command (name,description) values(#{name},#{description});\n &lt;/insert&gt;\n\n</code></pre>\n<p>七、一点细节</p>\n<pre><code>#{} 和${}区别：\n#{}相当于preparedStatment;\n${}相当于statment,它主要用于排序oderby \n\n</code></pre>\n<p>另外：</p>\n<p>敲黑板划重点，mybatis的所有知识都可以在官网上都有，建议看十遍，……<sup>_</sup>，地址：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html" rel="nofollow">http://www.mybatis.org/mybatis-3/zh/configuration.html</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730429', 'title': '关于Java的反射机制，你需要理解这些..', 'readNum': '31022', 'commentNum': '6', 'publishTime': '2016-12-18 21:53:51', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/53730429">http://blog.csdn.net/forezp/article/details/53730429</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。【翻译于 官方文档】</p>\n<p>本篇将从以下几个方面讲述反射的知识：</p>\n<ul>\n<li>calss的使用</li>\n<li>方法的反射</li>\n<li>构造函数的反射</li>\n<li>成员变量的反射</li>\n</ul>\n<h3><a id="class_14"></a>一、什么是class类</h3>\n<p>在面向对象的世界里，万物皆对象。类是对象，类是java.lang.Class类的实例对象。另外class类只有java虚拟机才能new出来。任何一个类都是Class 类的实例对象。这实例对象有三种表达方式：</p>\n<pre><code>public class User{\n}\n\npublic class ClassTest{\nUser u=new User();\n //方式1:\n Class c1=User.class;\n//方式2:\nClass c2=u.getClass();\n//方式3:\nClass c3=Class.forName("com.forezp.User");\n\n//可以通过类的类型创建该类的实例对象\nUser user=(User)c1.newInstance();\n}\n\n</code></pre>\n<h3><a id="class_37"></a>二、class类的动态加载</h3>\n<p>Class.forName(类的全称);该方法不仅表示了类的类型，还代表了动态加载类。编译时刻加载类是静态加载、运行时刻加载类是动态加载类。</p>\n<h3><a id="_40"></a>三、获取方法信息</h3>\n<p>基本的数据类型，void关键字都Class 类的实例;可以通过get<br>\name();getSimpleName()获取类的名称。</p>\n<pre><code>Class c1=String.class;\nClass c2=int.class;\nClass c3=void.class;\nSystem.out.println(c1.getName());\nSystem.out.println(c2.getSimpleName());\n</code></pre>\n<p>获取类的所有方法，并打印出来：</p>\n<pre><code>public static void printClassInfo(Object object){\n        Class c=object.getClass();\n        System.out.println("类的名称："+c.getName());\n\n        /**\n         * 一个成员方法就是一个method对象\n         * getMethod()所有的 public方法，包括父类继承的 public\n         * getDeclaredMethods()获取该类所有的方法，包括private ,但不包括继承的方法。\n         */\n        Method[] methods=c.getMethods();//获取方法\n        //获取所以的方法，包括private ,c.getDeclaredMethods();\n\n        for(int i=0;i&lt;methods.length;i++){\n            //得到方法的返回类型\n            Class returnType=methods[i].getReturnType();\n            System.out.print(returnType.getName());\n            //得到方法名：\n            System.out.print(methods[i].getName()+"(");\n\n            Class[] parameterTypes=methods[i].getParameterTypes();\n            for(Class class1:parameterTypes){\n                System.out.print(class1.getName()+",");\n            }\n            System.out.println(")");\n        }\n    }\n\n</code></pre>\n<pre><code>public class ReflectTest {\n\n        public static void main(String[] args){\n                String s="ss";\n                ClassUtil.printClassInfo(s);\n        }\n}\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>类的名称：java.lang.String</p>\n<p>booleanequals(java.lang.Object,)</p>\n</blockquote>\n<blockquote>\n<p>java.lang.StringtoString()</p>\n</blockquote>\n<blockquote>\n<p>inthashCode()</p>\n<p>…</p>\n</blockquote>\n<h3><a id="_106"></a>四、获取成员变量的信息</h3>\n<p>也可以获取类的成员变量信息</p>\n<pre><code>\n public static void printFiledInfo(Object o){\n\n        Class c=o.getClass();\n        /**\n         * getFileds()获取public\n         * getDeclaredFields()获取所有\n         */\n        Field[] fileds=c.getDeclaredFields();\n\n        for(Field f:fileds){\n            //获取成员变量的类型\n            Class filedType=f.getType();\n            System.out.println(filedType.getName()+" "+f.getName());\n        }\n\n    }\n\n</code></pre>\n<pre><code> public static void main(String[] args){\n                String s="ss";\n                //ClassUtil.printClassInfo(s);\n                ClassUtil.printFiledInfo(s);\n        }\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>[C value<br>\nint hash<br>\nlong serialVersionUID<br>\n[Ljava.io.ObjectStreamField; serialPersistentFields<br>\njava.util.Comparator CASE_INSENSITIVE_ORDER<br>\nint HASHING_SEED<br>\nint hash32</p>\n</blockquote>\n<h3><a id="_151"></a>五、获取构造函数的信息</h3>\n<pre><code>public static void printConstructInfo(Object o){\n        Class c=o.getClass();\n\n        Constructor[] constructors=c.getDeclaredConstructors();\n        for (Constructor con:constructors){\n            System.out.print(con.getName()+"(");\n\n            Class[] typeParas=con.getParameterTypes();\n            for (Class class1:typeParas){\n                System.out.print(class1.getName()+" ,");\n            }\n            System.out.println(")");\n        }\n    }\n\n</code></pre>\n<pre><code> public static void main(String[] args){\n                String s="ss";\n                //ClassUtil.printClassInfo(s);\n                //ClassUtil.printFiledInfo(s);\n                ClassUtil.printConstructInfo(s);\n        }\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>java.lang.String([B ,)<br>\njava.lang.String([B ,int ,int ,)<br>\njava.lang.String([B ,java.nio.charset.Charset ,)<br>\njava.lang.String([B ,java.lang.String ,)<br>\njava.lang.String([B ,int ,int ,java.nio.charset.Charset ,)<br>\njava.lang.String(int ,int ,[C ,)<br>\njava.lang.String([C ,boolean ,)<br>\njava.lang.String(java.lang.StringBuilder ,)<br>\njava.lang.String(java.lang.StringBuffer ,)</p>\n</blockquote>\n<blockquote>\n<p>…</p>\n</blockquote>\n<h3><a id="_197"></a>六、方法反射的操作</h3>\n<p>获取一个方法：需要获取方法的名称和方法的参数才能决定一个方法。</p>\n<p>方法的反射操作：</p>\n<pre><code>method.invoke(对象，参数列表);\n\n</code></pre>\n<p>举个例子：</p>\n<pre><code>class A{\n\n    public void add(int a,int b){\n        System.out.print(a+b);\n    }\n\n    public void toUpper(String a){\n        System.out.print(a.toUpperCase());\n    }\n}\n\n</code></pre>\n<pre><code> public static void main(String[] args) {\n        A a=new A();\n        Class c=a.getClass();\n        try {\n            Method method=c.getMethod("add",new Class[]{int.class,int.class});\n            //也可以 Method method=c.getMethod("add",int.class,int.class);\n            //方法的反射操作\n            method.invoke(a,10,10);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n</code></pre>\n<p>运行：</p>\n<blockquote>\n<p>20</p>\n</blockquote>\n<p>本篇文章已经讲解了java反射的基本用法， 它可以在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</p>\n<h3><a id="_244"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730421', 'title': 'web的监听器，你需要知道这些...', 'readNum': '27804', 'commentNum': '0', 'publishTime': '2016-12-18 21:53:16', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h3><a id="_0"></a>一、简介</h3>\n<p>Listener是Servlet规范的另一个高级特性，它用于监听java web程序的事件，例如创建、修改、删除session,request,context等，并触发相应的处理事件，这个处理事件是由web容器回掉的。</p>\n<p>学过安卓开发的同学一定很熟悉view.setonClickLister();这样的对安卓控件的监听。java web也是这样的 ，根据不同的listner 和不同的event，可以完成相应的处理事件。</p>\n<h3><a id="Listerner_5"></a>二、Listerner的分类</h3>\n<p>Listerner分为八种，前三种是用于监听对象的创建和销毁，中间三种用于监听对象属性的变化，后两种用于监听Session内对象。</p>\n<ul>\n<li>\n<p>httpSessionListner: 监听session的创建与销毁，用于收集在线用户信息。</p>\n</li>\n<li>\n<p>servletContextListener:监听context的创建与销毁，context代表当前web应用，该listener可用于启动时获取web.xml的初始化参数。</p>\n</li>\n<li>\n<p>servletRequestListener:  监听request 的创建与销毁。</p>\n</li>\n<li>\n<p>httpSessionAttributeListener 监听session的种属性变化</p>\n</li>\n<li>\n<p>ServletContextAttributeListener</p>\n</li>\n<li>\n<p>ServletRequestAttributeListener</p>\n</li>\n<li>\n<p>HttpSessionBindingListener,监听对象存入或者移除 session</p>\n</li>\n<li>\n<p>httpSessionActivationListener,钝化和重新加载 session的监听</p>\n</li>\n</ul>\n<h3><a id="sessionrequestservletContext_19"></a>三、监听session、request、servletContext</h3>\n<p>直接上代码，下面监听了这三个对象创建销毁。</p>\n<pre><code>public class ListenerTest implements HttpSessionListener ,ServletContextListener,ServletRequestListener{\n\n\tLog log=LogFactory.getLog(getClass());\n\tpublic void requestDestroyed(ServletRequestEvent sre) {\n\t\tHttpServletRequest request=(HttpServletRequest) sre.getServletRequest();\n\t\tlong time=System.currentTimeMillis()-(Long)request.getAttribute("time");\n\t\tlog.info("请求处理时间"+time);\n\t\t\n\t}\n\n\tpublic void requestInitialized(ServletRequestEvent sre) {\n\t\tHttpServletRequest request=(HttpServletRequest) sre.getServletRequest();\n\t\tString uri=request.getRequestURI();\n\t\turi=request.getQueryString()==null?uri:(uri+"?"+request.getQueryString());\n\t\tlog.info("ip"+request.getRemoteAddr()+uri);\n\t\trequest.setAttribute("time", System.currentTimeMillis());\n\t\t\n\t}\n\n\tpublic void contextDestroyed(ServletContextEvent sce) {\n\t\tServletContext servletContext=sce.getServletContext();\n\t\tlog.info("关闭："+servletContext.getContextPath());\n\t\t\n\t}\n\n\tpublic void contextInitialized(ServletContextEvent sce) {\n\t\tServletContext servletContext=sce.getServletContext();\n\t\tlog.info("启动："+servletContext.getContextPath());\n\t\t\n\t}\n\n\tpublic void sessionCreated(HttpSessionEvent se) {\n\t\tHttpSession session=se.getSession();\n\t\tlog.info("创建：session:"+session.getId());\n\t\t\n\t}\n\n\tpublic void sessionDestroyed(HttpSessionEvent se) {\n\t\tHttpSession session=se.getSession();\n\t\tlog.info("销毁建：session:"+session.getId());\n\t\t\n\t}\n\n}\n\n</code></pre>\n<p>需要在web.xml中配置：</p>\n<pre><code> &lt;listener&gt;\n    &lt;listener-class&gt;com.forezp.listener.ListenerTest&lt;/listener-class&gt;\n &lt;/listener&gt;\n\n</code></pre>\n<h3><a id="_80"></a>四、监听对象属性的变化</h3>\n<ul>\n<li>httpSessionAttributeListener 监听session的种属性变化</li>\n<li>ServletContextAttributeListener</li>\n<li>ServletRequestAttributeListener</li>\n</ul>\n<p>以上三种方法用于监听session ,context,request的属性发生变化，例如添加、更新、移除。<br>\n下面以session的属性变化为例子：</p>\n<pre><code>public class SessionAttributeListener  implements HttpSessionAttributeListener{\n\n\tLog log=LogFactory.getLog(getClass());\n\tpublic void attributeAdded(HttpSessionBindingEvent se) {\n\t\tHttpSession httpSession=se.getSession();\n\t\tlog.info("新建属性："+se.getName()+"值："+se.getValue());\n\t\t\n\t}\n\n\tpublic void attributeRemoved(HttpSessionBindingEvent se) {\n\t\tHttpSession httpSession=se.getSession();\n\t\tlog.info(" 删除属性："+se.getName()+"值："+se.getValue());\n\t\t\n\t}\n\n\tpublic void attributeReplaced(HttpSessionBindingEvent se) {\n\t\tHttpSession httpSession=se.getSession();\n\t\tlog.info(" 修改属性："+se.getName()+"原来的值："+se.getValue()+"新值："+httpSession.getAttribute(se.getName()));\n\t\t\n\t}\n\n}\n\n</code></pre>\n<p>web.xml配置，此处省略。</p>\n<h3><a id="session_116"></a>五、监听session内的对象</h3>\n<ul>\n<li>HttpSessionBindingListener,当对象被放到session里执行valueBond();当对象被移除，执行valueUnbond();</li>\n<li>httpSessionActivationListener,服务器关闭,会将session的内容保存在硬盘里，这个过程叫钝化；服务器重启，会将session的内容从硬盘中重新加载。钝化时执行sesionWillPassivate(),重新加载sessionDidActivate();</li>\n</ul>\n<p>举个例子：</p>\n<pre><code>public class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable {\n\n\tprivate String username;\n\tprivate String password;\n\t\n\tpublic void valueBound(HttpSessionBindingEvent httpsessionbindingevent) {\n\t\tSystem.out.println("valueBound Name:"+httpsessionbindingevent.getName());\n\t}\n\n\tpublic void valueUnbound(HttpSessionBindingEvent httpsessionbindingevent) {\n\t\tSystem.out.println("valueUnbound Name:"+httpsessionbindingevent.getName());\n\t}\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\n\t//钝化\n\tpublic void sessionWillPassivate(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println("sessionWillPassivate "+httpsessionevent.getSource());\n\t}\n\t//活化\n\tpublic void sessionDidActivate(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println("sessionDidActivate "+httpsessionevent.getSource());\n\t}\n\n}\n\n\n</code></pre>\n<p>init.jsp</p>\n<pre><code>\n&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;\n&lt;%\nString path = request.getContextPath();\nString basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";\nrequest.getSession().setAttribute("currentUser", new com.forezp.entity.User());\n\n%&gt;\n\n&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;base href="&lt;%=basePath%&gt;"&gt;\n    \n    &lt;title&gt;My JSP \'init.jsp\' starting page&lt;/title&gt;\n    \n\t&lt;meta http-equiv="pragma" content="no-cache"&gt;\n\t&lt;meta http-equiv="cache-control" content="no-cache"&gt;\n\t&lt;meta http-equiv="expires" content="0"&gt;    \n\t&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;\n\t&lt;meta http-equiv="description" content="This is my page"&gt;\n\t&lt;!--\n\t&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;\n\t--&gt;\n\n  &lt;/head&gt;\n  \n  &lt;body&gt;\n    这是初始化值的界面\n    &lt;button onclick="location.href=\'&lt;%=request.getContextPath()%&gt;/init.jsp\';"&gt;Init&lt;/button&gt;\n    &lt;button onclick="location.href=\'&lt;%=request.getContextPath()%&gt;/destory.jsp\';"&gt;Destory&lt;/button&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>destroy.jsp</p>\n<pre><code>&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;\n&lt;%\nString path = request.getContextPath();\nString basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";\n\nrequest.getSession().removeAttribute("currentUser");\n%&gt;\n\n&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;base href="&lt;%=basePath%&gt;"&gt;\n    \n    &lt;title&gt;My JSP \'destory.jsp\' starting page&lt;/title&gt;\n    \n\t&lt;meta http-equiv="pragma" content="no-cache"&gt;\n\t&lt;meta http-equiv="cache-control" content="no-cache"&gt;\n\t&lt;meta http-equiv="expires" content="0"&gt;    \n\t&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;\n\t&lt;meta http-equiv="description" content="This is my page"&gt;\n\t&lt;!--\n\t&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;\n\t--&gt;\n\n  &lt;/head&gt;\n  \n  &lt;body&gt;\n    这是销毁界面\n    &lt;button onclick="location.href=\'&lt;%=request.getContextPath()%&gt;/init.jsp\';"&gt;Init&lt;/button&gt;\n    &lt;button onclick="location.href=\'&lt;%=request.getContextPath()%&gt;/destory.jsp\';"&gt;Destory&lt;/button&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>当访问init.jsp，再访问destroy.jsp;再访问init,jsp，再关闭服务器，重启；log日志如下：</p>\n<blockquote>\n<p>valueBound Name:currentUser</p>\n</blockquote>\n<blockquote>\n<p>valueUnbound Name:currentUser</p>\n</blockquote>\n<blockquote>\n<p>sessionWillPassivate org.apache.catalina.session.StandardSessionFacade@33f3be1</p>\n</blockquote>\n<blockquote>\n<p>sessionDidActivate<br>\norg.apache.catalina.session.StandardSessionFacade@33f3be1</p>\n</blockquote>\n<h3><a id="_257"></a>六、显示在线人数：</h3>\n<pre><code>\n@WebListener\npublic class MyHttpSessionListener implements HttpSessionListener {\n\t\n\tprivate int userNumber = 0;\n\t\n\t@Override\n\tpublic void sessionCreated(HttpSessionEvent arg0) {\n\t\tuserNumber++;\n\t\targ0.getSession().getServletContext().setAttribute("userNumber", userNumber);\n\t}\n\n\t@Override\n\tpublic void sessionDestroyed(HttpSessionEvent arg0) {\n\t\tuserNumber--;\narg0.getSession().getServletContext().setAttribute("userNumber", userNumber);\n\t\t\n\t}\n\n}\n\n</code></pre>\n<p>jsp中显示：</p>\n<pre><code>\n&lt;body&gt;\n    当前在线用户人数:${userNumber }&lt;br/&gt;\n&lt;/body&gt;\n\n</code></pre>\n<p>这是一个简答的统计在线人数的方法，如果你需要知道这些人来自哪里，需要配合httpRequestListener配合，也可以实现单登陆，在这里不写代码了。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:41 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730410', 'title': 'Filter，一种aop编程思想的体现', 'readNum': '28160', 'commentNum': '1', 'publishTime': '2016-12-18 21:52:24', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h3><a id="filter_0"></a>一、filter简介</h3>\n<p>filter是Servlet规范里的一个高级特性，只用于对request、response的进行修改。</p>\n<p>filter提出了FilterChain的概念，客户端请求request在抵达servlet之前都会经过filterChain里的所有fiter，如图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122802368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="filter_8"></a>二、filter的生命周期</h3>\n<p>在web.xml中配置filter，当启动服务器时会实例化，并且会初始化，当有网络请求时会进行过滤操作，当 服务器关闭时，会进行销毁，全过程如下图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122816134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="filter_14"></a>三、编写第一个filter</h3>\n<p>filter类需实现fiter接口，需复写里面的三个方法，其中init(),在初始化时调用；doFiler()方法每次都会调用，在这个方法中一定要执行chain.doFilter(),否则request不会交给后面的filter或者servler;ondestroy()在关闭服务器时调用。</p>\n<pre><code>\npublic class FirstFilter implements Filter {\n\n\t@Override\n\tpublic void destroy() {\n\t\tSystem.out.println("destroy---FirstFilter");\n\t}\n\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\tSystem.out.println("start----doFilter--FirstFilter");\t\t\n\t\tchain.doFilter(request, response);\n\t\tSystem.out.println("end------doFilter--FirstFilter");\n\t}\n\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\tSystem.out.println("init----FirstFilter");\n\t}\n\n\n</code></pre>\n<p>配置filter:</p>\n<pre><code> &lt;filter&gt;\n        &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.forezp.filter.FirstFilter&lt;/filter-class&gt;\n        \n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; \n         &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; \n         &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; \n    &lt;/filter-mapping&gt;\n\n</code></pre>\n<p>其中，url_pattern可以配置多个，也可以用通配符，当访问满足路径匹配，并且符合dispatcher时，request会被filter拦截进行处理，处理完后的response再次被filter拦截，可以进行处理。</p>\n<p>其中dispatcher 默认REQUEST，四种不同的dispatcher：</p>\n<ul>\n<li>REQUEST:请求时有效</li>\n<li>FORWARD:当某servlet通过forward到该servlet才有效</li>\n<li>INCLUDE: jsp通过&lt; jsp: incluser/&gt; 请求servlet有效</li>\n<li>ERROR: &lt; %@page errorPage="" % &gt;有效</li>\n</ul>\n<h3><a id="_67"></a>四、防盗链</h3>\n<p>filter的特性使它可以处理特殊的工作，例如防盗链，字符编码的处理，日志记录，数据加密，过滤一些黑词等等。</p>\n<p>例如： 防盗链图片，当其他网站请求本网站图片资源时显示错误的图片，只有本应用先生的图片才显示正确的图片，代码如下：</p>\n<pre><code>public class ImageFilter implements Filter{\n\tpublic void init(FilterConfig config) throws Exception(){\n\t\n\t}\n\tpublic void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws Exception{\n\tHttpServletRequest request=(HttpServletRequest )req;\n\tHttpServletResponse  response=(HttpServletResponse)res;\n\tString referer=request.getHeader("referer");\n\t\tif(referer==null||!referer.contains(request.getServerName())){\n\t\trequest.getRequestDispatcher("/error.png").forwar(request,response);\n\t}else{\n\t\tchain.doFilter(request,response);\n\t\t  }\n\t}\n\tpublic void destroy(){}\n\n}\n\n</code></pre>\n<p>在web.xml中配置：</p>\n<pre><code>&lt;filter&gt;\n\t\t&lt;filter-name&gt;imageFilter&lt;/filter-name&gt;\n\t\t&lt;filter-class&gt;com.forezp.ImageFilter &lt;/filter-class&gt;\n\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n&lt;filter-name&gt;imageFilter&lt;/filter-name&gt;\n&lt;url-pattern&gt; /images/* &lt;/url-pattern&gt;\n &lt;/filter-mapping&gt;\n\n\n</code></pre>\n<p>当访问images下的所有图片会经过该filter,根据访问头信息，如果说本站点的访问则显示正确图片，否则先生错误图片。</p>\n<h3><a id="_111"></a>五、字符编码</h3>\n<p>直接上代码：</p>\n<pre><code>public class CharsetFilter implements Filter{\n\tprivate String characterEncoding;\n\tprivate String enabled;\n\tpublic void init(FilterConfig config) throws Exception(){\n\tcharacterEncoding=config.getInitParameter("characterEncoding");\n\tenabled=config.getInitParameter("enabled").equals("true");\n\t}\n\tpublic void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws Exception{\n\t\tif(enabled|| characterEncoding!=null){\n\t\t\treq.setCharacterEncoding(characterEncoding);\n\t\t\tres.setCharacterEncoding(characterEncoding);\n\t\t}\n\t\tchain.doFilter(req,res);\n\n\t}\n\t\n\tpublic void destroy(){\n\t  characterEncoding=null;\n\t}\n}\n\n</code></pre>\n<p>在web.xml中配置：</p>\n<pre><code>&lt;filter&gt;\n\t&lt;filter-name&gt;CharsetFilter&lt;/filter-name&gt;\n\t&lt;filter-class&gt;com.forezp.CharsetFilter &lt;/filter-class&gt;\n\t&lt;init-param&gt;\n\t\t&lt;param-name&gt;characterEncoding&lt;/param-name&gt;\n\t\t&lt;param-value&gt;UTF-8&lt;/param-value&gt;\n\t&lt;/init-param&gt;\n\t&lt;init-param&gt;\n\t\t&lt;param-name&gt;enabled&lt;/param-name&gt;\n\t\t&lt;param-value&gt;true&lt;/param-value&gt;\n\t&lt;/init-param&gt;\n\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n\t&lt;filter-name&gt;CharsetFilter&lt;/filter-name&gt;\n\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n\n\n</code></pre>\n<p>其中页面编码方式也必须一致，希望全部用utf-8，另外需要配置Tomcat的／config/server.xml编码：</p>\n<pre><code>&lt;Connector port="8080" protocal="HTTP/1.1"\n\tconnectionTimeout="20000"\n\tredirectPort="8443" URIEncoding="UTF-8"/&gt;\n\n</code></pre>\n<p>另外，还有比较常见的日志记录filter、异常捕捉filter、权限校验、内容替换filter等等。</p>\n<p>filter有很大的弹性机制，功能强大，而且跟servlet、jsp没耦合.filter是现在面向切面编程aop的一种思想体现，它能够胜任很多工作。</p>\n<p>2.5的fiter需要在web.xml中配置，执行顺序按照配置顺序，另外3.0可以用注解的方式配置filter，此时没有配置的顺序。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:41'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730396', 'title': '当Java遇见了Html--Jsp详解篇', 'readNum': '23807', 'commentNum': '0', 'publishTime': '2016-12-18 21:51:49', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>###一、什么是Jsp<br>\njsp是一种基于文本的程序，全名java server page,其特点是html和java程序共存。执行时jsp会被运行容器编译，编译后的jsp跟servlet一样，因此jsp是另一种形式的servlet。</p>\n<h3><a id="jsp_3"></a>二、jsp页面组成</h3>\n<p>jsp 页面包括以下内容：</p>\n<ul>\n<li>静态内容</li>\n<li>指令</li>\n<li>表达式</li>\n<li>小脚本</li>\n<li>声明</li>\n<li>注释</li>\n</ul>\n<p><em>1.指令：</em></p>\n<ul>\n<li>page指令：  通常位于jsp页面的顶端，同一个页面可以有多个page指令。</li>\n<li>include指令：将一个外部文件嵌入到jsp文件中。</li>\n<li>taglib指令 ：使用标签定义新的自定义标签。</li>\n</ul>\n<p><em>1.1其中page指令语法：</em></p>\n<pre><code>&lt;%@ page 属性=“属性值”&gt;\n\n</code></pre>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>language</td>\n<td>java</td>\n</tr>\n<tr>\n<td>import</td>\n<td>“”</td>\n</tr>\n</tbody>\n</table><p><em>1.2</em> include 指令</p>\n<pre><code>&lt;%@ include file="url" %&gt;\n\n</code></pre>\n<p><em>1.3 动作</em></p>\n<ul>\n<li>include动作</li>\n</ul>\n<pre><code>&lt;jsp:include page="url" flush="true"/&gt;\n</code></pre>\n<p><em>include 动作和include指令区别</em></p>\n\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>include指令</th>\n<th>include 动作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语法</td>\n<td>&lt; % @ include file=""/&gt;</td>\n<td>&lt; jsp:include page=“url” flush=“true”/&gt;</td>\n</tr>\n<tr>\n<td>发生时间</td>\n<td>页面转换期间</td>\n<td>请求期间</td>\n</tr>\n<tr>\n<td>包含内容</td>\n<td>文件实际内容</td>\n<td>页面的输出</td>\n</tr>\n<tr>\n<td>转化servlet</td>\n<td>一个servlet</td>\n<td>2个servlet</td>\n</tr>\n<tr>\n<td>编译时间</td>\n<td>较慢</td>\n<td>较快</td>\n</tr>\n<tr>\n<td>执行时间</td>\n<td>稍快</td>\n<td>较慢–每次资源必须被编译</td>\n</tr>\n</tbody>\n</table><p><em>forward动作</em></p>\n<pre><code>&lt;jsp:forward page="url"/&gt;\n\n==\n\nrequest.getRequestDispatcher("/url").forward(res,resp);\n\n</code></pre>\n<p><em>param动作</em></p>\n<pre><code>&lt;jsp:param name="参数名" value="参数值"/&gt;\n常常与&lt;jsp:forward&gt;一起使用\n\n</code></pre>\n<p>例子：</p>\n<pre><code>&lt;jsp:forward page="user.jsp"&gt;\n\n   &lt;jsp:param name="email"  value="1233@154.com"/&gt;\n&lt;/jsp:forward&gt;\n\n</code></pre>\n<p><em>2.jsp注释</em></p>\n<ul>\n<li>html注释</li>\n</ul>\n<pre><code>&lt;!-- html注释 --&gt;//客户端可见\n</code></pre>\n<ul>\n<li>jsp 注释</li>\n</ul>\n<pre><code>&lt;%-- jsp注释 --%&gt;//客户端不可见\n</code></pre>\n<ul>\n<li>jsp 脚本注释  //客户端不可见</li>\n</ul>\n<pre><code>//单行注射\n／** 多行注释*／\n</code></pre>\n<p><em>3.jsp脚本</em></p>\n<p>在jsp页面中执行的java代码，语法：</p>\n<pre><code>&lt;%   java 代码 %&gt;\n</code></pre>\n<p><em>4.jsp声明</em><br>\n在jsp页面定义变量或者方法，语法</p>\n<pre><code>&lt;%! java 代码  %&gt;\n</code></pre>\n<p>举例：</p>\n<pre><code>&lt;%! \n String s="adele";\n int add(int x,int y){\n    return x+y;\n }\n%&gt;\n\n</code></pre>\n<p><em>5.jsp表达式</em><br>\n在jsp页面执行的表达式，语法：</p>\n<pre><code>&lt;% =表达式 %&gt;// 表达式不以分号结尾\n\n</code></pre>\n<p>举例：</p>\n<pre><code>&lt;%! \n String s="adele";\n\n%&gt;\n&lt;h2&gt;  hello,&lt;%=s %&gt; &lt;/h2&gt;\n\n</code></pre>\n<h3><a id="jsp_149"></a>三、jsp生命周期</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190601122713199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">jspService()是用来处理客户端请求的，对于每一个请求，服务器会创建一个新的线程来处理该请求。以多线程方式执行大大降低对系统的资源需求，提高系统的并发量和缩短了响应时间，servlet是常驻在服务器内存中。</p>\n<p>它同servlet 一样，jsp 实例初始化和销毁也会调用sevlet的init() 和destroy();<br>\n另外jsp还有自己的初始化方法_jspInit();_jspDestroy();</p>\n<pre><code>&lt;%@ page language="java" contentType="text/html";charset="utf-8"&gt;\n\n&lt;%! \npublic void _jspInit(){\n}\npublic void _jspDestroy(){\n}\n%&gt;\n</code></pre>\n<h3><a id="javaben_167"></a>四、javaben的使用</h3>\n<p><em>动作元素：</em><br>\n动作元素为请求处理阶段提供信息。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122729138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>在jsp页面使用javaben</p>\n<ul>\n<li>像普通的java类一样，创建javabean;</li>\n<li>在jsp使用动作标签来使用 javaben</li>\n</ul>\n<p>相关标签如下：</p>\n<pre><code>&lt;jsp:useBwan id="" class="" scope="" /&gt;\n\n&lt;jsp:setProperty name="javabean 是例"  property="*"/&gt;(跟表单关联)\n\n&lt;jsp:setProperty name="javabean 是例"  property="javaben 属性名"/&gt;(跟表单关联)\n\n&lt;jsp:setProperty name="javabean 是例"  property="javaben 属性名"  value=""/&gt;(手动设置)\n\n\n&lt;jsp:setProperty name="javabean 是例"  property="javaben 属性名"  param="request对象参数"/&gt;(跟request参数关联)\n\n\n&lt;jsp:getProperty name="" property=""/&gt;\n</code></pre>\n<p>举个例子：<br>\n首先用户 在login.jsp提交表单，然后用户在dologin.jsp 根据动作标签获取参数。</p>\n<p>login.jsp</p>\n<pre><code>\n &lt;form name="loginForm" action="dologin.jsp?mypass=999999" method="post"&gt;\n      &lt;table&gt;\n        &lt;tr&gt;\n          &lt;td&gt;用户名：&lt;/td&gt;\n          &lt;td&gt;&lt;input type="text" name="username" value=""/&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n          &lt;td&gt;密码：&lt;/td&gt;\n          &lt;td&gt;&lt;input type="password" name="password" value=""/&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n          &lt;td colspan="2" align="center"&gt;&lt;input type="submit" value="登录"/&gt;&lt;/td&gt;\n          \n        &lt;/tr&gt;\n      &lt;/table&gt;\n    &lt;/form&gt;\n</code></pre>\n<p>dologin.jsp</p>\n<pre><code>\n&lt;body&gt;\n    &lt;jsp:useBean id="myUsers" class="com.po.Users" scope="page"/&gt;\n    &lt;h1&gt;setProperty动作元素&lt;/h1&gt;\n    &lt;hr&gt;\n   &lt;!--根据表单自动匹配所有的属性 --&gt;\n   &lt;%-- \n   &lt;jsp:setProperty name="myUsers" property="*"/&gt;  \n   --%&gt;\n   &lt;!--根据表单匹配所有部分的属性 --&gt;\n   &lt;%-- \n   &lt;jsp:setProperty name="myUsers" property="username"/&gt;  \n   --%&gt;\n   &lt;!--根表单无关，通过手工赋值给属性 --&gt;\n   &lt;%-- \n   &lt;jsp:setProperty name="myUsers" property="username" value="lisi"/&gt;\n   &lt;jsp:setProperty name="myUsers" property="password" value="888888"/&gt;\n   --%&gt;\n   &lt;!--通过URL传参数给属性赋值 --&gt;\n   &lt;jsp:setProperty name="myUsers" property="username"/&gt;\n   &lt;jsp:setProperty name="myUsers" property="password" param="mypass"/&gt;\n   &lt;!-- 使用传统的表达式方式来获取用户名和密码 --&gt;\n   &lt;%--     \n       用户名：&lt;%=myUsers.getUsername() %&gt;&lt;br&gt;\n       密码：&lt;%=myUsers.getPassword() %&gt;&lt;br&gt; \n   --%&gt;\n   &lt;!-- 使用getProperty方式来获取用户名和密码 --&gt;\n      用户名：&lt;jsp:getProperty name="myUsers" property="username"/&gt; &lt;br&gt;\n      密码：&lt;jsp:getProperty name="myUsers" property="password"/&gt;&lt;br&gt;\n   &lt;br&gt;\n   &lt;br&gt;\n      &lt;a href="testScope.jsp"&gt;测试javabean的四个作用域范围&lt;/a&gt;\n      &lt;% \n         request.getRequestDispatcher("testScope.jsp").forward(request, response);\n      %&gt;\n  &lt;/body&gt;\n\n</code></pre>\n<p><em>javaben 四大作用域</em></p>\n<ul>\n<li>page ，仅当前页面有效</li>\n<li>request  ,通过httpRequest.getAttribute()获取jvabean对象</li>\n<li>session ,通过httpSession.getAttribute() 获取javabean对象</li>\n<li>application，通过application.getAttribute方法获取javabean 对象。</li>\n</ul>\n<h3><a id="cookie_275"></a>五、cookie</h3>\n<p><em>1.概述：</em></p>\n<p>由于http协议的无状态，无法保存用户的状态，所以需要用session和cookie.</p>\n<p>cookie 是web服务器保存在客户端的一系列文本信息。它的作用时记录一些用户的行为，简化登陆，但是容易泄露用户信息。</p>\n<p><em>2.jsp创建和使用cookie</em></p>\n<ul>\n<li>创建cookie</li>\n</ul>\n<pre><code>Cookie cookie=new Cookie(String ,Object);\n</code></pre>\n<ul>\n<li>写入cookie</li>\n</ul>\n<pre><code>response.addCookie(cookie);\n</code></pre>\n<ul>\n<li>读取 cookie</li>\n</ul>\n<pre><code>Cookie[] cookies=request.getCookies();\n\n</code></pre>\n<p><em>3.cookie的常用方法</em></p>\n<ul>\n<li>setMaxAge();</li>\n<li>setValue();</li>\n<li>getName();</li>\n<li>getValue();</li>\n<li>getMaxAge();</li>\n</ul>\n<p>举个列子： 使用cookie记住用户登陆的账号密码；</p>\n<p>登陆界面：</p>\n<pre><code>\n&lt;body&gt;\n    &lt;h1&gt;用户登录&lt;/h1&gt;\n    &lt;hr&gt;\n    &lt;% \n      request.setCharacterEncoding("utf-8");\n      String username="";\n      String password = "";\n      Cookie[] cookies = request.getCookies();\n      if(cookies!=null&amp;&amp;cookies.length&gt;0)\n      {\n           for(Cookie c:cookies)\n           {\n              if(c.getName().equals("username"))\n              {\n                   username =  URLDecoder.decode(c.getValue(),"utf-8");\n              }\n              if(c.getName().equals("password"))\n              {\n                   password =  URLDecoder.decode(c.getValue(),"utf-8");\n              }\n           }\n      }\n    %&gt;\n    &lt;form name="loginForm" action="dologin.jsp" method="post"&gt;\n       &lt;table&gt;\n         &lt;tr&gt;\n           &lt;td&gt;用户名：&lt;/td&gt;\n           &lt;td&gt;&lt;input type="text" name="username" value="&lt;%=username %&gt;"/&gt;&lt;/td&gt;\n         &lt;/tr&gt;\n         &lt;tr&gt;\n           &lt;td&gt;密码：&lt;/td&gt;\n           &lt;td&gt;&lt;input type="password" name="password" value="&lt;%=password %&gt;" /&gt;&lt;/td&gt;\n         &lt;/tr&gt;\n         &lt;tr&gt;\n           &lt;td colspan="2"&gt;&lt;input type="checkbox" name="isUseCookie" checked="checked"/&gt;十天内记住我的登录状态&lt;/td&gt;\n         &lt;/tr&gt;\n         &lt;tr&gt;\n           &lt;td colspan="2" align="center"&gt;&lt;input type="submit" value="登录"/&gt;&lt;input type="reset" value="取消"/&gt;&lt;/td&gt;\n         &lt;/tr&gt;\n       &lt;/table&gt;\n    &lt;/form&gt;\n  &lt;/body&gt;\n\n</code></pre>\n<p>处理登陆逻辑的jsp</p>\n<pre><code> &lt;body&gt;\n    &lt;h1&gt;登录成功&lt;/h1&gt;\n    &lt;hr&gt;\n    &lt;br&gt;\n    &lt;br&gt;\n    &lt;br&gt;\n    &lt;% \n       request.setCharacterEncoding("utf-8");\n       //首先判断用户是否选择了记住登录状态\n       String[] isUseCookies = request.getParameterValues("isUseCookie");\n       if(isUseCookies!=null&amp;&amp;isUseCookies.length&gt;0)\n       {\n          //把用户名和密码保存在Cookie对象里面\n          String username = URLEncoder.encode(request.getParameter("username"),"utf-8");\n          //使用URLEncoder解决无法在Cookie当中保存中文字符串问题\n          String password = URLEncoder.encode(request.getParameter("password"),"utf-8");\n          \n          Cookie usernameCookie = new Cookie("username",username);\n          Cookie passwordCookie = new Cookie("password",password);\n          usernameCookie.setMaxAge(864000);\n          passwordCookie.setMaxAge(864000);//设置最大生存期限为10天\n          response.addCookie(usernameCookie);\n          response.addCookie(passwordCookie);\n       }\n       else\n       {\n          Cookie[] cookies = request.getCookies();\n          if(cookies!=null&amp;&amp;cookies.length&gt;0)\n          {\n             for(Cookie c:cookies)\n             {\n                if(c.getName().equals("username")||c.getName().equals("password"))\n                {\n                    c.setMaxAge(0); //设置Cookie失效\n                    response.addCookie(c); //重新保存。\n                }\n             }\n          }\n       }\n    %&gt;\n    &lt;a href="users.jsp" target="_blank"&gt;查看用户信息&lt;/a&gt;\n    \n  &lt;/body&gt;\n\n\n</code></pre>\n<p>使用cookie获取用户信息：</p>\n<pre><code> &lt;body&gt;\n    &lt;h1&gt;用户信息&lt;/h1&gt;\n    &lt;hr&gt;\n    &lt;% \n      request.setCharacterEncoding("utf-8");\n      String username="";\n      String password = "";\n      Cookie[] cookies = request.getCookies();\n      if(cookies!=null&amp;&amp;cookies.length&gt;0)\n      {\n           for(Cookie c:cookies)\n           {\n              if(c.getName().equals("username"))\n              {\n                   username = URLDecoder.decode(c.getValue(),"utf-8");\n              }\n              if(c.getName().equals("password"))\n              {\n                   password = URLDecoder.decode(c.getValue(),"utf-8");\n              }\n           }\n      }\n    %&gt;\n    &lt;BR&gt;\n    &lt;BR&gt;\n    &lt;BR&gt;\n         用户名：&lt;%=username %&gt;&lt;br&gt;\n         密码：&lt;%=password %&gt;&lt;br&gt;\n  &lt;/body&gt;\n\n</code></pre>\n<p><em>3.cookie和 session的区别</em></p>\n\n<table>\n<thead>\n<tr>\n<th>session</th>\n<th>cookie</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在服务端保存信息</td>\n<td>在客户端保存信息</td>\n</tr>\n<tr>\n<td>保存的 object类型</td>\n<td>保存的是 string 类型</td>\n</tr>\n<tr>\n<td>随会话结束，销毁数据</td>\n<td>可以长期保存在客户端中</td>\n</tr>\n<tr>\n<td>重要信息</td>\n<td>不重要信息</td>\n</tr>\n</tbody>\n</table><div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730384', 'title': '当Java遇见了Html--Jsp九大内置对象篇', 'readNum': '24636', 'commentNum': '0', 'publishTime': '2016-12-18 21:51:04', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>jsp内置对象对象是web容器创建的一组对象，不使用new关键词久可以使用的内置对象。<br>\n九大内置对象包括以下：</p>\n<ul>\n<li>out  --JspWriter</li>\n<li>request --ServletRequest</li>\n<li>reponse --ServletResponse</li>\n<li>config --ServletConfig</li>\n<li>session --HttpSession</li>\n<li>application --ServlerContext</li>\n<li>page --HttpJspPage</li>\n<li>pageContext --PageContext</li>\n<li>exception --Exception</li>\n</ul>\n<h3><a id="1out_14"></a>1、out对象</h3>\n<p>JspWriter类实例，是向客户端负责输出内容的。<br>\n常用方法如下：</p>\n<ul>\n<li>println();</li>\n<li>clear (),如果在flush()之后调用会抛出异常。</li>\n<li>clearBuffer();</li>\n<li>flush();</li>\n<li>isAutoFlush();</li>\n</ul>\n<p>举例子：</p>\n<pre><code>&lt;body&gt;\n   &lt;h1&gt;out内置对象&lt;/h1&gt;\n   &lt;% \n      out.println("&lt;h2&gt;静夜思&lt;/h2&gt;");\n      out.println("床前明月光&lt;br&gt;");\n      out.println("疑是地上霜&lt;br&gt;");\n      out.flush();\n      //out.clear();//这里会抛出异常。\n      out.clearBuffer();//这里不会抛出异常。\n      out.println("举头望明月&lt;br&gt;");\n      out.println("低头思故乡&lt;br&gt;");\n   \n   %&gt;\n       缓冲区大小：&lt;%=out.getBufferSize() %&gt;byte&lt;br&gt;\n       缓冲区剩余大小：&lt;%=out.getRemaining() %&gt;byte&lt;br&gt;\n      是否自动清空缓冲区：&lt;%=out.isAutoFlush() %&gt;&lt;BR&gt;    \n &lt;/body&gt;\n</code></pre>\n<h3><a id="2request_46"></a>2、request对象</h3>\n<p>客户端的请求被封装在request对象中，通过它可以了解客户端的请求，然后作出响应，request请求具有request请求域。<br>\n常用方法：</p>\n<ul>\n<li>getParameter(String name)</li>\n<li>getParamterValues(String name)</li>\n<li>setAttribute(String name,Onject o)</li>\n<li>getAttribute(string name)</li>\n<li>getContetType();</li>\n<li>getProtocol()</li>\n<li>getServerName();</li>\n</ul>\n<p>举个例子：用户注册提交数据给request.jsp，在request.jsp页面根据request对象可以获取提交过来的数据。</p>\n<p>reg.jsp 注册jsp</p>\n<pre><code>\n&lt;body&gt;\n   &lt;h1&gt;用户注册&lt;/h1&gt;\n   &lt;hr&gt;\n   &lt;% \n      int number=-1;\n      //说明用户第一次访问页面，计数器对象还未创建\n      if(application.getAttribute("counter")==null)\n      {\n          application.setAttribute("counter", 0);\n      }\n      number = Integer.parseInt(application.getAttribute("counter").toString());\n      number++;\n      application.setAttribute("counter", number);\n   %&gt;\n   &lt;!-- &lt;form name="regForm" action="request.jsp" method="post"&gt; --&gt;\n   &lt;form name="regForm" action="response.jsp" method="post"&gt;\n   &lt;table&gt;\n     &lt;tr&gt;\n       &lt;td&gt;用户名：&lt;/td&gt;\n       &lt;td&gt;&lt;input type="text" name="username"/&gt;&lt;/td&gt;\n     &lt;/tr&gt;\n     &lt;tr&gt;\n       &lt;td&gt;爱好：&lt;/td&gt;\n       &lt;td&gt;\n          &lt;input type="checkbox" name="favorite" value="read"&gt;读书\n          &lt;input type="checkbox" name="favorite" value="music"&gt;音乐\n          &lt;input type="checkbox" name="favorite" value="movie"&gt;电影\n          &lt;input type="checkbox" name="favorite" value="internet"&gt;上网\n       &lt;/td&gt;\n     &lt;/tr&gt;\n     &lt;tr&gt;\n        &lt;td colspan="2"&gt;&lt;input type="submit" value="提交"/&gt;&lt;/td&gt;\n     &lt;/tr&gt;\n   &lt;/table&gt;\n   &lt;/form&gt;\n   &lt;br&gt;\n   &lt;br&gt;\n   &lt;a href="request.jsp?username=李四"&gt;测试URL传参数&lt;/a&gt;\n   \n   &lt;br&gt;\n   &lt;br&gt;\n   &lt;center&gt;\n            您是第&lt;%=number %&gt;位访问本页面的用户。\n   &lt;/center&gt;\n &lt;/body&gt;\n\n</code></pre>\n<p>request.jsp</p>\n<pre><code> &lt;body&gt;\n  &lt;h1&gt;request内置对象&lt;/h1&gt;\n  &lt;% \n     request.setCharacterEncoding("utf-8"); //解决中文乱码问题，无法解决URL传递中文出现的乱码问题。\n     request.setAttribute("password", "123456");\n  \n  %&gt;\n      用户名：&lt;%=request.getParameter("username") %&gt;&lt;br&gt;   \n      爱好 ：&lt;% \n         if(request.getParameterValues("favorite")!=null)\n         {\n             String[] favorites = request.getParameterValues("favorite");\n             for(int i=0;i&lt;favorites.length;i++)\n             {\n                out.println(favorites[i]+"  ");\n             }\n          }\n      %&gt; &lt;br&gt;\n       密码：&lt;%=request.getAttribute("password") %&gt;&lt;br&gt; \n       请求体的MIME类型:&lt;%=request.getContentType() %&gt;&lt;br&gt;\n       协议类型及版本号:  &lt;%=request.getProtocol() %&gt;&lt;br&gt;\n       服务器主机名 :&lt;%=request.getServerName() %&gt;&lt;br&gt;\n       服务器端口号：&lt;%=request.getServerPort() %&gt;&lt;BR&gt;\n       请求文件的长度 ：&lt;%=request.getContentLength() %&gt;&lt;BR&gt;\n       请求客户端的IP地址：&lt;%=request.getRemoteAddr() %&gt;&lt;BR&gt;\n       请求的真实路径：&lt;%=request.getRealPath("request.jsp") %&gt;&lt;br&gt;\n       请求的上下文路径：&lt;%=request.getContextPath() %&gt;&lt;BR&gt;         \n               \n       \n                 \n&lt;/body&gt;\n</code></pre>\n<h3><a id="3response_150"></a>3、response对象</h3>\n<p>response对象包含了响应客户端请求的有关信息，它具有页面作用域，该页面的作用域只对该页面有效。常用方法：</p>\n<ul>\n<li>getCharacterEncoding()</li>\n<li>setContentType();</li>\n<li>getWriter();该方法打应输出流总是前于 out.println();</li>\n<li>sendRedirect(String location)</li>\n</ul>\n<p><em>请求重定向和请求转发：</em></p>\n<ul>\n<li>请求重定向：客户端行为:response.sendDirect();两次请求，前一次请求的请求对象不会保存，地址栏的url地址会发生改变</li>\n<li>请求转发：服务器行为，request.getResuestDispatcher().forward();一次请求，转发后请求对象会保存，地址栏url地址不会变。</li>\n</ul>\n<h3><a id="4session_164"></a>4、session对象</h3>\n<p>一些基本概念：</p>\n<ul>\n<li>session表示客户端与服务器的一次会话</li>\n<li>web中session指的是用户在浏览某个网站，是进入网站到关闭浏览器这段时间</li>\n<li>它是保存在服务器的内存中，不同用户有不同的session</li>\n<li>它在第一个jsp页面被装载时自动创建，完成会话期管理。</li>\n</ul>\n<p>它的的一些常用方法：</p>\n<ul>\n<li>getCreationTime();</li>\n<li>String getId();</li>\n<li>setAttribute(String name,Object o);</li>\n<li>getAttribute(String name);</li>\n<li>String[] getValueNames();</li>\n<li>int getMaxInactivieInterval();单位 秒</li>\n<li>setMaxInactiveInterval();</li>\n</ul>\n<p>举个例子：</p>\n<pre><code>\n&lt;body&gt;\n    &lt;h1&gt;session内置对象&lt;/h1&gt;\n    &lt;hr&gt;\n    &lt;% \n      SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");\n      Date d = new Date(session.getCreationTime());\n      session.setAttribute("username", "admin"); \n      session.setAttribute("password", "123456");\n      session.setAttribute("age", 20);\n      \n      //设置当前session最大生成期限单位是秒\n      //session.setMaxInactiveInterval(10);//10秒钟\n      \n    %&gt;\n    Session创建时间：&lt;%=sdf.format(d)%&gt;&lt;br&gt;    \n    Session的ID编号：&lt;%=session.getId()%&gt;&lt;BR&gt;\n         从Session中获取用户名：&lt;%=session.getAttribute("username") %&gt;&lt;br&gt;\n         \n    &lt;a href="session_page2.jsp" target="_blank"&gt;跳转到Session_page2.jsp&lt;/a&gt;     \n        \n  &lt;/body&gt;\n</code></pre>\n<p><em>session的生命周期：</em></p>\n<ul>\n<li>创建： 当客户端第一次访问某个页面jsp或者servlet，服务器会创建一个 sessionId,每次客户端向服务器发送请求时，都会将sessionId携带过去，服务器会对sessionId进行校验。</li>\n<li>活动： 当客户端通过超链接打开新页面属于同一次会话；当浏览页面全部关闭，重新打开属于一次新的会话。</li>\n<li>销毁：调用sesson.invalidate();session过期，默认是30分钟；服务器重启；</li>\n</ul>\n<h3><a id="5application_217"></a>5、application对象</h3>\n<ul>\n<li>application实现了用户数据共享，可存放全局变量。</li>\n<li>application 开始于服务器的重启，终止于服务器的关闭</li>\n<li>application 是ServletContext实例。</li>\n</ul>\n<p>常用方法：</p>\n<ul>\n<li>setAttribute(String ,Object);</li>\n<li>getAttribute(String);</li>\n<li>Enumeration getAttributeNames();</li>\n<li>getServerInfo();返回Jsp 引擎名和版本号</li>\n</ul>\n<p>举个例子：</p>\n<pre><code>\n&lt;body&gt;\n    &lt;h1&gt;application内置对象&lt;/h1&gt;\n    &lt;% \n       application.setAttribute("city", "北京");\n       application.setAttribute("postcode", "10000");\n       application.setAttribute("email", "lisi@126.com");\n       \n    %&gt;\n         所在城市是：&lt;%=application.getAttribute("city") %&gt;&lt;br&gt;\n    application中的属性有：&lt;% \n         Enumeration attributes = application.getAttributeNames();\n         while(attributes.hasMoreElements())\n         {\n            out.println(attributes.nextElement()+"  ");\n         }\n    %&gt;&lt;br&gt;\n    JSP(SERVLET)引擎名及版本号:&lt;%=application.getServerInfo() %&gt;&lt;br&gt;              \n                   \n  &lt;/body&gt;\n</code></pre>\n<h3><a id="6page_255"></a>6、page对象</h3>\n<p>page对象就是指当前jsp页面本身，有点像this指针，它是java.lang.Object类的实例。常用的方法就是Object 类的方法。</p>\n<ul>\n<li>getClass()</li>\n<li>hashCode();</li>\n<li>equals();</li>\n<li>copy();</li>\n<li>clone()</li>\n<li>toString();</li>\n<li>notify();</li>\n<li>notifyAll();</li>\n<li>wait();</li>\n</ul>\n<h3><a id="7pageContext_269"></a>7、pageContext对象</h3>\n<ul>\n<li>pageContext 提供了对jsp页面所有的对象及名字空间的访问</li>\n<li>它可以取application 某一属性，也可以取session;</li>\n<li>相当于页面所有功能的集大成者。</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>getOut()</li>\n<li>geSession();</li>\n<li>getPage();</li>\n<li>getReuest();</li>\n<li>getResponse();</li>\n<li>setAttribute();</li>\n<li>getAttibute();</li>\n<li>getAttributeScope();</li>\n<li>forward();</li>\n<li>include();</li>\n</ul>\n<h3><a id="8config_289"></a>8、config对象</h3>\n<p>它是在一个servlet初始化时，jsp页面用它传递信息，比如servlet初始化参数；以及服务器的有关信息。</p>\n<ul>\n<li>ServletContext getServletContext();</li>\n<li>getInitParameter(String);</li>\n<li>Enumeration getInitParameterNames();</li>\n</ul>\n<h3><a id="9exception_296"></a>9、exception对象</h3>\n<p>即异常对象。如果一个jsp想要用此对象，就必须把isErrorPage 设为true.</p>\n<pre><code>&lt;%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" isErrorPage="true" %&gt;\n&lt;%\n</code></pre>\n<p>九大内置对象，讲解完毕，感谢大家，后一篇文章会讲述除了jsp的九大内置对象其他内容。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730365', 'title': '当Java遇见了Html--Servlet篇', 'readNum': '24128', 'commentNum': '0', 'publishTime': '2016-12-18 21:49:52', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>###一、什么是servlet</p>\n<p>servlet是在服务器上运行的小程序。一个servlet就是一个 java类，并且通过“请求-响应”编程模型来访问的这个驻留在服务器内存里的程序。</p>\n<p>继承关系：</p>\n<pre><code>servlet(interface)-&gt;init(),service(),destroy();\n^\ngenericServlet(abstract class)-&gt;与协议无关\n^\nhttpServlet(abstract class)-&gt;实现了http协议\n\n</code></pre>\n<blockquote>\n<p>servlet 是一个接口，genericServlet是它的一个抽象实现类，但它没有实现任何的协议，httpServlet是genericServlet的子类，实现了http协议，一般我们写servlet需要继承httpServlet。</p>\n</blockquote>\n<p>###二、手工书写第一个servlet程序<br>\n1.创建一个web工程，新建一个 servlet包，创建一个HelloServlet类。需要复写doGet()和doPost()方法。</p>\n<pre><code>public class HelloServlet extends HttpServlet {\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\tSystem.out.println("get method invoke");\n\t\tPrintWriter out=resp.getWriter();\n\t\tout.print("hello get method");\n\t}\n\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\tSystem.out.println("post method invoke");\n\t\tPrintWriter out=resp.getWriter();\n\t\tout.print("hi post method");\n\t}\n}\n\n</code></pre>\n<p>在index.jsp上写两个访问servelet的路径方法。其中，&lt; a &gt;标签，是get请求，form表单指明post请求。</p>\n<pre><code>\n&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;\n&lt;%\nString path = request.getContextPath();\nString basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";\n%&gt;\n&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;base href="&lt;%=basePath%&gt;"&gt;\n    \n    &lt;title&gt;servelet first&lt;/title&gt;\n\t&lt;meta http-equiv="pragma" content="no-cache"&gt;\n\t&lt;meta http-equiv="cache-control" content="no-cache"&gt;\n\t&lt;meta http-equiv="expires" content="0"&gt;    \n\t&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;\n\t&lt;meta http-equiv="description" content="This is my page"&gt;\n\t&lt;!--\n\t&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;\n\t--&gt;\n  &lt;/head&gt;\n  \n  &lt;body&gt;\n    &lt;h1&gt;first servlet&lt;/h1&gt;\n    &lt;a href="servlet/HelloServlet"&gt;Get方式请求servlet&lt;/a&gt;\n    &lt;form action="servlet/HelloServlet" method="post"&gt;\n    &lt;input type="submit" value="Post方式请求servlet"/&gt;\n    &lt;/form&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>配置web.xml，需配置servlet的名字和具体的类名，以及访问路径。</p>\n<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"\n\txmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://java.sun.com/xml/ns/javaee \n\thttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;\n\t&lt;display-name&gt;&lt;/display-name&gt;\n\t&lt;welcome-file-list&gt;\n\t\t&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n\t&lt;/welcome-file-list&gt;\n\n\t&lt;servlet&gt;\n\t\t&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- servlet的名字 --&gt;\n\t\t&lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;\n\t&lt;/servlet&gt;\n\t&lt;servlet-mapping&gt;\n\t&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- servlet 名字 --&gt;\n\t&lt;url-pattern&gt;/servlet/HelloServlet&lt;/url-pattern&gt; &lt;!-- servlet访问路径 --&gt;\n\t&lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre>\n<p>部署该工程，运行，访问index.jsp界面，分别点击超链接和form表单，控制台输出类容：</p>\n<blockquote>\n<p>get method invoke</p>\n<p>post method invoke</p>\n</blockquote>\n<p>这说明，通过页面的访问，点击超链接和form表单提交按钮，分别访问了servelet里的doGet()和doPost().</p>\n<p>这里以get请求来说一下 servlet的执行顺序，如图：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601122927357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h3><a id="servlet_111"></a>三、servlet的生命周期</h3>\n<ul>\n<li>初始化阶段，可以是在服务器启动初始化，也可以在第一次调用初始化，生成实例。</li>\n<li>调用init();</li>\n<li>调用servicr();判断是哪一种请求，get请求会调用doGet(),post请求调用doPost();</li>\n<li>在服务器停止的时候，调用destroy();</li>\n</ul>\n<p>几个知识点：</p>\n<ul>\n<li>Servlet 启动时自动装载servlet，需要在 web.xml配置，在之间添加如下代码：&lt; loadon-starup &gt;1&lt; /loadon-starup&gt;,数字越小，优先级越高。如果不配置，则第一次访问servlet时装载。</li>\n<li>servlet被加载的时候，会调用init()方法，在整个生命周期中init（） 只会调用一次，装载后，实例贮存在服务器的内存中。</li>\n</ul>\n<h3><a id="Servlet_124"></a>四、Servlet获取表单数据</h3>\n<p>post提交表单，form的method属性设为post, 浏览器即以post方式提交表单内容，与get方式一样，servlet可以通过httpServletRequest对象的getParameter(String para)方式获取param对应的参数值。</p>\n<p>如下是jsp提交表单的代码：</p>\n<pre><code>\n&lt;body&gt;\n    &lt;h1&gt;用户注册&lt;/h1&gt;\n    &lt;hr&gt;\n    &lt;form name="regForm" action="servlet/RegServlet" method="post" &gt;\n\t\t\t  &lt;table border="0" width="800" cellspacing="0" cellpadding="0"&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="lalel"&gt;用户名：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;&lt;input type="text" name="username" /&gt;&lt;/td&gt;\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;密码：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;&lt;input type="password" name="mypassword" &gt;&lt;/td&gt;\n\t\t\t    \t\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;确认密码：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;&lt;input type="password" name="confirmpass" &gt;&lt;/td&gt;\n\t\t\t    \t\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;电子邮箱：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;&lt;input type="text" name="email" &gt;&lt;/td&gt;\n\t\t\t    \t\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;性别：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;&lt;input type="radio" name="gender" checked="checked" value="Male"&gt;男&lt;input type="radio" name="gender" value="Female"&gt;女&lt;/td&gt;\n\t\t\t    \t\n\t\t\t    &lt;/tr&gt;\n\t\t\t   \n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;出生日期：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;\n\t\t\t    \t  &lt;input name="birthday" type="text" id="control_date" size="10"\n                      maxlength="10" onclick="new Calendar().show(this);" readonly="readonly" /&gt;\n\t\t\t    \t&lt;/td&gt;\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;爱好：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;\n\t\t\t    \t&lt;input type="checkbox" name="favorite" value="nba"&gt; NBA  \n\t\t\t    \t  &lt;input type="checkbox" name="favorite" value="music"&gt; 音乐  \n\t\t\t    \t  &lt;input type="checkbox" name="favorite" value="movie"&gt; 电影  \n\t\t\t    \t  &lt;input type="checkbox" name="favorite" value="internet"&gt; 上网  \n\t\t\t    \t&lt;/td&gt;\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;自我介绍：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;\n\t\t\t    \t\t&lt;textarea name="introduce" rows="10" cols="40"&gt;&lt;/textarea&gt;\n\t\t\t    \t&lt;/td&gt;\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td class="label"&gt;接受协议：&lt;/td&gt;\n\t\t\t    \t&lt;td class="controler"&gt;\n\t\t\t    \t\t&lt;input type="checkbox" name="isAccept" value="true"&gt;是否接受霸王条款\n\t\t\t    \t&lt;/td&gt;\n\t\t\t    &lt;/tr&gt;\n\t\t\t    &lt;tr&gt;\n\t\t\t    \t&lt;td colspan="2" align="center"&gt;\n\t\t\t    \t\t&lt;input type="submit" value="注册"/&gt;  \n\t\t\t    \t    &lt;input type="reset" value="取消"/&gt;  \n\t\t\t    \t&lt;/td&gt;\n\t\t\t    &lt;/tr&gt;\n\t\t\t  &lt;/table&gt;\n\t\t\t&lt;/form&gt;\n  &lt;/body&gt;\n</code></pre>\n<p>其中兴趣爱好为多个，即字符串数组，需要使用 httpServletRequest的getParameters(String param)获取.</p>\n<p>下面是servlet接受信息：</p>\n<pre><code>\nrequest.setCharacterEncoding("utf-8");\n\n\t\t\tusername = request.getParameter("username");\n\t\t\tmypassword = request.getParameter("mypassword");\n\t\t\tgender = request.getParameter("gender");\n\t\t\temail = request.getParameter("email");\n\t\t\tintroduce = request.getParameter("introduce");\n\t\t\tbirthday = sdf.parse(request.getParameter("birthday"));\n\t\t\tif(request.getParameterValues("isAccpet")!=null)\n\t\t\t{\n\t\t\t  isAccept = request.getParameter("isAccept");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t  isAccept = "false";\n\t\t\t}\n\t\t\t//用来获取多个复选按钮的值\n\t\t\tfavorites = request.getParameterValues("favorite");\n\t\t\n</code></pre>\n<h3><a id="Servlet_227"></a>五、Servlet之间的跳转</h3>\n<p><em>1.转向（forward)</em></p>\n<p>转向是通过requestDispatcher对象的forward(httpServletRequest req,HttpServletResponse res)方法来实现的。</p>\n<pre><code>request.getRequestDispatcher("/servlet/LifeCycleServlet").forward(request,response);\n</code></pre>\n<p>其中getRequestDispatcher方法的参数，必须以“／”开头，表示web的根目录，比如要<br>\n跳转：\u3000“<a href="http://locahost:8080/servlet/servet/LifeCycleServlet" rel="nofollow">http://locahost:8080/servlet/servet/LifeCycleServlet</a>”, 则参数为"/servlet/LifeCycleServlet".</p>\n<p><em>2.重定向（redirect)</em><br>\n通过httpServlet的sendDirect(String location)方法。</p>\n<h3><a id="_242"></a>六、获取初始化参数</h3>\n<p>1.在 web.xml中配置servlet时，可以配置一些初始化参数，在servlet可以通过servletConfig接口提供的接口获取这些参数。</p>\n<p>在web.xml中配置init-param 参数：</p>\n<pre><code>&lt;servlet&gt;\n\t\t\n\t\t&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- servlet的名字 --&gt;\n\t\t&lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;\n\t\t&lt;init-param&gt;\n\t\t\t&lt;param-name&gt;username&lt;/param-name&gt;\n\t\t\t&lt;param-value&gt;forezp&lt;/param-value&gt;\n\t\t&lt;/init-param&gt;\n\t&lt;/servlet&gt;\n</code></pre>\n<p>在servlet中获取</p>\n<pre><code>\npublic class HelloServlet extends HttpServlet {\n\t\n\t@Override\n\tpublic void init() throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.init();\n\t\tString name=this.getInitParameter("username");\n\t\tSystem.out.println(name);\n\t}\n\t\n}\n</code></pre>\n<p>部署项目，访问helloServlet就可以看见在控制台打印了forezp</p>\n<p>2.也可以配置一些全局的参数:context-param.</p>\n<pre><code>&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"\n\txmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txsi:schemaLocation="http://java.sun.com/xml/ns/javaee \n\thttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;\n\t&lt;display-name&gt;&lt;/display-name&gt;\n\t&lt;welcome-file-list&gt;\n\t\t&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n\t&lt;/welcome-file-list&gt;\n\n\n\t&lt;context-param&gt;\n\t\t&lt;param-name&gt;haha&lt;/param-name&gt;\n\t\t&lt;param-value&gt;xixi&lt;/param-value&gt;\n\t&lt;/context-param&gt;\n\t\n\t&lt;/web-app&gt;\n\n</code></pre>\n<p>获取方式：</p>\n<p>servlet中通过getServletContext()获取servletContext对象，使用ServletContext的getInitParameter()方法获取制定参数名来获取参数。</p>\n<pre><code>ServletContext servletContext=getServletConfig().getServletContext();\n\t\tString str=servletContext.getInitParameter("haha");\n\t\tSystem.out.println(str);\n\n</code></pre>\n<h3><a id="servlet_310"></a>七、servlet九大内置对象</h3>\n<p><img src="https://img-blog.csdnimg.cn/20190601122956520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>本篇文章是我在学习 servlet的一个总结，参考资料包括《javaweb整合王者归来》，慕课网上的sevlet基础视频。下一篇文章讲讲述jsp的相关内容，尽情期待，感谢大家。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730352', 'title': '一篇SSM框架整合友好的文章（三）', 'readNum': '24241', 'commentNum': '0', 'publishTime': '2016-12-18 21:48:53', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>###一.SpringMVC理论</p>\n<blockquote>\n<p>它始终是围绕 handler、<br>\n数据模型 model、<br>\n页面view进行开发的。</p>\n</blockquote>\n<p>运行流程图：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112303228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>通过mvc配置文件，配置“中央处理器”dispatchservlet，当用户请求一个url，dispatchservlet通过handlerMapping（通过注解的形式）将url给对应的handleradapter,handleradapter的具体业务逻辑是controller即我们需要实现的部分，实现具体的业务逻辑之后，需要返回modelandview给dispatchservlet，dispatchservlet再返回具体的数据或者jsp给用户。</p>\n<h3><a id="http_12"></a>二.http请求地址映射</h3>\n<blockquote>\n<p>http请求 -&gt; sringmvc handler mapping注解 -&gt; handler处理</p>\n</blockquote>\n<p>1.注解映射：<br>\n@RequestMapping</p>\n<ul>\n<li>支持标准url</li>\n<li>ant风格url (? * 字符形式)</li>\n<li>{xxx}占位符  restful 形式</li>\n</ul>\n<p>2.请求方法细节</p>\n<ul>\n<li>请求参数绑定</li>\n<li>请求方式限制</li>\n<li>请求转发和重定向</li>\n<li>数据模型赋值</li>\n<li>返回joson数据</li>\n</ul>\n<p>举个列子：</p>\n<pre><code>\n@RequestMapping(value="/{seckillId}/detail",method = RequestMethod.GET)\n    public String detail(@PathVariable("seckillId") Long seckillId, Model model){\n        if(seckillId==null){\n            return "redirect:/seckill/list";\n        }\n        Seckill seckill=seckillService.getById(seckillId);\n        if(seckill==null){\n             return "redirect:/seckill/list";\n        }\n        model.addAttribute("seckill",seckill);\n      return "detail";\n    }\n</code></pre>\n<blockquote>\n<p>@PathVariable(“seckillId”)  请求参数绑定</p>\n<p>method = RequestMethod.GET) 请求方式限制</p>\n<p>return “redirect:/seckill/list”;<br>\nreturn “redirect:/seckill/list”;请求转发和重定向</p>\n<p>model.addAttribute(“seckill”,seckill);数据模型赋值</p>\n</blockquote>\n<blockquote>\n<p>返回json通过produces = {“application/json;charset=UTF-8”}／ @ResponseBody注解</p>\n</blockquote>\n<p>###三.整合springMVC框架<br>\n在webapp 的web-inf下的web.xml配置。<br>\n配置DisatchServlet：</p>\n<pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n      &lt;init-param&gt;\n          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n          &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;\n      &lt;/init-param&gt;\n  &lt;/servlet&gt;\n  \n   &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;\n        &lt;!--默认匹配所有的请求--&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n</code></pre>\n<p>创建spring-web.xml配置SpringMvc,在代码中有详细的注解：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"\n&gt;\n    &lt;!--配置springMVC--&gt;\n    &lt;!--1:开启springMVC注解模式--&gt;\n    &lt;!--简化配置\n    （1）自动注册DefautAnnotationHandlerMapping,AnnotationMethodHandlerAdapter\n     (2) 提供一系列：数据绑定，数字和日期的format @NumberFormat，@DataTimeFormat,\n         xml,json默认读写支持\n    --&gt;\n   &lt;mvc:annotation-driven/&gt;\n    &lt;!--2:静态资源默认servlet配置\n    1：加入对静态资源的处理：js，gif,png\n    2:允许使用"/"做整体映射\n    --&gt;\n   &lt;mvc:default-servlet-handler/&gt;\n    &lt;!--3:配置jsp 显示viewResolver--&gt;\n    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;\n        &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;\n        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;\n        &lt;property name="suffix" value=".jsp"/&gt;\n    &lt;/bean&gt;\n    &lt;!--4:扫描web相关的bean--&gt;\n    &lt;context:component-scan base-package="org.forezp.web"/&gt;\n&lt;/beans&gt;\n</code></pre>\n<h3><a id="controller_115"></a>四.controller的实现</h3>\n<blockquote>\n<p>通过@Controller 注解将controller注入到spring ioc中</p>\n<p>@RequestMapping url映射</p>\n<p>model用来存放数据的。</p>\n</blockquote>\n<p>例子：</p>\n<pre><code>@Controller\n@RequestMapping("/seckill") //url:/模块/资源/{id}/细分  /seckill/list\npublic class SeckillController {\n    private final Logger logger= LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private SeckillService seckillService;\n\n    @RequestMapping(value="/list",method = RequestMethod.GET)\n    public String list(Model model){\n        //获取列表页\n       List&lt;Seckill&gt; list=seckillService.getSerkillList();\n        model.addAttribute("list",list);\n        //list.jsp+model=ModelAndView\n        return "list";///WEB-INF/jsp/"list".jsp\n    }\n   }\n</code></pre>\n<p>###五.view的实现</p>\n<p>直接上代码：</p>\n<pre><code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;\n&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;\n&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;秒杀列表页&lt;/title&gt;\n    &lt;%@include file="common/head.jsp" %&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;!--页面显示部分--&gt;\n&lt;div class="container"&gt;\n    &lt;div class="panel panel-default"&gt;\n        &lt;div class="panel-heading text-center"&gt;\n            &lt;h2&gt;秒杀列表&lt;/h2&gt;\n        &lt;/div&gt;\n        &lt;div class="panel-body"&gt;\n            &lt;table class="table table-hover"&gt;\n                &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;名称&lt;/th&gt;\n                    &lt;th&gt;库存&lt;/th&gt;\n                    &lt;th&gt;开始时间&lt;/th&gt;\n                    &lt;th&gt;结束时间&lt;/th&gt;\n                    &lt;th&gt;创建时间&lt;/th&gt;\n                    &lt;th&gt;详情页&lt;/th&gt;\n                &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                &lt;tr&gt;\n                    &lt;c:forEach var="sk" items="${list}"&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;${sk.name}&lt;/td&gt;\n                    &lt;td&gt;${sk.number}&lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;fmt:formatDate value="${sk.startTime}" pattern="yyyy-MM-dd HH:mm:ss"/&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;fmt:formatDate value="${sk.endTime}" pattern="yyyy-MM-dd HH:mm:ss"/&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;fmt:formatDate value="${sk.createTime}" pattern="yyyy-MM-dd HH:mm:ss"/&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;a class="btn btn-info" href="/minnkill/seckill/${sk.seckillId}/detail" target="_blank"&gt;link&lt;/a&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;/c:forEach&gt;\n                &lt;/tr&gt;\n                &lt;/tbody&gt;\n            &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;\n&lt;script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt;\n\n&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;\n&lt;script src="http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js"&gt;&lt;/script&gt;\n&lt;/html&gt;\n\n\n</code></pre>\n<p>运行tomacat，<a href="http://localhost:8080/minnkill/seckill/list%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%95%E7%A4%BA:" rel="nofollow">http://localhost:8080/minnkill/seckill/list页面内容的展示:</a></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123051492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<blockquote>\n<p>通过url:<a href="http://localhost:8080/minnkill/seckill/list;%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E8%BF%87springmvc-mybatis%E6%A1%86%E6%9E%B6%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%BF%E5%88%B0%E4%BA%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%B1%95%E7%A4%BA%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E3%80%82" rel="nofollow">http://localhost:8080/minnkill/seckill/list;服务端通过springmvc-mybatis框架从数据库拿到了数据并展示在页面上。</a></p>\n</blockquote>\n<p>本系列文章到此结束，它属于我学习完秒杀api的课程的一个总结，由于个人水平和精力的有限，并不能做到面面俱到，也没有深入的的讲解SSM这个框架，再未来的三到四个月里，我会不断的学习，j2ee框架，servelet\\jsp\\mysql,以及html\\css\\js的知识，也算是一次小的冲刺，大家一起加油，一起进步。</p>\n<p><a href="http://download.csdn.net/detail/forezp/9697343">源码下载</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730340', 'title': '一篇SSM框架整合友好的文章（二）', 'readNum': '24732', 'commentNum': '2', 'publishTime': '2016-12-18 21:48:07', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>上一篇讲述了DAO 层，mybatis实现数据库的连接，DAO层接口设计，以及mybtis和spring的整合。DAO层采用接口设计方式实现，接口和SQL实现的分离，方便维护。DAO层所负责的仅仅是接口的设计和实现，而负责的逻辑即一个或多个DAO层接口的拼接是在Sevice层中完成。这篇文章接上篇文章，主要讲述Service层的实现、和Spring的整合以及声明如何声明事物。</p>\n<p>###一、Service层接口设计<br>\n业务接口设计应当站在“使用者”角度设计接口，应遵循三个规范：合理的命令，明确的参数，返回结果（正常接口／异常结果）。本例子采用的Java高并发的秒杀API系列课程的例子，创建设计的业务逻辑接口如下：</p>\n<pre><code>\npublic interface SeckillService {\n    /**\n     * 查询所有秒杀记录\n     * @return\n     */\n    List&lt;Seckill&gt; getSerkillList();\n  \n\n    /**\n     * 查询单个秒杀记录\n     * @param seckillId\n     * @return\n     */\n    Seckill getById(long seckillId);\n\n   \n    /**\n     * 秒杀开启时输出秒杀接口地址，\n     * 否则输出系统时间和秒杀时间\n     * @param seckillId\n     */\n    Exposer exportSeckillUrl(long seckillId);\n   \n\t\n\t／**\n\t  *执行秒杀接口\n\t  */\n   SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException,RepeatKillException,SeckillCloseException;\n  \n     \n</code></pre>\n<h3><a id="Service_39"></a>二、Service接口的实现</h3>\n<p>直接上代码了，在这里讲下秒杀业务的逻辑：首先是获取秒杀列表，点击列表进入秒杀详情页，这时获取系统时间，如果秒杀开始，获取秒杀地址，点击秒杀，执行秒杀。所以业务逻辑也只设计了这相关的4个业务逻辑。其中使用了dto层去传递响应数据，以及自定义异常，所有的异常都继承运行异常，这是为了方便spring自动回滚，这两个知识点，自行看源码。</p>\n<pre><code>package org.forezp.service.impl;\n\n@Service\npublic class SeckillServiceImpl implements SeckillService{\n    private Logger logger= LoggerFactory.getLogger(this.getClass());\n    //注入service依赖\n    @Autowired\n    private SeckillDao seckillDao;\n    @Autowired\n    private SuccessKilledDao successKilledDao;\n    //MD5盐值字符串，用户混淆MD5\n    private final String slat="sfsa=32q4r23234215ERWERT^**%^SDF";\n\t\n\t\n\t\n    public List&lt;Seckill&gt; getSerkillList() {\n        return seckillDao.queryAll(0,4);\n    }\n\n\n\n    public Seckill getById(long seckillId) {\n        return seckillDao.queryById(seckillId);\n    }\n\n\n\n    public Exposer exportSeckillUrl(long seckillId) {\n        Seckill seckill =seckillDao.queryById(seckillId);\n        if(seckill==null){\n            return new Exposer(false,seckillId);\n        }\n        Date startTime=seckill.getStartTime();\n        Date endTime=seckill.getEndTime();\n        //系统当前时间\n        Date nowTime=new Date();\n        if(nowTime.getTime()&lt;startTime.getTime()||nowTime.getTime()&gt;endTime.getTime()){\n            return new Exposer(false,seckillId,nowTime.getTime(),startTime.getTime(),endTime.getTime());\n        }\n        String md5=getMD5(seckillId);\n        return new Exposer(true,md5,seckillId);\n    }\n    private String getMD5(long seckillId){\n        String base=seckillId+"/"+slat;\n        String md5= DigestUtils.md5DigestAsHex(base.getBytes());\n        return md5;\n    }\n    \n    \n    @Transactional\n    /**\n     *使用注解控制事务方法的优点\n     * 1：开发团队达成一致约定，明确标注事务方法的编程风格\n     * 2：保证事务方法的执行时间尽可能短，不要穿插其他网络请求，RPC/HTTP请求或者剥离到事务方法外\n     * 3：不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制\n     */\n    public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException {\n        if(md5==null ||!md5.equals(getMD5(seckillId))){\n            throw new SeckillException("seckill data rewrite");\n        }\n        //执行秒杀逻辑：减库存+记录购买行为\n        Date nowTime=new Date();\n        try {\n            //记录购买行为\n            int insertCount=successKilledDao.insertSuccessKilled(seckillId,userPhone);\n            //唯一：seckillId，userphone\n            if(insertCount&lt;=0){\n                //重复秒杀\n                throw new RepeatKillException("seckill repeated");\n            }else{\n                //减库存，热点商品竞争\n                int updateCount=seckillDao.reduceNumber(seckillId,nowTime);\n                if(updateCount&lt;=0){\n                    //没有更新到记录,秒杀结束 rollback\n                    throw new SeckillCloseException("seckill is closed");\n                }else{\n                    //秒杀成功 commit\n                    SuccessKilled successKilled=successKilledDao.queryByIdWithSeckill(seckillId,userPhone);\n                    return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);\n                }\n            }\n\n        }catch(SeckillCloseException e1){\n            throw e1;\n        } catch (RepeatKillException e2){\n            throw e2;\n        } catch (Exception e) {\n            logger.error(e.getMessage(),e);\n            //所有的编译期异常，转化为运行期异常(运行时异常，spring可以做rollback操作)\n            throw new SeckillException("seckill inner error:"+e.getMessage());\n        }\n\n    }\n    //抛出异常是为了告诉spring是否rollback，此处使用存储过程的话，就不需要抛异常了\n    public SeckillExecution executeSeckillProcedure(long seckillId, long userPhone, String md5) {\n        if(md5 ==null || !md5.equals(getMD5(seckillId))){\n            return new SeckillExecution(seckillId,SeckillStatEnum.DATA_REWRITE);\n        }\n        Date killTime=new Date();\n        Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();\n        map.put("seckillId",seckillId);\n        map.put("phone",userPhone);\n        map.put("killTime",killTime);\n        map.put("result",null);\n        //执行存储过程，result被赋值\n        try {\n            seckillDao.killByProcedure(map);\n            int result=(Integer) map.get("result");\n            if(result==1){\n                SuccessKilled successKilled=successKilledDao.queryByIdWithSeckill(seckillId,userPhone);\n                return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);\n            }else{\n                return new SeckillExecution(seckillId,SeckillStatEnum.stateof(result));\n            }\n        } catch (Exception e) {\n            logger.error(e.getMessage(),e);\n            return new SeckillExecution(seckillId,SeckillStatEnum.INNER_ERROE);\n        }\n    }\n}\n\n</code></pre>\n<h3><a id="Sping_service_166"></a>三、Sping托管 service的实现类</h3>\n<p>和上一篇文章使用spring托管dao接口一样，这里也需要用 spring 托管service. spring ioc 使用对象工程模式，对所有的注入的依赖进行了管理，暴露出了一致性的访问接口，当我们需要某个对象时，直接从spring ioc中取就行了，不需要new，也不需要对它们的生命周期进行管理。更为重要的是spring 自动组装依赖，比如最终的接口controller依赖service,而service依赖dao,dao依赖sessionfactory,而sessionfactory依赖datasource,这些层层依赖是通过spring管理并层层组装，只要我们简单配置和注解就可以方便的使用，代码的分层和编程的艺术在spring框架中展现得淋漓尽至。</p>\n<blockquote>\n<p>本项目采用spring ioc :</p>\n<p>1.xml配置</p>\n<p>2.包扫描</p>\n<p>3.annotation注解。</p>\n</blockquote>\n<p>创建sping-service.xml</p>\n<p>采用包扫描+注解方式，首先在xml中声明包扫描：</p>\n<pre><code>\n&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n&lt;beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd"\n&gt;\n    &lt;!--扫描service包下所有使用注解的类型--&gt;\n    &lt;context:component-scan base-package="org.forezp.service"/&gt;\n\n</code></pre>\n<p>然后在org,forezp.service包下的类采用注解。比如@Service 注解声明是一个service， @Autowired注入service 所需依赖。</p>\n<pre><code>@Service//声明是一个service\npublic class SeckillServiceImpl implements SeckillService{\n\n //注入service依赖\n    @Autowired\n    private SeckillDao seckillDao;\n    @Autowired\n    private SuccessKilledDao successKilledDao;\n\n}\n</code></pre>\n<p>只需要一个包扫描和几个简单的注解就可以将service注解到spring  ioc容器中。</p>\n<h3><a id="spring_216"></a>四、spring声明式事物</h3>\n<p>在秒杀案例中，我们需要采用事物来防止数据的正确性，防止重复秒杀，防止库存不足、库存剩余等情况。一般使用事物需要开启事物／经常一些列的操作，提交或者回滚。spring声明式事物，就是将事物的开启、提交等托管给spring管理，我们只需要注重如何修改数据。</p>\n<p>配置spring 声明式事物<br>\n在spring-service.xml中配置：</p>\n<pre><code> &lt;!--配置事务管理器--&gt;\n    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;\n        &lt;!--注入数据库连接池--&gt;\n        &lt;property name="dataSource" ref="dataSource"/&gt;\n    &lt;/bean&gt;\n    &lt;!--配置基于注解的声明式事务\n        默认使用注解来管理事务行为\n    --&gt;\n    &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;\n\n</code></pre>\n<p>在需要事物的业务逻辑下加 @Transactional注解。<br>\n比如在开启秒杀方法：</p>\n<pre><code>@Transactional\npublic SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException {\n        if(md5==null ||!md5.equals(getMD5(seckillId))){\n        }\n\n</code></pre>\n<p><em>注意：</em></p>\n<blockquote>\n<p>1开发团队达成一致约定，明确标注事务方法的编程风格</p>\n<p>2：保证事务方法的执行时间尽可能短，不要穿插其他网络请求，RPC/HTTP请求或者剥离到事务方法外</p>\n<p>3：不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制</p>\n</blockquote>\n<h3><a id="_253"></a>五、单元测试</h3>\n<p>需要配置:</p>\n<blockquote>\n<p>@ContextConfiguration({<br>\n“classpath:spring/spring-dao.xml”,<br>\n“classpath:spring/spring-service.xml”<br>\n})<br>\n直接上代码：</p>\n</blockquote>\n<pre><code>\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\n        "classpath:spring/spring-dao.xml",\n        "classpath:spring/spring-service.xml"\n})\npublic class SeckillServiceTest {\n    private final Logger logger=LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private SeckillService seckillService;\n\n    @Test\n    public void getSerkillList() throws Exception {\n        List&lt;Seckill&gt; list=seckillService.getSerkillList();\n       System.out.println(list);\n       //执行结果[Seckill{seckillId=1000, name=\'1000元秒杀iphone6\'..... 省略。。。]\n\n\n    }\n\n    @Test\n    public void getById() throws Exception {\n        long id=1000;\n        Seckill seckill=seckillService.getById(id);\n        System.out.println(seckill);\n        //执行结果：Seckill{seckillId=1000, name=\'1000元秒杀iphone6\', number=100, startTime=Sun Nov 01 00:00:00 CST 2015,。。。。}\n    }\n\n    @Test\n    public void exportSeckillUrl() throws Exception {\n        long id=1000;\n        Exposer exposer=seckillService.exportSeckillUrl(id);\n        System.out.println(exposer);\n\n    }\n\n    @Test\n    public void executeSeckill() throws Exception {\n        long id=1000;\n        long phone=13502171122L;\n        String md5="e83eef2cc6b033ca0848878afc20e80d";\n        SeckillExecution execution=seckillService.executeSeckill(id,phone,md5);\n        System.out.println(execution);\n    }\n   }\n</code></pre>\n<p>这篇文章主要讲了service业务接口的编写和实现，以及采用xml和注解方式讲service 注入到spring ioc，以及声明式事物，不得不感叹spring 的强大。下一篇文章讲讲述 web层的开发，spring mvc的相关配置。感谢大家，再接再厉，晚安。<sup>_</sup>。</p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53730333', 'title': '一篇SSM框架整合友好的文章（一）', 'readNum': '25477', 'commentNum': '1', 'publishTime': '2016-12-18 21:47:29', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n  <p>转载请标明出处：  <br>\n  <a href="http://blog.csdn.net/forezp/article/details/53730333">http://blog.csdn.net/forezp/article/details/53730333</a> <br>\n  本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n\n<p>最近实在太忙，之前写的《rxjava系列文章》告一段落，还有两篇会在一月中旬补上，感谢大家。这篇文章讲述mybatis搭建DAO层，另外这系列文章是我看完《java高并发秒杀系列》的课程整理的，所以文章采用的例子也来源于这系列课程。</p>\n\n<h3 id="一环境工具">一.环境／工具</h3>\n\n<p>1.开发工具idea</p>\n\n<p>2.数据库mysql</p>\n\n<p>3.javaweb容器 tomcat</p>\n\n<p>4.构建项目工具maven</p>\n\n<p>关于这几个工具下载安装，环境的搭建就不介绍，自行百度。</p>\n\n\n\n<h3 id="二采用maven-构建项目">二.采用maven 构建项目</h3>\n\n<p>采用命令构架，当然也可以采用ide 直接构建。</p>\n\n<p><em>构建命令：</em></p>\n\n<blockquote>\n  <p>mvn archetype:generate -DgroupId=org.forezp -DartifactId=minnkill -DarchetypeArtifactId=maven-archetype-webapp</p>\n</blockquote>\n\n<p>低版本maven需要将generate 改为create.</p>\n\n\n\n<h3 id="三补全ssm框架相关依赖">三.补全SSM框架相关依赖</h3>\n\n<p>下面是SSM框架所需的所有框架</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-tag">&lt;<span class="hljs-title">project</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">"http://www.w3.org/2001/XMLSchema-instance"</span>\n  <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-title">modelVersion</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.seckill<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>seckill<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-title">packaging</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">name</span>&gt;</span>seckill Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-title">name</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">url</span>&gt;</span>http://maven.apache.org<span class="hljs-tag">&lt;/<span class="hljs-title">url</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">dependencies</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-comment">&lt;!--使用junit4，4以上使用注解--&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-title">scope</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--补全项目依赖--&gt;</span>\n    <span class="hljs-comment">&lt;!--1:日志，java日志：slf4j,log4j,logback,common-logging\n     使用：slf4j+logBack\n    --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.5.6<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--2:数据库相关依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>5.1.35<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-title">scope</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--DAO框架：MyBatis依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--myBatis自身实现的spring整合依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--3:Servlet web相关依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>2.5.4<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n\n    <span class="hljs-comment">&lt;!--4:spring依赖--&gt;</span>\n    <span class="hljs-comment">&lt;!--spring核心依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--spring dao层依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--spring web相关依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n    <span class="hljs-comment">&lt;!--spring test相关依赖--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n\n    <span class="hljs-comment">&lt;!--引入一些工具类--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>3.2<span class="hljs-tag">&lt;/<span class="hljs-title">version</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>\n\n\n  <span class="hljs-tag">&lt;/<span class="hljs-title">dependencies</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">build</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">finalName</span>&gt;</span>seckill<span class="hljs-tag">&lt;/<span class="hljs-title">finalName</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">build</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">project</span>&gt;</span>\n</code></pre>\n\n\n\n<h3 id="四建数据库">四.建数据库</h3>\n\n<p>仿java高并发秒杀系列》的视频，建了两张表，一张上库存表，一张上秒杀表，我直接贴sql语句了，比较简单。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs sql"><span class="hljs-comment">--创建数据库</span>\n<span class="hljs-operator"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> seckill;</span>\n<span class="hljs-comment">--使用数据库</span>\nuse seckill;\n\n<span class="hljs-comment">--库存表</span>\n<span class="hljs-operator"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> seckill(\n<span class="hljs-string">`seckill_id`</span> bigint <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">\'商品库存id\'</span>,\n<span class="hljs-string">`name`</span> <span class="hljs-keyword">VARCHAR</span>(<span class="hljs-number">120</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">\'商品名称\'</span>,\n<span class="hljs-string">`number`</span> <span class="hljs-keyword">int</span>  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">\'库存数量\'</span>,\n<span class="hljs-string">`start_time`</span> <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">"2016-05-07 13:28:00"</span>,\n<span class="hljs-string">`end_time`</span> <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">"2016-05-07 13:28:00"</span>,\n<span class="hljs-string">`create_time`</span> <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>  COMMENT <span class="hljs-string">\'创建时间\'</span>,\n <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (seckill_id),\n <span class="hljs-keyword">key</span> idx_start_time(start_time),\n<span class="hljs-keyword">key</span> idx_end_time(end_time),\n <span class="hljs-keyword">key</span> idx_create_time(create_time)\n)EnGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">1000</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 COMMENT=<span class="hljs-string">\'秒杀库存表\'</span>;</span>\n\n<span class="hljs-comment">---初始化数据</span>\n<span class="hljs-operator"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> seckill(name,<span class="hljs-keyword">number</span>,start_time,end_time)\n<span class="hljs-keyword">VALUES</span>\n (<span class="hljs-string">\'1000元秒杀iphone6\'</span>,<span class="hljs-number">100</span>,<span class="hljs-string">\'2015-11-01 00:00:00\'</span>,<span class="hljs-string">\'2015-11-02 00:00:00\'</span>),\n (<span class="hljs-string">\'500元秒杀ipad2\'</span>,<span class="hljs-number">200</span>,<span class="hljs-string">\'2015-11-01 00:00:00\'</span>,<span class="hljs-string">\'2015-11-02 00:00:00\'</span>),\n (<span class="hljs-string">\'300元秒杀小米4\'</span>,<span class="hljs-number">300</span>,<span class="hljs-string">\'2015-11-01 00:00:00\'</span>,<span class="hljs-string">\'2015-11-02 00:00:00\'</span>),\n (<span class="hljs-string">\'200元秒杀红米note\'</span>,<span class="hljs-number">400</span>,<span class="hljs-string">\'2015-11-01 00:00:00\'</span>,<span class="hljs-string">\'2015-11-02 00:00:00\'</span>);</span>\n\n <span class="hljs-comment">--秒杀成功明细表</span>\n <span class="hljs-comment">--用户登录认证相关的信息</span>\n <span class="hljs-operator"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> success_killed(\n <span class="hljs-string">`seckill_id`</span> bigint <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">\'秒杀商品id\'</span>,\n <span class="hljs-string">`user_phone`</span> bigint <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">\'用户手机号\'</span>,\n<span class="hljs-string">`state`</span> tinyint <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">\'状态标示:-1:无效 0:成功 1:已付款\'</span>,\n<span class="hljs-string">`create_time`</span> <span class="hljs-keyword">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">\'创建时间\'</span>,\n<span class="hljs-keyword">PRIMARY</span>  <span class="hljs-keyword">KEY</span> (seckill_id,user_phone),/*联合主键*/\n<span class="hljs-keyword">KEY</span> idx_create_time(create_time)\n )EnGINE=InnoDB  <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 COMMENT=<span class="hljs-string">\'秒杀明细表\'</span>;</span>\n</code></pre>\n\n\n\n<h3 id="五dao层实体编写和接口编写">五.DAO层实体编写和接口编写</h3>\n\n<p>1.创建org.forezp.entity包，根据数据库字段，编写实体。 <br>\n下面是Seckill库存实体：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Seckill {\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> seckillId;\n    <span class="hljs-keyword">private</span> String name;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;\n    <span class="hljs-keyword">private</span> Date startTime;\n    <span class="hljs-keyword">private</span> Date endTime;\n    <span class="hljs-keyword">private</span> Date createTime;\n    <span class="hljs-comment">//这里省去了写getter setter方法，在实际项目补上 </span>\n}</code></pre>\n\n<ol>\n<li>创建org.forezp.dao包 <br>\n编写Seckill接口</li>\n</ol>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SeckillDao</span> {</span>\n    <span class="hljs-comment">//减库存</span>\n    <span class="hljs-keyword">int</span> reduceNumber(<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"seckillId"</span>)<span class="hljs-keyword">long</span> seckillId,<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"killTime"</span>)Date killTime);\n    <span class="hljs-comment">//根据Id查询秒杀对象</span>\n    Seckill queryById(<span class="hljs-keyword">long</span> seckillId);\n    <span class="hljs-comment">//根据偏移量查询秒杀列表</span>\n    List&lt;Seckill&gt; queryAll(<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"offset"</span>)<span class="hljs-keyword">int</span> offset,<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"limit"</span>)<span class="hljs-keyword">int</span> limit);\n</code></pre>\n\n<p>采用mapper实现接口</p>\n\n<p>在resources目录下创建maaper文件夹，所有的接口实现类放在这里 ，另外项目采用xml的方式实现接口。采用这种方式的好处有很多，比如可以采用包扫描，更少的配置，所有的sql语句都放在这里，有利于统一规范，代码的可维护性和可读性也大大提高。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n\n<span class="hljs-doctype">&lt;!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>\n\n\n<span class="hljs-tag">&lt;<span class="hljs-title">mapper</span> <span class="hljs-attribute">namespace</span>=<span class="hljs-value">"org.forezp.dao.SeckillDao"</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">update</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"reduceNumber"</span>&gt;</span>\n        update\n        seckill\n        set\n        number = number-1\n        where seckill_id = #{seckillId}\n        and\n        start_time <span class="hljs-cdata">&lt;![CDATA[ &lt;= ]]&gt;</span>\n        #{killTime}\n        and end_time &gt;= #{killTime}\n        and number &gt; 0;\n    <span class="hljs-tag">&lt;/<span class="hljs-title">update</span>&gt;</span>\n\n     <span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"queryById"</span> <span class="hljs-attribute">resultType</span>=<span class="hljs-value">"Seckill"</span> <span class="hljs-attribute">parameterType</span>=<span class="hljs-value">"long"</span>&gt;</span>\n        select seckill_id,name,number,start_time,end_time,create_time from seckill\n        where seckill_id = #{seckillId}\n    <span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>\n\n\n   <span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"queryAll"</span> <span class="hljs-attribute">resultType</span>=<span class="hljs-value">"Seckill"</span>&gt;</span>\n        select seckill_id,name,number,start_time,end_time,create_time\n        from seckill\n        order by create_time desc\n        limit #{offset},#{limit}\n    <span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>\n\n\n<span class="hljs-tag">&lt;/<span class="hljs-title">mapper</span>&gt;</span>\n</code></pre>\n\n\n\n<h3 id="六-mybatis的配置">六. mybatis的配置</h3>\n\n<p>创建mybatis-config.xml 全局配置：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>\n<span class="hljs-doctype">&lt;!DOCTYPE configuration\n  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span>\n\n\n <span class="hljs-comment">&lt;!-- 配置全局属性 --&gt;</span>    \n\n<span class="hljs-tag">&lt;<span class="hljs-title">settings</span>&gt;</span>\n        <span class="hljs-comment">&lt;!--使用jdbc的getGeneratedKeys 获取数据库的自增主键值--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">setting</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"useGeneratedKeys"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"true"</span>/&gt;</span>\n        <span class="hljs-comment">&lt;!--使用别名替换列名 默认true\n        select name as title from table\n        --&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">setting</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"useColumnLabel"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"true"</span>/&gt;</span>\n        <span class="hljs-comment">&lt;!--开启驼峰命名转换--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">setting</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"mapUnderscoreToCamelCase"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"true"</span>/&gt;</span>\n\n    <span class="hljs-tag">&lt;/<span class="hljs-title">settings</span>&gt;</span>\n\n<span class="hljs-tag">&lt;/<span class="hljs-title">configuration</span>&gt;</span></code></pre>\n\n<p>创建jdbc.properties文件 <br>\n数据库配置文件和连接数据库驱动。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs ini"><span class="hljs-setting">driver=<span class="hljs-value">com.mysql.jdbc.Driver</span></span>\n<span class="hljs-setting">url=<span class="hljs-value">jdbc:mysql://localhost:<span class="hljs-number">3306</span>/seckill?useUnicode=<span class="hljs-keyword">true</span>&amp;characterEncoding=utf8</span></span>\n<span class="hljs-setting">username=<span class="hljs-value">root</span></span>\n<span class="hljs-setting">password=<span class="hljs-value"><span class="hljs-number">123</span></span></span></code></pre>\n\n\n\n<h3 id="七mybatis和spring-整合">七.mybatis和spring 整合</h3>\n\n<p>直接贴配置文件，文件已经写好了注释。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">beans</span> <span class="hljs-attribute">xmlns</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans"</span>\n       <span class="hljs-attribute">xmlns:xsi</span>=<span class="hljs-value">"http://www.w3.org/2001/XMLSchema-instance"</span>\n       <span class="hljs-attribute">xmlns:context</span>=<span class="hljs-value">"http://www.springframework.org/schema/context"</span>\n       <span class="hljs-attribute">xsi:schemaLocation</span>=<span class="hljs-value">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>\n&gt;</span>\n\n    <span class="hljs-comment">&lt;!--配置整合mybatis过程--&gt;</span>\n\n    <span class="hljs-comment">&lt;!--１.配置数据库相关参数--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">context:property-placeholder</span> <span class="hljs-attribute">location</span>=<span class="hljs-value">"classpath:jdbc.properties"</span>/&gt;</span>\n\n      <span class="hljs-comment">&lt;!--2.配置连接池属性--&gt;</span>   \n    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"dataSource"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"driverClassName"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"com.mysql.jdbc.Driver"</span>/&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"url"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"jdbc:mysql://127.0.0.1:3306/seckill"</span>/&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"username"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"root"</span>/&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"password"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"123"</span>/&gt;</span>\n\n    <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span>\n\n\n    <span class="hljs-comment">&lt;!--３.配置SqlSessionFactory对象--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"sqlSessionFactory"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>\n        <span class="hljs-comment">&lt;!--注入数据库连接池--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"dataSource"</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">"dataSource"</span>/&gt;</span>\n        <span class="hljs-comment">&lt;!--配置mybatis全局配置文件:mybatis-config.xml--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"configLocation"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"classpath:mybatis-config.xml"</span>/&gt;</span>\n        <span class="hljs-comment">&lt;!--扫描entity包,使用别名,多个用;隔开--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"typeAliasesPackage"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"org.forezp.entity"</span>/&gt;</span>\n        <span class="hljs-comment">&lt;!--扫描sql配置文件:mapper需要的xml文件--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"mapperLocations"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"classpath:mapper/*.xml"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span>\n\n    <span class="hljs-comment">&lt;!--４:配置扫描Dao接口包,动态实现DAO接口,注入到spring容器--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>\n        <span class="hljs-comment">&lt;!--注入SqlSessionFactory--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"sqlSessionFactoryBeanName"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"sqlSessionFactory"</span>/&gt;</span>\n        <span class="hljs-comment">&lt;!-- 给出需要扫描的Dao接口--&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"basePackage"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"org.forezp.dao"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">beans</span>&gt;</span></code></pre>\n\n<p>就这样mybatis和spring就整合好了，spring 提供了的ioc容器，为我们管理bean，我们不需要管理bean的生命周期.</p>\n\n\n\n<h3 id="八单元测试">八.单元测试</h3>\n\n<p>采用junit单元测试，spring 对junit做了很好的支持。只需要配置注解久可以了，</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java">\n<span class="hljs-javadoc">/**\n * 配置spring和junit整合，junit启动时加载springIOC容器\n */</span>\n<span class="hljs-annotation">@RunWith</span>(SpringJUnit4ClassRunner.class)\n<span class="hljs-annotation">@ContextConfiguration</span>(locations = {<span class="hljs-string">"classpath*:spring/spring-dao.xml"</span>})\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeckillDaoTest</span> {</span>\n\n\n    <span class="hljs-annotation">@Test</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduceNumber</span>() <span class="hljs-keyword">throws</span> Exception {\n        Date killTIme=<span class="hljs-keyword">new</span> Date();\n        <span class="hljs-keyword">int</span> updateCount =seckillDao.reduceNumber(<span class="hljs-number">1000</span>L,killTIme);\n        System.out.println(updateCount);\n        <span class="hljs-comment">//结果第一次执行为1 后面为0 </span>\n\n    }\n    <span class="hljs-comment">//注入Dao实现类依赖</span>\n    <span class="hljs-annotation">@Resource</span>\n    <span class="hljs-keyword">private</span> SeckillDao seckillDao;\n    <span class="hljs-annotation">@Test</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryById</span>() <span class="hljs-keyword">throws</span> Exception {\n        <span class="hljs-keyword">long</span> id=<span class="hljs-number">1001</span>;\n        Seckill seckill=seckillDao.queryById(id);\n        System.out.println(seckill.getName());\n        System.out.println(seckill);\n        <span class="hljs-comment">//运行结果</span>\n        <span class="hljs-javadoc">/** 500元秒杀ipad2*／\n      ／**  Seckill{seckillId=1001, name=\'500元秒杀ipad2\',number=200, startTime=Sun Nov 01 00:00:00 CST 2015, endTime=Mon Nov 02 00:00:00 CST 2015, createTime=Sun Nov 27 10:44:30 CST 2016}*/</span>\n    }\n\n    <span class="hljs-annotation">@Test</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryAll</span>() <span class="hljs-keyword">throws</span> Exception {\n        <span class="hljs-comment">//java没有保存形参的记录，queryAll(int offeset,int limit)-&gt;queryAll(arg0,arg1),通过@param注解来解决</span>\n\n        List&lt;Seckill&gt; seckills=seckillDao.queryAll(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);\n        <span class="hljs-keyword">for</span>(Seckill seckill:seckills){\n            System.out.println(seckill);\n        }\n    }\n\n}</code></pre>\n\n<p>到此为止，mybatis实现数据库的连接，和dao层代码的编写以及mybatis 和spring的整合 。我觉得学习路上虽然很孤单，但如果有一个分享的心态和持续学习的动力，生活也算是充实的，自己成长了，技术也提高了，回报也高了，生活品质也随之提高。所以无论做什么，自己快乐，并且能提高自己的快乐，且以此为目的就够了，祝自己好运。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9697343">源码下载</a></p>\n\n\n\n<h3 id="优秀文章推荐">优秀文章推荐：</h3>\n\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n\n<p><img src="http://upload-images.jianshu.io/upload_images/2279594-376be1da82d49908.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拍摄于深圳大沙河公园" title=""></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/53013762', 'title': '一篇RxJava友好的文章（三）', 'readNum': '23162', 'commentNum': '0', 'publishTime': '2016-11-02 22:15:31', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h1><a id="_0"></a>组合操作符</h1>\n<p>继上一篇讲述了过滤操作符，这一篇讲述组合操作符，组合操作符可用于组合多个Observable。组合操作符相对于过滤操作符要复杂很多，也较难以理解，需要花费时间去看文档查资料，写demo才能有一定的理解，这系列文章的例子将会在系列文章写完同意上传，敬请期待。</p>\n<h2><a id="1starWith_3"></a>1.starWith操作符</h2>\n<p>starWith是在数据序列的开头插入一条指定的项;<br>\n如果你想要一个Observable在发射数据之前先发射一个指定的数据序列，可以使用 StartWith  操作符，原理如图所示。（如果你想一个Observable发射的数据末尾追加一个数据序列可以使用 Concat  操作符，与startwith 相反）</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123150430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>  Observable.just(1,2,3,4,5).startWith(9,8)\n     .subscribe(new Action1&lt;Integer&gt;() {\n                @Override\n                public void call(Integer integer) {\n                    Log.e(TAG,""+integer);\n                }\n            });\n\n</code></pre>\n<p>程序运行结果：</p>\n<blockquote>\n<p>9,8,1,2,3,4,5</p>\n</blockquote>\n<h2><a id="2CombineLatest_25"></a>2.CombineLatest操作符</h2>\n<p>当两个Observables中的任何一个发射了数据时，使用一个函数结合每个Observable发射的最近数据项，并且基于这个函数的结果发射数据。原理如图所示：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123207399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>Observable.combineLatest(Observable.just(1, 2, 3), \n    Observable.just("a", "b", "c", "d"), new Func2&lt;Integer, String,       String&gt;() {\n            @Override\n            public String call(Integer integer, String s) {\n                Log.e(TAG,"combineLatest:"+"integer:"+integer+"&gt;&gt;String:"+s);\n                return integer+s;\n            }\n        }).subscribe(new Action1&lt;String&gt;() {\n            @Override\n            public void call(String s) {\n                Log.e(TAG,s);\n            }\n        });\n</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>3a 3b 3c 3d</p>\n</blockquote>\n<p>CombineLatest  在原始的Observable中任意一个发射了数据<br>\n时发射一条数据。当原始Observables的任何一个发射了一条数据时， CombineLatest  使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值。</p>\n<h2><a id="3Merge_52"></a>3.Merge</h2>\n<p>合并多个Observables的发射物;<br>\n使用 Merge  操作符你可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。Merge  可能会让合并的Observables发射的数据交错（有一个类似的操作符 Concat  不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123221770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>Observable.merge(Observable.just(1,3,4,5),Observable.just(22,33,44))\n    .subscribe(new Action1&lt;Integer&gt;() {\n            @Override\n            public void call(Integer integer) {\n                Log.e(TAG,""+integer);\n            }\n        });\n\n</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>1,2,3,4,5,22,33,44</p>\n</blockquote>\n<h2><a id="4zip_73"></a>4.zip</h2>\n<p>Zip  操作符返回一个Obversable，它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。</p>\n<pre><code>  Observable.zip(Observable.just(1, 2, 3, 4, 5), \n        Observable.just("a", "b", "c"), new      Func2&lt;Integer, String, String&gt;() {\n            @Override\n            public String call(Integer integer, String integer2) {\n                return integer+integer2;\n            }\n        })\n        .subscribe(new Action1&lt;String&gt;() {\n            @Override\n            public void call(String s) {\n                Log.e(TAG,""+s);\n            }\n        });\n</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>1a ,2b,3c</p>\n</blockquote>\n<p>所有的组合操作符：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123246805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>这些组合操作符都不是这么容易理解的，需要自己慢慢的领悟，学好rxjava需要投入一定时间和精力，总之多多练习就好了，需要我的这系列文章能够帮助到像我一样对rxjava热爱的人，感谢大家。</p>\n<p>(<a href="https://github.com/forezp/banya">https://github.com/forezp/banya</a>)<br>\n项目地址：<a href="https://github.com/forezp/banya">https://github.com/forezp/banya</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52987706', 'title': 'javascript入门笔记9-认识DOM', 'readNum': '23158', 'commentNum': '0', 'publishTime': '2016-10-31 22:17:03', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h2 id="认识dom">认识DOM</h2>\n\n<hr>\n\n<blockquote>\n  <p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p>\n</blockquote>\n\n<p><strong>将HTML代码分解为DOM节点层次图:</strong></p>\n\n<p><img src="http://img.mukewang.com/5375ca7e0001dd8d04830279.jpg" alt="" title=""></p>\n\n<p><em>HTML文档可以说由节点构成的集合，DOM节点有:</em></p>\n\n<ul>\n<li><p>元素节点：上图中、、</p><p>等都是元素节点，即标签。</p><p></p></li>\n<li><p>文本节点:向用户展示的内容中的JavaScript、DOM、CSS等文本。</p></li>\n<li><p>属性节点:元素属性，如<a>标签的链接属性href=”http://www.imooc.com”。</a></p></li>\n</ul>\n\n<hr>\n\n<p><strong>节点属性</strong></p>\n\n<p><img src="http://img.mukewang.com/5375c953000117ee05240129.jpg" alt="" title=""></p>\n\n<p><strong>遍历节点树:</strong></p>\n\n<p><img src="http://img.mukewang.com/53f17a6400017d2905230219.jpg" alt="" title=""></p>\n\n<p><strong>DOM操作:</strong></p>\n\n<p><img src="http://img.mukewang.com/538d29da000152db05360278.jpg" alt="" title=""></p>\n\n\n\n<h3 id="getelementsbyname方法">getElementsByName()方法</h3>\n\n<p><strong>语法：</strong></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">document<span class="hljs-preprocessor">.getElementsByName</span>(name)</code></pre>\n\n<p>与getElementById() 方法不同的是，通过元素的 name 属性查询元素，而不是通过 id 属性。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n<li><p>因为文档中的 name 属性可能不唯一，所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。</p></li>\n<li><p>和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。</p></li>\n</ul>\n\n<hr>\n\n\n\n<h3 id="getelementsbytagname方法">getElementsByTagName()方法</h3>\n\n<p>返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">document<span class="hljs-preprocessor">.getElementsByTagName</span>(Tagname)</code></pre>\n\n<p><em>说明：</em></p>\n\n<ul>\n<li><p>Tagname是标签的名称，如p、a、img等标签名。</p></li>\n<li><p>和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。</p></li>\n</ul>\n\n<hr>\n\n\n\n<h3 id="getattribute方法">getAttribute()方法</h3>\n\n<p>通过元素节点的属性名称获取属性的值</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">elementNode<span class="hljs-preprocessor">.getAttribute</span>(name)</code></pre>\n\n<p><em>说明:</em></p>\n\n<ul>\n<li><p>elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。</p></li>\n<li><p>name：要想查询的元素节点的属性名字</p></li>\n</ul>\n\n<hr>\n\n\n\n<h3 id="setattribute方法">setAttribute()方法</h3>\n\n<p>setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">elementNode.setAttribute(name,<span class="hljs-keyword">value</span>)\n</code></pre>\n\n<p><em>说明：</em></p>\n\n<ul>\n<li><p>name: 要设置的属性名。</p></li>\n<li><p>value: 要设置的属性值。</p></li>\n</ul>\n\n\n\n<h2 id="节点属性">节点属性</h2>\n\n<p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：</p>\n\n<ul>\n<li><p>nodeName : 节点的名称</p></li>\n<li><p>nodeValue ：节点的值</p></li>\n<li><p>nodeType ：节点的类型</p></li>\n</ul>\n\n<p><strong>一、nodeName 属性:</strong></p>\n\n<p>节点的名称，是只读的。</p>\n\n<ul>\n<li>元素节点的 nodeName 与标签名相同</li>\n<li>属性节点的 nodeName 是属性的名称</li>\n<li>文本节点的 nodeName 永远是 #text</li>\n<li>文档节点的 nodeName 永远是 #document</li>\n</ul>\n\n<p><strong>二、nodeValue 属性：节点的值</strong></p>\n\n<ul>\n<li>元素节点的 nodeValue 是 undefined 或 null</li>\n<li>文本节点的 nodeValue 是文本自身</li>\n<li>属性节点的 nodeValue 是属性的值</li>\n</ul>\n\n<p><strong>三、nodeType 属性:</strong></p>\n\n<p>节点的类型，是只读的。以下常用的几种结点类型</p>\n\n<table>\n<thead>\n<tr>\n  <th>元素类似</th>\n  <th>节点类型</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td>元素</td>\n  <td>1</td>\n</tr>\n<tr>\n  <td>属性</td>\n  <td>2</td>\n</tr>\n<tr>\n  <td>文本</td>\n  <td>3</td>\n</tr>\n<tr>\n  <td>注释</td>\n  <td>8</td>\n</tr>\n<tr>\n  <td>文档</td>\n  <td>9</td>\n</tr>\n</tbody></table>\n\n\n<hr>\n\n\n\n<h3 id="访问子结点childnodes">访问子结点childNodes</h3>\n\n<p>访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">elementNode<span class="hljs-preprocessor">.childNodes</span></code></pre>\n\n<p><em>注意：</em></p>\n\n<p>如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。</p>\n\n<hr>\n\n\n\n<h3 id="访问子结点的第一和最后项">访问子结点的第一和最后项</h3>\n\n<p><strong>一、firstChild</strong> <br>\n属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">node<span class="hljs-preprocessor">.firstChild</span></code></pre>\n\n<p><em>说明：</em> <br>\n与elementNode.childNodes[0]是同样的效果。 </p>\n\n<p><strong>二、 lastChild</strong> </p>\n\n<p>属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">node<span class="hljs-preprocessor">.lastChild</span>\n</code></pre>\n\n<p><em>说明：</em></p>\n\n<p>与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 </p>\n\n<hr>\n\n\n\n<h3 id="访问父节点parentnode">访问父节点parentNode</h3>\n\n<p>获取指定节点的父节点 <br>\n<em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">elementNode<span class="hljs-preprocessor">.parentNode</span></code></pre>\n\n<p><em>注意:</em> <br>\n父节点只能有一个。</p>\n\n<p>看看下面的例子,获取 P 节点的父节点，代码如下:</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"text"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">p</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"con"</span>&gt;</span> parentNode 获取指点节点的父节点<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span> \n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> mynode= document.getElementById(<span class="hljs-string">"con"</span>);\n  document.write(mynode.parentNode.nodeName);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p><em>运行结果:</em> <br>\nparentNode 获取指点节点的父节点 <br>\nDIV</p>\n\n<hr>\n\n\n\n<h3 id="访问兄弟节点">访问兄弟节点</h3>\n\n<p><strong>1. nextSibling</strong> 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">nodeObject<span class="hljs-preprocessor">.nextSibling</span></code></pre>\n\n<p><em>说明：</em>如果无此节点，则该属性返回 null。</p>\n\n<p><strong>2. previousSibling</strong> 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">nodeObject<span class="hljs-preprocessor">.previousSibling</span> </code></pre>\n\n<p><em>说明：</em>如果无此节点，则该属性返回 null。</p>\n\n<hr>\n\n\n\n<h3 id="插入节点appendchild">插入节点appendChild()</h3>\n\n<p>在指定节点的最后一个子节点列表之后添加一个新的子节点。</p>\n\n<p><em>语法:</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs erlang"><span class="hljs-function"><span class="hljs-title">appendChild</span><span class="hljs-params">(newnode)</span></span></code></pre>\n\n<p><em>参数:</em> <br>\nnewnode：指定追加的节点 <br>\n <em>例子：</em> <br>\n<img src="http://img.mukewang.com/5398fd020001ad4905890193.jpg" alt="" title=""></p>\n\n<p><em>运行结果:</em></p>\n\n<blockquote>\n  <p>HTML <br>\n  JavaScript <br>\n  This is a new p</p>\n</blockquote>\n\n\n\n<h3 id="插入节点insertbefore">插入节点insertBefore()</h3>\n\n<p>insertBefore() 方法可在已有的子节点前插入一个新的子节点。</p>\n\n<p><em>语法:</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">insertBefore(newnode,node)</span>;</code></pre>\n\n<p><em>参数:</em></p>\n\n<p>newnode: 要插入的新节点。 <br>\nnode: 指定此节点前插入节点。</p>\n\n\n\n<h3 id="删除节点removechild">删除节点removeChild()</h3>\n\n<p>removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。</p>\n\n<p><em>语法:</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">nodeObject<span class="hljs-preprocessor">.removeChild</span>(node)\n</code></pre>\n\n<p><em>参数:</em> <br>\nnode ：必需，指定需要删除的节点。</p>\n\n<p>我们来看看下面代码，删除子点。</p>\n\n<p><img src="http://img.mukewang.com/5399744d000153a306060342.jpg" alt="" title=""></p>\n\n<p><em>运行结果:</em></p>\n\n<blockquote>\n  <p>HTML</p>\n</blockquote>\n\n<hr>\n\n\n\n<h3 id="删除节点的内容-javascript">删除节点的内容: javascript</h3>\n\n<p>替换元素节点replaceChild() <br>\nreplaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 </p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">node<span class="hljs-preprocessor">.replaceChild</span> (newnode,oldnew )</code></pre>\n\n<p><em>参数：</em></p>\n\n<p>newnode : 必需，用于替换 oldnew 的对象。  <br>\noldnew : 必需，被 newnode 替换的对象。</p>\n\n<hr>\n\n\n\n<h3 id="创建元素节点createelement">创建元素节点createElement</h3>\n\n<p>createElement()方法可创建元素节点。此方法可返回一个 Element 对象。</p>\n\n<p><strong>语法：</strong></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">document<span class="hljs-preprocessor">.createElement</span>(tagName)</code></pre>\n\n<p><strong>参数:</strong> <br>\ntagName：字符串值，这个字符串用来指明创建元素的类型。</p>\n\n<p>注意：要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。</p>\n\n<p>我们来创建一个按钮，代码如下：</p>\n\n\n   var body = document.body; \n   var input = document.createElement("input");  \n   input.type = "button";  \n   input.value = "创建一个按钮";  \n   body.appendChild(input);  \n \n\n<p>效果：在HTML文档中，创建一个按钮。</p>\n\n<hr>\n\n\n\n<h3 id="创建文本节点createtextnode">创建文本节点createTextNode</h3>\n\n<p>createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。</p>\n\n<p><strong>语法：</strong></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-title">document</span>.createTextNode(<span class="hljs-typedef"><span class="hljs-keyword">data</span>)</span></code></pre>\n\n<p><strong>参数：</strong></p>\n\n<p>data : 字符串值，可规定此节点的文本。 <br>\n我们来创建一个</p><div>元素并向其中添加一条消息，代码如下</div><p></p>\n\n<p><img src="http://img.mukewang.com/53951c200001d32d07130554.jpg" alt="" title=""></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:42 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52987673', 'title': 'javascript入门笔记7-计时器', 'readNum': '22665', 'commentNum': '0', 'publishTime': '2016-10-31 22:15:22', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h2 id="计时器">计时器</h2>\n\n<p><em>语法</em>：</p>\n\n<blockquote>\n  <p>setInterval(代码，交互时间)</p>\n</blockquote>\n\n<p><em>参数说明：</em></p>\n\n<blockquote>\n  <ol>\n  <li><p>代码：要调用的函数或要执行的代码串。</p></li>\n  <li><p>交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。</p></li>\n  </ol>\n</blockquote>\n\n<p><em>例子：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>定时器<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> attime;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clock</span><span class="hljs-params">()</span>{</span>\n    <span class="hljs-keyword">var</span> time=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();          \n    attime=  time.getHours()+<span class="hljs-string">\':\'</span>+time.getMinutes()+<span class="hljs-string">\':\'</span>+time.getSeconds();;\n    document.getElementById(<span class="hljs-string">"clock"</span>).value = attime;\n  }\n  <span class="hljs-keyword">var</span> timer = setInterval(clock,<span class="hljs-number">1000</span>);\n\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"clock"</span> <span class="hljs-attribute">size</span>=<span class="hljs-value">"50"</span>  /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>\n</code></pre>\n\n\n\n<h2 id="取消计时器">取消计时器</h2>\n\n<p><em>语法：</em></p>\n\n<blockquote>\n  <p>clearInterval(id_of_setInterval)</p>\n</blockquote>\n\n<p><em>参数说明：</em></p>\n\n<blockquote>\n  <p>id_of_setInterval：由 setInterval() 返回的 ID 值。</p>\n</blockquote>\n\n<p><em>任务：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>计时器<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clock</span><span class="hljs-params">()</span>{</span>\n      <span class="hljs-keyword">var</span> time=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();                    \n      document.getElementById(<span class="hljs-string">"clock"</span>).value = time;\n   }\n    <span class="hljs-keyword">var</span> i=setInterval(<span class="hljs-string">"clock()"</span>,<span class="hljs-number">100</span>);\n\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"clock"</span> <span class="hljs-attribute">size</span>=<span class="hljs-value">"50"</span>  /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"Stop"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"clearInterval(i)"</span>  /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>\n</code></pre>\n\n\n\n<h2 id="延时计时器-settimeout">延时计时器 setTimeout()</h2>\n\n<p>setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。</p>\n\n<p><em>语法：</em></p>\n\n<blockquote>\n  <p>setTimeout(代码,延迟时间);</p>\n</blockquote>\n\n<p><em>例子：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tinfo</span><span class="hljs-params">()</span>{</span>\n  <span class="hljs-keyword">var</span> t=setTimeout(<span class="hljs-string">"alert(\'Hello!\')"</span>,<span class="hljs-number">5000</span>);\n }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"start"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">"tinfo()"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>\n</code></pre>\n\n<blockquote>\n  <p>要创建一个运行于无穷循环中的计数器，我们需要编写一个函数来调用其自身。在下面的代码，当按钮被点击后，输入域便从0开始计数。</p>\n</blockquote>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">var</span> num=<span class="hljs-number">0</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numCount</span><span class="hljs-params">()</span>{</span>\n document.getElementById(<span class="hljs-string">\'txt\'</span>).value=num;\n num=num+<span class="hljs-number">1</span>;\n setTimeout(<span class="hljs-string">"numCount()"</span>,<span class="hljs-number">1000</span>);\n }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"txt"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"Start"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">"numCount()"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n\n\n<h2 id="取消计时器cleartimeout">取消计时器clearTimeout()</h2>\n\n<p><em>语法：</em></p>\n\n<blockquote>\n  <p>clearTimeout(id_of_setTimeout)</p>\n</blockquote>\n\n<p><em>参数说明：</em></p>\n\n<blockquote>\n  <p>id_of_setTimeout：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。</p>\n</blockquote>\n\n<p><em>列子</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> num=<span class="hljs-number">0</span>,i;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timedCount</span><span class="hljs-params">()</span>{</span>\n    document.getElementById(<span class="hljs-string">\'txt\'</span>).value=num;\n    num=num+<span class="hljs-number">1</span>;\n    i=setTimeout(timedCount,<span class="hljs-number">1000</span>);\n  }\n    setTimeout(timedCount,<span class="hljs-number">1000</span>);\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopCount</span><span class="hljs-params">()</span>{</span>\n    clearTimeout(i);\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"txt"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"Stop"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">"stopCount()"</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:42'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52987687', 'title': 'javascript入门笔记8-window对象', 'readNum': '22688', 'commentNum': '0', 'publishTime': '2016-10-31 22:16:14', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h2 id="history-对象">History 对象</h2>\n\n<p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。</p>\n\n<blockquote>\n  <p>注意:从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。</p>\n</blockquote>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">window</span><span class="hljs-class">.history</span>.<span class="hljs-attr_selector">[属性|方法]</span></code></pre>\n\n<p><em>History 对象属性</em></p>\n\n<table>\n<thead>\n<tr>\n  <th>属性</th>\n  <th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td>length</td>\n  <td>返回浏览器历史列表的URL数量</td>\n</tr>\n</tbody></table>\n\n\n<p><em>History 对象方法</em></p>\n\n<table>\n<thead>\n<tr>\n  <th>方法</th>\n  <th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td>back()</td>\n  <td>加载history前一个url</td>\n</tr>\n<tr>\n  <td>forward()</td>\n  <td>加载history下一个url</td>\n</tr>\n<tr>\n  <td>go()</td>\n  <td>加载history某一个url</td>\n</tr>\n</tbody></table>\n\n\n<p>例子</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> HL = window.history.length;\n  document.write(HL);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n\n\n<h3 id="返回前一个页面">返回前一个页面：</h3>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">window<span class="hljs-preprocessor">.history</span><span class="hljs-preprocessor">.back</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p><em>或者</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">window<span class="hljs-preprocessor">.history</span><span class="hljs-preprocessor">.go</span>(-<span class="hljs-number">1</span>)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<h3 id="返回下一个浏览的页面">返回下一个浏览的页面</h3>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">window<span class="hljs-preprocessor">.history</span><span class="hljs-preprocessor">.forward</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p><em>或者</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">window<span class="hljs-preprocessor">.history</span><span class="hljs-preprocessor">.go</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span></code></pre>\n\n<p></p>\n\n\n\n<h2 id="location对象">Location对象</h2>\n\n<p>location用于获取或设置窗体的URL，并且可以用于解析URL。 <br>\n<em>语法</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">location</span>.<span class="hljs-attr_selector">[属性|方法]</span>\n</code></pre>\n\n<p>location 对象属性：</p>\n\n<p><img src="http://img.mukewang.com/5354b1d00001c4ec06220271.jpg" alt="" title=""></p>\n\n<p>location 对象方法:</p>\n\n<p><img src="http://img.mukewang.com/5354b1eb00016a2405170126.jpg" alt="" title=""></p>\n\n\n\n<h2 id="navigator对象">Navigator对象</h2>\n\n<p><em>对象属性</em></p>\n\n<p><img src="http://img.mukewang.com/5354cff70001428b06880190.jpg" alt="" title=""></p>\n\n<p>示例：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n   <span class="hljs-keyword">var</span> browser=navigator.appName;\n   <span class="hljs-keyword">var</span> b_version=navigator.appVersion;\n   document.write(<span class="hljs-string">"Browser name"</span>+browser);\n   document.write(<span class="hljs-string">"&lt;br&gt;"</span>);\n   document.write(<span class="hljs-string">"Browser version"</span>+b_version);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n\n\n<h2 id="screen对象">screen对象</h2>\n\n<p>screen对象用于获取用户的屏幕信息。</p>\n\n<p><em>语法：</em></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">window<span class="hljs-preprocessor">.screen</span>.属性</code></pre>\n\n<p><em>d对象属性</em> <br>\n<img src="http://img.mukewang.com/5354d2810001a47706210213.jpg" alt="" title=""></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52973368', 'title': '一篇RxJava友好的文章（二）', 'readNum': '23575', 'commentNum': '3', 'publishTime': '2016-10-30 18:33:53', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>上一篇文章介绍了rxjava的基本用法，和一些常用的操作符，以及rxjava的链式操作带来的好处。由于rxjava非常的强大，让我如此的痴迷，我打算写五篇文章，专门讲解rxjava 常见的操作符和用法，敬请期待。这篇文章主要讲解过滤操作符。</p>\n<h3><a id="1distinct_2"></a>1.distinct操作符</h3>\n<p>过滤掉重复的数据项，只让还没有发送过数据项通过。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123419312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>  \n rx.Observable.just("1","2","2","3","4")\n   .distinct(new Func1&lt;String, String&gt;() {\n            @Override\n            public String call(String s) {\n                return "key"+s;//这时候比较的是key+s  而不是比较s\n            }\n        })\n    .subscribe(new Action1&lt;String&gt;() {\n            @Override\n            public void call(String s) {\n                Log.e(TAG,s);\n            }\n        });\n    }\n</code></pre>\n<p><em>运行程序，输出结果 ：</em></p>\n<blockquote>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n</blockquote>\n<p>它的作用是去掉相同的元素，例如例子中去掉了2</p>\n<h3><a id="2ElementAt_39"></a>2.ElementAt</h3>\n<p>只发射第n项数据</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123434638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>   rx.Observable.just("1","2","3")\n   .elementAt(1)\n   .subscribe(new Action1&lt;String&gt;() {//只发射第二个元素\n            @Override\n            public void call(String s) {\n                Log.e(TAG,s);\n            }\n        });\n\n        rx.Observable.just("1","2","3")\n        .elementAtOrDefault(11,"11111")\n        .subscribe(new Action1&lt;String&gt;() {//只发射第二个元素\n            @Override\n            public void call(String s) {\n                Log.e(TAG,s);\n            }\n        });       \n                            \n</code></pre>\n<p><em>运行结果：</em></p>\n<blockquote>\n<p>2</p>\n<p>11111</p>\n</blockquote>\n<p>elemntAt(1)发射第二项数据；elementAtOrDefault(11,“11111”)，由于observable没有11找个索引元素，所以发送了默认的11111</p>\n<h3><a id="3first_74"></a>3.first操作符</h3>\n<p>只发射第一项数据或者满足条件的第一项数据，如果你需要第一项数据，或者满足条件的第一项数据，可以使用该操作符</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123449535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>rx.Observable.just("1","2","3")\n  .first()\n  .subscribe(new Action1&lt;String&gt;() {\n            @Override\n            public void call(String s) {\n                Log.e(TAG,s);\n            }\n        });\n\nrx.Observable.just(1,2,3)\n   .first(new Func1&lt;Integer, Boolean&gt;() {\n          @Override\n        public Boolean call(Integer integer) {\n           if(integer&gt;2) return true;\n              return false;\n          }\n        })\n    .subscribe(new Action1&lt;Integer&gt;() {\n        @Override\n        public void call(Integer integer) {\n             Log.e(TAG,integer+"");\n          }\n      }); \n</code></pre>\n<p><em>运行结果：</em></p>\n<blockquote>\n<p>1</p>\n<p>3</p>\n</blockquote>\n<h3><a id="4last__112"></a>4.last 操作符</h3>\n<p>last只发射最后一项数据，和first 正好相反。</p>\n<pre><code>rx.Observable.just(1,2,3,4)\n.last().subscribe(new Action1&lt;Integer&gt;() {\n            @Override\n            public void call(Integer integer) {\n                Log.e(TAG,integer+"");\n            }\n        });\n</code></pre>\n<p>允许结果：</p>\n<blockquote>\n<p>4</p>\n</blockquote>\n<h3><a id="5sample_130"></a>5.sample操作符</h3>\n<p>定期采样并发射 observable 最近的数据</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123506246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>rx.Observable.interval(300, TimeUnit.MILLISECONDS)\n   .sample(2,TimeUnit.SECONDS)\n   .subscribe(new Action1&lt;Long&gt;() {\n            @Override\n            public void call(Long aLong) {\n                Log.e(TAG,aLong+"");\n            }\n        });\n\n</code></pre>\n<p><em>运行结果：</em></p>\n<blockquote>\n<p>6</p>\n<p>13</p>\n<p>…</p>\n</blockquote>\n<p>observal 每300ms发射一个从0到n的数据，sample 每隔2s取一个observal 最近发射的数据，并发射出去。</p>\n<h3><a id="6skip_157"></a>6.skip操作符</h3>\n<p>跳过前n项数据，也就说不发射前n项数据。</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123521767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<pre><code>rx.Observable.just(1,2,4,5,6)\n    .skip(2)\n    .subscribe(new Action1&lt;Integer&gt;() {\n            @Override\n            public void call(Integer integer) {\n                Log.e(TAG,integer+"");\n            }\n        });\n\n</code></pre>\n<p><em>运行结果:</em></p>\n<blockquote>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n</blockquote>\n<p>前面2项数据跳过不发射。</p>\n<p>所有的过滤操作符：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123551975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p>好了，今天的讲解了过滤操作符，写了这篇文章相信你很快就会理解。<br>\n过滤操作符不止这些，另外还有很多其他的过滤操作符，需要你们自己一个一个的摸索了。感谢大家，如果觉得可以点个赞吧，哈哈……<br>\n<sup>_</sup></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52953632', 'title': 'Android 最新学习资料收集', 'readNum': '23424', 'commentNum': '0', 'publishTime': '2016-10-28 09:50:31', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>收集这份资料的灵感来源于我的浏览器收藏夹快爆了，后来在github 上也看到了很优秀的开源库的收集资料，非常的好，但是太过于多，也不够新，所以决定自己来做一个。原始的markdowm文件已经放到github上，欢迎<a href="https://github.com/forezp/AndroidMaterialLatest">下载和star</a> 。这份资料我会不断的完善，也欢迎一些经验丰富的开发者可以一起来完善，直接<a href="https://github.com/forezp/AndroidMaterialLatest/pulls">pull request</a> 或者<a href="https://github.com/forezp/AndroidMaterialLatest/issues">issue</a>，我会定期筛选合并，有一些好的建议和意见随时<a href="#%E8%81%94%E7%B3%BB%E6%88%91" rel="nofollow">联系我</a>，欢迎转载，谢谢收藏。</p>\n\n<h2 id="目录">目录</h2>\n\n<ul>\n<li><a href="#%E5%AE%89%E5%8D%93%E6%B5%81%E8%A1%8C%E6%A1%86%E6%9E%B6%E6%8E%A8%E8%8D%90" rel="nofollow">安卓流行框架</a></li>\n<li><a href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99" rel="nofollow">常用网站</a></li>\n<li><a href="#%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90" rel="nofollow">博客推荐</a></li>\n<li><a href="#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E8%8D%90" rel="nofollow">微信公众号推荐</a></li>\n<li><a href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90" rel="nofollow">书籍推荐</a></li>\n<li><a href="#RxJava%E7%B3%BB%E5%88%97" rel="nofollow">RxJava系列</a></li>\n<li><a href="#retrofi%E7%B3%BB%E5%88%97" rel="nofollow">retrofi系列</a></li>\n<li><a href="#MVP%E7%B3%BB%E5%88%97" rel="nofollow">MVP系列</a></li>\n<li><a href="#MaterialDesign%E7%B3%BB%E5%88%97" rel="nofollow">MaterialDesign系列</a></li>\n<li><a href="#MVP-retrofit-rxjava-materialDesign%E7%B3%BB%E5%88%97" rel="nofollow">MVP-retrofit-rxjava-materialDesign系列</a></li>\n<li><a href="#Kotlin%E7%B3%BB%E5%88%97" rel="nofollow">Kotlin系列</a></li>\n<li><a href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0" rel="nofollow">开源项目学习</a></li>\n<li><a href="#%E5%BC%80%E6%BA%90%E5%BA%93%E6%94%B6%E9%9B%86" rel="nofollow">开源库收集</a></li>\n<li><a href="#Android%E5%BC%80%E5%8F%91%E8%80%85%E6%9D%82%E5%BF%97%E5%91%A8%E5%88%8A" rel="nofollow">Android开发者杂志周刊</a></li>\n<li><a href="#%E5%B7%A5%E5%85%B7" rel="nofollow">工具</a></li>\n<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" rel="nofollow">开发环境</a></li>\n<li><a href="#%E7%B4%A0%E6%9D%90" rel="nofollow">素材</a></li>\n<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" rel="nofollow">设计模式</a></li>\n<li><a href="#%E6%96%87%E6%A1%A3" rel="nofollow">文档</a></li>\n<li><a href="#%E6%84%9F%E8%B0%A2" rel="nofollow">感谢</a></li>\n<li><a href="#%E8%81%94%E7%B3%BB%E6%88%91" rel="nofollow">联系我</a></li>\n</ul>\n\n<p>=========================================================</p>\n\n\n\n<h2 id="安卓流行框架">安卓流行框架</h2>\n\n<table>\n<thead>\n<tr>\n  <th>分类</th>\n  <th>框架名称</th>\n  <th>推荐理由</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td>缓存</td>\n  <td><a href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a></td>\n  <td>DiskLruCache ，JakeWharton开源，缓存神器</td>\n</tr>\n<tr>\n  <td>图片加载</td>\n  <td><a href="https://github.com/bumptech/glide">Glide</a></td>\n  <td>可播放gif，谷歌推荐的图片加载</td>\n</tr>\n<tr>\n  <td>图片加载</td>\n  <td><a href="https://github.com/facebook/fresco">Fresco</a></td>\n  <td>可播放gif，流畅性最好的加载框架，Facebook 出品</td>\n</tr>\n<tr>\n  <td>图片加载</td>\n  <td><a href="https://github.com/square/picasso">Picasso</a></td>\n  <td>squre inc.开源的图片加载框架。</td>\n</tr>\n<tr>\n  <td>图片处理</td>\n  <td><a href="https://github.com/wasabeef/picasso-transformations">Picasso—transformations</a></td>\n  <td>图片处理框架。</td>\n</tr>\n<tr>\n  <td>图片处理</td>\n  <td><a href="https://github.com/wasabeef/glide-transformations">Glide—transformations</a></td>\n  <td>图片处理框架。</td>\n</tr>\n<tr>\n  <td>网络请求</td>\n  <td><a href="https://github.com/square/okhttp">Okhttp</a></td>\n  <td>非常强大的一个网络请求框架。</td>\n</tr>\n<tr>\n  <td>网络请求</td>\n  <td><a href="https://github.com/square/retrofit">Retrofit</a></td>\n  <td>基于okhttp ,squire出品，必属精品。。</td>\n</tr>\n<tr>\n  <td>网络请求</td>\n  <td><a href="https://github.com/mcxiaoke/android-volley">volley</a></td>\n  <td>谷歌之前出品的网络框架。</td>\n</tr>\n<tr>\n  <td>数据解析</td>\n  <td><a href="https://github.com/google/gson">Gson</a></td>\n  <td>非常好用的JSOn解析。</td>\n</tr>\n<tr>\n  <td>数据解析</td>\n  <td><a href="https://github.com/FasterXML/jackson">jackson</a></td>\n  <td>这个也不错。</td>\n</tr>\n<tr>\n  <td>数据库</td>\n  <td><a href="https://github.com/greenrobot/greenDAO">greendao</a></td>\n  <td>一个轻量、效率快的数据库。</td>\n</tr>\n<tr>\n  <td>数据库</td>\n  <td><a href="https://github.com/realm/realm-java">realm</a></td>\n  <td>好用，替代sqlite。</td>\n</tr>\n<tr>\n  <td>数据库</td>\n  <td><a href="https://github.com/satyan/sugar">Sugar</a></td>\n  <td>另外一个好用的数据库，个人推荐GreenDao。</td>\n</tr>\n<tr>\n  <td>依赖注入</td>\n  <td><a href="https://github.com/JakeWharton/butterknife">ButterKnife</a></td>\n  <td>注解，让你的代码整洁，配合ButterKnife Zelezny，一键生成注解。</td>\n</tr>\n<tr>\n  <td>图表</td>\n  <td><a href="https://github.com/diogobernardino/WilliamChart">WilliamChart</a></td>\n  <td>强大的图标库。</td>\n</tr>\n<tr>\n  <td>图表</td>\n  <td><a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a></td>\n  <td>强大的图标库。</td>\n</tr>\n<tr>\n  <td>事件总线</td>\n  <td><a href="https://github.com/greenrobot/EventBus">EventBus</a></td>\n  <td>一个简单移动的事件总线。</td>\n</tr>\n<tr>\n  <td>事件总线</td>\n  <td><a href="https://github.com/square/otto">otto</a></td>\n  <td>另一个简单移动的事件总线。</td>\n</tr>\n<tr>\n  <td>响应式</td>\n  <td><a href="https://github.com/ReactiveX/RxJava">RXjava</a></td>\n  <td>响应式编程 ，功能强大，值得学习。</td>\n</tr>\n<tr>\n  <td>响应式</td>\n  <td><a href="https://github.com/ReactiveX/RxAndroid">RXAndroid</a></td>\n  <td>响应式编程 ，功能强大，值得学习。。</td>\n</tr>\n<tr>\n  <td>响应式</td>\n  <td><a href="https://github.com/JakeWharton/RxBinding">RXBinding</a></td>\n  <td>响应式编程 ，功能强大，值得学习。。</td>\n</tr>\n<tr>\n  <td>Log</td>\n  <td><a href="https://github.com/orhanobut/logger">logger</a></td>\n  <td>一个logger框架。</td>\n</tr>\n<tr>\n  <td>Log</td>\n  <td><a href="https://github.com/spf13/hugo">Hugo</a></td>\n  <td>一个logger框架。</td>\n</tr>\n<tr>\n  <td>Log</td>\n  <td><a href="https://github.com/JakeWharton/timber">Timber</a></td>\n  <td>一个logger框架。</td>\n</tr>\n<tr>\n  <td>测试框架</td>\n  <td><a href="https://github.com/mockito/mockito">mockito</a></td>\n  <td>一个强大的用于 Java 开发的模拟测试框架。</td>\n</tr>\n<tr>\n  <td>测试框架</td>\n  <td><a href="https://github.com/RobotiumTech/robotium">robotium</a></td>\n  <td>是一款国外的Android自动化测试框架。</td>\n</tr>\n<tr>\n  <td>调试框架</td>\n  <td><a href="https://github.com/facebook/stetho">stetho</a></td>\n  <td>facebook的Android调试工具Stetho。</td>\n</tr>\n<tr>\n  <td>性能优化</td>\n  <td><a href="https://github.com/square/leakcanary">leakcanary</a></td>\n  <td>一个检查内存泄露的插件，非常的强大。</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="常用网站">常用网站</h2>\n\n<table>\n<thead>\n<tr>\n  <th>网站名称</th>\n  <th>推荐理由</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="google.com" rel="nofollow">Google</a></td>\n  <td>google搜索，让信息传遍世界</td>\n</tr>\n<tr>\n  <td><a href="http://www.github.com/" rel="nofollow">Github</a></td>\n  <td>面向世界的代码托管平台，在GitHub，你可以十分轻易地找到海量的开源代码</td>\n</tr>\n<tr>\n  <td><a href="http://stackoverflow.com/" rel="nofollow">StackOverFlow</a></td>\n  <td>一个与程序相关的IT技术问答网站</td>\n</tr>\n<tr>\n  <td><a href="https://segmentfault.com/t/android" rel="nofollow">SegmentFault</a></td>\n  <td>中文的开发者社区及媒体,中国的StackOverFlow</td>\n</tr>\n<tr>\n  <td><a href="http://www.oschina.net/" rel="nofollow">开源中国</a></td>\n  <td>开源中国社区</td>\n</tr>\n<tr>\n  <td><a href="http://developer.android.com/" rel="nofollow">安卓开发社区</a></td>\n  <td>安卓官网</td>\n</tr>\n<tr>\n  <td><a href="http://gold.xitu.io/" rel="nofollow">掘金</a></td>\n  <td>掘金，号称中国质量最高的技术分享社区</td>\n</tr>\n<tr>\n  <td><a href="http://www.csdn.net/">csdn</a></td>\n  <td>CSDN，全球最大的中文IT技术社区</td>\n</tr>\n<tr>\n  <td><a href="http://www.csdn.net/">泡在网上的日子</a></td>\n  <td>泡在网上的日子，一个正对移动开发的技术分享论坛。</td>\n</tr>\n<tr>\n  <td><a href="http://gank.io/" rel="nofollow">干货集中营</a></td>\n  <td>干货集中营，每日分享。</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="博客推荐">博客推荐</h2>\n\n<table>\n<thead>\n<tr>\n  <th>博客地址</th>\n  <th>博主信息</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="http://android-developers.blogspot.com/" rel="nofollow">Android Developers Blog</a></td>\n  <td>Android官网博客 ，有Android 的最新资讯，要翻墙。</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/guolin_blog">郭霖</a></td>\n  <td>博主郭霖是大神, 人人都称”郭神”, 是第一行代码的作者, 博主在 CSDN 上所写的文章都非常值得学习</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/lmj623565791/">张鸿洋</a></td>\n  <td>张鴻洋是 CSDN 博客专家, “洋神”, 他的每一篇博客都很值得大家去学习</td>\n</tr>\n<tr>\n  <td><a href="http://blog.daimajia.com/" rel="nofollow">代码家</a></td>\n  <td>Android 大神, 博主收集了很多 Android 开源库, 博主自己也做了很多开源库, 非常值得学习，另外是<a href="gank.io" rel="nofollow">gank.io</a>的组织者。</td>\n</tr>\n<tr>\n  <td><a href="http://www.trinea.cn/" rel="nofollow">Trinea</a></td>\n  <td>目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库<a href="https://github.com/Trinea">上面</a>都有,并且有源码解析，大家可以去关注一下, <a href="http://p.codekk.com" rel="nofollow">地址</a> .</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/xyz_lmn">张兴业</a></td>\n  <td>张兴业同样也是 CSDN 博客专家</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/lzyzsd/">大头鬼</a></td>\n  <td>hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 写了一系列RXJava 资料。</td>\n</tr>\n<tr>\n  <td><a href="http://over140.cnblogs.com/" rel="nofollow">农民伯伯</a></td>\n  <td>资深博客写手，他的博客非常值得一看。</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/singwhatiwanna">任玉刚</a></td>\n  <td>《安卓开发艺术探索》作者。</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/Luoshengyang">罗升阳</a></td>\n  <td>CSDN博客专家，《安卓系统源代码情景分析》。</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="微信公众号推荐">微信公众号推荐</h2>\n\n<table>\n<thead>\n<tr>\n  <th>微信公众号ID</th>\n  <th>博主信息</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td>guolin_blog</td>\n  <td>郭霖的公众号，有每日推荐文章，《第一行代码》作者。</td>\n</tr>\n<tr>\n  <td>hongyangAndroid</td>\n  <td>张鸿洋的公众号。有每日推荐文字，Csdn博客专家。</td>\n</tr>\n<tr>\n  <td>AndroidDeveloper</td>\n  <td>他是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 <a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" rel="nofollow">Android学习之路</a> 帮助了无数人, 里面还有很多好的文章非常适合新手入门,</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="书籍推荐">书籍推荐</h2>\n\n<table>\n<thead>\n<tr>\n  <th>书籍名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="https://book.douban.com/subject/25942191/" rel="nofollow">第一行代码</a></td>\n  <td>郭霖大杰作，适合新人</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/25762168/" rel="nofollow">Java核心技术 卷I</a></td>\n  <td>java入门书籍</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/3360807/" rel="nofollow">Effective Java</a></td>\n  <td>进阶书</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/10484692/" rel="nofollow">Java并发编程</a></td>\n  <td>Java并发编程</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/26274206/" rel="nofollow">给大忙人看的Java8</a></td>\n  <td>给大忙人看的Java8</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/1723199/" rel="nofollow">Thinking In Java 中文版</a></td>\n  <td>学习Java 语言必备书籍</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/26599539/" rel="nofollow">Android群英传</a></td>\n  <td>本书作者 @Tomcat 的猫。</td>\n</tr>\n<tr>\n  <td><a href="http://product.china-pub.com/4806147" rel="nofollow">Android开发艺术探索</a></td>\n  <td>由任玉刚所著.</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/24722612/" rel="nofollow">深入理解Java虚拟机</a></td>\n  <td>不是很难 ，需要看看</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/4889838/" rel="nofollow">鸟哥的Linux私房菜</a></td>\n  <td>太经典。</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/25863515/" rel="nofollow">图解Http</a></td>\n  <td>让你很快上手http。</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/2243615/" rel="nofollow">Head First设计模式</a></td>\n  <td>Head First设计模式</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/5387402/" rel="nofollow">程序员修炼之道</a></td>\n  <td>程序员修炼之道</td>\n</tr>\n<tr>\n  <td><a href="http://iissnan.com/progit/html/zh/ch1_0.html" rel="nofollow">Git权威指南中文手册</a></td>\n  <td>Git权威指南中文手册</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/1139426/" rel="nofollow">数据结构与算法基础</a></td>\n  <td>数据结构和算法的书，比较全</td>\n</tr>\n<tr>\n  <td><a href="https://book.douban.com/subject/2228378/" rel="nofollow">JavaScript权威指南</a></td>\n  <td>JavaScript权威指南，学习js一本书差不多了</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="rxjava系列">RxJava系列</h2>\n\n<table>\n<thead>\n<tr>\n  <th>名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" rel="nofollow">ReactiveX/RxJava文档中文版</a></td>\n  <td>大神们在百忙之中翻译的文档，感谢开源。</td>\n</tr>\n<tr>\n  <td><a href="http://reactivex.io/RxJava/javadoc/" rel="nofollow">ReactiveX/RxJava官方API</a></td>\n  <td>ReactiveX/RxJava官方API</td>\n</tr>\n<tr>\n  <td><a href="http://gank.io/post/560e15be2dca930e00da1083" rel="nofollow">给 Android 开发者的 RxJava 详解</a></td>\n  <td>给 Android 开发者的 RxJava 详解 ,作者：扔物线</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/lzyzsd/article/details/41833541/">深入浅出RxJava</a></td>\n  <td>大头鬼写的Rxjava 系列</td>\n</tr>\n<tr>\n  <td><a href="http://www.apkbus.com/forum.php?mod=viewthread&amp;tid=257703&amp;extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline&amp;_dsign=43e9b95f" rel="nofollow">老罗Rxjava视频</a></td>\n  <td>老罗Rxjava视频</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="retrofi系列">retrofi系列</h2>\n\n<table>\n<thead>\n<tr>\n  <th>名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="http://square.github.io/retrofit/" rel="nofollow">官方文档</a></td>\n  <td>squire出品，必属精品。</td>\n</tr>\n<tr>\n  <td><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html" rel="nofollow">Retrofit 2.0：有史以来最大的改进</a></td>\n  <td>泡在网上的日子，翻译。</td>\n</tr>\n<tr>\n  <td><a href="http://blog.csdn.net/ljd2038/article/details/51046512">Retrofit2.0使用详解</a></td>\n  <td>讲解了基本的使用方法</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="mvp系列">MVP系列</h2>\n\n<table>\n<thead>\n<tr>\n  <th>名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0227/2503.html" rel="nofollow">Android中的MVP</a></td>\n  <td>泡在网上的日子翻译。</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/googlesamples/android-architecture">google写的列子</a></td>\n  <td>google写的MvP例子。</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/android10/Android-CleanArchitecture">Android-CleanArchitecture</a></td>\n  <td>一个适合新人的MVP例子</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="materialdesign系列">MaterialDesign系列</h2>\n\n<table>\n<thead>\n<tr>\n  <th>名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><ul>\n<a href="https://www.google.com/design/spec/material-design/introduction.html" rel="nofollow">Material Design 教程</a>\n</ul></td>\n  <td>google官方提高的materail design 指导。</td>\n</tr>\n<tr>\n  <td><ul>\n<a href="https://github.com/1sters/material_design_zh_2">Material Design 教程(中文版)</a>\n</ul></td>\n  <td>翻译的中文文档。</td>\n</tr>\n<tr>\n  <td><ul>\n<a href="https://github.com/navasmdc/MaterialDesignLibrary">Material Design Android Library </a>(Material Design 开源库)\n</ul></td>\n  <td>一些非常优秀的material design 开源库。</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="mvp-retrofit-rxjava-materialdesign系列">MVP-retrofit-rxjava-materialDesign系列</h2>\n\n<table>\n<thead>\n<tr>\n  <th>名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="https://github.com/forezp/banya">瓣呀</a></td>\n  <td><a href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API仿网易音乐的开源项目（本人写的，欢迎star）</a></td>\n</tr>\n<tr>\n  <td><a href="https://github.com/Freelander/Elephant">大象</a></td>\n  <td>一个第三放PHPHUB客户端</td>\n</tr>\n<tr>\n  <td><a href="http://www.jianshu.com/p/8c3898eed1bb" rel="nofollow">开发资料</a></td>\n  <td>开发 Material Design+RxJava+Retrofit+MVP App 参考资料</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="kotlin系列">Kotlin系列</h2>\n\n<table>\n<thead>\n<tr>\n  <th>名称</th>\n  <th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="http://www.weibo.com/ttarticle/p/show?id=2309403942933815527259" rel="nofollow">kotlin 介绍</a></td>\n  <td>kotlin 介绍</td>\n</tr>\n<tr>\n  <td><a href="http://kotlinlang.org/" rel="nofollow">kotlin 官网</a></td>\n  <td>kotlin 官网，最新的资讯。</td>\n</tr>\n<tr>\n  <td><a href="https://www.zhihu.com/question/25289041" rel="nofollow">kotlin,网友对其评价</a></td>\n  <td>网友对其评价 ，很中肯。本人已经在学习，觉得如果熟练，开发速度大大提高，代码可读性也提高。</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="开源项目学习">开源项目学习</h2>\n\n<table>\n<thead>\n<tr>\n  <th>项目名称</th>\n  <th>项目简介</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="https://github.com/google/iosched">Google I/O 2014</a></td>\n  <td>Google I/O Android App 使用了当时最新推出的 Material Design 设计</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/googlesamples/android-UniversalMusicPlayer">Google play music</a></td>\n  <td>一个跨多个平台音乐播放器</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/pockethub/PocketHub">github客户端</a></td>\n  <td>开源者 github 团队, 支持项目的 lssues 和 Gists 并集成了新闻 feed 以便及时获取来自组织好友和资料库的更新信息, 还提供了一个用于快速访问你创建,监控以及发布 issue 面板, 可查看并将问题加到收藏夹</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/MiCode/Notes">MIUI 便签</a></td>\n  <td>MiCode 便签是小米便签的社区开源版, 由 MIUI 团队(ww.miui.com)发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议</td>\n</tr>\n<tr>\n  <td><a href="http://git.oschina.net/oschina/android-app" rel="nofollow">oschina</a></td>\n  <td>开源中国社区 Android 客户端, 此开源的是 v1 版本, v2 版本将在 2015 年年中开源</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/zxing/zxing">ZXing</a></td>\n  <td>二维码扫描工具,市场上许多应用的二维码扫描工具都是从这个修改得到的</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/drakeet/Meizhi">Meizhi</a></td>\n  <td>开发者是许晓峰(Drakeet), 该 app 是数据来自代码家干货网站 <a href="http://gank.io" rel="nofollow">gank.io</a>, 有很多开发者都纷纷为这网站做客户端 app, 因为代码家大神开放该网站的 Api, 更重要的是该网站每天除了有干货还有漂亮妹子看呢, 该 App 使用到的技术有 RxJava + Retrofit, 代码结构非常清晰, 值得一看的开源 App.</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/Curzibn/Luban">鲁班</a></td>\n  <td>Android图片压缩工具，仿微信朋友圈压缩策略,一个优秀的压缩图片框架</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/izzyleung/ZhihuDailyPurify">ZhihuDailyPurify </a></td>\n  <td>知乎日报·净化</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/forezp/banya">瓣呀</a></td>\n  <td><a href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API仿网易音乐的开源项目（本人写的，欢迎star）</a></td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="开源库收集">开源库收集</h2>\n\n<ul>\n<li><a href="https://github.com/wasabeef/awesome-android-ui">awesome-android-ui</a></li>\n<li><a href="https://github.com/wasabeef/awesome-android-libraries">awesome-android-libraries</a></li>\n<li><a href="http://www.jcodecraeer.com/plus/list.php?tid=31" rel="nofollow">泡在网上的日子</a></li>\n<li><a href="http://alamkanak.github.io/android-libraries-and-resources/" rel="nofollow">Android Libraries and Resources </a></li>\n<li><a href="http://android-arsenal.com/" rel="nofollow">Android Arsenal </a>(一个专门收集 android 开源库的网站, 网站经常更新)</li>\n<li><a href="https://github.com/Trinea/android-open-project">Android 开源项目汇总 </a>(Trinea 大神收集的)</li>\n<li><a href="http://codekk.com/open-source-project-analysis" rel="nofollow">Android 开源项目源码分析 </a>(在懂得使用这些开源项目同时, 也应该了解当中的原理)</li>\n<li><a href="http://www.apkbus.com/forum-417-1.html" rel="nofollow">安卓巴士</a></li>\n</ul>\n\n\n\n<h2 id="android开发者杂志周刊">Android开发者杂志周刊</h2>\n\n<table>\n<thead>\n<tr>\n  <th>周刊名</th>\n  <th>周刊简介</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="http://gank.io/" rel="nofollow">干货集中营</a></td>\n  <td>由 <a href="http://blog.daimajia.com/" rel="nofollow">代码家</a> 维护更新, 分享内容有漂亮妹子, Android 干货, iOS 干货, App, 技术以外推荐, 还有休息视频</td>\n</tr>\n<tr>\n  <td><a href="http://androidweekly.net/" rel="nofollow">Android Weekly</a></td>\n  <td>Android Weekly 是由Android 团队的成员和国外知名的 Android 开发者维护, 分享的都是干货。</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="工具">工具</h2>\n\n<table>\n<thead>\n<tr>\n  <th>工具名称</th>\n  <th>推荐理由</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="https://github.com/getlantern/lantern">蓝灯</a></td>\n  <td>Lantern ，免费翻墙神器</td>\n</tr>\n<tr>\n  <td><a href="http://www.bejson.com/" rel="nofollow">bejson</a></td>\n  <td>Json查看，Json生成实体</td>\n</tr>\n<tr>\n  <td><a href="http://tool.lu/sql/" rel="nofollow">sql</a></td>\n  <td>sql语句验证</td>\n</tr>\n<tr>\n  <td><a href="http://www.iconfont.cn/" rel="nofollow">矢量图</a></td>\n  <td>阿里巴巴的矢量图库</td>\n</tr>\n<tr>\n  <td><a href="http://labs.rampinteractive.co.uk/android_dp_px_calculator/" rel="nofollow">dp px 转换</a></td>\n  <td>阿里巴巴的矢量图库</td>\n</tr>\n<tr>\n  <td><a href="http://translate.google.cn/" rel="nofollow">谷歌翻译</a></td>\n  <td>谷歌翻译</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="开发环境">开发环境</h2>\n\n<table>\n<thead>\n<tr>\n  <th>环境/工具</th>\n  <th>简述</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td><a href="http://www.androiddevtools.cn/" rel="nofollow">AndroidDevTools</a></td>\n  <td>一个收集整理Android开发所需的Android SDK、开发中用到的工具、Android开发教程、Android设计规范，免费的设计素材的网站,很齐全，有它够用了。</td>\n</tr>\n<tr>\n  <td><a href="http://developer.android.com/sdk/index.html" rel="nofollow">Android Studio</a></td>\n  <td>安卓官方开发工具，基于IDEA , 比Eclipse好太多，没有用的同学赶紧转吧。</td>\n</tr>\n<tr>\n  <td><a href="https://www.genymotion.com/#!/download" rel="nofollow">Genymotion</a></td>\n  <td>安卓模拟器。</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/skylot/jadx">jadx</a></td>\n  <td>Android 反编译神器, 不同于常见的 <a href="https://github.com/pxb1988/dex2jar">dex2jar</a></td>\n</tr>\n<tr>\n  <td><a href="https://github.com/ligi/GradleDependenciesHelperPlugin">GradleDependenciesHelperPlugin</a></td>\n  <td>Gradle 依赖自动补全插件</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/square/leakcanary">LeakCanary</a></td>\n  <td>Square开源的一个非常有用的工具,检测出内存泄的问题</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/avast/android-butterknife-zelezny">ButterKnife Zelezny</a></td>\n  <td>ButterKnife 生成器, 使用起来非常简单方便, 为你简写了很多代码。</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/nicoulaj/idea-markdown">idea-markdown</a></td>\n  <td>在 AS 中编写 Markdown 文件, 可以直接预览网页显示效果</td>\n</tr>\n<tr>\n  <td><a href="http://facebook.github.io/stetho/" rel="nofollow">Stetho</a></td>\n  <td>Stetho 是 Facebook 出品的一个强大的 Android 调试工具,使用该工具你可以在 Chrome Developer Tools 查看 App 的布局</td>\n</tr>\n<tr>\n  <td><a href="https://github.com/zzz40500/GsonFormat">GsonFormat</a></td>\n  <td>现在大多数服务端 api 都以 json 数据格式返回, 而客户端需要根据 api 接口生成相应的实体类, 这个插件把这个过程自动化了</td>\n</tr>\n</tbody></table>\n\n\n\n\n<h2 id="素材">素材</h2>\n\n<ul>\n<li><a href="http://www.iconfont.cn/" rel="nofollow">阿里巴巴矢量图</a></li>\n<li><a href="http://www.materialup.com/" rel="nofollow">Material Design设计模板与素材</a></li>\n<li><a href="https://iconstore.co/" rel="nofollow">Icon Store</a></li>\n<li><a href="https://design.google.com/icons/" rel="nofollow">Material icons</a></li>\n<li><a href="https://github.com/gztchan/awesome-design/">awesome-design</a></li>\n</ul>\n\n\n\n<h2 id="设计模式">设计模式</h2>\n\n<ul>\n<li><a href="https://github.com/iluwatar/java-design-patterns#model-view-presenter">java-design-patterns</a></li>\n<li><a href="https://github.com/HackathonHackers/programming-ebooks/blob/master/Java/Effective%20Java%20%282nd%20Edition%29.pdf">Effective Java</a></li>\n<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653">Java之美[从菜鸟到高手演变]之设计模式</a></li>\n</ul>\n\n\n\n<h2 id="文档">文档</h2>\n\n<ul>\n<li><a href="http://www.fresco-cn.org/" rel="nofollow">Fresco文档</a></li>\n<li><a href="http://mrfu.me/2016/02/27/Glide_Getting_Started/" rel="nofollow">Glide 中文非官方文档</a></li>\n<li><a href="http://developer.android.com/reference/android/package-summary.html" rel="nofollow">Android 官方 API 文档</a>(网站需要翻墙)</li>\n<li><a href="http://hukai.me/android-training-course-in-chinese/index.html" rel="nofollow">Android 官方培训课程中文版</a>(Google Android 官方培训课程翻译的中文版)</li>\n</ul>\n\n\n\n<h2 id="感谢">感谢</h2>\n\n<ul>\n<li>感谢这么多伟大的开源者，感谢这么多伟大的开源公司，因为开源，世界变得更加美好。</li>\n</ul>\n\n\n\n<h2 id="联系我">联系我</h2>\n\n<ul>\n<li>Email:124746406@qq.com </li>\n<li>GitHub: <a href="https://github.com/forezp">Forezp</a></li>\n<li>Blog : <a href="http://blog.csdn.net/forezp">csdn blog</a></li>\n<li>原文件: <a href="https://github.com/forezp/AndroidMaterialLatest/issues">AndroidMaterialLatest</a></li>\n</ul>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52886700', 'title': '一篇RxJava友好的文章（一）', 'readNum': '23737', 'commentNum': '0', 'publishTime': '2016-10-21 20:03:02', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n<p>转载请标明出处：<br>\n<a href="http://blog.csdn.net/forezp/article/details/52886700">http://blog.csdn.net/forezp/article/details/52886700</a><br>\n本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n<p>Rxjava在目前的开发中已经是如火如荼，非常的流行，唯一的就是上手不太容易，学习成本高，学习rxjava有一段时间了，也看了<a href="http://www.apkbus.com/forum.php?mod=viewthread&amp;tid=257703&amp;extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline&amp;_dsign=43e9b95f" rel="nofollow">老罗的rxjava视频</a>，决定自己总结下。</p>\n<p>另外欢迎star我的另一个项目,<a href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API模仿网易云音乐的开源app</a></p>\n<h3><a id="_7"></a>准备</h3>\n<p>在android工程中的gradle.build中配置，为了更好的理解，所以导入java8 的lambda 表达式。</p>\n<pre><code>compile \'io.reactivex:rxjava:1.2.1\'\ncompile \'io.reactivex:rxandroid:1.2.1\'\n</code></pre>\n<h3><a id="_14"></a>基础</h3>\n<p>rxjava 中有两个核心的对象Observable（被观察者，它会发出一系列的事件源）和Subscribers（观察者，接受事件源），Observable发出事件后，中间可以有一系列的操作、变化，可以精确的控制事件，最终被观察者所接收。其中Observable每发出一个事件就会，就会调用他的subscriber 的onext()，直到发生错误onerror()或onComplete()结束。</p>\n<p>1.用Observable.create去创建一个Observable对象，并发射一个"hi Rxjava"，就结束。</p>\n<pre><code>Observable&lt;String&gt; observable= Observable.create(\n      new Observable.OnSubscribe&lt;String&gt;() {    \n   @Override   \n   public void call(Subscriber&lt;? super String&gt;    subscriber)\n   {  \n      subscriber.onNext("hi RxJava");           \n      subscriber.onCompleted();   \n  }});\n</code></pre>\n<p>然后，我们需要去创建一个subscriber去处理observable发射过来的数据。</p>\n<pre><code>Subscriber&lt;String&gt; subscriber=new Subscriber&lt;String&gt;() {\n   @Override  \n   public void onCompleted() {     \n      Log.e(TAG,"onCompleted"); \n   }   \n  @Override  \n   public void onError(Throwable e) {                    \n      Log.e(TAG,e.getMessage());   \n   }    \n  @Override\n  public void onNext(String s) {     \n      Log.e(TAG,s);   \n  }};\n</code></pre>\n<p>最后需要，subscribe函数把observable对象和subscriber对象关联起来，这样就完成了subscriber对observable的订阅。</p>\n<pre><code>observable.subscribe(subscriber);\n</code></pre>\n<p>程序运行一下：<br>\n<img src="https://img-blog.csdnimg.cn/20190601123715800.png" alt="在这里插入图片描述"><br>\n可能你觉得这样太复杂了，但是涉及到了与之前不一样的变成思想，即响应式编程。</p>\n<p>2.用just去创建observable，just英语意思是仅仅的意思，如果只发出一个事件可以用这种方式。另外在创建Subscriber的时候，如果仅仅关心onNext()，这时可以用Action1这个对象。</p>\n<pre><code>Observable.just("hi Rxjava2").subscribe(new Action1&lt;String&gt;() {    \n   @Override \n   public void call(String s) {       \n      Log.e(TAG,s);  \n  }});\n</code></pre>\n<p>运行程序：</p>\n<p><img src="https://img-blog.csdnimg.cn/2019060112372911.png" alt="在这里插入图片描述"></p>\n<p>3.用from创建observable，这种方式创建，需要传入一个集合，它会一个一个的发射，在subscriber上它会一个一个的接收。</p>\n<pre><code>String [] strs={"1","2","3","4"};\nObservable.from(Arrays.asList(strs))\n.subscribe(new Action1&lt;String&gt;() {   \n   @Override   \n    public void call(String s) {       \n        Log.e(TAG,s);    \n }});\n</code></pre>\n<p>运行程序：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123743279.png" alt="在这里插入图片描述"></p>\n<p>是不是有点像高级for循环－.－  。</p>\n<p>4.操作符map，是用在observable和subcriber中间，是为了操作observable发射的数据，操作之后的数据，会被subcriber 接收。rxjava有很多操作符，map操作符是将一个事件转换为另一个事件的。</p>\n<pre><code>Observable.just("hi rxjava")\n.map(new Func1&lt;String, String&gt;() {  \n  @Override    \n  public String call(String s) {    \n    return s+" ,你好rxjava";   \n   }})\n.subscribe(new Action1&lt;String&gt;() {    \n     @Override    \n     public void call(String s) {    \n        Log.e(TAG,s);   \n  }});\n</code></pre>\n<p>运行程序：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123800843.png" alt="在这里插入图片描述"></p>\n<p>另外,map操作符可以将转换类型，比如string 转int .</p>\n<pre><code>Observable.just("hi rxjava")\n.map(new Func1&lt;String, Integer&gt;() { \n   @Override    \n    public Integer call(String s) { \n       return s.hashCode();    \n   }})\n.subscribe(new Action1&lt;Object&gt;() { \n   @Override  \n    public void call(Object s) {    \n       Log.e(TAG,s+"");   \n }});\n</code></pre>\n<p>5.flatmap操作符<br>\nflatMap操作符接收一个Observable的输出作为输入，同时输出另外一个Observable。在flatMap操作符中，我们可以做一系列的事情，然后输出的新的Observable，这个Observable是我们在Subscriber想要接收的。</p>\n<pre><code>Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() {    \n  @Override   \n  public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) {           \n      String [] strs={"1","2","3","4","5","6","7"};           \n      subscriber.onNext(Arrays.asList(strs));   \n }})\n.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;?&gt;&gt;() {    \n   @Override \n   public Observable&lt;?&gt; call(List&lt;String&gt; list) {     \n      return Observable.from(list);  \n   }})\n.subscribe(new Action1&lt;Object&gt;() { \n   @Override   \n   public void call(Object o) {  \n      Log.e(TAG,o.toString());  \n  }});\n</code></pre>\n<p>首先Observable发出一个list , 然后经过flatmap 将其变成from创建的Observable，这个Observable将list中的元素一个一个的发射，然后，subcriber 中接收。</p>\n<p>运行程序：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123819345.png" alt="在这里插入图片描述"></p>\n<p>6.filter 操作符，对Observable发射的数据进行过滤操作，哪有subcriber接收 ，哪些不接收。</p>\n<pre><code>Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() {    \n   @Override \n   public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) {        \n      String [] strs={"1","2","3","4","5","6","7"};          \n      subscriber.onNext(Arrays.asList(strs));   \n   }})\n.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;?&gt;&gt;() {    \n   @Override \n   public Observable&lt;?&gt; call(List&lt;String&gt; list) {   \n     return Observable.from(list);  \n  }})\n.filter(new Func1&lt;Object, Boolean&gt;() {//filter 操作符，去掉“1”;    \n   @Override \n   public Boolean call(Object o) {        \n     if(o.toString().equals("1"))return false;   \n     return true;    \n}})\n.subscribe(new Action1&lt;Object&gt;() {\n  @Override    \n  public void call(Object o) {        \n    Log.e(TAG,o.toString()); \n }});\n</code></pre>\n<p>运行程序：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123832185.png" alt="在这里插入图片描述"></p>\n<p>7.take操作符，固定返回数量。take(2)，返回2个结果。</p>\n<pre><code>Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() {    \n  @Override  \n  public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) {        \n    String [] strs={"1","2","3","4","5","6","7"};        \n    subscriber.onNext(Arrays.asList(strs));    \n }})\n.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;?&gt;&gt;() {    \n  @Override   \n   public Observable&lt;?&gt; call(List&lt;String&gt; list) {  \n      return Observable.from(list);  \n  }})\n.filter(new Func1&lt;Object, Boolean&gt;() {//filter 操作符，去掉“1”;    \n   @Override   \n   public Boolean call(Object o) {        \n     if(o.toString().equals("1"))return false;     \n     return true;    \n }})\n.take(2)\n.subscribe(new Action1&lt;Object&gt;() {//take 操作符，最多输出的数量    \n   @Override  \n   public void call(Object o) {     \n       Log.e(TAG,o.toString());  \n  }});\n</code></pre>\n<p>运行程序：</p>\n<p><img src="https://img-blog.csdnimg.cn/20190601123849403.png" alt="在这里插入图片描述"></p>\n<p>rxjava中还有很多操作符，具体见<a href="http://reactivex.io/RxJava/javadoc/" rel="nofollow">官网文档</a>和<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" rel="nofollow">中文文档</a>，操作符可以让你对数据流做任何操作。多个操作符配合起来，可以让很复杂的逻辑变得简单，同时，在操作数据的过程中，subcriber并不需要知道中间做了那些操作，只需要知道返回的结果，操作数据也变的简单。</p>\n<p><a href="https://github.com/forezp/RxJavaDemo">源码下载</a></p>\n<h3><a id="_213"></a>优秀文章推荐：</h3>\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/80125819', 'title': '瓣呀，一个基于豆瓣api仿网易云音乐的开源项目', 'readNum': '11828', 'commentNum': '0', 'publishTime': '2016-10-20 23:19:57', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <ul>\n<li>\n</ul>\n<p>整体采用material design 风格，本人是网易云音乐的粉丝，所以界面模仿了网页云音乐，另外，项目中尽量使用了5.0之后的新控件。</p>\n<ul>\n<li>\n</ul>\n<p>项目整体采用mvp+rxjava+retrofit 框架，使用glide进行图片展示，用butterknif注解，另外使用了java 8 新特性，拉姆达表达式，安卓原生并不支持，需要导插件，具体见项目。</p>\n<ul>\n<li>并对retrofit的okhttpClient进行了缓存配置，很遗憾，豆瓣API在服务端并没有对返回数据进行Cache-Control 设置。</li>\n<li>后续会采用本地数据库对数据进行缓存，初步定为使用realm。</li>\n<li>项目地址：<a href="https://github.com/forezp/banya">https://github.com/forezp/banya</a></li>\n<li>这是我的一个利用课余时间做的一个项目，仅供娱乐，项目的一切数据来自豆瓣api v2.0，一切数据归豆瓣所有。</li>\n</ul>\n<p>主界面：</p>\n<ul>\n<li>主界面采用material design 设计风格，使用了NavigationView和DrawerLayout的抽屉效果，CoordinatorLayout和viewpager 配合，使用behavior属性，对toolbar的显示和隐藏进行了控制。使用了tablayout和viewpager配合，切换fragment，整体风格类似于网易云音乐。</li>\n<li>用到的豆瓣API有热映榜、top250、搜索图书、搜索音乐，等。<br>\n<img src="https://img-blog.csdn.net/20161020232735568" alt="图片描述"><br>\n抽屉界面：</li>\n</ul>\n<p>抽屉界面</p>\n<ul>\n<li>使用到的icon来自google 的开源icon库，material design icon 地址：点击进入 ，看来谷歌为material design 花费了大量的精力，然而，一般的项目组都是ios的设计风格，让android去开发，作为一名安卓开发者，感觉到非常的不幸，为什么好的东西不能被产品和设计接受。<br>\n<img src="https://img-blog.csdn.net/20161020232827569" alt="图片描述"></li>\n</ul>\n<p>项目中使用了webview 进行展示</p>\n<p><img src="https://img-blog.csdn.net/20161020232906171" alt="图片描述"><br>\n感谢</p>\n<ul>\n<li>感谢豆瓣开放测试api。</li>\n<li>感谢开源项目 <a href="http://gank.io" rel="nofollow">gank.io</a></li>\n<li>同时项目也借鉴了其他的开源项目，感谢。</li>\n<li>同时希望可以帮助到其他人。<br>\n关于我<br>\n见图： 希望能认识一些趣味相投的人一起进步<br>\n<img src="https://img-blog.csdn.net/20161020233043915" alt="图片描述"></li>\n</ul>\n<p>Contatct Me:</p>\n<p><a href="mailto:Email:124746406@qq.com" rel="nofollow">Email:124746406@qq.com</a><br>\nBlog : <a href="http://blog.csdn.net/forezp">http://blog.csdn.net/forezp</a><br>\nGitHub: <a href="https://github.com/forezp">https://github.com/forezp</a></p>\n<div>\n    <p align="center">\n        <img src="https://img-blog.csdn.net/20170708155617159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="258" height="258">\n        <br>\n        扫码关注公众号有惊喜\n    </p>\n    <p align="center">\n        <strong>（转载本站文章请注明作者和出处 <a href="https://www.fangzhipeng.com" rel="nofollow">方志朋的博客</a>）</strong>\n    </p>\n</div>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52825189', 'title': '瓣呀，一个开源项目', 'readNum': '24643', 'commentNum': '8', 'publishTime': '2016-10-15 22:00:59', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h1><a id="app_2"></a>瓣呀，一个非官方的豆瓣app</h1>\n<p>源码下载： <a href="https://github.com/forezp/banya">https://github.com/forezp/banya</a></p>\n<ul>\n<li>\n<p>首页分为三大模块，包括：电影、看书、音乐。而电影模块又包括最近热门电影、TOP250；看书模块包括综合、文学、流行、文化、生活五个部分；音乐模块包括流行、经典、韩系、欧美四个模块。</p>\n</li>\n<li>\n<p>首页界面风格采用Material Design设计规范，使用了CoordinatorLayout和viewpager配合，使用behavior属性对toolbar的显示和隐藏进行了控制，tablayout和viewpager配合，viewpager切换fragment，整体界面模仿了网易云音乐。</p>\n</li>\n<li>\n<p>抽屉界面的实现是使用DrawerLayout和NavigationView配合，使用的icon来自<a href="https://design.google.com/icons/index.html" rel="nofollow">material design icon</a>。</p>\n</li>\n<li>\n<p>详情界面模仿了豆瓣app的详情界面，包括了电影详情、音乐详情、书籍详情，另外使用了webview 对详情页面和导演、演员、作者歌手的个人信息进行了展示。</p>\n</li>\n<li>\n<p>项目整体采用mvp+rxjava+retrofit 框架，用butterknif注解，使用glide进行图片展示，另外使用了java8的拉姆达表达式，安卓原生并不支持，需要导插件。</p>\n</li>\n<li>\n<p>对okhttpClient进行了缓存配置，然而豆瓣API对Cache-Control的设置为no-cache，所以目前没有缓存，需要自己实现，后面会花时间用Realm去实现本地缓存。</p>\n</li>\n<li>\n<p>整体界面采用了沉浸式布局，另外使用了主题切换。在切换主题时，存在一个bug，切换时 statusBar的颜色并没有改变，这个问题已经提交给了<a href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a> 的作者。</p>\n</li>\n</ul>\n<h2><a id="ScreenShot_22"></a>ScreenShot</h2>\n<p><img src="https://img-blog.csdnimg.cn/20190601124054294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>\n<img src="https://img-blog.csdnimg.cn/20190601124120291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601124132505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<p><img src="https://img-blog.csdnimg.cn/20190601124144191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mb3JlenAuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>\n<h2><a id="api_30"></a>api</h2>\n<p>app所以的api都来自<a href="https://developers.douban.com/wiki/?title=api_v2" rel="nofollow">豆瓣Api V2（测试版）</a>;一切数据都归豆瓣所有。</p>\n<h2><a id="Statement_34"></a>Statement</h2>\n<p>该项目仅供交流学习使用，如果该项目有侵犯版权问题，或被告知需停止共享与使用，本人会及时删除此页面与整个项目。</p>\n<h2><a id="_38"></a>感谢</h2>\n<ul>\n<li><a href="https://github.com/ReactiveX/RxJava">RXJava</a></li>\n<li><a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></li>\n<li><a href="https://github.com/square/okhttp">okhttp</a></li>\n<li><a href="https://github.com/square/retrofit">retrofit</a></li>\n<li><a href="https://github.com/JakeWharton/butterknife">butterknif</a></li>\n<li><a href="https://github.com/bumptech/glide">glide</a></li>\n<li><a href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a></li>\n</ul>\n<h2><a id="_49"></a>关于我</h2>\n<p>一个在深圳的全栈开发者，对技术有着强烈的追求。</p>\n<h2><a id="_53"></a>联系我:</h2>\n<ul>\n<li><a href="mailto:Email:124746406@qq.com" rel="nofollow">Email:124746406@qq.com</a></li>\n<li>jianshu: <a href="http://www.jianshu.com/users/f2550db5eca3/latest_articles" rel="nofollow">jianshu</a></li>\n<li>Blog : <a href="http://blog.csdn.net/forezp">csdn blog</a></li>\n<li>GitHub: <a href="https://github.com/forezp">Forezp</a></li>\n</ul>\n<h2><a id="License_60"></a>License</h2>\n<p>Copyright 2016 Forezp</p>\n<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>\n<p><a href="http://www.apache.org/licenses/LICENSE-2.0" rel="nofollow">http://www.apache.org/licenses/LICENSE-2.0</a></p>\n<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>\n\n                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52810752', 'title': 'javascript入门笔记6-内置对象', 'readNum': '22715', 'commentNum': '0', 'publishTime': '2016-10-13 22:23:59', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.Date 日期对象 <br>\n日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）。</p>\n\n<p>定义一个时间对象 :</p>\n\n<p>var Udate=new Date();  <br>\n注意:使用关键字new，Date()的首字母必须大写。 </p>\n\n<p>使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。</p>\n\n<p>如果要自定义初始值，可以用以下方法：</p>\n\n<p>var d = new Date(2012, 10, 1);  //2012年10月1日 <br>\nvar d = new Date(‘Oct 1, 2012’); //2012年10月1日 <br>\n我们最好使用下面介绍的“方法”来严格定义时间。</p>\n\n<p>访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;”</p>\n\n<p>Date对象中处理时间和日期的常用方法： <br>\n<img src="https://img-blog.csdn.net/20161013221247570" alt="这里写图片描述" title=""></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>获得年份 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">var</span> mydate=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); \n<span class="hljs-keyword">var</span> myyear=mydate.getFullYear()     ;\ndocument.write(<span class="hljs-string">"年份:"</span>+myyear);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>2.返回星期方法 <br>\ngetDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下:</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>获得星期<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> mydate=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();\n  <span class="hljs-keyword">var</span> weekday=[<span class="hljs-string">"星期日"</span>,<span class="hljs-string">"星期一"</span>,<span class="hljs-string">"星期二"</span>,<span class="hljs-string">"星期三"</span>,<span class="hljs-string">"星期四"</span>,<span class="hljs-string">"星期五"</span>,<span class="hljs-string">"星期六"</span>];\n  document.write(<span class="hljs-string">"今天是："</span> +weekday[mydate.getDay()] );\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>3. <br>\n返回/设置时间方法 <br>\nget/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> mydate=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();\n  document.write(<span class="hljs-string">"当前时间："</span>+mydate+<span class="hljs-string">"&lt;br&gt;"</span>);\n  mydate.setTime(mydate.getTime() + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);\n  document.write(<span class="hljs-string">"推迟一小时时间："</span> + mydate);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52801166', 'title': 'javascript入门笔记5-事件', 'readNum': '22640', 'commentNum': '0', 'publishTime': '2016-10-13 21:54:34', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.继续循环continue; <br>\ncontinue的作用是仅仅跳过本次循环，而整个循环体继续执行。 <br>\n语句结构：</p>\n\n<p>for(初始条件;判断条件;循环后条件值更新) <br>\n{ <br>\n  if(特殊情况) <br>\n  { continue; } <br>\n 循环代码 <br>\n}</p>\n\n<p>2.JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</p>\n\n<p>比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。</p>\n\n<p><img src="https://img-blog.csdn.net/20161013212433241" alt="这里写图片描述" title=""></p>\n\n<p>3.鼠标单击事件( onclick ）</p>\n\n<p>onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span><span class="hljs-params">()</span>{</span>\n        <span class="hljs-keyword">var</span> numa,numb,sum;\n        numa=<span class="hljs-number">6</span>;\n        numb=<span class="hljs-number">8</span>;\n        sum=numa+numb;\n        document.write(<span class="hljs-string">"两数和为:"</span>+sum);  }\n   </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"点击提交"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"add2()"</span> /&gt;</span>\n   <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>4.鼠标经过事件（onmouseover）</p>\n\n<p>鼠标经过事件，当鼠标移到一个对象上时，该对象就触发onmouseover事件，并执行onmouseover事件调用的程序。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 鼠标经过事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n      confirm(<span class="hljs-string">"请输入密码后，再单击确定!"</span>); }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n密码:<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"password"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"password"</span> &gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"确定"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"确定"</span>  <span class="hljs-attribute">onmouseover</span>=<span class="hljs-value">"message()"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>5. <br>\n鼠标移开事件（onmouseout） <br>\n鼠标移开事件，当鼠标移开当前对象时，执行onmouseout调用的程序。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>鼠标移开事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n    alert(<span class="hljs-string">"不要移开，点击后进行慕课网!"</span>); }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"http://www.imooc.com"</span> <span class="hljs-attribute">onmouseout</span>=<span class="hljs-value">"message()"</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>6.光标聚焦事件onfocus</p>\n\n<p>当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 光标聚焦事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n      alert(<span class="hljs-string">"请选择，您现在的职业！"</span>);\n    }\n  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n请选择您的职业：<span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"career"</span> <span class="hljs-attribute">onfocus</span>=<span class="hljs-value">"message"</span>&gt;</span> \n      <span class="hljs-tag">&lt;<span class="hljs-title">option</span>&gt;</span>学生<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span> \n      <span class="hljs-tag">&lt;<span class="hljs-title">option</span>&gt;</span>教师<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span> \n      <span class="hljs-tag">&lt;<span class="hljs-title">option</span>&gt;</span>工程师<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span> \n      <span class="hljs-tag">&lt;<span class="hljs-title">option</span>&gt;</span>演员<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span> \n      <span class="hljs-tag">&lt;<span class="hljs-title">option</span>&gt;</span>会计<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span> \n    <span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span> \n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>7.失焦事件（onblur）</p>\n\n<p>onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 失焦事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n    alert(<span class="hljs-string">"请确定已输入密码后，在移开!"</span>); }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>    \n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n   用户:<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"username"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"请输入用户名！"</span> &gt;</span>\n   密码:<span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"password"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"请输入密码！"</span>  <span class="hljs-attribute">onblur</span>=<span class="hljs-value">"message()"</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>8.内容选中事件（onselect）</p>\n\n<p>选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 内容选中事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n    alert(<span class="hljs-string">"您触发了选中事件！"</span>); }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>    \n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n  个人简介：<span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-title">textarea</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"summary"</span> <span class="hljs-attribute">cols</span>=<span class="hljs-value">"60"</span> <span class="hljs-attribute">rows</span>=<span class="hljs-value">"5"</span>  <span class="hljs-attribute">onselect</span>=<span class="hljs-value">"message()"</span>&gt;</span>请写入个人简介，不少于200字！<span class="hljs-tag">&lt;/<span class="hljs-title">textarea</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>9.文本框内容改变事件（onchange)</p>\n\n<p>通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 文本框内容改变事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n    alert(<span class="hljs-string">"您改变了文本内容！"</span>); }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>    \n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n  个人简介：<span class="hljs-tag">&lt;<span class="hljs-title">br</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-title">textarea</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"summary"</span> <span class="hljs-attribute">cols</span>=<span class="hljs-value">"60"</span> <span class="hljs-attribute">rows</span>=<span class="hljs-value">"5"</span>  <span class="hljs-attribute">onchange</span>=<span class="hljs-value">"message()"</span>&gt;</span>请写入个人简介，不少于200字！<span class="hljs-tag">&lt;/<span class="hljs-title">textarea</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>10.加载事件（onload） <br>\n事件会在页面加载完成后，立即发生，同时执行被调用的程序。 <br>\n注意： <br>\na. 加载页面时，触发onload事件，事件写在body标签内。 <br>\nb. 此节的加载页面，可理解为打开一个新页面时。 <br>\n如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 加载事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span><span class="hljs-params">()</span>{</span>\n    alert(<span class="hljs-string">"加载中，请稍等…"</span>); }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>    \n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span> <span class="hljs-attribute">onload</span>=<span class="hljs-value">"message()"</span>&gt;</span>\n  欢迎学习JavaScript。\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>11.卸载事件（onunload） <br>\n当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p>\n\n<p>注意：不同浏览器对onunload事件支持不同。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 卸载事件 <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">   \n     window.onunload = onunload_message;   \n     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onunload_message</span><span class="hljs-params">()</span>{</span>   \n        alert(<span class="hljs-string">"您确定离开该网页吗？"</span>);   \n    }   \n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>   \n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  欢迎学习JavaScript。\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>12.任务 <br>\n使用JS完成一个简单的计算器功能。实现2个输入框中输入整数后，点击第三个输入框能给出2个整数的加减乘除。</p>\n\n<p>提示：获取元素的值设置和获取方法为：例：赋值：document.getElementById(“id”）.value = 1； 取值：var = document.getElementById(“id”）.value；</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> 事件<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>  \n  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>{</span>\n\n    <span class="hljs-comment">//获取第一个输入框的值</span>\n    <span class="hljs-keyword">var</span> a=document.getElementById(<span class="hljs-string">"txt1"</span>).value;\n    <span class="hljs-comment">//获取第二个输入框的值</span>\n    <span class="hljs-keyword">var</span> b=document.getElementById(<span class="hljs-string">"txt2"</span>).value;\n    <span class="hljs-comment">//获取选择框的值</span>\n    <span class="hljs-keyword">var</span> c=document.getElementById(<span class="hljs-string">"select"</span>).value;\n    <span class="hljs-comment">//获取通过下拉框来选择的值来改变加减乘除的运算法则</span>\n\n    <span class="hljs-keyword">switch</span>(c){\n    <span class="hljs-keyword">case</span><span class="hljs-string">"+"</span>:\n    <span class="hljs-keyword">var</span> sum=<span class="hljs-built_in">parseInt</span>(a)+<span class="hljs-built_in">parseInt</span>(b);\n    <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span><span class="hljs-string">"-"</span>:\n    <span class="hljs-keyword">var</span> sum=<span class="hljs-built_in">parseInt</span>(a)-<span class="hljs-built_in">parseInt</span>(b);\n    <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span><span class="hljs-string">"*"</span>:\n    <span class="hljs-keyword">var</span> sum=<span class="hljs-built_in">parseInt</span>(a)*<span class="hljs-built_in">parseInt</span>(b);\n    <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span><span class="hljs-string">"/"</span>:\n    <span class="hljs-keyword">var</span> sum=<span class="hljs-built_in">parseInt</span>(a)/<span class="hljs-built_in">parseInt</span>(b);\n    <span class="hljs-keyword">break</span>;\n    }\n    <span class="hljs-comment">//设置结果输入框的值 </span>\n    document.getElementById(<span class="hljs-string">"fruit"</span>).value=sum;\n   }\n  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> \n <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span> \n <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">\'text\'</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">\'txt1\'</span> /&gt;</span> \n   <span class="hljs-tag">&lt;<span class="hljs-title">select</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">\'select\'</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">option</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">\'+\'</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">option</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"-"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">option</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"*"</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">option</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"/"</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span>\n   <span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">\'text\'</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">\'txt2\'</span> /&gt;</span> \n   <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">\'button\'</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">\' = \'</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"count()"</span>/&gt;</span> <span class="hljs-comment">&lt;!--通过 = 按钮来调用创建的函数，得到结果--&gt;</span> \n   <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">\'text\'</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">\'fruit\'</span> /&gt;</span>   \n <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52800969', 'title': 'javascript入门笔记4-数组', 'readNum': '22577', 'commentNum': '0', 'publishTime': '2016-10-12 21:33:09', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.数组 <br>\nvar arr=new Array(); <br>\nvar myarray= new Array(8); //创建数组，存储8个数据。  <br>\n注意： <br>\n1.创建的新数组是空数组，没有值，如输出，则显示undefined。 <br>\n2.虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度为8，仍然可以将元素存储在规定长度以外。 <br>\na.</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">var</span> myarray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">66</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>,<span class="hljs-number">77</span>,<span class="hljs-number">59</span>);<span class="hljs-comment">//创建数组同时赋值</span></code></pre>\n\n<p>b.</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> myarray = [<span class="hljs-number">66</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>,<span class="hljs-number">77</span>,<span class="hljs-number">59</span>];<span class="hljs-comment">//直接输入一个数组（称 “字面量数组”）</span></code></pre>\n\n<p>c.</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n <span class="hljs-keyword">var</span> myarr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">//定义数组</span>\n myarr[<span class="hljs-number">0</span>]=<span class="hljs-number">80</span>; \n myarr[<span class="hljs-number">1</span>]=<span class="hljs-number">60</span>;\n myarr[<span class="hljs-number">2</span>]=<span class="hljs-number">99</span>;\n document.write(<span class="hljs-string">"第一个人的成绩是:"</span>+myarr[<span class="hljs-number">0</span>]);\n document.write(<span class="hljs-string">"第二个人的成绩是:"</span>+myarr[<span class="hljs-number">1</span>]);\n document.write(<span class="hljs-string">"第三个人的成绩是:"</span>+myarr[<span class="hljs-number">2</span>]);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p>2.了解成员数量(数组属性length) <br>\nmyarray.length; //获得数组myarray的长度</p>\n\n<p>JavaScript数组的length属性是可变的，这一点需要特别注意。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs livecodeserver">arr.<span class="hljs-built_in">length</span>=<span class="hljs-number">10</span>;<span class="hljs-comment"> //增大数组的长度</span>\ndocument.<span class="hljs-built_in">write</span>(arr.<span class="hljs-built_in">length</span>);<span class="hljs-comment"> //数组长度已经变为10</span>\n\nvar arr=[<span class="hljs-number">98</span>,<span class="hljs-number">76</span>,<span class="hljs-number">54</span>,<span class="hljs-number">56</span>,<span class="hljs-number">76</span>];<span class="hljs-comment"> // 包含5个数值的数组</span>\ndocument.<span class="hljs-built_in">write</span>(arr.<span class="hljs-built_in">length</span>);<span class="hljs-comment"> //显示数组的长度5</span>\narr[<span class="hljs-number">15</span>]=<span class="hljs-number">34</span>; <span class="hljs-comment"> //增加元素，使用索引为15,赋值为34</span>\nalert(arr.<span class="hljs-built_in">length</span>);<span class="hljs-comment"> //显示数组的长度16</span></code></pre>\n\n<p>3.二维数组，我们看成一组盒子，不过每个盒子里还可以放多个盒子。</p>\n\n<p>二维数组的表示: myarray[ ][ ]</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-number">1.</span> 二维数组的定义方法一\n\n<span class="hljs-keyword">var</span> myarr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();  <span class="hljs-comment">//先声明一维 </span>\n<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++){   <span class="hljs-comment">//一维长度为2</span>\n   myarr[i]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();  <span class="hljs-comment">//再声明二维 </span>\n   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++){   <span class="hljs-comment">//二维长度为3</span>\n   myarr[i][j]=i+j;   <span class="hljs-comment">// 赋值，每个数组元素的值为i+j</span>\n   }\n }\n\n\n<span class="hljs-number">2.</span> 二维数组的定义方法二\n\n<span class="hljs-keyword">var</span> Myarr = [[<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">2</span> ],[<span class="hljs-number">1</span> , <span class="hljs-number">2</span> , <span class="hljs-number">3</span>]]\n\n<span class="hljs-number">3.</span> 赋值\n\nmyarr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">5</span>; <span class="hljs-comment">//将5的值传入到数组中，覆盖原有值。</span>\n\n说明: myarr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] ,<span class="hljs-number">0</span> 表示表的行，<span class="hljs-number">1</span>表示表的列。\n\n</code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:43 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52792228', 'title': 'javascript入门笔记3-dom', 'readNum': '18683', 'commentNum': '0', 'publishTime': '2016-10-11 22:00:44', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.通过ID获取元素 <br>\n document.getElementById(“id”) </p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>document.getElementById<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">p</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"con"</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> mychar=   document.getElementById(<span class="hljs-string">"con"</span>)        ;\n  document.write(<span class="hljs-string">"结果:"</span>+mychar); <span class="hljs-comment">//输出获取的P标签。 </span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>2. <br>\ninnerHTML 属性用于获取或替换 HTML 元素的内容。 <br>\n语法：Object.innerHTML</p>\n\n<p>1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。</p>\n\n<p>2.注意书写，innerHTML区分大小写。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>innerHTML<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">h2</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"con"</span>&gt;</span>javascript<span class="hljs-tag">&lt;/<span class="hljs-title">H2</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span> JavaScript是一种基于对象、事件驱动的简单脚本语言，嵌入在HTML文档中，由浏览器负责解释和执行，在网页上产生动态的显示效果并实现与用户交互功能。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> mychar=   document.getElementById(<span class="hljs-string">"con"</span>)        ;\n  document.write(<span class="hljs-string">"原标题:"</span>+mychar.innerHTML+<span class="hljs-string">"&lt;br&gt;"</span>); <span class="hljs-comment">//输出原h2标签内容</span>\n  mychar.innerHTML=<span class="hljs-string">"ddd"</span>;\n  document.write(<span class="hljs-string">"修改后的标题:"</span>+mychar.innerHTML); <span class="hljs-comment">//输出修改后h2标签内容</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>3.改变 HTML 样式 <br>\nHTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？</p>\n\n<p>语法: <br>\nObject.style.property=new style;</p>\n\n<p>注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>style样式<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">h2</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"con"</span>&gt;</span>I love JavaScript<span class="hljs-tag">&lt;/<span class="hljs-title">H2</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span> JavaScript使网页显示动态效果并实现与用户交互功能。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">var</span> mychar= document.getElementById(<span class="hljs-string">"con"</span>);\n    mychar.style.color=<span class="hljs-string">"red"</span>;\n    mychar.style.backgroundColor=<span class="hljs-string">"#CCC"</span>;\n    mychar.style.width=<span class="hljs-string">"300"</span>;\n  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>4.显示和隐藏（display属性） <br>\n语法： <br>\nObject.style.display = value</p>\n\n<p>value值： <br>\nnone:隐藏 <br>\nblock:显示</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=gb2312"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>display<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript"> \n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hidetext</span><span class="hljs-params">()</span>  \n        {</span>  \n        <span class="hljs-keyword">var</span> mychar = document.getElementById(<span class="hljs-string">"con"</span>);\n        mychar.style.display=<span class="hljs-string">"none"</span>;\n        }  \n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showtext</span><span class="hljs-params">()</span>  \n        {</span>  \n        <span class="hljs-keyword">var</span> mychar = document.getElementById(<span class="hljs-string">"con"</span>);\n        mychar.style.display=<span class="hljs-string">"block"</span>;\n\n        }\n    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> \n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span> \n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>  \n    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>  \n    <span class="hljs-tag">&lt;<span class="hljs-title">p</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"con"</span>&gt;</span>做为一个Web开发师来说，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span> \n    <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n       <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"hidetext()"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"隐藏内容"</span> /&gt;</span> \n       <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"showtext()"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"显示内容"</span> /&gt;</span> \n    <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span> \n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>5.控制类名（className 属性） <br>\n语法： <br>\nobject.className = classname</p>\n\n<p>作用: <br>\n1.获取元素的class 属性 <br>\n2. 为网页内的某个元素指定一个css样式来更改该元素的外观 <br>\n例子：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml">\n<span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=gb2312"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>className属性<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">\n    <span class="hljs-tag">body</span><span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"><span class="hljs-number">16</span>px</span></span>;<span class="hljs-rule">}</span></span>\n    <span class="hljs-class">.one</span><span class="hljs-rules">{\n        <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"><span class="hljs-number">1</span>px solid <span class="hljs-hexcolor">#eee</span></span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">230</span>px</span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">50</span>px</span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"><span class="hljs-hexcolor">#ccc</span></span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value">red</span></span>;\n    <span class="hljs-rule">}</span></span>\n    <span class="hljs-class">.two</span><span class="hljs-rules">{\n        <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"><span class="hljs-number">1</span>px solid <span class="hljs-hexcolor">#ccc</span></span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">230</span>px</span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">50</span>px</span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"><span class="hljs-hexcolor">#9CF</span></span></span>;\n        <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value">blue</span></span>;\n    <span class="hljs-rule">}</span></span>\n    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">p</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"p1"</span> &gt;</span> JavaScript使网页显示动态效果并实现与用户交互功能。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"添加样式"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"add()"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">p</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"p2"</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"one"</span>&gt;</span>JavaScript使网页显示动态效果并实现与用户交互功能。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"更改外观"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"modify()"</span>/&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>{</span>\n          <span class="hljs-keyword">var</span> p1 = document.getElementById(<span class="hljs-string">"p1"</span>);\n          p1.className=<span class="hljs-string">"one"</span>;\n       }\n       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span>{</span>\n          <span class="hljs-keyword">var</span> p2 = document.getElementById(<span class="hljs-string">"p2"</span>);\n          p2.className=<span class="hljs-string">"two"</span>;\n       }\n    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>6.任务 <br>\n一、定义”改变颜色”的函数</p>\n\n<p>提示: <br>\nobj.style.color <br>\nobj.style.backgroundColor  <br>\n二、定义”改变宽高”的函数</p>\n\n<p>提示: <br>\nobj.style.width <br>\nobj.style.height  <br>\n三、定义”隐藏内容”的函数</p>\n\n<p>提示: <br>\nobj.style.display=”none”; <br>\n四、定义”显示内容”的函数</p>\n\n<p>提示: <br>\nobj.style.display=”block”; <br>\n五、定义”取消设置”的函数</p>\n\n<p>提示:  <br>\n使用confirm()确定框，来确认是否取消设置。 <br>\n如是将以上所有的设置恢复原始值,否则不做操作。 <br>\n六、当点击相应按钮，执行相应操作，为按钮添加相应事件</p>\n\n<p>答案：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE HTML&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">Content</span>=<span class="hljs-value">"text/html; charset=utf-8"</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>javascript<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">style</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/css"</span>&gt;</span><span class="css">\n<span class="hljs-tag">body</span><span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"><span class="hljs-number">12</span>px</span></span>;<span class="hljs-rule">}</span></span>\n<span class="hljs-id">#txt</span><span class="hljs-rules">{\n    <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">400</span>px</span></span>;\n    <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">600</span>px</span></span>;\n    <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"><span class="hljs-hexcolor">#333</span> solid <span class="hljs-number">1</span>px</span></span>;\n    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"><span class="hljs-number">5</span>px</span></span>;<span class="hljs-rule">}</span></span>\n<span class="hljs-tag">p</span><span class="hljs-rules">{\n    <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"><span class="hljs-number">18</span>px</span></span>;\n    <span class="hljs-rule"><span class="hljs-attribute">text-indent</span>:<span class="hljs-value"><span class="hljs-number">2</span>em</span></span>;<span class="hljs-rule">}</span></span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">h2</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"con"</span>&gt;</span>JavaScript课程<span class="hljs-tag">&lt;/<span class="hljs-title">H2</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"txt"</span>&gt;</span> \n     <span class="hljs-tag">&lt;<span class="hljs-title">h5</span>&gt;</span>JavaScript为网页添加动态效果并实现与用户交互的功能。<span class="hljs-tag">&lt;/<span class="hljs-title">h5</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>1. JavaScript入门篇，让不懂JS的你，快速了解JS。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>\n  <span class="hljs-comment">&lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"改变颜色"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"clo()"</span>&gt;</span>  \n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"改变宽高"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"wid()"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"隐藏内容"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"hid()"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"显示内容"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"blo()"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"取消设置"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"res()"</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n<span class="hljs-comment">//定义"改变颜色"的函数</span>\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clo</span><span class="hljs-params">()</span>{</span>\n        <span class="hljs-keyword">var</span> p = document.getElementById(<span class="hljs-string">"txt"</span>);\n        p.style.color=<span class="hljs-string">"red"</span>;   \n    }\n<span class="hljs-comment">//定义"改变宽高"的函数</span>\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wid</span><span class="hljs-params">()</span>{</span>\n        <span class="hljs-keyword">var</span> p = document.getElementById(<span class="hljs-string">"txt"</span>);\n        p.style.width=<span class="hljs-string">"300px"</span>;\n        p.style.height=<span class="hljs-string">"300px"</span>;\n    }\n<span class="hljs-comment">//定义"隐藏内容"的函数</span>\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hid</span><span class="hljs-params">()</span>{</span>\n        <span class="hljs-keyword">var</span> p = document.getElementById(<span class="hljs-string">"txt"</span>);\n        p.style.display = <span class="hljs-string">"none"</span>;\n    }\n<span class="hljs-comment">//定义"显示内容"的函数</span>\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blo</span><span class="hljs-params">()</span>{</span>\n        <span class="hljs-keyword">var</span> p = document.getElementById(<span class="hljs-string">"txt"</span>);\n        p.style.display = <span class="hljs-string">"block"</span>;\n    }\n<span class="hljs-comment">//定义"取消设置"的函数</span>\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span><span class="hljs-params">()</span>{</span>\n        <span class="hljs-keyword">var</span> p1 = confirm(<span class="hljs-string">"是否取消"</span>);\n        <span class="hljs-keyword">var</span> p = document.getElementById(<span class="hljs-string">"txt"</span>);\n        <span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">true</span>){\n            p.removeAttribute(<span class="hljs-string">\'style\'</span>);\n        }\n    }\n  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:43'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52792091', 'title': 'javascript入门笔记2-window', 'readNum': '19186', 'commentNum': '2', 'publishTime': '2016-10-11 21:45:08', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.JavaScript-输出内容（document.write）</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  document.write(<span class="hljs-string">"I love JavaScript！"</span>); <span class="hljs-comment">//内容用""括起来，""里的内容直接输出。</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"hello world!"</span>;\n  document.write(mystr);  <span class="hljs-comment">//直接写变量名，输出变量存储的内容。</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p>2.JavaScript-警告（alert 消息对话框）</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n   <span class="hljs-keyword">var</span> mynum = <span class="hljs-number">30</span>;\n   alert(<span class="hljs-string">"hello!"</span>);\n   alert(mynum);\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n</code></pre>\n\n<p>3.confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。 <br>\n语法:confirm(str); <br>\n参数说明: <br>\nstr：在消息对话框中要显示的文本 <br>\n返回值: Boolean值</p>\n\n<p>返回值: <br>\n当用户点击”确定”按钮时，返回true <br>\n当用户点击”取消”按钮时，返回false</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">var</span> mymessage=confirm(<span class="hljs-string">"你喜欢JavaScript吗?"</span>);\n    <span class="hljs-keyword">if</span>(mymessage==<span class="hljs-literal">true</span>)\n    {   document.write(<span class="hljs-string">"很好,加油!"</span>);   }\n    <span class="hljs-keyword">else</span>\n    {  document.write(<span class="hljs-string">"JS功能强大，要学习噢!"</span>);   }\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p>4.JavaScript-提问（prompt 消息对话框）</p>\n\n<p>prompt弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。</p>\n\n<p>语法: <br>\nprompt(str1, str2); <br>\n参数说明： <br>\nstr1: 要显示在消息对话框中的文本，不可修改 <br>\nstr2：文本框中的内容，可以修改 <br>\n返回值: <br>\n1. 点击确定按钮，文本框中的内容将作为函数返回值 <br>\n2. 点击取消按钮，将返回null</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> myname=prompt(<span class="hljs-string">"请输入你的姓名:"</span>);\n<span class="hljs-keyword">if</span>(myname!=<span class="hljs-keyword">null</span>)\n  {   alert(<span class="hljs-string">"你好"</span>+myname); }\n<span class="hljs-keyword">else</span>\n  {  alert(<span class="hljs-string">"你好 my friend."</span>);  }</code></pre>\n\n<p>5.JavaScript-打开新窗口（window.open） <br>\n语法：window.open([URL], [窗口名称], [参数字符串])</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs applescript">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。\n窗口名称：可选参数，被打开窗口的名称。\n    <span class="hljs-number">1.</span>该名称由字母、数字和下划线字符组成。\n    <span class="hljs-number">2.</span><span class="hljs-string">"_top"</span>、<span class="hljs-string">"_blank"</span>、<span class="hljs-string">"_self"</span>具有特殊意义的名称。\n       _blank：在新窗口显示目标网页\n       _self：在当前窗口显示目标网页\n       _top：框架网页中在上部窗口中显示目标网页\n    <span class="hljs-number">3.</span>相同 <span class="hljs-property">name</span> 的窗口只能创建一个，要想创建多个窗口则 <span class="hljs-property">name</span> 不能相同。\n   <span class="hljs-number">4.</span><span class="hljs-property">name</span> 不能包含有空格。\n参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</code></pre>\n\n<p>例子：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript"> window.open(<span class="hljs-string">\'http://www.imooc.com\'</span>,<span class="hljs-string">\'_blank\'</span>,<span class="hljs-string">\'width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes\'</span>)\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p>6.JavaScript-关闭窗口（window.close）</p>\n\n<p>window.close();   //关闭本窗口</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n   <span class="hljs-keyword">var</span> mywin=window.open(<span class="hljs-string">\'http://www.imooc.com\'</span>); <span class="hljs-comment">//将新打的窗口对象，存储在变量mywin中</span>\n   mywin.close();\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p>7.任务</p>\n\n<p>a、新窗口打开时弹出确认框，是否打开 <br>\n提示: 使用 if 判断确认框是否点击了确定，如点击弹出输入对话框，否则没有任何操作。 <br>\nb、通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/ <br>\nc、打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span> new document <span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>  \n  <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html; charset=gbk"</span>/&gt;</span>   \n  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">  \n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openmy</span><span class="hljs-params">()</span>{</span>\n    <span class="hljs-keyword">var</span> please_confirm=confirm(<span class="hljs-string">"是否需要打开新窗口"</span>)<span class="hljs-comment">// 新窗口打开时弹出确认框，是否打开</span>\n    <span class="hljs-keyword">if</span>(please_confirm==<span class="hljs-literal">true</span>)\n    {\n        <span class="hljs-keyword">var</span> text=prompt(<span class="hljs-string">"请输入网址"</span>);\n        window.open(<span class="hljs-string">"http://"</span>+text,<span class="hljs-string">\'_blank\'</span>,<span class="hljs-string">\'width=400,high=500,menubar=no,toolbar=no\'</span>)\n        }\n\n\n    <span class="hljs-comment">// 通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/</span>\n\n    <span class="hljs-comment">//打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。</span>\n    }\n\n  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span> \n <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span> \n <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span> \n      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"新窗口打开网站"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"openmy()"</span> /&gt;</span> \n <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:44'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52782528', 'title': 'Javascript入门笔记1-script标签', 'readNum': '19706', 'commentNum': '2', 'publishTime': '2016-10-10 22:26:08', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>1.script标签在HTML文件中添加JavaScript代码.</p>\n\n<p>JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。</p>\n\n<p>JS文件不能直接运行，需嵌入到HTML文件中执行，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"script.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n</code></pre>\n\n<p>2. <br>\n我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。放在head部分;最常用的方式是在页面中head部分放置script元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。放在body部分;JavaScript代码在网页读取到该语句的时候就会执行.</p>\n\n<p>注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</p>\n\n<p>3. <br>\n变量名可以任意取名，但要遵循命名规则: <br>\n    1.变量必须使用字母、下划线(_)或者美元符($)开始。</p>\n\n<p>2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 <br>\n    3.不能使用JavaScript关键词与JavaScript保留字。 <br>\n注意:</p>\n\n<p>在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。</p>\n\n<p>变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。</p>\n\n<p>4.if(条件) <br>\n{ 条件成立时执行的代码 } <br>\nelse <br>\n{ 条件不成立时执行的代码 }</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n   <span class="hljs-keyword">var</span> myage = <span class="hljs-number">18</span>;\n   <span class="hljs-keyword">if</span>(myage&gt;=<span class="hljs-number">18</span>)  <span class="hljs-comment">//myage&gt;=18是判断条件</span>\n   { document.write(<span class="hljs-string">"你是成年人。"</span>);}\n   <span class="hljs-keyword">else</span>  <span class="hljs-comment">//否则年龄小于18</span>\n   { document.write(<span class="hljs-string">"未满18岁，你不是成年人。"</span>);}\n</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span></code></pre>\n\n<p>5. <br>\n如何定义一个函数呢？基本语法如下:</p>\n\n<p>function 函数名() <br>\n{ <br>\n     函数代码; <br>\n}</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs scilab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span><span class="hljs-params">()</span>{</span>\n   var <span class="hljs-built_in">sum</span> = <span class="hljs-number">3</span> + <span class="hljs-number">2</span>;\n   alert(<span class="hljs-built_in">sum</span>);\n}</code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:44'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52712819', 'title': '线程池和信号量', 'readNum': '21284', 'commentNum': '0', 'publishTime': '2016-10-09 21:44:17', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>当我们需要执行一个异步任务时，通常会创建一个线程并启动它，通常任务执行完，线程会被回收，这的确很方便。但我们有大量的任务需要去执行，高并发的情况下，我们都需要不断的创建线程，创建线程和执行线程任务时非常耗费系统资源的，所以我们需要使用线程池，线程池很好的避免了这种情况，并且能很好的控制线程的执行。</p>\n\n<p>java中的主要是ThreadPoolExecutor这个类，具体的可以参考下<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" rel="nofollow">海子的博客</a></p>\n\n<pre class="prettyprint"><code class=" hljs cs">\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ExcutorService {\n\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {\n         ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">200</span>, TimeUnit.MILLISECONDS,\n                 <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">5</span>));\n\n         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">15</span>;i++){\n             MyTask myTask = <span class="hljs-keyword">new</span> MyTask(i);\n             executor.execute(myTask);\n             System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="hljs-string">"，队列中等待执行的任务数目："</span>+\n             executor.getQueue().size()+<span class="hljs-string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());\n         }\n         executor.shutdown();\n    }\n\n\n}\n</code></pre>\n\n<p>注意上述代码，如何任务数超过15 会出一场，因为我们在new线程池的时候，就已经指定了个数，即5＋10</p>\n\n<pre class="prettyprint"><code class=" hljs http">\n\n<span class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>{</span>\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> taskNum;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span>(<span class="hljs-keyword">int</span> num) {\n        <span class="hljs-keyword">this</span>.taskNum = num;\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {\n        System.out.println(<span class="hljs-string">"正在执行task "</span>+taskNum);\n        <span class="hljs-keyword">try</span> {\n            Thread.currentThread().sleep(<span class="hljs-number">4000</span>);\n        } <span class="hljs-keyword">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(<span class="hljs-string">"task "</span>+taskNum+<span class="hljs-string">"执行完毕"</span>);\n    }\n\n}\n</span></code></pre>\n\n<p>ThreadPoolExecutor这个类可以很好的控制任务的执行。 <br>\n当我们需要控制最多5个线程同时进行时，我们需要使用信号量， <br>\nacquire()表示需要获取一个许可，当没有许可的时候，线程阻塞，release()表示释放一个许可，下一个阻塞的线程会获取许可，得到执行，通过信号量可以控制现场并发的个数。</p>\n\n<pre class="prettyprint"><code class=" hljs java">\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {\n\n        Semaphore semaphore=<span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">5</span>);\n        ExecutorService executorService=Executors.newFixedThreadPool(<span class="hljs-number">5</span>) ;\n\n        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++){\n            <span class="hljs-keyword">final</span> String temp=<span class="hljs-string">""</span>+i;\n\n            Runnable run =<span class="hljs-keyword">new</span> Runnable() {\n\n                <span class="hljs-annotation">@Override</span>\n                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {\n                    <span class="hljs-keyword">try</span> {\n                        semaphore.acquire();\n\n                        System.out.println(temp);\n                        Thread.sleep((<span class="hljs-keyword">long</span>)Math.random()*<span class="hljs-number">2000</span>);\n                        semaphore.release();\n                    } <span class="hljs-keyword">catch</span> (Exception e) {\n                        e.printStackTrace();\n                    }\n\n\n                }\n            };\n            executorService.execute(run);\n        }\n\n    }</code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:44'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52621898', 'title': 'Rxjava+retrofit+mvp整合', 'readNum': '19854', 'commentNum': '2', 'publishTime': '2016-09-22 13:07:02', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n  <p>转载请标明出处：  <br>\n  <a href="http://blog.csdn.net/forezp/article/details/52621898">http://blog.csdn.net/forezp/article/details/52621898</a> <br>\n  本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n\n<p>最近在看Rxjava，写了一个简单的 demo整合了Rxjava +retrofit+mvp，写完了迫不及待的分享出来了，打算以后的开发都用这个，太强大了，另外OKhTTP用了网络缓存，非常的方便，以后写缓存都不需要写本地数据库了。</p>\n\n<p>这个项目使用到了拉姆达表达式： <br>\n在安卓中使用Java 8 lambda表达式，很遗憾安卓原生不支持，需要用插件。 <br>\n 在工程中build.GRADLE导入：</p>\n\n<pre class="prettyprint"><code class=" hljs matlab">  dependencies <span class="hljs-cell">{\n        classpath <span class="hljs-string">\'com.android.tools.build:gradle:2.1.0\'</span>\n        classpath <span class="hljs-string">\'me.tatarka:gradle-retrolambda:3.2.5\'</span>\n    }</span>\n</code></pre>\n\n<p>在项目的build.gradle导入</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs bash">  apply plugin: <span class="hljs-string">\'me.tatarka.retrolambda\'</span></code></pre>\n\n<p>需要使用到Java8在android根下</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">  android {\n    compileOptions {\n        sourceCompatibility JavaVersion<span class="hljs-preprocessor">.VERSION</span>_1_8\n        targetCompatibility JavaVersion<span class="hljs-preprocessor">.VERSION</span>_1_8\n    }\n}</code></pre>\n\n<p>这样就可以在android下使用拉姆达表达式。</p>\n\n<p>引入RXjAVA、RxAndroid、retrofit  jar包</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs bash">  compile <span class="hljs-string">\'io.reactivex:rxandroid:1.2.1\'</span>\n    compile <span class="hljs-string">\'com.squareup.retrofit2:retrofit:2.1.0\'</span>\n    compile <span class="hljs-string">\'com.squareup.retrofit2:converter-gson:2.1.0\'</span>\n    compile <span class="hljs-string">\'com.squareup.retrofit2:adapter-rxjava:2.1.0\'</span></code></pre>\n\n<p>关于retrofit的用法，<a href="http://square.github.io/retrofit/" rel="nofollow">点击见官网</a>。</p>\n\n<p>关于Rxjava的用法， <a href="https://github.com/mcxiaoke/RxDocs">翻译的Rxjava中文文档</a></p>\n\n<p>本文是一个整理好的RxJava+retrofit+Mvp的例子。</p>\n\n<p>本文的的网络请求来源知乎API.</p>\n\n<p>1.首先创建retrofit 接口</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> ZhihuApi {\n    @GET(<span class="hljs-string">"news/latest"</span>)\n    Observable&lt;NewsTimeLine&gt; getLatestNews();\n}\n</code></pre>\n\n<p>2.创建retrofit  service</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">\n  File httpCacheDirectory = new File(MyApp<span class="hljs-preprocessor">.mContext</span><span class="hljs-preprocessor">.getCacheDir</span>(), <span class="hljs-string">"responses"</span>)<span class="hljs-comment">;</span>\n        int cacheSize = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><span class="hljs-comment">; // 10 MiB</span>\n        Cache cache = new Cache(httpCacheDirectory, cacheSize)<span class="hljs-comment">;</span>\n        OkHttpClient client = new OkHttpClient<span class="hljs-preprocessor">.Builder</span>()\n                <span class="hljs-preprocessor">.addInterceptor</span>(REWRITE_CACHE_CONTROL_INTERCEPTOR)\n                <span class="hljs-preprocessor">.cache</span>(cache)<span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>\n        Retrofit retrofit_zhihu = new Retrofit<span class="hljs-preprocessor">.Builder</span>()\n                <span class="hljs-preprocessor">.baseUrl</span>(ZHIHU_BASE_URL)\n                <span class="hljs-preprocessor">.client</span>(client)\n                <span class="hljs-preprocessor">.addConverterFactory</span>(GsonConverterFactory<span class="hljs-preprocessor">.create</span>())\n                <span class="hljs-preprocessor">.addCallAdapterFactory</span>(RxJavaCallAdapterFactory<span class="hljs-preprocessor">.create</span>())\n                <span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>\n        ZhihuApiService = retrofit_zhihu<span class="hljs-preprocessor">.create</span>(ZhihuApi<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>\n\n</code></pre>\n\n<p>配置json解析</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">   <span class="hljs-preprocessor">.addConverterFactory</span>(GsonConverterFactory<span class="hljs-preprocessor">.create</span>())</code></pre>\n\n<p>配置Rxjava  适配器</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">  <span class="hljs-preprocessor">.addCallAdapterFactory</span>(RxJavaCallAdapterFactory<span class="hljs-preprocessor">.create</span>())</code></pre>\n\n<p>其中配置了网络缓存</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">   Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = chain -&gt; {\n        CacheControl<span class="hljs-preprocessor">.Builder</span> cacheBuilder = new CacheControl<span class="hljs-preprocessor">.Builder</span>()<span class="hljs-comment">;</span>\n        cacheBuilder<span class="hljs-preprocessor">.maxAge</span>(<span class="hljs-number">0</span>, TimeUnit<span class="hljs-preprocessor">.SECONDS</span>)<span class="hljs-comment">;</span>\n        cacheBuilder<span class="hljs-preprocessor">.maxStale</span>(<span class="hljs-number">365</span>, TimeUnit<span class="hljs-preprocessor">.DAYS</span>)<span class="hljs-comment">;</span>\n        CacheControl cacheControl = cacheBuilder<span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>\n        Request request = chain<span class="hljs-preprocessor">.request</span>()<span class="hljs-comment">;</span>\n        if (!NetUtils<span class="hljs-preprocessor">.isNetworkAvailable</span>(MyApp<span class="hljs-preprocessor">.mContext</span>)) {\n            request = request<span class="hljs-preprocessor">.newBuilder</span>()\n                    <span class="hljs-preprocessor">.cacheControl</span>(cacheControl)\n                    <span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>\n        }\n        Response originalResponse = chain<span class="hljs-preprocessor">.proceed</span>(request)<span class="hljs-comment">;</span>\n        if (NetUtils<span class="hljs-preprocessor">.isNetworkAvailable</span>(MyApp<span class="hljs-preprocessor">.mContext</span>)) {\n            int maxAge = <span class="hljs-number">0</span><span class="hljs-comment">; // read from cache</span>\n            return originalResponse<span class="hljs-preprocessor">.newBuilder</span>()\n                    <span class="hljs-preprocessor">.removeHeader</span>(<span class="hljs-string">"Pragma"</span>)\n                    <span class="hljs-preprocessor">.header</span>(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"public ,max-age="</span> + maxAge)\n                    <span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>\n        } else {\n            int maxStale = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">28</span><span class="hljs-comment">; // tolerate 4-weeks stale</span>\n            return originalResponse<span class="hljs-preprocessor">.newBuilder</span>()\n                    <span class="hljs-preprocessor">.removeHeader</span>(<span class="hljs-string">"Pragma"</span>)\n                    <span class="hljs-preprocessor">.header</span>(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"public, only-if-cached, max-stale="</span> + maxStale)\n                    <span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>\n        }\n    }<span class="hljs-comment">;</span>\n</code></pre>\n\n<p>在MVP的P层进行网络请求，传统的应该是Model  层，写在P层少一次接口回调。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">   public void getNews(IGetZhihuNewsView iGetZhihuNewsView){\n        zhihuApi<span class="hljs-preprocessor">.getLatestNews</span>( )\n                <span class="hljs-preprocessor">.subscribeOn</span>(Schedulers<span class="hljs-preprocessor">.io</span>())\n                <span class="hljs-preprocessor">.observeOn</span>(AndroidSchedulers<span class="hljs-preprocessor">.mainThread</span>())\n                <span class="hljs-preprocessor">.subscribe</span>(newsTimeLine -&gt; {\n                    disPlayZhihuList(iGetZhihuNewsView,newsTimeLine, context)<span class="hljs-comment">;</span>\n                },this::loadError)<span class="hljs-comment">;</span>\n    }\n</code></pre>\n\n<p>其中view接口</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> IGetZhihuNewsView {\n    <span class="hljs-keyword">void</span>  getSuccess(NewsTimeLine newsTimeLine);\n}\n</code></pre>\n\n<p>在Activity中</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IGetZhihuNewsView</span> {</span>\n    <span class="hljs-keyword">private</span> TextView tv;\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {\n        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        tv= (TextView) findViewById(R.id.tv) ;\n        ZhihuPresenter zhihuPresenter=<span class="hljs-keyword">new</span> ZhihuPresenter(<span class="hljs-keyword">this</span>);\n        zhihuPresenter.getNews(<span class="hljs-keyword">this</span>);\n    }\n\n   <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSuccess</span>(NewsTimeLine newsTimeLine) {\n        tv.setText(newsTimeLine.toString());\n    }\n}</code></pre>\n\n<p>代码比较简单，~~~</p>\n\n<p><a href="https://github.com/forezp/RxJavaRetrofit">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:44'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52606056', 'title': 'Java 8 lambda初试', 'readNum': '18943', 'commentNum': '0', 'publishTime': '2016-09-21 11:31:36', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：</p>\n\n<pre><code>public int add(int x, int y) {\n    return x + y;\n}\n</code></pre>\n\n<p>转成λ表达式后是这个样子：</p>\n\n<pre><code>(int x, int y) -&gt; x + y;\n</code></pre>\n\n<p>参数类型也可以省略，Java编译器会根据上下文推断出来：</p>\n\n<pre><code>(x, y) -&gt; x + y; //返回两数之和\n</code></pre>\n\n<p>或者</p>\n\n<pre><code>(x, y) -&gt; { return x + y; } //显式指明返回值\n</code></pre>\n\n<p>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</p>\n\n<p>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</p>\n\n<pre><code>() -&gt; { System.out.println("Hello Lambda!"); }\n</code></pre>\n\n<p>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</p>\n\n<pre><code>c -&gt; { return c.size(); }\n</code></pre>\n\n<pre class="prettyprint"><code class=" hljs coffeescript">public static <span class="hljs-reserved">void</span> main(String[] args) {\n        Arrays.asList( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> ).forEach( e<span class="hljs-function"> -&gt;</span> {\n            System.out.<span class="hljs-built_in">print</span>( e +<span class="hljs-string">"\\n"</span>);\n\n        } );\n        System.out.<span class="hljs-built_in">print</span>( <span class="hljs-string">"\\n--------------------------"</span> );\n        Arrays.asList<span class="hljs-function"><span class="hljs-params">( <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> )</span>.<span class="hljs-title">sort</span><span class="hljs-params">( ( e1, e2 ) -&gt; e1.compareTo( e2 ) )</span>;\n\n\n        /**\n         * 可见λ表达式有三部分组成：参数列表，箭头（-&gt;</span>），以及一个表达式或语句块。\n         * 下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受<span class="hljs-number">0</span>个参数，返回<span class="hljs-reserved">void</span>，其实就是Runnable里run方法的一个实现）：\n         * <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> { System.out.println(<span class="hljs-string">"Hello Lambda!"</span>); }\n         */\n        Thread t2=<span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;{\n            System.out.println(<span class="hljs-string">"This is from an anonymous method (lambda exp).\\n"</span>);\n        })</span>;\n        <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;\n        /**\n         * 迭代<span class="hljs-title">LIST</span>\n         */\n        <span class="hljs-title">List</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">listStr</span>=<span class="hljs-title">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;<span class="hljs-params">()</span>;\n        <span class="hljs-title">listStr</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"sss"</span>)</span>;\n        <span class="hljs-title">listStr</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-string">"1111"</span>)</span>;\n        <span class="hljs-title">listStr</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(e-&gt;{\n            <span class="hljs-keyword">if</span>(e.equals(<span class="hljs-string">"sss"</span>)){\n                System.out.<span class="hljs-built_in">print</span>(e);\n            }\n        })</span>;\n\n    }</span></code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:44'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-4_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52594511', 'title': '改变shape solid color', 'readNum': '17639', 'commentNum': '0', 'publishTime': '2016-09-20 11:53:00', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">shape</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">solid</span> <span class="hljs-attribute">android:color</span>=<span class="hljs-value">"#FF4081"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">corners</span> <span class="hljs-attribute">android:radius</span>=<span class="hljs-value">"15dp"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">shape</span>&gt;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">RelativeLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>\n    <span class="hljs-attribute">xmlns:tools</span>=<span class="hljs-value">"http://schemas.android.com/tools"</span>\n    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n    <span class="hljs-attribute">android:paddingBottom</span>=<span class="hljs-value">"@dimen/activity_vertical_margin"</span>\n    <span class="hljs-attribute">android:paddingLeft</span>=<span class="hljs-value">"@dimen/activity_horizontal_margin"</span>\n    <span class="hljs-attribute">android:paddingRight</span>=<span class="hljs-value">"@dimen/activity_horizontal_margin"</span>\n    <span class="hljs-attribute">android:paddingTop</span>=<span class="hljs-value">"@dimen/activity_vertical_margin"</span>\n    <span class="hljs-attribute">tools:context</span>=<span class="hljs-value">"forezp.com.changesolidcolorfromshape.MainActivity"</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">TextView\n</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/tv"</span>\n        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@drawable/button"</span>\n        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>\n        <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"14sp"</span>\n        <span class="hljs-attribute">android:padding</span>=<span class="hljs-value">"10dp"</span>\n        <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"#ffffff"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n        <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"Hello World!"</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">RelativeLayout</span>&gt;</span>\n</code></pre>\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> {</span>\n    <span class="hljs-comment">//http://stackoverflow.com/questions/16775891/how-to-change-solid-color-from-the-code</span>\n    <span class="hljs-keyword">private</span> TextView tv;\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {\n        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        tv=(TextView)findViewById(R.id.tv);\n        GradientDrawable myGrad = (GradientDrawable)tv.getBackground();\n        myGrad.setColor(Color.BLACK);\n    }\n}</code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:44'}
2020-02-05 20:12:44 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:41] - MainThread - INFO - 翻页：6 nextUrl：https://blog.csdn.net/forezp/article/list/6
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52539702', 'title': '一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本', 'readNum': '19689', 'commentNum': '6', 'publishTime': '2016-09-14 16:52:44', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>jixiaohua发了一篇一个老鸟也发了一份他给公司内部小伙伴整理的路线图。另一份 Android 开发学习路线图。可惜不是MarkDown格式的，所以jixiaohua直接上传的截图，在jixiaohua的呼吁下，我花了些时间，把这篇大牛的推荐清单编辑成了Markdown格式，方便大家浏览，学习。</p>\n\n<p>有一些链接可能还不是特别准确，因为我只能根据图片上的书或者资源的名字去Google可能的书籍，所以链接上有什么不对的，欢迎大家评论指出，我会及时更正。请参考原文：另一份 Android 开发学习路线图 帮助修改。谢谢。</p>\n\n<p>基础工具部分： 中文手册，我猜测是Maven中文手册，可是我并没有找到这样的资源，欢迎知道的朋友告诉我； <br>\nAndroid部分有 『第三方库集合』，我没能找到资源地址； <br>\n书籍我大多是给的豆瓣链接，如果觉得不合适可以替换一下； <br>\n关于Markdown表格</p>\n\n<p>本来我一开始整理了一份表格版本的, 用 Mou 写的，表格内的换行用<br>标签处理的，但是在DiyCode上来发的时候，发现Markdown表格内部不支持<br>标签换行，所以就只能整理成平铺的文档格式。Markdown对于表格的支持不是很强大。</p>\n\n<p>程序设计</p>\n\n<p>一、java</p>\n\n<p>（a）基本语法(如继承、异常、引用、泛型等)</p>\n\n<p>Java核心技术 卷I（适合入门） <br>\n进阶 <br>\nEffective Java中文版（如何写好的Java代码） <br>\nJava解惑 （介绍烂Java代码是什么样的） <br>\n（b）多线程、并发</p>\n\n<p>Java并发编程实战 （系统全面的介绍了Java的并发，如何设计支持并发的数据结构） <br>\n（c）Java 7</p>\n\n<p>Java程序员修炼之道 （详细的介绍Java 7 的新特性） <br>\n（d）Java 8</p>\n\n<p>写给大忙人看的Java SE 8 <br>\n函数式编程思维 <br>\n（e）Java虚拟机</p>\n\n<p>深入理解Java虚拟机 （并不是那么难，Java程序员都该看看） <br>\n（f）性能优化</p>\n\n<p>Java性能优化权威指南 （后面的章节好像用处不大，前面有些部分还是值得看） <br>\n二、算法与数据结构</p>\n\n<p>算法时间复杂度、空间复杂度的基本认知 <br>\n熟悉常用数据结构：链表、队列、散列表、树等； <br>\n递归、分支等基本思想； <br>\n常用算法应用：排序、查找、比较等 <br>\n数据结构与算法分析 （涵盖面比较全、示例是Java语言） <br>\n算法设计与分析基础 （实用主义的典型、偏算法设计） <br>\n编程珠玑 （实践型算法数据） <br>\n三、操作系统</p>\n\n<p>对Linux/OS的基本认知 <br>\nLinux的常用命令 <br>\n鸟哥的Linux私房菜 <br>\nLinux内核设计与实现(原书第3版) （很精炼的语言描述清楚了内核算法） <br>\n四、网络</p>\n\n<p>Http/Https <br>\nTCP/IP <br>\n图解HTTP <br>\n图解TCP/IP <br>\n进阶 <br>\nTCP/IP详解 <br>\n五、Android</p>\n\n<p>四大组件（服务、广播、ContentProvider、页面容器） <br>\n基础UI组件（ListView、ViewPager） <br>\n异步任务机制（AsyncTask、Handler、线程池） <br>\n布局优化（层级、绘制、碎片化处理） <br>\n图片加载（Bitmap、缓冲区） <br>\nUniversalMusicePlayer (通过学习一个音乐播放器的代码能很快了解四大组件) <br>\nAndroid Training官方课程 <br>\nAndroid一些重要知识点解析整理 <br>\nAndroid UI/UX库（各类常用组件及扩展组件的集合） <br>\nPicasso 、 Glide （两个图片加载库） <br>\nThe Google I/O 2015 Android App (Google大会官方的App，适合学习各类实现) <br>\nAndroid开发技术前线 （定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章） <br>\n进阶 <br>\n第三方库集合 （列举了常见的各方向第三方库） <br>\n软件工程</p>\n\n<p>一、基础工具</p>\n\n<p>IDE、Git、Maven <br>\nAndroidStudio <br>\nGit权威指南中文手册 <br>\n二、软件质量</p>\n\n<p>代码整洁 <br>\n码质量 <br>\n码重构 <br>\n编写可读代码的艺术 （来自Google工程师，专注于代码可读性） <br>\n代码整洁之道（使用面向对象+敏捷开发原则编写清晰可维护的代码） <br>\n重构-改善既有代码的设计 （学习改善已有代码） <br>\n重构手册 （改善代码的实际操作） <br>\n三、设计模式</p>\n\n<p>23种常见设计模式 <br>\n大话设计模式 <br>\nHead First设计模式(两本入门级的设计模式书籍) <br>\n进阶 <br>\n设计模式-可复用面向对象软件的基础（设计模式在实际中的应用） <br>\n四、敏捷开发</p>\n\n<p>解析极限编程 <br>\n敏捷开发的艺术 <br>\n进阶 <br>\n敏捷软件开发-原则、模式与实践 <br>\n五、专业开发</p>\n\n<p>序员职业素养 <br>\n更高效、更实效 <br>\n程序员的是职业素养 <br>\n程序员修炼之道-从小工到专家 <br>\n六、思考人生</p>\n\n<p>黑客与画家 (硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52524091', 'title': 'Android Realm初试', 'readNum': '17124', 'commentNum': '3', 'publishTime': '2016-09-13 11:02:10', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>Realm is a mobile database that runs directly inside phones, tablets or wearables. This repository holds the source code for the Java version of Realm, which currently runs only on Android.</p>\n\n<p>Realm是一个移动端的数据库，它可以在手机、平板。穿戴设备上运行。这个仓库的代码是一个Java版本的代码，目前只用在安卓端。</p>\n\n<p>摘自：<a href="https://github.com/realm/realm-java">https://github.com/realm/realm-java</a></p>\n\n<p>导入JAR</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs bash">  compile <span class="hljs-string">\'io.realm:realm-android:0.87.0\'</span>\n</code></pre>\n\n<p>在Application 中配置，不配置也可以，就是默认的哦。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> {</span>\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>() {\n        <span class="hljs-keyword">super</span>.onCreate();\n        initRealm();\n    }\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initRealm</span>(){\n        RealmConfiguration configuration = <span class="hljs-keyword">new</span> RealmConfiguration\n                .Builder(<span class="hljs-keyword">this</span>)\n                .name(<span class="hljs-string">"test.realm"</span>)\n                .deleteRealmIfMigrationNeeded()\n                .schemaVersion(<span class="hljs-number">7</span>).migration(<span class="hljs-keyword">new</span> RealmMigration() {\n\n                    <span class="hljs-annotation">@Override</span>\n                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">migrate</span>(DynamicRealm realm, <span class="hljs-keyword">long</span> oldVersion, <span class="hljs-keyword">long</span> newVersion) {\n\n                    }\n                }).build();\n\n        Realm.setDefaultConfiguration(configuration);\n    }\n}</code></pre>\n\n<p>创建实体类，需集成RealmObject</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">RealmObject</span>{</span>\n    <span class="hljs-annotation">@PrimaryKey</span>\n    <span class="hljs-keyword">private</span> String id;\n    <span class="hljs-keyword">private</span> String userName;\n    <span class="hljs-keyword">private</span> String mobile;\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span>() {\n        <span class="hljs-keyword">return</span> id;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span>(String id) {\n        <span class="hljs-keyword">this</span>.id = id;\n    }\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span>() {\n        <span class="hljs-keyword">return</span> userName;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserName</span>(String userName) {\n        <span class="hljs-keyword">this</span>.userName = userName;\n    }\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getMobile</span>() {\n        <span class="hljs-keyword">return</span> mobile;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobile</span>(String mobile) {\n        <span class="hljs-keyword">this</span>.mobile = mobile;\n    }\n}</code></pre>\n\n<p>在Activity中初始化</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">Realm myRealm ;\n myRealm</span>=<span class="hljs-string"> Realm.getInstance(this);</span></code></pre>\n\n<p>添加数据：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">  //Realm开始处理事物  方式<span class="hljs-number">1</span>：\n        myRealm<span class="hljs-preprocessor">.beginTransaction</span>()<span class="hljs-comment">;</span>\n        User user = myRealm<span class="hljs-preprocessor">.createObject</span>(User<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>\n        user<span class="hljs-preprocessor">.setId</span>(<span class="hljs-string">"445115"</span>)<span class="hljs-comment">;</span>\n        user<span class="hljs-preprocessor">.setMobile</span>(<span class="hljs-string">"44545"</span>)<span class="hljs-comment">;</span>\n        user<span class="hljs-preprocessor">.setUserName</span>(<span class="hljs-string">"hha"</span>)<span class="hljs-comment">;</span>\n        myRealm<span class="hljs-preprocessor">.commitTransaction</span>()<span class="hljs-comment">;</span>\n        //方式<span class="hljs-number">2</span>：\n  User user2=new User()<span class="hljs-comment">;</span>\n        user2<span class="hljs-preprocessor">.setId</span>(<span class="hljs-string">"1123"</span>)<span class="hljs-comment">;</span>\n        user2<span class="hljs-preprocessor">.setUserName</span>(<span class="hljs-string">"sss"</span>)<span class="hljs-comment">;</span>\n        user2<span class="hljs-preprocessor">.setMobile</span>(<span class="hljs-string">"445"</span>)<span class="hljs-comment">;</span>\n        myRealm<span class="hljs-preprocessor">.beginTransaction</span>()<span class="hljs-comment">;</span>\n        User userCopy2 = myRealm<span class="hljs-preprocessor">.copyToRealm</span>(user2)<span class="hljs-comment">;</span>\n        myRealm<span class="hljs-preprocessor">.commitTransaction</span>()<span class="hljs-comment">;</span>\n</code></pre>\n\n<p>查找数据</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> RealmResults&lt;User&gt; listUser = myRealm<span class="hljs-preprocessor">.where</span>(User<span class="hljs-preprocessor">.class</span>)<span class="hljs-preprocessor">.findAll</span>()<span class="hljs-comment">;</span>\n\n        StringBuilder stringBuilder=new StringBuilder()<span class="hljs-comment">;</span>\n\n        for(User u:listUser) {\n            stringBuilder<span class="hljs-preprocessor">.append</span>(u<span class="hljs-preprocessor">.getUserName</span>()+<span class="hljs-string">"--------****--------- "</span>)<span class="hljs-comment">;</span>\n            Log<span class="hljs-preprocessor">.d</span>(<span class="hljs-string">"results1"</span>,u<span class="hljs-preprocessor">.getUserName</span>())<span class="hljs-comment">;</span>\n        }\n        tv<span class="hljs-preprocessor">.setText</span>(stringBuilder<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;</span>\n</code></pre>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>\n\n<p><a href="https://github.com/forezp/RealmJavaTest">源码下载</a></p>\n\n<p><a href="http://blog.csdn.net/forezp">csdn博客</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52550775', 'title': '拍照／选择相册，图片压缩旋转处理', 'readNum': '17076', 'commentNum': '0', 'publishTime': '2016-09-15 20:20:54', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>最近做项目需要用到拍照和选择相册照片，并显示出来imageview 上，然后压缩上传到服务器中，这本是一个非常常见的功能，但对于图片的处理确实一个技术活，稍微不注意会出现oom，图片压缩也要处理的刚刚好，不能浪费用户的流量，也不能过分的压缩使图片失真，这真的不简单，好在开源中国的安卓端app以开源，本人特意从开源中国整理了这个demo，分享给大家。</p>\n\n<p>进入相册选择照片：注意6.0之后要申请运行时权限，即api23。</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "> Intent intent;\n        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">19</span>) {\n            intent = <span class="hljs-keyword">new</span> Intent();\n            intent.setAction(Intent.ACTION_GET_CONTENT);\n            intent.setType(<span class="hljs-string">"image/*"</span>);\n            startActivityForResult(Intent.createChooser(intent, <span class="hljs-string">"选择图片"</span>), ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD);\n        } <span class="hljs-keyword">else</span> {\n            intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n            intent.setType(<span class="hljs-string">"image/*"</span>);\n            startActivityForResult(Intent.createChooser(intent, <span class="hljs-string">"选择图片"</span>), ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD);\n        }</code></pre>\n\n<p>或者拍照：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs lasso">  <span class="hljs-keyword">private</span> <span class="hljs-literal">void</span> toCamera() {\n        <span class="hljs-comment">// 判断是否挂载了SD卡</span>\n        <span class="hljs-built_in">String</span> savePath <span class="hljs-subst">=</span> <span class="hljs-string">""</span>;\n        <span class="hljs-built_in">String</span> storageState <span class="hljs-subst">=</span> Environment<span class="hljs-built_in">.</span>getExternalStorageState();\n        <span class="hljs-keyword">if</span> (storageState<span class="hljs-built_in">.</span><span class="hljs-keyword">equals</span>(Environment<span class="hljs-built_in">.</span>MEDIA_MOUNTED)) {\n            savePath <span class="hljs-subst">=</span> Environment<span class="hljs-built_in">.</span>getExternalStorageDirectory()\n                    <span class="hljs-built_in">.</span>getAbsolutePath() <span class="hljs-subst">+</span> <span class="hljs-string">"/oschina/Camera/"</span>;\n            File savedir <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> File(savePath);\n            <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>savedir<span class="hljs-built_in">.</span>exists()) {\n                savedir<span class="hljs-built_in">.</span>mkdirs();\n            }\n        }\n\n        <span class="hljs-comment">// 没有挂载SD卡，无法保存文件</span>\n        <span class="hljs-keyword">if</span> (TextUtils<span class="hljs-built_in">.</span>isEmpty(savePath)) {\n           <span class="hljs-comment">// AppContext.showToastShort("无法保存照片，请检查SD卡是否挂载");</span>\n            <span class="hljs-keyword">return</span>;\n        }\n\n        <span class="hljs-built_in">String</span> timeStamp <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> SimpleDateFormat(<span class="hljs-string">"yyyyMMddHHmmss"</span>)<span class="hljs-built_in">.</span>format(<span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>());\n        <span class="hljs-built_in">String</span> fileName <span class="hljs-subst">=</span> timeStamp <span class="hljs-subst">+</span> <span class="hljs-string">".jpg"</span>;<span class="hljs-comment">// 照片命名</span>\n        File out <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> File(savePath, fileName);\n        Uri uri <span class="hljs-subst">=</span> Uri<span class="hljs-built_in">.</span>fromFile(out);\n        <span class="hljs-comment">//tweet.setImageFilePath(savePath + fileName); // 该照片的绝对路径</span>\n        mPhotoPath<span class="hljs-subst">=</span>savePath <span class="hljs-subst">+</span> fileName;\n        Intent intent <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> Intent(MediaStore<span class="hljs-built_in">.</span>ACTION_IMAGE_CAPTURE);\n        intent<span class="hljs-built_in">.</span>putExtra(MediaStore<span class="hljs-built_in">.</span>EXTRA_OUTPUT, uri);\n        startActivityForResult(intent, ImageUtils<span class="hljs-built_in">.</span>REQUEST_CODE_GETIMAGE_BYCAMERA);\n    }</code></pre>\n\n<p>在onActivity获取图片信息：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span>(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, Intent data) {\n        <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, data);\n        <span class="hljs-keyword">if</span> (resultCode != Activity.RESULT_OK)\n            <span class="hljs-keyword">return</span>;\n        <span class="hljs-keyword">if</span> (requestCode == ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD) {\n            <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>)\n                <span class="hljs-keyword">return</span>;\n            Uri selectedImageUri = data.getData();\n            <span class="hljs-keyword">if</span> (selectedImageUri != <span class="hljs-keyword">null</span>) {\n                String path = ImageUtils.getImagePath(selectedImageUri, <span class="hljs-keyword">this</span>);\n                setImageFromPath(path);\n            }\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requestCode == ImageUtils.REQUEST_CODE_GETIMAGE_BYCAMERA) {\n            <span class="hljs-comment">//setImageFromPath(tweet.getImageFilePath());</span>\n            setImageFromPath(mPhotoPath);\n\n\n        }\n    }\n</code></pre>\n\n<p>通过返回的uri获取图片路径</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-javadoc">/**\n     * 通过Uri获取文件路径\n     * 支持图片媒体,文件等\n     * &lt;p/&gt;\n     * Author qiujuer@live.cn\n     *\n     *<span class="hljs-javadoctag"> @param</span> uri     Uri\n     *<span class="hljs-javadoctag"> @param</span> context Context\n     *<span class="hljs-javadoctag"> @return</span> 文件路径\n     */</span>\n    <span class="hljs-annotation">@SuppressLint</span>({<span class="hljs-string">"NewApi"</span>, <span class="hljs-string">"Recycle"</span>})\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getImagePath</span>(Uri uri, Context context) {\n        String selection = <span class="hljs-keyword">null</span>;\n        String[] selectionArgs = <span class="hljs-keyword">null</span>;\n        <span class="hljs-comment">// Uri is different in versions after KITKAT (Android 4.4), we need to</span>\n        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">19</span> &amp;&amp; DocumentsContract.isDocumentUri(context.getApplicationContext(), uri)) {\n            String authority = uri.getAuthority();\n            <span class="hljs-keyword">if</span> (<span class="hljs-string">"com.android.externalstorage.documents"</span>.equals(authority)) {\n                <span class="hljs-comment">// isExternalStorageDocument</span>\n                <span class="hljs-keyword">final</span> String docId = DocumentsContract.getDocumentId(uri);\n                <span class="hljs-keyword">final</span> String[] split = docId.split(<span class="hljs-string">":"</span>);\n                <span class="hljs-keyword">return</span> Environment.getExternalStorageDirectory() + <span class="hljs-string">"/"</span> + split[<span class="hljs-number">1</span>];\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"com.android.providers.downloads.documents"</span>.equals(authority)) {\n                <span class="hljs-comment">// isDownloadsDocument</span>\n                <span class="hljs-keyword">final</span> String id = DocumentsContract.getDocumentId(uri);\n                uri = ContentUris.withAppendedId(\n                        Uri.parse(<span class="hljs-string">"content://downloads/public_downloads"</span>), Long.valueOf(id));\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"com.android.providers.media.documents"</span>.equals(authority)) {\n                <span class="hljs-comment">// isMediaDocument</span>\n                <span class="hljs-keyword">final</span> String docId = DocumentsContract.getDocumentId(uri);\n                <span class="hljs-keyword">final</span> String[] split = docId.split(<span class="hljs-string">":"</span>);\n                <span class="hljs-keyword">final</span> String type = split[<span class="hljs-number">0</span>];\n                <span class="hljs-keyword">if</span> (<span class="hljs-string">"image"</span>.equals(type)) {\n                    uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\n                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"video"</span>.equals(type)) {\n                    uri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;\n                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"audio"</span>.equals(type)) {\n                    uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                }\n                selection = <span class="hljs-string">"_id=?"</span>;\n                selectionArgs = <span class="hljs-keyword">new</span> String[]{\n                        split[<span class="hljs-number">1</span>]\n                };\n            }\n        }\n        <span class="hljs-keyword">if</span> (<span class="hljs-string">"content"</span>.equalsIgnoreCase(uri.getScheme())) {\n            String[] projection = {MediaStore.Images.Media.DATA};\n            Cursor cursor = <span class="hljs-keyword">null</span>;\n            <span class="hljs-keyword">try</span> {\n                cursor = context.getContentResolver()\n                        .query(uri, projection, selection, selectionArgs, <span class="hljs-keyword">null</span>);\n                <span class="hljs-keyword">if</span> (cursor != <span class="hljs-keyword">null</span>) {\n                    <span class="hljs-keyword">int</span> column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);\n                    <span class="hljs-keyword">if</span> (cursor.moveToFirst()) {\n                        <span class="hljs-keyword">return</span> cursor.getString(column_index);\n                    }\n                }\n            } <span class="hljs-keyword">catch</span> (Exception e) {\n                e.fillInStackTrace();\n            } <span class="hljs-keyword">finally</span> {\n                <span class="hljs-keyword">if</span> (cursor != <span class="hljs-keyword">null</span>)\n                    cursor.close();\n            }\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"file"</span>.equalsIgnoreCase(uri.getScheme())) {\n            <span class="hljs-keyword">return</span> uri.getPath();\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n    }</code></pre>\n\n<p>根据图片地址去获取bitmap这时需要自己传入图片的大小即高度和宽度，根据自己的需求去传。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">Bitmap bitmap </span>=<span class="hljs-string"> BitmapCreate.bitmapFromStream(new FileInputStream(path), 512, 512);</span></code></pre>\n\n<p>图片压缩</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java">\n  <span class="hljs-javadoc">/**\n     * 获取一个指定大小的bitmap&lt;br&gt;\n     * 实际调用的方法是bitmapFromByteArray(data, 0, data.length, w, h);\n     *\n     *<span class="hljs-javadoctag"> @param</span> is        从输入流中读取Bitmap\n     *<span class="hljs-javadoctag"> @param</span> reqWidth  目标宽度\n     *<span class="hljs-javadoctag"> @param</span> reqHeight 目标高度\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">bitmapFromStream</span>(InputStream is, <span class="hljs-keyword">int</span> reqWidth,\n                                          <span class="hljs-keyword">int</span> reqHeight) {\n        <span class="hljs-keyword">if</span> (reqHeight == <span class="hljs-number">0</span> || reqWidth == <span class="hljs-number">0</span>) {\n            <span class="hljs-keyword">try</span> {\n                <span class="hljs-keyword">return</span> BitmapFactory.decodeStream(is);\n            } <span class="hljs-keyword">catch</span> (OutOfMemoryError e) {\n            }\n        }\n        <span class="hljs-keyword">byte</span>[] data = FileUtils.input2byte(is);\n        <span class="hljs-keyword">return</span> bitmapFromByteArray(data, <span class="hljs-number">0</span>, data.length, reqWidth, reqHeight);\n    }\n\n    <span class="hljs-javadoc">/**\n     * 获取一个指定大小的bitmap\n     *\n     *<span class="hljs-javadoctag"> @param</span> data      Bitmap的byte数组\n     *<span class="hljs-javadoctag"> @param</span> offset    image从byte数组创建的起始位置\n     *<span class="hljs-javadoctag"> @param</span> length    the number of bytes, 从offset处开始的长度\n     *<span class="hljs-javadoctag"> @param</span> reqWidth  目标宽度\n     *<span class="hljs-javadoctag"> @param</span> reqHeight 目标高度\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">bitmapFromByteArray</span>(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">int</span> offset,\n                                             <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight) {\n        <span class="hljs-keyword">if</span> (reqHeight == <span class="hljs-number">0</span> || reqWidth == <span class="hljs-number">0</span>) {\n            <span class="hljs-keyword">try</span> {\n                <span class="hljs-keyword">return</span> BitmapFactory.decodeByteArray(data, offset, length);\n            } <span class="hljs-keyword">catch</span> (OutOfMemoryError e) {\n            }\n        }\n        BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();\n        options.inJustDecodeBounds = <span class="hljs-keyword">true</span>;\n        options.inPurgeable = <span class="hljs-keyword">true</span>;\n        BitmapFactory.decodeByteArray(data, offset, length, options);\n        options = calculateInSampleSize(options, reqWidth, reqHeight);\n        <span class="hljs-keyword">return</span> BitmapFactory.decodeByteArray(data, offset, length, options);\n    }\n\n    <span class="hljs-javadoc">/**\n     * 图片压缩处理（使用Options的方法）\n     * &lt;br&gt;\n     * &lt;b&gt;说明&lt;/b&gt; 使用方法：\n     * 首先你要将Options的inJustDecodeBounds属性设置为true，BitmapFactory.decode一次图片 。\n     * 然后将Options连同期望的宽度和高度一起传递到到本方法中。\n     * 之后再使用本方法的返回值做参数调用BitmapFactory.decode创建图片。\n     * &lt;br&gt;\n     * &lt;b&gt;说明&lt;/b&gt; BitmapFactory创建bitmap会尝试为已经构建的bitmap分配内存\n     * ，这时就会很容易导致OOM出现。为此每一种创建方法都提供了一个可选的Options参数\n     * ，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存\n     * ，返回值也不再是一个Bitmap对象， 而是null。虽然Bitmap是null了，但是Options的outWidth、\n     * outHeight和outMimeType属性都会被赋值。\n     *\n     *<span class="hljs-javadoctag"> @param</span> reqWidth  目标宽度,这里的宽高只是阀值，实际显示的图片将小于等于这个值\n     *<span class="hljs-javadoctag"> @param</span> reqHeight 目标高度,这里的宽高只是阀值，实际显示的图片将小于等于这个值\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BitmapFactory.Options <span class="hljs-title">calculateInSampleSize</span>(\n            <span class="hljs-keyword">final</span> BitmapFactory.Options options, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> reqWidth,\n            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> reqHeight) {\n        <span class="hljs-comment">// 源图片的高度和宽度</span>\n        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = options.outHeight;\n        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = options.outWidth;\n        <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;\n        <span class="hljs-keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) {\n            <span class="hljs-comment">// 计算出实际宽高和目标宽高的比率</span>\n            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightRatio = Math.round((<span class="hljs-keyword">float</span>) height\n                    / (<span class="hljs-keyword">float</span>) reqHeight);\n            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthRatio = Math.round((<span class="hljs-keyword">float</span>) width / (<span class="hljs-keyword">float</span>) reqWidth);\n            <span class="hljs-comment">// 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span>\n            <span class="hljs-comment">// 一定都会大于等于目标的宽和高。</span>\n            inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;\n        }\n        <span class="hljs-comment">// 设置压缩比例</span>\n        options.inSampleSize = inSampleSize;\n        options.inJustDecodeBounds = <span class="hljs-keyword">false</span>;\n        <span class="hljs-keyword">return</span> options;\n    }</code></pre>\n\n<p>将压缩后的bitmap存在sdcard中，待会儿要上传到服务器中。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java">  <span class="hljs-javadoc">/**\n     * 图片写入文件\n     *\n     *<span class="hljs-javadoctag"> @param</span> bitmap\n     *            图片\n     *<span class="hljs-javadoctag"> @param</span> filePath\n     *            文件路径\n     *<span class="hljs-javadoctag"> @return</span> 是否写入成功\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">bitmapToFile</span>(Bitmap bitmap, String filePath) {\n        <span class="hljs-keyword">boolean</span> isSuccess = <span class="hljs-keyword">false</span>;\n        <span class="hljs-keyword">if</span> (bitmap == <span class="hljs-keyword">null</span>) {\n            <span class="hljs-keyword">return</span> isSuccess;\n        }\n        File file = <span class="hljs-keyword">new</span> File(filePath.substring(<span class="hljs-number">0</span>,\n                filePath.lastIndexOf(File.separator)));\n        <span class="hljs-keyword">if</span> (!file.exists()) {\n            file.mkdirs();\n        }\n\n        OutputStream out = <span class="hljs-keyword">null</span>;\n        <span class="hljs-keyword">try</span> {\n            out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(filePath),\n                    <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>);\n            isSuccess = bitmap.compress(Bitmap.CompressFormat.PNG, <span class="hljs-number">100</span>, out);\n        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {\n            e.printStackTrace();\n        } <span class="hljs-keyword">finally</span> {\n            closeIO(out);\n        }\n        <span class="hljs-keyword">return</span> isSuccess;\n    }\n</code></pre>\n\n<p>将压缩后的bitmap 根据需求进一步缩放，显示在imageview上。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-javadoc">/**\n     * 放大缩小图片\n     *\n     *<span class="hljs-javadoctag"> @param</span> bitmap\n     *<span class="hljs-javadoctag"> @param</span> w\n     *<span class="hljs-javadoctag"> @param</span> h\n     *<span class="hljs-javadoctag"> @return</span>\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">zoomBitmap</span>(Bitmap bitmap, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h) {\n        Bitmap newbmp = <span class="hljs-keyword">null</span>;\n        <span class="hljs-keyword">if</span> (bitmap != <span class="hljs-keyword">null</span>) {\n            <span class="hljs-keyword">int</span> width = bitmap.getWidth();\n            <span class="hljs-keyword">int</span> height = bitmap.getHeight();\n            Matrix matrix = <span class="hljs-keyword">new</span> Matrix();\n            <span class="hljs-keyword">float</span> scaleWidht = ((<span class="hljs-keyword">float</span>) w / width);\n            <span class="hljs-keyword">float</span> scaleHeight = ((<span class="hljs-keyword">float</span>) h / height);\n            matrix.postScale(scaleWidht, scaleHeight);\n            newbmp = Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height, matrix,\n                    <span class="hljs-keyword">true</span>);\n        }\n        <span class="hljs-keyword">return</span> newbmp;\n    }\n</code></pre>\n\n<p>在拍照的过程中，有的机型照片会倒转，这是需要处理一下即可</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**\n     * 读取图片属性：旋转的角度\n     *<span class="hljs-javadoctag"> @param</span> path 图片绝对路径\n     *<span class="hljs-javadoctag"> @return</span> degree旋转的角度\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readPictureDegree</span>(String path) {\n        <span class="hljs-keyword">int</span> degree  = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">try</span> {\n            ExifInterface exifInterface = <span class="hljs-keyword">new</span> ExifInterface(path);\n            <span class="hljs-keyword">int</span> orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\n            <span class="hljs-keyword">switch</span> (orientation) {\n                <span class="hljs-keyword">case</span> ExifInterface.ORIENTATION_ROTATE_90:\n                    degree = <span class="hljs-number">90</span>;\n                    <span class="hljs-keyword">break</span>;\n                <span class="hljs-keyword">case</span> ExifInterface.ORIENTATION_ROTATE_180:\n                    degree = <span class="hljs-number">180</span>;\n                    <span class="hljs-keyword">break</span>;\n                <span class="hljs-keyword">case</span> ExifInterface.ORIENTATION_ROTATE_270:\n                    degree = <span class="hljs-number">270</span>;\n                    <span class="hljs-keyword">break</span>;\n            }\n        } <span class="hljs-keyword">catch</span> (IOException e) {\n            e.printStackTrace();\n        }\n        <span class="hljs-keyword">return</span> degree;\n    }\n\n    <span class="hljs-javadoc">/**\n     * 旋转图片\n     *<span class="hljs-javadoctag"> @param</span> angle\n     *<span class="hljs-javadoctag"> @param</span> bitmap\n     *<span class="hljs-javadoctag"> @return</span>\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">rotaingImageView</span>(<span class="hljs-keyword">int</span> angle , Bitmap bitmap) {\n        <span class="hljs-comment">//旋转图片 动作</span>\n        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();\n        matrix.postRotate(angle);\n        System.out.println(<span class="hljs-string">"angle2="</span> + angle);\n        <span class="hljs-comment">// 创建新的图片</span>\n        Bitmap resizedBitmap = Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,\n                bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="hljs-keyword">true</span>);\n        <span class="hljs-keyword">return</span> resizedBitmap;\n    }</code></pre>\n\n<p>这些代码百分之七八十来自开源中国。感谢原作者。</p>\n\n<p><a href="https://github.com/forezp/SelectPicAndCamera">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52459555', 'title': 'NestedScrollView和RecyclerView使用，并设置间距', 'readNum': '17226', 'commentNum': '0', 'publishTime': '2016-09-07 14:49:22', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>NestedScrollView和RecyclerView使用，并设置间距: <br>\n效果图如下： <br>\n<img src="http://oaurstf0m.bkt.clouddn.com/DEREEE360.gif" alt="这里写图片描述" title=""> <br>\n1.NestedScrollView 和RecyclerView嵌套问题（类似ScrollView 和listView）\\ <br>\n需重写 RecyclerView  的  GridLayoutManager(还有另外2种，随便搜下就有)</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FullyGridLayoutManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GridLayoutManager</span> {</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-title">FullyGridLayoutManager</span>(Context context, <span class="hljs-keyword">int</span> spanCount) {\n        <span class="hljs-keyword">super</span>(context, spanCount);\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">FullyGridLayoutManager</span>(Context context, <span class="hljs-keyword">int</span> spanCount, <span class="hljs-keyword">int</span> orientation, <span class="hljs-keyword">boolean</span> reverseLayout) {\n        <span class="hljs-keyword">super</span>(context, spanCount, orientation, reverseLayout);\n    }\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] mMeasuredDimension = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span>(RecyclerView.Recycler recycler, RecyclerView.State state, <span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec) {\n        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthMode = View.MeasureSpec.getMode(widthSpec);\n        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightMode = View.MeasureSpec.getMode(heightSpec);\n        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSize = View.MeasureSpec.getSize(widthSpec);\n        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSize = View.MeasureSpec.getSize(heightSpec);\n\n        <span class="hljs-keyword">int</span> width = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">int</span> height = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">int</span> count = getItemCount();\n        <span class="hljs-keyword">int</span> span = getSpanCount();\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {\n            measureScrapChild(recycler, i,\n                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),\n                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),\n                    mMeasuredDimension);\n\n            <span class="hljs-keyword">if</span> (getOrientation() == HORIZONTAL) {\n                <span class="hljs-keyword">if</span> (i % span == <span class="hljs-number">0</span>) {\n                    width = width + mMeasuredDimension[<span class="hljs-number">0</span>];\n                }\n                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {\n                    height = mMeasuredDimension[<span class="hljs-number">1</span>];\n                }\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-keyword">if</span> (i % span == <span class="hljs-number">0</span>) {\n                    height = height + mMeasuredDimension[<span class="hljs-number">1</span>];\n                }\n                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {\n                    width = mMeasuredDimension[<span class="hljs-number">0</span>];\n                }\n            }\n        }\n\n        <span class="hljs-keyword">switch</span> (widthMode) {\n            <span class="hljs-keyword">case</span> View.MeasureSpec.EXACTLY:\n                width = widthSize;\n            <span class="hljs-keyword">case</span> View.MeasureSpec.AT_MOST:\n            <span class="hljs-keyword">case</span> View.MeasureSpec.UNSPECIFIED:\n        }\n\n        <span class="hljs-keyword">switch</span> (heightMode) {\n            <span class="hljs-keyword">case</span> View.MeasureSpec.EXACTLY:\n                height = heightSize;\n            <span class="hljs-keyword">case</span> View.MeasureSpec.AT_MOST:\n            <span class="hljs-keyword">case</span> View.MeasureSpec.UNSPECIFIED:\n        }\n\n        setMeasuredDimension(width, height);\n    }\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureScrapChild</span>(RecyclerView.Recycler recycler, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> widthSpec,\n                                   <span class="hljs-keyword">int</span> heightSpec, <span class="hljs-keyword">int</span>[] measuredDimension) {\n        <span class="hljs-keyword">if</span> (position &lt; getItemCount()) {\n            <span class="hljs-keyword">try</span> {\n                View view = recycler.getViewForPosition(<span class="hljs-number">0</span>);<span class="hljs-comment">//fix 动态添加时报IndexOutOfBoundsException</span>\n                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) {\n                    RecyclerView.LayoutParams p = (RecyclerView.LayoutParams) view.getLayoutParams();\n                    <span class="hljs-keyword">int</span> childWidthSpec = ViewGroup.getChildMeasureSpec(widthSpec,\n                            getPaddingLeft() + getPaddingRight(), p.width);\n                    <span class="hljs-keyword">int</span> childHeightSpec = ViewGroup.getChildMeasureSpec(heightSpec,\n                            getPaddingTop() + getPaddingBottom(), p.height);\n                    view.measure(childWidthSpec, childHeightSpec);\n                    measuredDimension[<span class="hljs-number">0</span>] = view.getMeasuredWidth() + p.leftMargin + p.rightMargin;\n                    measuredDimension[<span class="hljs-number">1</span>] = view.getMeasuredHeight() + p.bottomMargin + p.topMargin;\n                    recycler.recycleView(view);\n                }\n            } <span class="hljs-keyword">catch</span> (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n\n<p>重写NestedScrollView,实际上是NestedScrollView禁止滑动</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNestedScrollView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NestedScrollView</span> {</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> downX;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> downY;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mTouchSlop;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">MyNestedScrollView</span>(Context context) {\n        <span class="hljs-keyword">super</span>(context);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">MyNestedScrollView</span>(Context context, AttributeSet attrs) {\n        <span class="hljs-keyword">super</span>(context, attrs);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">MyNestedScrollView</span>(Context context, AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr) {\n        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span>(MotionEvent e) {\n        <span class="hljs-keyword">int</span> action = e.getAction();\n        <span class="hljs-keyword">switch</span> (action) {\n            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:\n                downX = (<span class="hljs-keyword">int</span>) e.getRawX();\n                downY = (<span class="hljs-keyword">int</span>) e.getRawY();\n                <span class="hljs-keyword">break</span>;\n            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:\n                <span class="hljs-keyword">int</span> moveY = (<span class="hljs-keyword">int</span>) e.getRawY();\n                <span class="hljs-keyword">if</span> (Math.abs(moveY - downY) &gt; mTouchSlop) {\n                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n                }\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onInterceptTouchEvent(e);\n    }\n}\n</code></pre>\n\n<p>让recyclerView滑动</p>\n\n<p>“`java <br>\n   recyclerView.setNestedScrollingEnabled(false);</p>\n\n<p>“` <br>\n 给recyclerView创建Adapter</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> DemoAdapter extends RecyclerView.Adapter&lt;DemoViewHolder&gt; {\n    <span class="hljs-keyword">private</span> ArrayList&lt;String&gt; list;\n    <span class="hljs-keyword">public</span> Context mContext;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">DemoAdapter</span>(Context mContext) {\n        <span class="hljs-keyword">this</span>.mContext=mContext;\n    }\n    @Override\n    <span class="hljs-keyword">public</span> DemoViewHolder <span class="hljs-title">onCreateViewHolder</span>(ViewGroup parent, <span class="hljs-keyword">int</span> viewType) {\n        View mView = LayoutInflater.<span class="hljs-keyword">from</span>(mContext).inflate(R.layout.item_viewholder, parent, <span class="hljs-keyword">false</span>);\n        DemoViewHolder mViewHolder = <span class="hljs-keyword">new</span> DemoViewHolder(mView);\n        <span class="hljs-keyword">return</span> mViewHolder;\n    }\n\n    @Override\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span>(DemoViewHolder holder, <span class="hljs-keyword">int</span> position) {\n        Glide.with(mContext).load(<span class="hljs-string">"http://img.nongshanghang.cn/allimg/160906/22435210b_1.jpg"</span>).<span class="hljs-keyword">into</span>(  holder.imageView);\n    }\n\n    @Override\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span>() {\n        <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;\n    }\n}\n</code></pre>\n\n<p>Viewholder 部分</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> {</span>\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">DemoViewHolder</span>(View itemView) {\n        <span class="hljs-keyword">super</span>(itemView);\n        imageView=(ImageView)itemView.findViewById(R.id.imageview);\n    }\n    <span class="hljs-keyword">public</span> ImageView imageView;\n}\n</code></pre>\n\n<p>设置RecyclerView 的item间距</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpacesItemDecoration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ItemDecoration</span>  {</span>\n\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> left;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> right;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bottom;\n    <span class="hljs-keyword">public</span> <span class="hljs-title">SpacesItemDecoration</span>(<span class="hljs-keyword">int</span> space) {\n        <span class="hljs-keyword">this</span>.left=space;\n        <span class="hljs-keyword">this</span>.right=space;\n        <span class="hljs-keyword">this</span>.top=space;\n        <span class="hljs-keyword">this</span>.bottom=space;\n\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">SpacesItemDecoration</span>(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> top,<span class="hljs-keyword">int</span> bottom) {\n        <span class="hljs-keyword">this</span>.left=left;\n        <span class="hljs-keyword">this</span>.right=right;\n        <span class="hljs-keyword">this</span>.top=top;\n        <span class="hljs-keyword">this</span>.bottom=bottom;\n\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getItemOffsets</span>(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n        outRect.left=left;\n        outRect.right=right;\n        outRect.bottom=bottom;\n        outRect.top=top;\n\n    }\n}\n</code></pre>\n\n<p>最后设置</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">   recyclerView=(RecyclerView)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.recyclerview</span>)<span class="hljs-comment">;</span>\n        recyclerView<span class="hljs-preprocessor">.setNestedScrollingEnabled</span>(false)<span class="hljs-comment">;</span>\n        layoutManager=new FullyGridLayoutManager(this,<span class="hljs-number">3</span>,GridLayoutManager<span class="hljs-preprocessor">.VERTICAL</span>,false)<span class="hljs-comment">;</span>\n        adpater=new DemoAdapter(this)<span class="hljs-comment">;</span>\n        recyclerView<span class="hljs-preprocessor">.setAdapter</span>(adpater)<span class="hljs-comment">;</span>\n        recyclerView<span class="hljs-preprocessor">.setLayoutManager</span>(layoutManager)<span class="hljs-comment">;</span>\n        SpacesItemDecoration decoration<span class="hljs-comment">;</span>\n        //  if (Integer<span class="hljs-preprocessor">.parseInt</span>(android<span class="hljs-preprocessor">.os</span><span class="hljs-preprocessor">.Build</span><span class="hljs-preprocessor">.VERSION</span><span class="hljs-preprocessor">.SDK</span>) &gt;= <span class="hljs-number">19</span>) {\n        //     decoration = new SpacesItemDecoration(ScreenUtils<span class="hljs-preprocessor">.dipToPx</span>(getActivity(), <span class="hljs-number">4</span>), ScreenUtils<span class="hljs-preprocessor">.dipToPx</span>(getActivity(), <span class="hljs-number">4</span>), ScreenUtils<span class="hljs-preprocessor">.dipToPx</span>(getActivity(), <span class="hljs-number">0</span>), ScreenUtils<span class="hljs-preprocessor">.dipToPx</span>(getActivity(), <span class="hljs-number">8</span>))<span class="hljs-comment">;</span>\n        //   }else{\n        decoration = new SpacesItemDecoration(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">;</span>\n        //  }\n        recyclerView<span class="hljs-preprocessor">.addItemDecoration</span>(decoration)<span class="hljs-comment">;</span>\n        adpater<span class="hljs-preprocessor">.notifyDataSetChanged</span>()<span class="hljs-comment">;</span>\n</code></pre>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9624181">源码下载</a></p>\n\n<p><a href="http://blog.csdn.net/forezp">csdn博客</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52250018', 'title': 'android 圆角图片的实现形式', 'readNum': '16862', 'commentNum': '1', 'publishTime': '2016-08-19 13:40:45', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>android 圆角图片的实现形式，包括用第三方、也有系统的。比如makeramen:roundedimageview，系统的cardview ， glide .fresco 。</p>\n\n<p><img src="https://img-blog.csdn.net/20160819134250608" alt="这里写图片描述" title=""></p>\n\n<pre class="prettyprint"><code class=" hljs bash"> compile <span class="hljs-string">\'com.android.support:appcompat-v7:24.0.0\'</span>\n    compile <span class="hljs-string">\'com.makeramen:roundedimageview:2.2.1\'</span>\n    compile <span class="hljs-string">\'com.android.support:cardview-v7:24.0.0\'</span>\n    compile <span class="hljs-string">\'com.github.bumptech.glide:glide:3.7.0\'</span>\n    compile <span class="hljs-string">\'com.facebook.fresco:fresco:0.12.0\'</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">&lt;android<span class="hljs-preprocessor">.support</span><span class="hljs-preprocessor">.v</span>7<span class="hljs-preprocessor">.widget</span><span class="hljs-preprocessor">.CardView</span>\n    xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>\n    xmlns:app=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>\n    android:id=<span class="hljs-string">"@+id/id_cardview"</span>\n    android:layout_width=<span class="hljs-string">"match_parent"</span>\n    android:layout_height=<span class="hljs-string">"wrap_content"</span>\n    android:layout_gravity=<span class="hljs-string">"center_horizontal"</span>\n    app:cardBackgroundColor=<span class="hljs-string">"@color/bg_light_gray"</span>\n    app:cardCornerRadius=<span class="hljs-string">"3dp"</span>\n    app:cardUseCompatPadding=<span class="hljs-string">"false"</span>\n    app:cardPreventCornerOverlap=<span class="hljs-string">"true"</span>\n\n    &gt;\n    &lt;ImageView\n        android:id=<span class="hljs-string">"@+id/iv_subject"</span>\n        android:gravity=<span class="hljs-string">"center"</span>\n        android:scaleType=<span class="hljs-string">"centerCrop"</span>\n        android:layout_width=<span class="hljs-string">"match_parent"</span>\n        android:layout_height=<span class="hljs-string">"200dp"</span> /&gt;\n\n    &lt;TextView\n        android:paddingLeft=<span class="hljs-string">"5dp"</span>\n        android:paddingBottom=<span class="hljs-string">"5dp"</span>\n        android:background=<span class="hljs-string">"@drawable/bg_biaoti"</span>\n        android:id=<span class="hljs-string">"@+id/tv_subject"</span>\n        android:gravity=<span class="hljs-string">"center_vertical"</span>\n        android:text=<span class="hljs-string">""</span>\n        android:ellipsize=<span class="hljs-string">"end"</span>\n        android:singleLine=<span class="hljs-string">"true"</span>\n        android:textSize=<span class="hljs-string">"13sp"</span>\n        android:textColor=<span class="hljs-string">"@color/white"</span>\n        android:layout_gravity=<span class="hljs-string">"bottom"</span>\n        android:layout_width=<span class="hljs-string">"match_parent"</span>\n        android:layout_height=<span class="hljs-string">"wrap_content"</span> /&gt;\n\n&lt;/android<span class="hljs-preprocessor">.support</span><span class="hljs-preprocessor">.v</span>7<span class="hljs-preprocessor">.widget</span><span class="hljs-preprocessor">.CardView</span>&gt;</code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">\n iv_round=(RoundedImageView) findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.iv</span>_round)<span class="hljs-comment">;</span>\n Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_round)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> iv_cardview=(ImageView)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.iv</span>_cardview)<span class="hljs-comment">;</span>\n   Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_cardview)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">   iv_fresco=(SimpleDraweeView)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.iv</span>_fresco)<span class="hljs-comment">;</span>\n        Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_round)<span class="hljs-comment">;</span>\n        Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_cardview)<span class="hljs-comment">;</span>\n        Uri uri = Uri<span class="hljs-preprocessor">.parse</span>(url)<span class="hljs-comment">;</span>\n        iv_fresco<span class="hljs-preprocessor">.setImageURI</span>(uri)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> roundimageview.forezp.com.roundimageview;\n\n<span class="hljs-keyword">import</span> android.content.Context;\n<span class="hljs-keyword">import</span> android.content.res.Resources;\n<span class="hljs-keyword">import</span> android.graphics.Bitmap;\n<span class="hljs-keyword">import</span> android.graphics.BitmapShader;\n<span class="hljs-keyword">import</span> android.graphics.Canvas;\n<span class="hljs-keyword">import</span> android.graphics.Paint;\n<span class="hljs-keyword">import</span> android.graphics.RectF;\n\n<span class="hljs-keyword">import</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;\n<span class="hljs-keyword">import</span> com.bumptech.glide.load.resource.bitmap.BitmapTransformation;\n\n<span class="hljs-javadoc">/**\n * Created by Administrator on 2016/8/19 0019.\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">GlideRoundTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BitmapTransformation</span> {</span>\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> radius = <span class="hljs-number">0</span>f;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">GlideRoundTransform</span>(Context context) {\n        <span class="hljs-keyword">this</span>(context, <span class="hljs-number">4</span>);\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">GlideRoundTransform</span>(Context context, <span class="hljs-keyword">int</span> dp) {\n        <span class="hljs-keyword">super</span>(context);\n        <span class="hljs-keyword">this</span>.radius = Resources.getSystem().getDisplayMetrics().density * dp;\n    }\n\n    <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">protected</span> Bitmap <span class="hljs-title">transform</span>(BitmapPool pool, Bitmap toTransform, <span class="hljs-keyword">int</span> outWidth, <span class="hljs-keyword">int</span> outHeight) {\n        <span class="hljs-keyword">return</span> roundCrop(pool, toTransform);\n    }\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">roundCrop</span>(BitmapPool pool, Bitmap source) {\n        <span class="hljs-keyword">if</span> (source == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n\n        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {\n            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = <span class="hljs-keyword">new</span> Canvas(result);\n        Paint paint = <span class="hljs-keyword">new</span> Paint();\n        paint.setShader(<span class="hljs-keyword">new</span> BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(<span class="hljs-keyword">true</span>);\n        RectF rectF = <span class="hljs-keyword">new</span> RectF(<span class="hljs-number">0</span>f, <span class="hljs-number">0</span>f, source.getWidth(), source.getHeight());\n        canvas.drawRoundRect(rectF, radius, radius, paint);\n        <span class="hljs-keyword">return</span> result;\n    }\n\n    <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span>() {\n        <span class="hljs-keyword">return</span> getClass().getName() + Math.round(radius);\n    }\n}\n</code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">    Glide.with(<span class="hljs-keyword">this</span>).load(url).transform(<span class="hljs-keyword">new</span> GlideRoundTransform(<span class="hljs-keyword">this</span>,<span class="hljs-number">6</span>)).<span class="hljs-keyword">into</span>(iv_glide);</code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52249514', 'title': 'android 圆角图片的实现形式', 'readNum': '16199', 'commentNum': '0', 'publishTime': '2016-08-19 12:10:33', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <pre class="prettyprint"><code class=" hljs bash"> compile <span class="hljs-string">\'com.android.support:appcompat-v7:24.0.0\'</span>\n    compile <span class="hljs-string">\'com.makeramen:roundedimageview:2.2.1\'</span>\n    compile <span class="hljs-string">\'com.android.support:cardview-v7:24.0.0\'</span>\n    compile <span class="hljs-string">\'com.github.bumptech.glide:glide:3.7.0\'</span>\n    compile <span class="hljs-string">\'com.facebook.fresco:fresco:0.12.0\'</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">&lt;android<span class="hljs-preprocessor">.support</span><span class="hljs-preprocessor">.v</span>7<span class="hljs-preprocessor">.widget</span><span class="hljs-preprocessor">.CardView</span>\n    xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>\n    xmlns:app=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>\n    android:id=<span class="hljs-string">"@+id/id_cardview"</span>\n    android:layout_width=<span class="hljs-string">"match_parent"</span>\n    android:layout_height=<span class="hljs-string">"wrap_content"</span>\n    android:layout_gravity=<span class="hljs-string">"center_horizontal"</span>\n    app:cardBackgroundColor=<span class="hljs-string">"@color/bg_light_gray"</span>\n    app:cardCornerRadius=<span class="hljs-string">"3dp"</span>\n    app:cardUseCompatPadding=<span class="hljs-string">"false"</span>\n    app:cardPreventCornerOverlap=<span class="hljs-string">"true"</span>\n\n    &gt;\n    &lt;ImageView\n        android:id=<span class="hljs-string">"@+id/iv_subject"</span>\n        android:gravity=<span class="hljs-string">"center"</span>\n        android:scaleType=<span class="hljs-string">"centerCrop"</span>\n        android:layout_width=<span class="hljs-string">"match_parent"</span>\n        android:layout_height=<span class="hljs-string">"200dp"</span> /&gt;\n\n    &lt;TextView\n        android:paddingLeft=<span class="hljs-string">"5dp"</span>\n        android:paddingBottom=<span class="hljs-string">"5dp"</span>\n        android:background=<span class="hljs-string">"@drawable/bg_biaoti"</span>\n        android:id=<span class="hljs-string">"@+id/tv_subject"</span>\n        android:gravity=<span class="hljs-string">"center_vertical"</span>\n        android:text=<span class="hljs-string">""</span>\n        android:ellipsize=<span class="hljs-string">"end"</span>\n        android:singleLine=<span class="hljs-string">"true"</span>\n        android:textSize=<span class="hljs-string">"13sp"</span>\n        android:textColor=<span class="hljs-string">"@color/white"</span>\n        android:layout_gravity=<span class="hljs-string">"bottom"</span>\n        android:layout_width=<span class="hljs-string">"match_parent"</span>\n        android:layout_height=<span class="hljs-string">"wrap_content"</span> /&gt;\n\n&lt;/android<span class="hljs-preprocessor">.support</span><span class="hljs-preprocessor">.v</span>7<span class="hljs-preprocessor">.widget</span><span class="hljs-preprocessor">.CardView</span>&gt;</code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">\n iv_round=(RoundedImageView) findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.iv</span>_round)<span class="hljs-comment">;</span>\n Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_round)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> iv_cardview=(ImageView)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.iv</span>_cardview)<span class="hljs-comment">;</span>\n   Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_cardview)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">   iv_fresco=(SimpleDraweeView)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.iv</span>_fresco)<span class="hljs-comment">;</span>\n        Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_round)<span class="hljs-comment">;</span>\n        Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(url)<span class="hljs-preprocessor">.into</span>(iv_cardview)<span class="hljs-comment">;</span>\n        Uri uri = Uri<span class="hljs-preprocessor">.parse</span>(url)<span class="hljs-comment">;</span>\n        iv_fresco<span class="hljs-preprocessor">.setImageURI</span>(uri)<span class="hljs-comment">;</span></code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> roundimageview.forezp.com.roundimageview;\n\n<span class="hljs-keyword">import</span> android.content.Context;\n<span class="hljs-keyword">import</span> android.content.res.Resources;\n<span class="hljs-keyword">import</span> android.graphics.Bitmap;\n<span class="hljs-keyword">import</span> android.graphics.BitmapShader;\n<span class="hljs-keyword">import</span> android.graphics.Canvas;\n<span class="hljs-keyword">import</span> android.graphics.Paint;\n<span class="hljs-keyword">import</span> android.graphics.RectF;\n\n<span class="hljs-keyword">import</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;\n<span class="hljs-keyword">import</span> com.bumptech.glide.load.resource.bitmap.BitmapTransformation;\n\n<span class="hljs-javadoc">/**\n * Created by Administrator on 2016/8/19 0019.\n */</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">GlideRoundTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BitmapTransformation</span> {</span>\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> radius = <span class="hljs-number">0</span>f;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">GlideRoundTransform</span>(Context context) {\n        <span class="hljs-keyword">this</span>(context, <span class="hljs-number">4</span>);\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">GlideRoundTransform</span>(Context context, <span class="hljs-keyword">int</span> dp) {\n        <span class="hljs-keyword">super</span>(context);\n        <span class="hljs-keyword">this</span>.radius = Resources.getSystem().getDisplayMetrics().density * dp;\n    }\n\n    <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">protected</span> Bitmap <span class="hljs-title">transform</span>(BitmapPool pool, Bitmap toTransform, <span class="hljs-keyword">int</span> outWidth, <span class="hljs-keyword">int</span> outHeight) {\n        <span class="hljs-keyword">return</span> roundCrop(pool, toTransform);\n    }\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">roundCrop</span>(BitmapPool pool, Bitmap source) {\n        <span class="hljs-keyword">if</span> (source == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n\n        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {\n            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = <span class="hljs-keyword">new</span> Canvas(result);\n        Paint paint = <span class="hljs-keyword">new</span> Paint();\n        paint.setShader(<span class="hljs-keyword">new</span> BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(<span class="hljs-keyword">true</span>);\n        RectF rectF = <span class="hljs-keyword">new</span> RectF(<span class="hljs-number">0</span>f, <span class="hljs-number">0</span>f, source.getWidth(), source.getHeight());\n        canvas.drawRoundRect(rectF, radius, radius, paint);\n        <span class="hljs-keyword">return</span> result;\n    }\n\n    <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span>() {\n        <span class="hljs-keyword">return</span> getClass().getName() + Math.round(radius);\n    }\n}\n</code></pre>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">    Glide.with(<span class="hljs-keyword">this</span>).load(url).transform(<span class="hljs-keyword">new</span> GlideRoundTransform(<span class="hljs-keyword">this</span>,<span class="hljs-number">6</span>)).<span class="hljs-keyword">into</span>(iv_glide);</code></pre>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52247793', 'title': '拆掉思维的墙', 'readNum': '17925', 'commentNum': '2', 'publishTime': '2016-08-19 09:45:19', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>你是不是在追求安全感？</p>\n\n<p>思维有时候给我们太多的禁锢，安全感就是其一。为了生活安全感，有人放弃了梦想；为了职业安全感，有人放弃了多样的可能；为了爱的安全感，有人放弃了真正的人生。 <br>\n安全感的需要源自我们内在的恐惧。恐惧有三层： <br>\n第一层是恐惧做不成某件事； <br>\n第二层是恐惧做不成时别人对我们的开法或批评； <br>\n第三层是恐惧我们无法应对这样的看法或批评。 <br>\n其实，恐惧就像一个懦夫，当你撸起袖子准备跟它大干一场的时候，它却逃的无影踪。 <br>\n排除恐惧要问自己两个触底反弹的问题：如果我失败了，新来替代我的那个家伙，他会怎么办？既然这样，为什么我们不这样去做？</p>\n\n<p>逃出安全感，让有趣的生命扑面而来</p>\n\n<p>逃出安全感的掌控，让有趣的生命扑面而来，生活不是单调的百分之百。可是，生活和工作中我们总会遇到不感兴趣的人和感兴趣的人。前者日复一日重复的活着，就像复读机，数十年如一日。后者总是活力四射，充满好奇，不断尝试并乐于分享其中带来的喜悦。 <br>\n做一个有趣之人，生活也会对你有趣，而无趣之人往往是因为缺乏胆识，不敢冒险，也不能体验探索的乐趣。有趣之人，冒险——投入，成功了是一种收获，不成功也会有快乐甚至智慧。无趣之人，冒险——投入，成功了会担心失败，不成功也会有恐惧。 <br>\n生命不是追求一个结果，而是一个追求快乐的过程。投入到当下之中，只有在投入中体验的快乐才是无条件的快乐。</p>\n\n<p>心智模决定命运</p>\n\n<p>你的思维决定你的疆域。你的见识决定你看到的世界。正如小时候我只知道电灯电话楼上楼下，没有想过网络世界的神奇，更没有想过移动互联网带给生活的便捷。永远不要给可能性设置障碍，要知道凡是所想皆有存在，我们只是需要发现和等待。 </p>\n\n<p>成功学不能学</p>\n\n<p>成功永远都是小概率事件，过的非常惨也一样是小概率事件。这是社会学正态分布告诉我们的。可是，为什么还有所谓的成功学大师？他们在一次次推销自己的成功理论，让你心潮澎湃。但是你要知道，历史和经历是无法模仿的，唯有在自己的梦想之路越走越近。 <br>\nsuccess源自中古英语succeden，前面是拉丁文前缀suc，代表“靠近、接近”。后面是“走”的词根cess。所以，success本意是：越走越近。如果你有一个梦想，就去捍卫它；如果你有一个目标就去争取它。走起来，不羡慕走在高处的人，不轻视走在你后面的人，成功就是越走越近。 </p>\n\n<p>如何找到热衷一生的事业？</p>\n\n<p>如果你还在等待一个热衷一生的事业，打算找到后再全力以赴，那么你是不可能找到的。这就是小说和现实的区别。你只有在该尝试的年纪不停的尝试，在该专注的年纪专注投入，才能找到热衷一生的事业。 <br>\n选择职业与恋爱一样，如果你只和结婚对象谈恋爱，那么很难找到结婚的人。选择职业也要“一见钟情很多，两情相悦一些，白头偕老一个”。 <br>\n职业是你的天赋和现实世界的结合，不要奢望能有30年，50年的规划。在你视野所及的范围内精细计划，在你听说的范围内需要大方向的规划，而那些你连听都没听说过的地方，你需要的是相信。 </p>\n\n<p>原来我还可以这样活</p>\n\n<p>投入当下，体验越来越近的成功感也许是最好的活法。但是，有两种心智模式决定着你的幸福感：受害者模式和掌控者模式。受害者习惯于把自己的痛苦和快乐放在别人手上，面带怨气。掌控者乐观积极，把每件事情都看成生命的一件礼物，自我掌控，总能做好当下。你是哪一种？ </p>\n\n<p>幸福是一种转换力</p>\n\n<p>每个人内在都存在一个男人和一个女人。男人代表社会系统，是通过对外获取资源得以生存；女人代表自我系统，将资源转换为内心的幸福感得以让生存变得更好。小时候，社会系统和自我系统均衡发展，但随着成长我们越来越会看社会的要求，家长亲友的态度，同龄人的攀比。在竞争中社会系统变得越来越强大，而自我系统相对越来越渺小，以至于有些人丧生了自我系统，无论获取再多的资源也无法更好的生活，没有幸福感而言。很多人会掉入父母的剧本里去扮演一个自己，也有很多人落入世俗里随波逐流，从未思考过我是谁，从未想过活出自己。 </p>\n\n<p>上天不需要你成功，只需要你尝试</p>\n\n<p>活出自己需要不断的尝试，在当下立即行动。不要在抱怨中浪费生命，陷入“等死模式”。与其在等待中枯萎不如在等待中绽放。但是，你也许有这样的经验，雄心壮志制定一个长远的计划，然后浅尝辄止，没有了下文。我们要警惕自己变成一个“开始爱好者”，仅仅在开始时热情高涨，却无法坚持下来。但无论如何不要去等待一个万事具备的开始，我们虽然常说好的开始是成功的一半，可是坏的开始也是成功的三分之一。</p>\n\n<p>成长为自己的样子</p>\n\n<p>测评无法预测你的未来，只有内心才知道自己的样子。时常问问自己：我到底希望自己成为什么样子的人？或许给自己设定几个关键词，定下计划，去做你希望成为那样的人。但是要记住，我们的生命就是一个三脚架：自我、家庭、职业。三者的平衡才是最稳固的人生。</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/52057118', 'title': 'Java +安卓 定时任务', 'readNum': '17005', 'commentNum': '1', 'publishTime': '2016-07-28 17:15:33', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h4 id="1android-自带闹钟定时任务">1.android 自带闹钟定时任务</h4>\n\n<p>安卓闹钟可以配合广播来实现（不推荐），系统资源浪费，安卓系统在5.0以后的定时 <br>\n任务貌似触发时间不准了，因为了为了省电。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">//获取系统闹钟\nAlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE)<span class="hljs-comment">;</span>\nIntent intent = new Intent(ReportDetailsActivity<span class="hljs-preprocessor">.this</span>, ReportDetailsActivity<span class="hljs-preprocessor">.MyReceiver</span><span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>\npendingIntent = PendingIntent<span class="hljs-preprocessor">.getBroadcast</span>(getApplicationContext(), <span class="hljs-number">0</span>, intent, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>\n//开启定时任务\nalarmManager<span class="hljs-preprocessor">.setRepeating</span>(AlarmManager<span class="hljs-preprocessor">.RTC</span>_WAKEUP, System<span class="hljs-preprocessor">.currentTimeMillis</span>() + <span class="hljs-number">1000</span>, <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>, pendingIntent)<span class="hljs-comment">;</span>\n</code></pre>\n\n<p>记得在manifeast 文件配置该广播</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> {</span>\n\n       <span class="hljs-annotation">@Override</span>\n       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span>(Context context, Intent intent) {\n            <span class="hljs-keyword">if</span> (bo &gt; <span class="hljs-number">0</span>) {\n                <span class="hljs-keyword">if</span> (bo &gt; <span class="hljs-number">240</span>) {<span class="hljs-comment">//刷票</span>\n                    handler.sendEmptyMessage(<span class="hljs-number">3</span>);<span class="hljs-comment">//弹窗警告 刷票</span>\n                } <span class="hljs-keyword">else</span> {\n                    handler.sendEmptyMessage(<span class="hljs-number">2</span>);\n                }\n           }\n\n        }\n    }\n</code></pre>\n\n<p>在OnDestroy()中取消闹钟</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-annotation">@Override</span>\n<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span>() {\n    alarmManager.cancel(pendingIntent);\n}\n</code></pre>\n\n\n\n<h4 id="2开启thread">2.开启Thread</h4>\n\n<p>睡5s中去定时操作任务。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>{</span>\n\n        @Override\n        <span class="hljs-keyword">public</span> void run() {\n            <span class="hljs-keyword">while</span> (isLoop){\n                <span class="hljs-keyword">try</span> {\n\n                    <span class="hljs-keyword">if</span> (bo &gt; <span class="hljs-number">0</span>) {\n                        <span class="hljs-keyword">if</span> (bo &gt; <span class="hljs-number">240</span>) {<span class="hljs-comment">//刷票</span>\n                            handler.sendEmptyMessage(<span class="hljs-number">3</span>);<span class="hljs-comment">//弹窗警告 刷票</span>\n                        } <span class="hljs-keyword">else</span> {\n                            handler.sendEmptyMessage(<span class="hljs-number">2</span>);\n                        }\n                    }\n                    Thread.sleep(<span class="hljs-number">5000</span>);\n                }<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">Exception</span> e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n</code></pre>\n\n<p>在onCreate()方法中开启：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs lasso">loopThread<span class="hljs-subst">=</span><span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(<span class="hljs-literal">new</span> MyRunnable());\nloopThread<span class="hljs-built_in">.</span>start();</code></pre>\n\n<p>在页面销毁时终止掉该Thread</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs bash">isLoop=<span class="hljs-literal">false</span>;\nloopThread.interrupt();</code></pre>\n\n\n\n<h4 id="3-使用timer类">3. 使用timer类。</h4>\n\n<p>开启timer</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs r"> Timer timer=new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n            //TODO <span class="hljs-keyword">...</span>\n\n            }\n        },new Date(),<span class="hljs-number">5000</span>);</code></pre>\n\n<p>终止timer</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">  timer<span class="hljs-preprocessor">.cancel</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>以上三种定时任务除了第一种不要随便使用外，推荐使用第三种和第二种。</p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:45 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51971069', 'title': 'android动画解析（初级）', 'readNum': '15456', 'commentNum': '0', 'publishTime': '2016-07-20 18:44:01', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>效果图：</p>\n\n<p>ObjectAnimator继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。那么既然是继承关系，说明ValueAnimator中可以使用的方法在ObjectAnimator中也是可以正常使用的，它们的用法也非常类似.</p>\n\n<p>1.旋转控件：</p>\n\n<pre class="prettyprint"><code class=" hljs avrasm"> ObjectAnimator animator = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"rotation"</span>, <span class="hljs-number">0</span>f, <span class="hljs-number">360</span>f)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.setDuration</span>(<span class="hljs-number">5000</span>)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.start</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>2.平移控件</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">float curTranslationX = textView<span class="hljs-preprocessor">.getTranslationX</span>()<span class="hljs-comment">;</span>\n                ObjectAnimator animator = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"translationX"</span>, curTranslationX, -<span class="hljs-number">500</span>f, curTranslationX)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.setDuration</span>(<span class="hljs-number">5000</span>)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.start</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>3.放大缩小</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> ObjectAnimator animator = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"scaleY"</span>, <span class="hljs-number">1</span>f, <span class="hljs-number">3</span>f, <span class="hljs-number">1</span>f)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.setDuration</span>(<span class="hljs-number">3000</span>)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.start</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>4.透明  控件</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">  ObjectAnimator animator = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"alpha"</span>, <span class="hljs-number">1</span>f, <span class="hljs-number">0</span>f,<span class="hljs-number">1</span>f)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.setDuration</span>(<span class="hljs-number">3000</span>)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.start</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>用法确实比较简单。 <br>\n5.组合动画 <br>\n实现组合动画功能主要需要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法： <br>\nafter(Animator anim)   将现有动画插入到传入的动画之后执行 <br>\nafter(long delay)   将现有动画延迟指定毫秒后执行 <br>\nbefore(Animator anim)   将现有动画插入到传入的动画之前执行 <br>\nwith(Animator anim)   将现有动画和传入的动画同时执行</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> ObjectAnimator moveIn = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"translationX"</span>, -<span class="hljs-number">500</span>f, <span class="hljs-number">0</span>f)<span class="hljs-comment">;</span>\n                ObjectAnimator rotate = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"rotation"</span>, <span class="hljs-number">0</span>f, <span class="hljs-number">360</span>f)<span class="hljs-comment">;</span>\n                ObjectAnimator fadeInOut = ObjectAnimator<span class="hljs-preprocessor">.ofFloat</span>(textView, <span class="hljs-string">"alpha"</span>, <span class="hljs-number">1</span>f, <span class="hljs-number">0</span>f, <span class="hljs-number">1</span>f)<span class="hljs-comment">;</span>\n                AnimatorSet animSet = new AnimatorSet()<span class="hljs-comment">;</span>\n                AnimatorSet<span class="hljs-preprocessor">.Builder</span> builder=animSet<span class="hljs-preprocessor">.play</span>(rotate)<span class="hljs-comment">;</span>\n                builder<span class="hljs-preprocessor">.with</span>(fadeInOut)<span class="hljs-preprocessor">.after</span>(moveIn)<span class="hljs-comment">;</span>\n                animSet<span class="hljs-preprocessor">.setDuration</span>(<span class="hljs-number">5000</span>)<span class="hljs-comment">;</span>\n                animSet<span class="hljs-preprocessor">.start</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>布局实现</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-title">set</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>\n    <span class="hljs-attribute">android:ordering</span>=<span class="hljs-value">"sequentially"</span> &gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">objectAnimator\n</span>        <span class="hljs-attribute">android:duration</span>=<span class="hljs-value">"2000"</span>\n        <span class="hljs-attribute">android:propertyName</span>=<span class="hljs-value">"translationX"</span>\n        <span class="hljs-attribute">android:valueFrom</span>=<span class="hljs-value">"-500"</span>\n        <span class="hljs-attribute">android:valueTo</span>=<span class="hljs-value">"0"</span>\n        <span class="hljs-attribute">android:valueType</span>=<span class="hljs-value">"floatType"</span> &gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">objectAnimator</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">set</span> <span class="hljs-attribute">android:ordering</span>=<span class="hljs-value">"together"</span> &gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">objectAnimator\n</span>            <span class="hljs-attribute">android:duration</span>=<span class="hljs-value">"3000"</span>\n            <span class="hljs-attribute">android:propertyName</span>=<span class="hljs-value">"rotation"</span>\n            <span class="hljs-attribute">android:valueFrom</span>=<span class="hljs-value">"0"</span>\n            <span class="hljs-attribute">android:valueTo</span>=<span class="hljs-value">"360"</span>\n            <span class="hljs-attribute">android:valueType</span>=<span class="hljs-value">"floatType"</span> &gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">objectAnimator</span>&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">set</span> <span class="hljs-attribute">android:ordering</span>=<span class="hljs-value">"sequentially"</span> &gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-title">objectAnimator\n</span>                <span class="hljs-attribute">android:duration</span>=<span class="hljs-value">"1500"</span>\n                <span class="hljs-attribute">android:propertyName</span>=<span class="hljs-value">"alpha"</span>\n                <span class="hljs-attribute">android:valueFrom</span>=<span class="hljs-value">"1"</span>\n                <span class="hljs-attribute">android:valueTo</span>=<span class="hljs-value">"0"</span>\n                <span class="hljs-attribute">android:valueType</span>=<span class="hljs-value">"floatType"</span> &gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-title">objectAnimator</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-title">objectAnimator\n</span>                <span class="hljs-attribute">android:duration</span>=<span class="hljs-value">"1500"</span>\n                <span class="hljs-attribute">android:propertyName</span>=<span class="hljs-value">"alpha"</span>\n                <span class="hljs-attribute">android:valueFrom</span>=<span class="hljs-value">"0"</span>\n                <span class="hljs-attribute">android:valueTo</span>=<span class="hljs-value">"1"</span>\n                <span class="hljs-attribute">android:valueType</span>=<span class="hljs-value">"floatType"</span> &gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-title">objectAnimator</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">set</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">set</span>&gt;</span>\n\n<span class="hljs-tag">&lt;/<span class="hljs-title">set</span>&gt;</span></code></pre>\n\n<p>代码：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">Animator animator = AnimatorInflater<span class="hljs-preprocessor">.loadAnimator</span>(MainActivity<span class="hljs-preprocessor">.this</span>, R<span class="hljs-preprocessor">.animator</span><span class="hljs-preprocessor">.setanim</span>)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.setTarget</span>(textView)<span class="hljs-comment">;</span>\n                animator<span class="hljs-preprocessor">.start</span>()<span class="hljs-comment">;</span></code></pre>\n\n<p>调用AnimatorInflater的loadAnimator来将XML动画文件加载进来，然后再调用setTarget()方法将这个动画设置到某一个对象上面，最后再调用start()方法启动动画就可以了，就是这么简单。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9587802">源码下载</a></p>\n\n<p><a href="http://blog.csdn.net/forezp">csdn博客</a></p>\n\n<p>本文参考了 郭神的博客：<a href="http://blog.csdn.net/guolin_blog/article/details/43536355">http://blog.csdn.net/guolin_blog/article/details/43536355</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:45'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51853338', 'title': 'android 轮播图', 'readNum': '15064', 'commentNum': '0', 'publishTime': '2016-07-07 18:11:02', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>最近做项目，自己封装了一个图片轮播的组件，主要的思想就采用ViewPager和ScrollGater实现，图片加载用的Imageloader，也可以换其他的，比如Glide.具体封装的组件件源码，这里只说下用法，首先上布局文件。 <br>\n<img src="https://img-blog.csdn.net/20160708091623612" width="300" alt="图片名称" align="center"></p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs ">&lt;LinearLayout xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>\n    xmlns:tools=<span class="hljs-string">"http://schemas.android.com/tools"</span>\n    android:layout_width=<span class="hljs-string">"match_parent"</span>\n    android:layout_height=<span class="hljs-string">"match_parent"</span>\n    android:orientation=<span class="hljs-string">"vertical"</span>\n    tools:context=<span class="hljs-string">".MainActivity"</span> &gt;\n\n    &lt;LinearLayout\n        android:id=<span class="hljs-string">"@+id/root"</span>\n        android:layout_width=<span class="hljs-string">"match_parent"</span>\n        android:layout_height=<span class="hljs-string">"180dp"</span>\n        android:orientation=<span class="hljs-string">"vertical"</span> &gt;\n\n        &lt;com.example.shuffviewdemo.ShufflingView\n            android:id=<span class="hljs-string">"@+id/shuffling_view"</span>\n            android:layout_width=<span class="hljs-string">"match_parent"</span>\n            android:layout_height=<span class="hljs-string">"wrap_content"</span> &gt;\n        &lt;/com.example.shuffviewdemo.ShufflingView&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>\n\n<p>初始化ShufflingView,设置des可见，轮播的指示器在底部。设置点击事件监听。</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs ">mShufflingView = (ShufflingView) findViewById(R.id.shuffling_view);\n        mShufflingView.setContentDesVisibility(View.VISIBLE);\n        mShufflingView.setDotGravity(Gravity.BOTTOM);\n        mShufflingView.setOnItemClickListener(mOnShufflingItemClickListener);\n        bannerList = <span class="hljs-keyword">new</span> ArrayList&lt;ShufflingItemBean&gt;();\n        loadShuffingViewData();\n</code></pre>\n\n<p>设置shufflingView 的beans接收的是一个arraylist对象。</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs ">\nShufflingItemBean shufflingItemBean=<span class="hljs-keyword">new</span> ShufflingItemBean();\n        shufflingItemBean.setImg(<span class="hljs-string">"http://img3.imgtn.bdimg.com/it/u=4227020988,3565099621&amp;fm=21&amp;gp=0.jpg"</span>);\n        shufflingItemBean.setUrl(<span class="hljs-string">"www.baidu.com"</span>);<span class="hljs-comment">//点击跳转到webview</span>\n        bannerList.add(shufflingItemBean);\n        bannerList.add(shufflingItemBean);\n        bannerList.add(shufflingItemBean);\n        mShufflingView.updateDatas(bannerList);</code></pre>\n\n<p>shufflingView 的监听，具体的跳转和类型，根据需求组件设置。</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">actionFromType</span>(Context context, ShufflingItemBean item) {\n        <span class="hljs-keyword">if</span> (item.getType().equals(<span class="hljs-string">"-1"</span>)) {\n            <span class="hljs-keyword">return</span>;\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.getType().equals(<span class="hljs-string">"1"</span>)) {<span class="hljs-comment">// 交易贴</span>\n\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.getType().equals(<span class="hljs-string">"2"</span>)) {<span class="hljs-comment">// 外部链接</span>\n\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.getType().equals(<span class="hljs-string">"3"</span>)) {<span class="hljs-comment">// 资讯贴</span>\n\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.getType().equals(<span class="hljs-string">"4"</span>)) {<span class="hljs-comment">// 应援贴</span>\n\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.getType().equals(<span class="hljs-string">"5"</span>)) {<span class="hljs-comment">//</span>\n            <span class="hljs-comment">//Intent intent = new Intent(context, WebViewActivity.class);</span>\n\n\n            <span class="hljs-comment">//intent.putExtra("url",</span>\n            <span class="hljs-comment">//item.getUrl());</span>\n\n\n            <span class="hljs-comment">//intent.putExtra("type", 1);</span>\n            <span class="hljs-comment">//context.startActivity(intent);</span>\n        } <span class="hljs-keyword">else</span> {<span class="hljs-comment">// 其他</span>\n\n        }\n\n    }</code></pre>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9570165">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51873137', 'title': 'android design 新控件', 'readNum': '17728', 'commentNum': '3', 'publishTime': '2016-07-10 20:17:37', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <blockquote>\n  <p>转载请标明出处：  <br>\n  <a href="http://blog.csdn.net/forezp/article/details/51873137">http://blog.csdn.net/forezp/article/details/51873137</a> <br>\n  本文出自<a href="http://blog.csdn.net/forezp">方志朋的博客</a></p>\n</blockquote>\n\n<p>最近在研究android   开发的新控件，包括drawer layout ,NavigationView,CoordinatorLayout,AppBarLayout,Toolbar,TabLayout,SwipeRefreshLayout,Recyclerview等。</p>\n\n<p>先上效果图：</p>\n\n<p><img src="https://img-blog.csdn.net/20160710200140616" width="300" alt="图片名称" align="center">     <img src="https://img-blog.csdn.net/20160710200214538" width="300" alt="图片名称" align="center"> <br>\n<img src="https://img-blog.csdn.net/20160710200253055" width="300" alt="图片名称" align="center">   <img src="https://img-blog.csdn.net/20160710200353322" width="300" alt="图片名称" align="center"></p>\n\n<p>主界面上drawlayou 和NavigationView形成抽屉效果，布局文件如下：</p>\n\n<pre class="prettyprint"><code class="language-java hljs ">&lt;android.support.v4.widget.DrawerLayout\n    xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>\n    xmlns:app=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>\n    android:id=<span class="hljs-string">"@+id/id_drawerlayout"</span>\n    android:layout_width=<span class="hljs-string">"match_parent"</span>\n    android:layout_height=<span class="hljs-string">"match_parent"</span>\n    &gt;\n    &lt;include layout=<span class="hljs-string">"@layout/home_content"</span>/&gt;\n    &lt;android.support.design.widget.NavigationView\n        android:id=<span class="hljs-string">"@+id/id_navigationview"</span>\n        app:itemTextColor=<span class="hljs-string">"@color/selector_nav_menu_textcolor"</span>\n        android:layout_gravity=<span class="hljs-string">"left"</span>\n        android:layout_width=<span class="hljs-string">"match_parent"</span>\n        android:layout_height=<span class="hljs-string">"match_parent"</span>&gt;\n\n    &lt;/android.support.design.widget.NavigationView&gt;\n\n&lt;/android.support.v4.widget.DrawerLayout&gt;</code></pre>\n\n<p>java代码：抽屉部分</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">drawerLayout = (DrawerLayout)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.id</span>_drawerlayout)<span class="hljs-comment">;</span>\nnavigationView = (NavigationView)findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.id</span>_navigationview)<span class="hljs-comment">;</span>\n ActionBarDrawerToggle mActionBarDrawerToggle =\n                new ActionBarDrawerToggle(this, drawerLayout, toolbar, R<span class="hljs-preprocessor">.string</span><span class="hljs-preprocessor">.open</span>, R<span class="hljs-preprocessor">.string</span><span class="hljs-preprocessor">.close</span>)<span class="hljs-comment">;</span>\n        mActionBarDrawerToggle<span class="hljs-preprocessor">.syncState</span>()<span class="hljs-comment">;</span>\n        drawerLayout<span class="hljs-preprocessor">.setDrawerListener</span>(mActionBarDrawerToggle)<span class="hljs-comment">;</span>\n\n        //给NavigationView填充顶部区域，也可在xml中使用app:headerLayout=<span class="hljs-string">"@layout/header_nav"</span>来设置\n        navigationView<span class="hljs-preprocessor">.inflateHeaderView</span>(R<span class="hljs-preprocessor">.layout</span><span class="hljs-preprocessor">.header</span>_nav)<span class="hljs-comment">;</span>\n        View headerView = navigationView<span class="hljs-preprocessor">.getHeaderView</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>\n\n        CircleImageView circleImageView = (CircleImageView)headerView<span class="hljs-preprocessor">.findViewById</span>(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.id</span>_circleview)<span class="hljs-comment">;</span>\n        Glide<span class="hljs-preprocessor">.with</span>(this)<span class="hljs-preprocessor">.load</span>(<span class="hljs-string">"http://pic1.nipic.com/2008-10-30/200810309416546_2.jpg"</span>)<span class="hljs-preprocessor">.into</span>(circleImageView)<span class="hljs-comment">;</span>\n\n        //给NavigationView填充Menu菜单，也可在xml中使用app:menu=<span class="hljs-string">"@menu/menu_nav"</span>来设置\n        navigationView<span class="hljs-preprocessor">.inflateMenu</span>(R<span class="hljs-preprocessor">.menu</span><span class="hljs-preprocessor">.menu</span>_nav)<span class="hljs-comment">;</span>\n</code></pre>\n\n<p>可以给navigationview 设置点击事件：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">mNav<span class="hljs-preprocessor">.setNavigationItemSelectedListener</span>(new NavigationView<span class="hljs-preprocessor">.OnNavigationItemSelectedListener</span>() {\n            @Override public boolean onNavigationItemSelected(MenuItem menuItem) {\n\n                String msgString = <span class="hljs-string">""</span><span class="hljs-comment">;</span>\n\n                switch (menuItem<span class="hljs-preprocessor">.getItemId</span>()) {\n                    case R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.nav</span>_menu_home:\n                        msgString = (String) menuItem<span class="hljs-preprocessor">.getTitle</span>()<span class="hljs-comment">;</span>\n                        <span class="hljs-keyword">break</span><span class="hljs-comment">;</span>\n                    case R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.nav</span>_menu_categories:\n                        msgString = (String) menuItem<span class="hljs-preprocessor">.getTitle</span>()<span class="hljs-comment">;</span>\n                        <span class="hljs-keyword">break</span><span class="hljs-comment">;</span>\n                    case R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.nav</span>_menu_feedback:\n                        msgString = (String) menuItem<span class="hljs-preprocessor">.getTitle</span>()<span class="hljs-comment">;</span>\n                        <span class="hljs-keyword">break</span><span class="hljs-comment">;</span>\n                    case R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.nav</span>_menu_setting:\n                        msgString = (String) menuItem<span class="hljs-preprocessor">.getTitle</span>()<span class="hljs-comment">;</span>\n                        <span class="hljs-keyword">break</span><span class="hljs-comment">;</span>\n                }\n\n                // Menu item点击后选中，并关闭Drawerlayout\n                menuItem<span class="hljs-preprocessor">.setChecked</span>(true)<span class="hljs-comment">;</span>\n                drawerLayout<span class="hljs-preprocessor">.closeDrawers</span>()<span class="hljs-comment">;</span>\n\n                Toast<span class="hljs-preprocessor">.makeText</span>(HomeActivity<span class="hljs-preprocessor">.this</span>,msgString,Toast<span class="hljs-preprocessor">.LENGTH</span>_SHORT)<span class="hljs-preprocessor">.show</span>()<span class="hljs-comment">;</span>\n\n                return true<span class="hljs-comment">;</span></code></pre>\n\n<p>draw layout  和navigation view 组合可以写成非常好的抽屉效果，避免了第三方库，用原生的感觉非常棒。 <br>\n－－－－－－－－－－抽屉部分结束－－－－－－－－－－－ <br>\n<br> <br>\n<br></p>\n\n<p>tab layout 和view pager 实现联动效果：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs mel"> <span class="hljs-comment">// 初始化ViewPager的适配器，并设置给它</span>\n        mViewPagerAdapter = new MyViewPagerAdapter(getSupportFragmentManager(), mTitles, mFragments);\n        viewPager.setAdapter(mViewPagerAdapter);\n        <span class="hljs-comment">// 设置ViewPager最大缓存的页面个数</span>\n        viewPager.setOffscreenPageLimit(<span class="hljs-number">5</span>);\n        <span class="hljs-comment">// 给ViewPager添加页面动态监听器（为了让Toolbar中的Title可以变化相应的Tab的标题）</span>\n        viewPager.addOnPageChangeListener(this);\n\n        <span class="hljs-keyword">tabLayout</span>.setTabMode(MODE_SCROLLABLE);\n        <span class="hljs-comment">// 将TabLayout和ViewPager进行关联，让两者联动起来</span>\n        <span class="hljs-keyword">tabLayout</span>.setupWithViewPager(viewPager);\n        <span class="hljs-comment">// 设置Tablayout的Tab显示ViewPager的适配器中的getPageTitle函数获取到的标题</span>\n        <span class="hljs-keyword">tabLayout</span>.setTabsFromPagerAdapter(mViewPagerAdapter);\n</code></pre>\n\n<p>RefreshLayout 实现下拉刷新效果: <br>\n布局文件：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-title">android.support.v4.widget.SwipeRefreshLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>\n        <span class="hljs-attribute">xmlns:app</span>=<span class="hljs-value">"http://schemas.android.com/apk/res-auto"</span>\n        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/id_swiperefreshlayout"</span>\n        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">app:layout_behavior</span>=<span class="hljs-value">"@string/appbar_scrolling_view_behavior"</span>\n        &gt;</span>\n\n        <span class="hljs-comment">&lt;!--\n                使用RecyclerView需要在build.gradle中添加\n               compile \'com.android.support:recyclerview-v7:23.3.0\'\n        --&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-title">android.support.v7.widget.RecyclerView\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/id_recyclerview"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n            <span class="hljs-attribute">android:foregroundGravity</span>=<span class="hljs-value">"center"</span>\n            /&gt;</span>\n\n\n    <span class="hljs-tag">&lt;/<span class="hljs-title">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></code></pre>\n\n<p>在fragment 实现下拉刷新接口：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwipeRefreshLayout</span>.<span class="hljs-title">OnRefreshListener</span>{</span>}</code></pre>\n\n<p>mSwipeRefreshLayout实现下拉是的颜色变化，和设置监听事件。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">mSwipeRefreshLayout<span class="hljs-preprocessor">.setColorSchemeResources</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.main</span>_blue_light, R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.main</span>_blue_dark)<span class="hljs-comment">;</span>\n mSwipeRefreshLayout<span class="hljs-preprocessor">.setOnRefreshListener</span>(this)<span class="hljs-comment">;</span></code></pre>\n\n<p>下拉刷新刷新数据的接口实现的方法：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span>() {\n\n        <span class="hljs-keyword">new</span> Handler().postDelayed(<span class="hljs-keyword">new</span> Runnable() {\n            <span class="hljs-annotation">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {\n               mSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//关闭下拉动画</span>\n\n\n                }\n            }\n        }, <span class="hljs-number">1000</span>);\n    }</code></pre>\n\n<p>－－－－－－－－－下拉刷新结束－－－－－－－－－－</p>\n\n<p>RecyclerView可以实现listview （横行和纵向）.gridview（横行和纵向） ,瀑布流的效果。 <br>\n我讲解一下最简单的效果：listview的效果： <br>\n直接上代码：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">mLayoutManager =new LinearLayoutManager(getActivity(), LinearLayoutManager<span class="hljs-preprocessor">.VERTICAL</span>, false)<span class="hljs-comment">;</span>\nmRecyclerViewAdapter = new DemoRecyclerViewAdapter(getActivity())<span class="hljs-comment">;</span>\nmRecyclerViewAdapter<span class="hljs-preprocessor">.setOnItemClickListener</span>(this)<span class="hljs-comment">;</span>\n            mRecyclerView<span class="hljs-preprocessor">.setAdapter</span>(mRecyclerViewAdapter)<span class="hljs-comment">;</span>\n            mRecyclerViewAdapter<span class="hljs-preprocessor">.setList</span>(list)<span class="hljs-comment">;</span>\n            mRecyclerView<span class="hljs-preprocessor">.setLayoutManager</span>(mLayoutManager)<span class="hljs-comment">;</span>\n            mRecyclerViewAdapter<span class="hljs-preprocessor">.notifyDataSetChanged</span>()<span class="hljs-comment">;                        </span></code></pre>\n\n<p>其中adapter 的写法：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> DemoRecyclerViewAdapter extends RecyclerView.Adapter&lt;DemoRecyclerViewHolder&gt; {\n    <span class="hljs-keyword">private</span> Context context;\n    <span class="hljs-keyword">private</span> ArrayList&lt;ImageBean&gt; list;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">DemoRecyclerViewAdapter</span>(Context mContext) {\n        <span class="hljs-keyword">this</span>.context = mContext;\n\n    }\n    @Override\n    <span class="hljs-keyword">public</span> DemoRecyclerViewHolder <span class="hljs-title">onCreateViewHolder</span>(ViewGroup parent, <span class="hljs-keyword">int</span> viewType) {\n        View mView= LayoutInflater.<span class="hljs-keyword">from</span>(context).inflate(R.layout.item_demo_adapter,parent,<span class="hljs-keyword">false</span>);\n        DemoRecyclerViewHolder recyclerViewHolder=<span class="hljs-keyword">new</span> DemoRecyclerViewHolder(mView);\n        <span class="hljs-keyword">return</span> recyclerViewHolder;\n    }\n\n    @Override\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span>(final DemoRecyclerViewHolder holder, final <span class="hljs-keyword">int</span> position) {\n        <span class="hljs-keyword">if</span>(mOnItemClickListener!=<span class="hljs-keyword">null</span>){\n            holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() {\n                @Override\n                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(View v) {\n                    mOnItemClickListener.onItemClick(holder.itemView,position);\n                }\n            });\n            holder.itemView.setOnLongClickListener(<span class="hljs-keyword">new</span> View.OnLongClickListener() {\n                @Override\n                <span class="hljs-keyword">public</span> boolean <span class="hljs-title">onLongClick</span>(View v) {\n                    mOnItemClickListener.onItemLongClick(holder.itemView, position);\n                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n                }\n            });\n        }\n        holder.textView.setText(list.<span class="hljs-keyword">get</span>(position).getName());\n        Glide.with(context).load(list.<span class="hljs-keyword">get</span>(position).getImg()).<span class="hljs-keyword">into</span>(holder.imageView);\n\n    }\n\n\n\n    @Override\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span>() {\n        <span class="hljs-keyword">return</span> list.size();\n    }\n}</code></pre>\n\n<p>adapter的写法根之前BaseAdapter 很类似，需要特别注意的是: <br>\n加载布局文件的方法一定是这个，要不然会出现match_parent 失效。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">View mView= LayoutInflater<span class="hljs-preprocessor">.from</span>(context)<span class="hljs-preprocessor">.inflate</span>(R<span class="hljs-preprocessor">.layout</span><span class="hljs-preprocessor">.item</span>_demo_adapter,parent,false)<span class="hljs-comment">;</span></code></pre>\n\n<p>还有一些其他的控件如cardview 比较简单就不说了，toolbar的用法会在下次给出好的例子。</p>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9571175">源码下载</a></p>\n\n\n\n<h3 id="优秀文章推荐">优秀文章推荐：</h3>\n\n<ul>\n<li><a href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n</ul>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51757821', 'title': 'Viewpager实现今日头条顶部导航的功能', 'readNum': '15449', 'commentNum': '0', 'publishTime': '2016-06-25 11:41:02', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>利用简单的Textview 和Viewpager实现滑动、点击换页的效果，效果图如下：</p>\n\n<p><img src="https://img-blog.csdn.net/20160625113922931" width="200" alt="行走的那些事" align="center">\u3000\u3000\u3000<img src="https://img-blog.csdn.net/20160625113940119" width="200" alt="行走的那些事" align="center"></p>\n\n<p>先上布局文件代码：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>\n    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n    <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/white"</span>\n    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span> &gt;</span>\n\n   <span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout\n</span>       <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/red_base"</span>\n       <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"horizontal"</span>\n       <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n       <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"50dp"</span>&gt;</span>\n\n   <span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- 选项卡 --&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout\n</span>        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"40dp"</span>\n        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/white"</span>\n        <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"horizontal"</span>\n        <span class="hljs-attribute">android:weightSum</span>=<span class="hljs-value">"5"</span> &gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">FrameLayout\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab1_fl"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_weight</span>=<span class="hljs-value">"1"</span>\n            <span class="hljs-attribute">android:clickable</span>=<span class="hljs-value">"true"</span>\n            <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span> &gt;</span>\n\n            <span class="hljs-tag">&lt;<span class="hljs-title">TextView\n</span>                <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab1_tv"</span>\n                <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_gravity</span>=<span class="hljs-value">"center"</span>\n                <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"全部"</span>\n                <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"@color/red_base"</span>\n                <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">FrameLayout</span>&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">View\n</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0.5dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/divider_gray_line"</span> /&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">FrameLayout\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab2_fl"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_weight</span>=<span class="hljs-value">"1"</span>\n            <span class="hljs-attribute">android:clickable</span>=<span class="hljs-value">"true"</span>\n            <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span> &gt;</span>\n\n            <span class="hljs-tag">&lt;<span class="hljs-title">TextView\n</span>                <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab2_tv"</span>\n                <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_gravity</span>=<span class="hljs-value">"center"</span>\n                <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"周边"</span>\n                <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"@color/text_gray_4"</span>\n                <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">FrameLayout</span>&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">View\n</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0.5dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/divider_gray_line"</span> /&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">FrameLayout\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab3_fl"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_weight</span>=<span class="hljs-value">"1"</span>\n            <span class="hljs-attribute">android:clickable</span>=<span class="hljs-value">"true"</span>\n            <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span> &gt;</span>\n\n            <span class="hljs-tag">&lt;<span class="hljs-title">TextView\n</span>                <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab3_tv"</span>\n                <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_gravity</span>=<span class="hljs-value">"center"</span>\n                <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"应援"</span>\n                <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"@color/text_gray_4"</span>\n                <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">FrameLayout</span>&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">View\n</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0.5dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/divider_gray_line"</span> /&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">FrameLayout\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab4_fl"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_weight</span>=<span class="hljs-value">"1"</span>\n            <span class="hljs-attribute">android:clickable</span>=<span class="hljs-value">"true"</span>\n            <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span> &gt;</span>\n\n            <span class="hljs-tag">&lt;<span class="hljs-title">TextView\n</span>                <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab4_tv"</span>\n                <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_gravity</span>=<span class="hljs-value">"center"</span>\n                <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"话题"</span>\n                <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"@color/text_gray_4"</span>\n                <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">FrameLayout</span>&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">View\n</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0.5dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_marginBottom</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"10dp"</span>\n            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/divider_gray_line"</span> /&gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">FrameLayout\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab5_fl"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>\n            <span class="hljs-attribute">android:layout_weight</span>=<span class="hljs-value">"1"</span>\n            <span class="hljs-attribute">android:clickable</span>=<span class="hljs-value">"true"</span>\n            <span class="hljs-attribute">android:gravity</span>=<span class="hljs-value">"center"</span> &gt;</span>\n\n            <span class="hljs-tag">&lt;<span class="hljs-title">TextView\n</span>                <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_tab5_tv"</span>\n                <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>\n                <span class="hljs-attribute">android:layout_gravity</span>=<span class="hljs-value">"center"</span>\n                <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"明星"</span>\n                <span class="hljs-attribute">android:textColor</span>=<span class="hljs-value">"@color/text_gray_4"</span>\n                <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-title">FrameLayout</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout\n</span>        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"3dp"</span>\n        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/white"</span> &gt;</span>\n\n        <span class="hljs-tag">&lt;<span class="hljs-title">ImageView\n</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_cursor"</span>\n            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"80dp"</span>\n            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"3dp"</span>\n            <span class="hljs-attribute">android:layout_marginTop</span>=<span class="hljs-value">"0dip"</span>\n            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/title_bar_blue"</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">View\n</span>        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"0.1dp"</span>\n        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/btn_bg_gray"</span> /&gt;</span>\n    <span class="hljs-comment">&lt;!-- 选项卡内容显示区域 --&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">View\n</span>        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"10dp"</span>\n        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"@color/bg_light_gray"</span> /&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-title">android.support.v4.view.ViewPager\n</span>        <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/rim_third_vp"</span>\n        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>\n        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span> /&gt;</span>\n\n<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre>\n\n<p>上面红色指示器的view的初始化</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> screenWidth;<span class="hljs-comment">//指示器</span>\n<span class="hljs-keyword">private</span> ImageView cursorImg;\n<span class="hljs-keyword">private</span> LinearLayout.LayoutParams lp;\n\n\n <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViews</span>(){\n\n        WindowManager wm = (WindowManager)\n                getSystemService(Context.WINDOW_SERVICE);\n\n        <span class="hljs-keyword">int</span> width = wm.getDefaultDisplay().getWidth();\n        screenWidth=width/<span class="hljs-number">5</span>;\n        cursorImg = (ImageView) findViewById(R.id.rim_cursor);\n        lp = (LinearLayout.LayoutParams) cursorImg.getLayoutParams();\n        lp.width = screenWidth;\n        cursorImg.setLayoutParams(lp);\n        leftMargin = lp.leftMargin;\n  }</code></pre>\n\n<p>初始化indicater</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm">private void initViewPager() {\n        viewPager = (ViewPager) findViewById(R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.rim</span>_third_vp)<span class="hljs-comment">;</span>\n        fragmentsList = new ArrayList&lt;Fragment&gt;()<span class="hljs-comment">;</span>\n        fragment1 = new RimFragment()<span class="hljs-comment">;     </span>\n        fragmentsList<span class="hljs-preprocessor">.add</span>(fragment1)<span class="hljs-comment">;</span>\n        fragmentsList<span class="hljs-preprocessor">.add</span>(fragment2)<span class="hljs-comment">;</span>\n        fragmentsList<span class="hljs-preprocessor">.add</span>(fragment3)<span class="hljs-comment">;</span>\n        fragmentsList<span class="hljs-preprocessor">.add</span>(fragment4)<span class="hljs-comment">;</span>\n        fragmentsList<span class="hljs-preprocessor">.add</span>(fragment5)<span class="hljs-comment">;</span>\n\n        viewPager<span class="hljs-preprocessor">.setAdapter</span>(new FragmentAdapter(getSupportFragmentManager(),\n                fragmentsList))<span class="hljs-comment">;</span>\n        viewPager<span class="hljs-preprocessor">.setCurrentItem</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>\n        viewPager<span class="hljs-preprocessor">.setOnPageChangeListener</span>(this)<span class="hljs-comment">;</span>\n    }</code></pre>\n\n<p>设置上面选项卡的点击事件</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> @Override\n    public void onClick(View v) {\n        switch (v<span class="hljs-preprocessor">.getId</span>()){\n            case R<span class="hljs-preprocessor">.id</span><span class="hljs-preprocessor">.rim</span>_tab1_fl:\n                viewPager<span class="hljs-preprocessor">.setCurrentItem</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>\n                num_tab1_tv<span class="hljs-preprocessor">.setTextColor</span>(getResources()<span class="hljs-preprocessor">.getColor</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.red</span>_base))<span class="hljs-comment">;</span>\n                num_tab2_tv<span class="hljs-preprocessor">.setTextColor</span>(getResources()<span class="hljs-preprocessor">.getColor</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.text</span>_gray_4))<span class="hljs-comment">;</span>\n                num_tab3_tv<span class="hljs-preprocessor">.setTextColor</span>(getResources()<span class="hljs-preprocessor">.getColor</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.text</span>_gray_4))<span class="hljs-comment">;</span>\n                num_tab4_tv<span class="hljs-preprocessor">.setTextColor</span>(getResources()<span class="hljs-preprocessor">.getColor</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.text</span>_gray_4))<span class="hljs-comment">;</span>\n                num_tab5_tv<span class="hljs-preprocessor">.setTextColor</span>(getResources()<span class="hljs-preprocessor">.getColor</span>(R<span class="hljs-preprocessor">.color</span><span class="hljs-preprocessor">.text</span>_gray_4))<span class="hljs-comment">;</span>\n                fragment1<span class="hljs-preprocessor">.setMsgName</span>(<span class="hljs-string">"1"</span>,<span class="hljs-string">"周边"</span>)<span class="hljs-comment">;//周边的官方和会员的接口参数,官方</span>\n                <span class="hljs-keyword">break</span><span class="hljs-comment">;</span></code></pre>\n\n<p>设置viewpager 滑动事件</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageScrolled</span>(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">float</span> positionOffset, <span class="hljs-keyword">int</span> positionOffsetPixels) {\n\n        offset = (screenWidth - cursorImg.getLayoutParams().width) / <span class="hljs-number">5</span>;\n\n        hidePoint(position, positionOffsetPixels);<span class="hljs-comment">//设置红色指示器的位置</span>\n        cursorImg.setLayoutParams(lp);\n        currentIndex = position;\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageSelected</span>(<span class="hljs-keyword">int</span> position) {\n\n        <span class="hljs-keyword">switch</span> (position){<span class="hljs-comment">//设置点击事件</span>\n            <span class="hljs-keyword">case</span>  <span class="hljs-number">0</span>:\n                fragment1.setMsgName(<span class="hljs-string">"1"</span>,<span class="hljs-string">"周边"</span>);\n                num_tab1_tv.setTextColor(getResources().getColor(R.color.red_base));\n                num_tab2_tv.setTextColor(getResources().getColor(R.color.text_gray_4));\n                num_tab3_tv.setTextColor(getResources().getColor(R.color.text_gray_4));\n                num_tab4_tv.setTextColor(getResources().getColor(R.color.text_gray_4));\n                num_tab5_tv.setTextColor(getResources().getColor(R.color.text_gray_4));\n                <span class="hljs-keyword">break</span>;\n\n\n        }\n\n        <span class="hljs-keyword">if</span> (position==<span class="hljs-number">0</span>)\n        {\n\n\n        }<span class="hljs-keyword">else</span> {\n\n        }\n\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageScrollStateChanged</span>(<span class="hljs-keyword">int</span> state) {\n\n    }\n\n    <span class="hljs-comment">//设置指示器的位置</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hidePoint</span>(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> positionOffsetPixels) {\n        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) {<span class="hljs-comment">// 0&lt;-&gt;1</span>\n            lp.leftMargin = (<span class="hljs-keyword">int</span>) (positionOffsetPixels / <span class="hljs-number">5</span>) + offset;\n\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) {<span class="hljs-comment">// 1&lt;-&gt;2</span>\n            lp.leftMargin = (<span class="hljs-keyword">int</span>) (positionOffsetPixels / <span class="hljs-number">5</span>) + screenWidth\n                    + offset;\n\n        }<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(position==<span class="hljs-number">2</span>){\n            lp.leftMargin = (<span class="hljs-keyword">int</span>) (positionOffsetPixels / <span class="hljs-number">5</span>) + screenWidth*<span class="hljs-number">2</span>\n                    + offset;\n        }\n        <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(position==<span class="hljs-number">3</span>){\n            lp.leftMargin = (<span class="hljs-keyword">int</span>) (positionOffsetPixels / <span class="hljs-number">5</span>) + screenWidth*<span class="hljs-number">3</span>\n                    + offset;\n        }\n        <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(position==<span class="hljs-number">4</span>){\n            lp.leftMargin = (<span class="hljs-keyword">int</span>) (positionOffsetPixels / <span class="hljs-number">5</span>) + screenWidth*<span class="hljs-number">4</span>\n                    + offset;\n        }\n    }\n</code></pre>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9559206">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51736388', 'title': 'EventBus 基础篇', 'readNum': '15178', 'commentNum': '0', 'publishTime': '2016-06-22 18:46:49', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>最近在研究RxJava ，突然想起了事件分发另一个强大的框架Eventbus ,并且项目经常用到，特意整理了下。 <br>\nwhat is Eventbus? <br>\n官方的解释为： <br>\nEventBus is a publish/subscribe event bus optimized for Android. <br>\n它是专门为优化安卓一个 发布者/订阅者的事件总线。</p>\n\n<p><img src="https://img-blog.csdn.net/20160622183052058" alt="事件分发流程" title=""></p>\n\n<p>发布者，发布事件。通过事件总线（其实就是在一个单例内部维持着一个map对象存储了一堆的方法），分发给订阅者。</p>\n\n<p>它的优点： <br>\n轻量、简单、降低耦合。</p>\n\n<p>用法： <br>\n1.声明Event事件</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MessageEvent { <span class="hljs-comment">/* Additional fields if needed */</span> }</code></pre>\n\n<p>2.注册</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cpp">eventBus.<span class="hljs-keyword">register</span>(<span class="hljs-keyword">this</span>);</code></pre>\n\n<p>声明方法，有四种方法，最主要的是：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"> @Subscribe\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEventMainThread</span>(CommonEvent <span class="hljs-keyword">event</span>) {\n\n    }</code></pre>\n\n<p>3.发布事件</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">eventBus.post(<span class="hljs-keyword">event</span>);</code></pre>\n\n<p>例子： <br>\n在oncrete（） 方法中注册，无论是Activity 还是Fragment ,不在这里注册会报错。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {\n        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        EventBus.getDefault().register(<span class="hljs-keyword">this</span>);\n        btn=(Button)findViewById(R.id.btn);\n        tv=(TextView)findViewById(R.id.tv);\n        btn.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() {\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(View v) {\n                Intent intent=<span class="hljs-keyword">new</span> Intent(MainActivity.<span class="hljs-keyword">this</span>,SecondActivity.class);\n                startActivity(intent);\n            }\n        });\n    }</code></pre>\n\n<p>在OnDestroy中反注册</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java">  <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span>() {\n        <span class="hljs-keyword">super</span>.onDestroy();\n        EventBus.getDefault().unregister(<span class="hljs-keyword">this</span>);\n    }</code></pre>\n\n<p>声明订阅者：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"> @Subscribe\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEventMainThread</span>(CommonEvent <span class="hljs-keyword">event</span>) {\n\n       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.getType().equals(CommonEvent.TYPE_99)){\n           tv.setText(<span class="hljs-string">"从第二个页面来的：eventtype="</span>+<span class="hljs-keyword">event</span>.getType());\n       }\n    }</code></pre>\n\n<p>在需要触发事件的位置提交事件：例如我在第二个界面提交事件，在第一个页面接受：</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs avrasm"> EventBus<span class="hljs-preprocessor">.getDefault</span>()<span class="hljs-preprocessor">.post</span>(new CommonEvent(CommonEvent<span class="hljs-preprocessor">.TYPE</span>_99))<span class="hljs-comment">;</span></code></pre>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9556776">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_1 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51731783', 'title': 'AndroidMVP', 'readNum': '15714', 'commentNum': '4', 'publishTime': '2016-06-22 09:17:58', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <h2 id="mvp模式简介">Mvp模式简介</h2>\n\n<p>衍生于MVC 模式，降低了耦合性，避免了View(Activity/Fragment)承担了所有的责任， <br>\n分担了UI层的职责。<br></p>\n\n<p>在MVP模式里通常包含4个要素： <br>\n* View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity); <br>\n* View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试; <br>\n* Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合); <br>\n* Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</p>\n\n\n\n<h2 id="为什么要使用-mvp模式">为什么要使用 MVP模式</h2>\n\n<p>在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面， <br>\n 并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的 职责不断增加， <br>\n 以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中 View， <br>\n 它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 <br>\n Presenter处理）.<br></p>\n\n<p>在实际的开发过程中,往往需求和界面是不确定的，随着开发的不断推进，原来的很多界面基本修改得面目全非，这是许多开发者面临 <br>\n 的一个非常头疼的问题，MVP在一定程度上了解决了这个问题。</p>\n\n<p>##MVP 实战 <br>\n （0）UserBean</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs">\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> User {\n\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>  id;\n    <span class="hljs-keyword">private</span> String name ;\n    <span class="hljs-keyword">private</span> String mobile ;\n    <span class="hljs-keyword">private</span> String password;\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span>() {\n        <span class="hljs-keyword">return</span> id;\n    }\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span>(<span class="hljs-keyword">int</span> id) {\n        <span class="hljs-keyword">this</span>.id = id;\n    }\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {\n        <span class="hljs-keyword">return</span> name;\n    }\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {\n        <span class="hljs-keyword">this</span>.name = name;\n    }\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getMobile</span>() {\n        <span class="hljs-keyword">return</span> mobile;\n    }\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobile</span>(String mobile) {\n        <span class="hljs-keyword">this</span>.mobile = mobile;\n    }\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span>() {\n        <span class="hljs-keyword">return</span> password;\n    }\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span>(String password) {\n        <span class="hljs-keyword">this</span>.password = password;\n    }\n    @Override\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"User [id="</span> + id + <span class="hljs-string">", name="</span> + name + <span class="hljs-string">", mobile="</span> + mobile + <span class="hljs-string">", password="</span> + password + <span class="hljs-string">"]"</span>;\n    }\n}\n</code></pre>\n\n<p>（1）IUserModel 用户登录model接口 <br>\n 需要实现其接口，一般是读取网络数据，并存在JavaBean 中，并对javabean 有set和get的读写权限。 <br>\n <br>\n 一般为了需要一个Listerner 来监听网络请求读写数据的情况。</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> IUserModel {\n\n    <span class="hljs-comment">// 用户登录接口</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span>(String phone, String passwdMd5, final LoginHandler handler);\n\n}\n</code></pre>\n\n<p>（2）IUserLoginView  用户登录view 接口<br>\n    根据需求，VIEw 需要对Model的bean数据进行操作，当登录成功，返回登录人信息情况。</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserLoginView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IUserView</span> {</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserLoginSuccess</span>(User user);\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserLoginError</span>(String msg);\n}</code></pre>\n\n<p>(3)IUserModel监听类</p>\n\n<p>Model联网成功后，根据返回情况进行监听，它也起到了传递数据的作用，它将Model的数据传递给 <br>\n  Presenter ，从而Presenter 来讲数据传递给view</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java">\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NetworkHandler</span> {</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginSuccess</span>(User user);       <span class="hljs-comment">// 登录成功</span>\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginError</span>(String msg);         <span class="hljs-comment">// 登录失败</span>\n}</code></pre>\n\n<p>(4)UserPresenter</p>\n\n<p>连接model 层和 view层，处理model和view进行交互。</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPresenter</span> {</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG=<span class="hljs-string">"UserPresenter"</span>;\n\n    <span class="hljs-keyword">private</span> IUserModel mUser;      \n    <span class="hljs-keyword">private</span> IUserView mView;       \n\n\n    <span class="hljs-javadoc">/**\n     * 创建用户模型的主导器\n     *\n     *<span class="hljs-javadoctag"> @param</span> view 如果不需要进行界面展示则View传入null\n     */</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-title">UserPresenter</span>(@Nullable IUserView view) {\n        mUser = UserModel.getInstance();\n        mView = view;\n    }\n\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span>(String mobile,String password){\n        mUser.login(mobile, password, <span class="hljs-keyword">new</span> LoginHandler() {\n\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onlinkError</span>(String msg) {\n                <span class="hljs-keyword">if</span>(mView!=<span class="hljs-keyword">null</span>&amp;&amp;mView <span class="hljs-keyword">instanceof</span> IUserLoginView)\n                 ( (IUserLoginView) mView).onUserLoginError(msg);\n\n            }\n\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginSuccess</span>(User u) {\n                <span class="hljs-keyword">if</span> (mView != <span class="hljs-keyword">null</span> &amp;&amp; mView <span class="hljs-keyword">instanceof</span> IUserLoginView)\n                    ((IUserLoginView) mView).onUserLoginSuccess(u);\n\n            }\n\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginError</span>(String msg) {\n               <span class="hljs-keyword">if</span>(mView!=<span class="hljs-keyword">null</span>&amp;&amp;mView <span class="hljs-keyword">instanceof</span> IUserLoginView)\n                   ((IUserLoginView)mView).onUserLoginError(msg);\n\n            }\n        });\n    }\n\n}</code></pre>\n\n<p>（5）View 实现层<br></p>\n\n\n\n<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserLoginView</span>{</span>\n\n    <span class="hljs-annotation">@ViewInject</span>(id=R.id.btn_login,click=<span class="hljs-string">"login"</span>) Button btn_login;\n    <span class="hljs-annotation">@ViewInject</span>(id=R.id.et_login_name)EditText et_login_name;\n    <span class="hljs-annotation">@ViewInject</span>(id=R.id.et_login_password) EditText et_login_password;\n    <span class="hljs-keyword">private</span> Context mContext;\n    <span class="hljs-keyword">private</span> UserPresenter userPresenter;\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {\n        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        FinalActivity.initInjectedView(<span class="hljs-keyword">this</span>);\n        mContext=<span class="hljs-keyword">this</span>;\n        userPresenter=<span class="hljs-keyword">new</span> UserPresenter(<span class="hljs-keyword">this</span>);\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span>(View v){\n        String mobile=et_login_name.getText().toString();\n        String password=et_login_password.getText().toString();\n        String md5Pwd=MD5(password);\n        userPresenter.login(mobile, md5Pwd);\n\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserLoginSuccess</span>(User user) {\n\n        Toast.makeText(mContext, <span class="hljs-string">""</span>+user.toString(), Toast.LENGTH_SHORT).show();\n\n    }\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserLoginError</span>(String msg) {\n        Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();\n\n    } \n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">MD5</span>(String plain) {  \n        <span class="hljs-keyword">try</span> {\n            MessageDigest md5 = MessageDigest.getInstance(<span class="hljs-string">"MD5"</span>);\n            md5.update(plain.getBytes(<span class="hljs-string">"UTF-8"</span>));\n            <span class="hljs-keyword">byte</span>[] m = md5.digest();\n            StringBuilder hex = <span class="hljs-keyword">new</span> StringBuilder(m.length * <span class="hljs-number">2</span>);\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : m) {\n                <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">0xFF</span>) &lt; <span class="hljs-number">0x10</span>) hex.append(<span class="hljs-string">"0"</span>);\n                hex.append(Integer.toHexString(b &amp; <span class="hljs-number">0xFF</span>));\n            }\n            <span class="hljs-keyword">return</span> hex.toString();\n        } <span class="hljs-keyword">catch</span> (Exception e) {\n           e.printStackTrace();\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n        }\n    }  \n}\n\n</code></pre>\n\n<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写 <br>\n更多的博文。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9556104">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_0 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51726458', 'title': 'Javascript和android原生互调', 'readNum': '15616', 'commentNum': '0', 'publishTime': '2016-06-21 12:47:54', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>最近在做原生和js端的互调的功能，自己改了个demo，给大家讲解下。 <br>\n先上js代码</p>\n\n\n\n<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"UTF-8"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>方法调用基本流程测试<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"helloweb"</span>&gt;</span> \n    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"echoInfo"</span>&gt;</span>如果有数据返回，会显示在这儿<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">\n\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funFromjs</span><span class="hljs-params">()</span>{</span>\n        document.getElementById(<span class="hljs-string">"helloweb"</span>).innerHTML=<span class="hljs-string">"HelloWebView,i\'m from js"</span>;\n    }\n        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoInfo</span><span class="hljs-params">( container, obj )</span>{</span>\n            <span class="hljs-keyword">var</span> domContainer = document.getElementById(<span class="hljs-string">\'echoInfo\'</span>);\n            domContainer.innerHTML = <span class="hljs-built_in">JSON</span>.stringify( obj );\n        }\n\n        <span class="hljs-comment">//function windowCallback( str ){</span>\n            <span class="hljs-comment">//echoInfo( \'echoInfo\', str );</span>\n        <span class="hljs-comment">//}</span>\n\n         window.windowCallback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( str )</span>{</span>\n            echoInfo( <span class="hljs-string">\'echoInfo\'</span>, str );\n         };\n\n        <span class="hljs-keyword">var</span> MfsJSBridge = MfsJSBridge || <span class="hljs-literal">undefined</span>;\n        <span class="hljs-keyword">if</span>( <span class="hljs-literal">undefined</span> != MfsJSBridge ){\n\n            <span class="hljs-comment">//看这里</span>\n            <span class="hljs-keyword">var</span> params = {\n                id : <span class="hljs-number">1</span>,\n                name : <span class="hljs-string">\'测试\'</span>\n            };\n\n            <span class="hljs-keyword">var</span> strParams = <span class="hljs-built_in">JSON</span>.stringify( params );\n\n            MfsJSBridge.invoke( <span class="hljs-string">\'testFunc\'</span>, strParams, <span class="hljs-string">\'windowCallback\'</span>);\n\n        }<span class="hljs-keyword">else</span>{\n            alert(<span class="hljs-string">\'未定义MfsJSBridge\'</span>);\n\n        }\n\n    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>\n\n<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>\n\n<p>android webview 设置可用javascript</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//设置编码</span>\n mWebView.getSettings().setDefaultTextEncodingName(<span class="hljs-string">"utf-8"</span>);\n <span class="hljs-comment">//支持js</span>\nmWebView.getSettings().setJavaScriptEnabled(<span class="hljs-keyword">true</span>);</code></pre>\n\n<p>android 调js</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs ">mBtn1.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() {\n\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(View v) {\n              mWebView.loadUrl(<span class="hljs-string">"javascript:funFromjs()"</span>);<span class="hljs-comment">//其中funFromjs()为js的方法</span>\n              Toast.makeText(mContext, <span class="hljs-string">"调用javascript:funFromjs()"</span>, Toast.LENGTH_LONG).show();\n            }\n        });\n</code></pre>\n\n<p>js调原生，原生响应时间并回调数据</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs ">\n mWebView.addJavascriptInterface(<span class="hljs-keyword">new</span> Object(){\n            <span class="hljs-comment">//注意4.4以后加注解，位置在这个方法名上面，鉴于很多这个的例子，瞎、、写注解位置，并需要下                        //载积分写了这个</span>\n            <span class="hljs-annotation">@JavascriptInterface</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span>(String name ,String t,String callback) {\n                <span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">"testFunc"</span>)){ \n                <span class="hljs-comment">//其中t 为js带过来的数据          </span>\n                    Toast.makeText(mContext, t,Toast.LENGTH_LONG).show();\n\n                    String strJson = <span class="hljs-string">"{\\"code\\":122, \\"msg\\":\\"1231\\", \\"data\\":null}"</span>;\n\n                    <span class="hljs-comment">//回调数据给js 其中callback 为android 掉js 的方法名称。</span>\n                    mWebView.loadUrl(<span class="hljs-string">"javascript:"</span>+ callback +<span class="hljs-string">"(\'"</span> + strJson + <span class="hljs-string">"\')"</span>);\n                }\n              <span class="hljs-comment">//  Toast.makeText(mContext, name, Toast.LENGTH_LONG).show();</span>\n\n            }\n        },<span class="hljs-string">"MfsJSBridge"</span>);</code></pre>\n\n<p>代码比较简单，最主要的是 @JavascriptInterface注解的位置大家注意下。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9555368">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:54] - ThreadPoolExecutor-5_2 - INFO - {'link': 'https://blog.csdn.net/forezp/article/details/51693269', 'title': 'android 省市区三级联动', 'readNum': '17118', 'commentNum': '1', 'publishTime': '2016-06-16 17:12:33', 'content': '<div id="content_views" class="markdown_views prism-atom-one-dark">\n                    <!-- flowchart 箭头图标 勿删 -->\n                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>\n                    </svg>\n                                            <p>最近项目，需要用到三级联动，在网上找了一些例子，进行了修改，实现，提炼出来了给大家分享 <br>\n实现思路是在三个wheelview 进行联动。选择了省，马上就关联到市和区，选择了市 ，马上就可以关联到区。</p>\n\n<p>效果图：</p>\n\n<p><img src="https://img-blog.csdn.net/20160616165630865" width="300" alt="图片名称" align="center"> <br>\n首先建了三个Model 用于存数据 <br>\n存省 和市的list 和区的</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProvinceInfoModel</span> {</span>\n    <span class="hljs-keyword">private</span> String name;\n    <span class="hljs-keyword">private</span> List&lt;CityInfoModel&gt; cityList;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">ProvinceInfoModel</span>() {\n        <span class="hljs-keyword">super</span>();\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">ProvinceInfoModel</span>(String name, List&lt;CityInfoModel&gt; cityList) {\n        <span class="hljs-keyword">super</span>();\n        <span class="hljs-keyword">this</span>.name = name;\n        <span class="hljs-keyword">this</span>.cityList = cityList;\n    }\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {\n        <span class="hljs-keyword">return</span> name;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {\n        <span class="hljs-keyword">this</span>.name = name;\n    }\n\n    <span class="hljs-keyword">public</span> List&lt;CityInfoModel&gt; <span class="hljs-title">getCityList</span>() {\n        <span class="hljs-keyword">return</span> cityList;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCityList</span>(List&lt;CityInfoModel&gt; cityList) {\n        <span class="hljs-keyword">this</span>.cityList = cityList;\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"ProvinceInfoModel [name="</span> + name + <span class="hljs-string">", cityList="</span> + cityList + <span class="hljs-string">"]"</span>;\n    }\n}\n\n</code></pre>\n\n<p>存市和其对应的区list</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityInfoModel</span> {</span>\n\n    <span class="hljs-keyword">private</span> String name;\n    <span class="hljs-keyword">private</span> List&lt;DistrictInfoModel&gt; districtList;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">CityInfoModel</span>() {\n        <span class="hljs-keyword">super</span>();\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">CityInfoModel</span>(String name, List&lt;DistrictInfoModel&gt; districtList) {\n        <span class="hljs-keyword">super</span>();\n        <span class="hljs-keyword">this</span>.name = name;\n        <span class="hljs-keyword">this</span>.districtList = districtList;\n    }\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {\n        <span class="hljs-keyword">return</span> name;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {\n        <span class="hljs-keyword">this</span>.name = name;\n    }\n\n    <span class="hljs-keyword">public</span> List&lt;DistrictInfoModel&gt; <span class="hljs-title">getDistrictList</span>() {\n        <span class="hljs-keyword">return</span> districtList;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDistrictList</span>(List&lt;DistrictInfoModel&gt; districtList) {\n        <span class="hljs-keyword">this</span>.districtList = districtList;\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"CityInfoModel [name="</span> + name + <span class="hljs-string">", districtList="</span> + districtList\n                + <span class="hljs-string">"]"</span>;\n    }\n}\n</code></pre>\n\n<p>区的modeL</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistrictInfoModel</span> {</span>\n\n    <span class="hljs-keyword">private</span> String name;\n    <span class="hljs-keyword">private</span> String zipcode;\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">DistrictInfoModel</span>() {\n        <span class="hljs-keyword">super</span>();\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-title">DistrictInfoModel</span>(String name, String zipcode) {\n        <span class="hljs-keyword">super</span>();\n        <span class="hljs-keyword">this</span>.name = name;\n        <span class="hljs-keyword">this</span>.zipcode = zipcode;\n    }\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {\n        <span class="hljs-keyword">return</span> name;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {\n        <span class="hljs-keyword">this</span>.name = name;\n    }\n\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">getZipcode</span>() {\n        <span class="hljs-keyword">return</span> zipcode;\n    }\n\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZipcode</span>(String zipcode) {\n        <span class="hljs-keyword">this</span>.zipcode = zipcode;\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"DistrictInfoModel [name="</span> + name + <span class="hljs-string">", zipcode="</span> + zipcode + <span class="hljs-string">"]"</span>;\n    }\n\n}</code></pre>\n\n<p>数据存储在xml中，在assets目录下，详情见源代码，代码太多了。</p>\n\n<p>用的sax解析xml并得到数据存储在内存中</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddrXmlParser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultHandler</span> {</span>\n\n    <span class="hljs-keyword">private</span> List&lt;ProvinceInfoModel&gt; provinceList = <span class="hljs-keyword">new</span> ArrayList&lt;ProvinceInfoModel&gt;();\n\n\n    <span class="hljs-keyword">public</span> java.util.List&lt;ProvinceInfoModel&gt; <span class="hljs-title">getDataList</span>() {\n        <span class="hljs-keyword">return</span> provinceList;\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startDocument</span>() <span class="hljs-keyword">throws</span> SAXException {\n\n    }\n\n    ProvinceInfoModel provinceModel = <span class="hljs-keyword">new</span> ProvinceInfoModel();\n    CityInfoModel cityModel = <span class="hljs-keyword">new</span> CityInfoModel();\n    DistrictInfoModel districtModel = <span class="hljs-keyword">new</span> DistrictInfoModel();\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startElement</span>(String uri, String localName, String qName,\n                             Attributes attributes) <span class="hljs-keyword">throws</span> SAXException {\n        <span class="hljs-keyword">if</span> (qName.equals(<span class="hljs-string">"province"</span>)) {\n            provinceModel = <span class="hljs-keyword">new</span> ProvinceInfoModel();\n            provinceModel.setName(attributes.getValue(<span class="hljs-number">0</span>));\n            provinceModel.setCityList(<span class="hljs-keyword">new</span> ArrayList&lt;CityInfoModel&gt;());\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qName.equals(<span class="hljs-string">"city"</span>)) {\n            cityModel = <span class="hljs-keyword">new</span> CityInfoModel();\n            cityModel.setName(attributes.getValue(<span class="hljs-number">0</span>));\n            cityModel.setDistrictList(<span class="hljs-keyword">new</span> ArrayList&lt;DistrictInfoModel&gt;());\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qName.equals(<span class="hljs-string">"district"</span>)) {\n            districtModel = <span class="hljs-keyword">new</span> DistrictInfoModel();\n            districtModel.setName(attributes.getValue(<span class="hljs-number">0</span>));\n            districtModel.setZipcode(attributes.getValue(<span class="hljs-number">1</span>));\n        }\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endElement</span>(String uri, String localName, String qName)\n            <span class="hljs-keyword">throws</span> SAXException {\n        <span class="hljs-keyword">if</span> (qName.equals(<span class="hljs-string">"district"</span>)) {\n            cityModel.getDistrictList().add(districtModel);\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qName.equals(<span class="hljs-string">"city"</span>)) {\n            provinceModel.getCityList().add(cityModel);\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qName.equals(<span class="hljs-string">"province"</span>)) {\n            provinceList.add(provinceModel);\n        }\n    }\n\n    <span class="hljs-annotation">@Override</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">characters</span>(<span class="hljs-keyword">char</span>[] ch, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> length)\n            <span class="hljs-keyword">throws</span> SAXException {\n    }\n}\n</code></pre>\n\n<p>需要在activity 中开启线程读取数据</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readAddrDatas</span>() {\n        List&lt;ProvinceInfoModel&gt; provinceList = <span class="hljs-keyword">null</span>;\n        AssetManager asset = getAssets();\n        <span class="hljs-keyword">try</span> {\n            InputStream input = asset.open(<span class="hljs-string">"province_data.xml"</span>);\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser parser = spf.newSAXParser();\n            AddrXmlParser handler = <span class="hljs-keyword">new</span> AddrXmlParser();\n            parser.parse(input, handler);\n            input.close();\n            provinceList = handler.getDataList();\n            <span class="hljs-keyword">if</span> (provinceList != <span class="hljs-keyword">null</span> &amp;&amp; !provinceList.isEmpty()) {\n                mCurrentProviceName = provinceList.get(<span class="hljs-number">0</span>).getName();\n                List&lt;CityInfoModel&gt; cityList = provinceList.get(<span class="hljs-number">0</span>).getCityList();\n                <span class="hljs-keyword">if</span> (cityList != <span class="hljs-keyword">null</span> &amp;&amp; !cityList.isEmpty()) {\n                    mCurrentCityName = cityList.get(<span class="hljs-number">0</span>).getName();\n                    List&lt;DistrictInfoModel&gt; districtList = cityList.get(<span class="hljs-number">0</span>).getDistrictList();\n                    mCurrentDistrictName = districtList.get(<span class="hljs-number">0</span>).getName();\n                }\n            }\n            mProvinceDatas = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; provinceList.size(); i++) {\n                mProvinceDatas.add(provinceList.get(i).getName());\n                List&lt;CityInfoModel&gt; cityList = provinceList.get(i).getCityList();\n                ArrayList&lt;String&gt; cityNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();\n                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cityList.size(); j++) {\n                    cityNames.add(cityList.get(j).getName());\n                    List&lt;DistrictInfoModel&gt; districtList = cityList.get(j).getDistrictList();\n                    ArrayList&lt;String&gt; distrinctNameArray = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();\n                    DistrictInfoModel[] distrinctArray = <span class="hljs-keyword">new</span> DistrictInfoModel[districtList.size()];\n                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; districtList.size(); k++) {\n                        DistrictInfoModel districtModel = <span class="hljs-keyword">new</span> DistrictInfoModel(districtList.get(k).getName(), districtList.get(k).getZipcode());\n                        distrinctArray[k] = districtModel;\n                        distrinctNameArray.add(districtModel.getName());\n                    }\n                    mDistrictDatasMap.put(cityNames.get(j), distrinctNameArray);\n                }\n                mCitisDatasMap.put(provinceList.get(i).getName(), cityNames);\n            }\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n        } <span class="hljs-keyword">catch</span> (Throwable e) {\n            e.printStackTrace();\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n        }\n    }\n</code></pre>\n\n<p>读取完数据需要设置weelview 的数据</p>\n\n\n\n<pre class="prettyprint"><code class="language-java hljs ">\n mProvincePicker.setOnSelectListener(<span class="hljs-keyword">new</span> WheelView.OnSelectListener() {\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endSelect</span>(<span class="hljs-keyword">int</span> id, String text) {\n                String provinceText = mProvinceDatas.get(id);\n                <span class="hljs-keyword">if</span> (!mCurrentProviceName.equals(provinceText)) {\n                    mCurrentProviceName = provinceText;\n                    ArrayList&lt;String&gt; mCityData = mCitisDatasMap.get(mCurrentProviceName);\n                    mCityPicker.resetData(mCityData);\n                    mCityPicker.setDefault(<span class="hljs-number">0</span>);\n                    mCurrentCityName = mCityData.get(<span class="hljs-number">0</span>);\n\n                    ArrayList&lt;String&gt; mDistrictData = mDistrictDatasMap.get(mCurrentCityName);\n                    mCountyPicker.resetData(mDistrictData);\n                    mCountyPicker.setDefault(<span class="hljs-number">0</span>);\n                    mCurrentDistrictName = mDistrictData.get(<span class="hljs-number">0</span>);\n                }\n            }\n\n            <span class="hljs-annotation">@Override</span>\n            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selecting</span>(<span class="hljs-keyword">int</span> id, String text) {\n            }\n        });</code></pre>\n\n<p>代码不一一写成，详情见源码。</p>\n\n<p><a href="http://download.csdn.net/detail/forezp/9551637">源码下载</a></p>                                    </div>', 'table': 'p_news_csdn', 'created_at': '2020-02-05 20:12:46'}
2020-02-05 20:12:46 - /Users/chenhao/Desktop/spiderProject/V1/CSDN/run.py[line:41] - MainThread - INFO - 翻页：7 nextUrl：https://blog.csdn.net/forezp/article/list/7
